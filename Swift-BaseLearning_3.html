
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  Swift基础知识 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14976096897839.html">字符串和字符</a></h1>
			<p class="meta"><time datetime="2017-06-16T18:41:29+08:00" 
			pubdate data-updated="true">06/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>字符串是字符的集合,用<code>string</code>类型表示. 一个<code>String</code>的内容可以用许多方式读取，例如作为包括作为<code>Character</code>值的集合的方式</p>

<p><code>Swift</code>的<code>String</code>和<code>Character</code>类型提供了快速和兼容<code>Unicode</code>的方式供代码使用。<br/>
String 类型是一种快速、现代化的字符串实现。 每一个字符串都是由编码无关的<code>Unicode</code>字符组成，并支持访问字符的多种<code>Unicode</code>表示形式</p>

<blockquote>
<p>注意</p>

<p>Swift的String类型 与 Foundation的NSString类型可以无缝桥接。<br/>
Foundation对String扩展，使其可以访问NSString类型中定义的方法。<br/>
这意味着可以直接调用NSString方法，而无需进行任何类型转换</p>
</blockquote>

<h2 id="toc_0">字符串字面量</h2>

<pre><code class="language-swift">//someString 常量通过字符串字面量进行初始化
let someString = &quot;Some string literal value&quot;
</code></pre>

<h3 id="toc_1">多行字符串字面量</h3>

<p>三个双引号包括这具有稳定属性的文本字符集合</p>

<pre><code class="language-swift">let quotation = &quot;&quot;&quot;
The White Rabbit put on his spectacles.  &quot;Where shall I begin,
please your Majesty?&quot; he asked.

&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on
till you come to the end; then stop.&quot;
&quot;&quot;&quot;
</code></pre>

<p>如果多行字符串中包含换行符的话，则多行字符串字面量也会包含换行符。<br/>
可以通过在行末尾添加反斜杠<code>\</code>作为续行符</p>

<h3 id="toc_2">字符串字面量的特殊字符</h3>

<p>特殊字符主要有：</p>

<ul>
<li>转义字符<code>\0</code>、反斜杠<code>\\</code>、水平制表符<code>\t</code>、换行符<code>\n</code>、回车符<code>\r</code>、双引号<code>&quot;</code>、单引号<code>\&#39;</code></li>
<li>Unicode标量，写法为<code>\u{n}</code>(u为小写)，n为任意一到八位十六进制数且可用的unicode码</li>
</ul>

<pre><code class="language-swift">let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;
// &quot;Imageination is more important than knowledge&quot; - Enistein
let dollarSign = &quot;\u{24}&quot;             // $，Unicode 标量 U+0024
let blackHeart = &quot;\u{2665}&quot;           // ♥，Unicode 标量 U+2665
let sparklingHeart = &quot;\u{1F496}&quot;      // 💖，Unicode 标量 U+1F496
</code></pre>

<p>由于多行字符串字面量使用了三个双引号，所以可以再多行字符串字面量直接使用双引号而不用加转义符。</p>

<pre><code class="language-swift">let threeDoubleQuotes = &quot;&quot;&quot;
Escaping the first quote \&quot;&quot;&quot;
Escaping all three quotes \&quot;\&quot;\&quot;
&quot;&quot;&quot;
</code></pre>

<h3 id="toc_3">扩展字符串分隔符</h3>

<p>将字符串文字放在扩展分隔符中，字符串的特殊字符会被直接包含而非转义后的效果<br/>
如果想要在扩展分隔符中的文字有特殊效果，可以在转义字符后添加与其实位置个数相匹配的<code>#</code>符<br/>
扩展分隔符也可以用于多行字符串文字</p>

<pre><code class="language-swift">＃&quot;Line 1 \nLine 2&quot;＃  //打印的为\n而非换行符

＃&quot;Line 1 \#nLine 2&quot;＃   //实现换行效果
###&quot;Line1 \###nLine2&quot;### //实现换行效果

let threeMoreDoubleQuotationMarks = #&quot;&quot;&quot;
Here are three more double quotes: &quot;&quot;&quot;
&quot;&quot;&quot;#
</code></pre>

<h2 id="toc_4">初始化空字符串</h2>

<pre><code class="language-swift">var emptyString = &quot;&quot; // 空字符串字面量
var anotherEmptyString = String() // 初始化方法


if emptyString.isEmpty {
print(&quot;Nothing to see here&quot;)
}
// 打印输出：&quot;Nothing to see here&quot;
</code></pre>

<h2 id="toc_5">字符串可变性</h2>

<pre><code class="language-swift">//通过指定为变量使其可修改
var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;
// variableString 现在为 &quot;Horse and carriage&quot;
</code></pre>

<p>与OC中的<code>NSString</code>和<code>NSMutableSting</code>确定是否可更改不同,<code>Swift</code>中类似其他值取决于其被定义为常量还是变量</p>

<h2 id="toc_6">字符串是值类型</h2>

<p><strong><code>Swift</code>的<code>String</code>类型是值类型</strong>。如果您<strong>创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作</strong>。这样保证了在函数/方法中传递的是字符串的值不会被修改，除非你自己去修改它。</p>

<blockquote>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>

<p>注意:</p>

<p><code>Swift</code>的<code>String</code>是值类型而<code>NSString</code>是引用类型,<code>NSString</code>的意思是初始化了一个指针指向了这个字符串，但Swift <code>String</code>的意思则是把字符串字面量赋值给变量</p>
</blockquote>

<h2 id="toc_7">使用字符</h2>

<p>可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code> 属性来获取每一个字符的值</p>

<pre><code class="language-swift">for character in &quot;Dog!?&quot;.characters {
    print(character)
}
// 
</code></pre>

<pre><code class="language-swift">//声明一个Character类型
let exclamationMark: Character = &quot;!&quot;

//用character类型数组初始化字符串
let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]
let catString = String(catCharacters)
print(catString)

</code></pre>

<h2 id="toc_8">连接字符串和字符</h2>

<p>字符串可以通过加法相加在一起<br/>
可以通过<code>+=</code>运算符将一个字符串添加到一个已经存在字符串变量上</p>

<pre><code class="language-swift">let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2

var instruction = &quot;look over&quot;
instruction += string2
</code></pre>

<p>可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部</p>

<pre><code class="language-swift">//初始化字符也是用双引号
let exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
// welcome 现在等于 &quot;hello there!&quot;
</code></pre>

<blockquote>
<p>注意</p>

<p>不能将一个字符串或者字符添加到字符变量上，因为字符变量只能包含一个字符</p>

<p>初始化字符也是用双引号与c中使用单引号不同</p>
</blockquote>

<h2 id="toc_9">字符串插值</h2>

<p>可以用以反斜线为前缀的圆括号将常量、变量或表达式插入字符串字面量或者多行字符串字面量之中</p>

<pre><code class="language-swift">let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
// message 是 &quot;3 times 2.5 is 7.5&quot;
</code></pre>

<blockquote>
<p>注意</p>

<p>插值字符串中写在括号内的表达式不能包含非转义反斜杠 ()，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>

<h2 id="toc_10">Unicode</h2>

<p>Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p>

<h3 id="toc_11">Unicode标量</h3>

<p><code>Unicode</code>标量是对应字符或者修饰符的唯一的21位数字</p>

<blockquote>
<p>Unicode 码位(code poing) 的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF<br/>
Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位，其码位范围是 U+D800 到 U+DFFF 。<br/>
不是所有的21位<code>Unicode</code>标量都代表一个字符，因为有一些标量是留作未来分配的。</p>
</blockquote>

<h3 id="toc_12">可扩展的字形群集</h3>

<p>每一个<code>Swift</code>的<code>Character</code>类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<pre><code class="language-swift">/*
    字母 é 可以用单一的 Unicode 标量 é (U+00E9)来表示
    一个标准的字母e(U+0065)加上一个急促重音的标量(U+0301)，这样一对标量就表示了同样的字母é 
*/
let eAcute: Character = &quot;\u{E9}&quot; // é
let combinedEAcute: Character = &quot;\u{65}\u{301}&quot; // e 后面加上 ?
// eAcute 是 é, combinedEAcute 是 é
</code></pre>

<p>因此我们可以用很多复杂的脚本字符来表示单一的Character值</p>

<p>可扩展字形集是一个将许多复杂的脚本字符表示为单个字符值的灵活方式。</p>

<p>例如</p>

<pre><code class="language-swift">/*
    可拓展的字符群集可以使包围记号的标量包围其他Unicode标量，作为一个单一的Character值
*/
let enclosedEAcute: Character = &quot;\u{20DD}&quot;//&quot;⃝&quot;
let enclosedEAcute11: Character = &quot;\u{E9}\u{20DD}&quot;//é⃝
</code></pre>

<h2 id="toc_13">计算字符数量</h2>

<p>通过字符串的<code>count</code>属性获取<code>Character</code>值的数量</p>

<p>注意:<br/>
我们在使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时不一定会改变字符数量</p>

<pre><code class="language-swift">var word = &quot;cafe&quot;//这时候字符数量是4
word += &quot;\u{301}&quot; //这时候字符数量还是4 因为e和新增的字符组合为é

let eAcute = &quot;\u{00E9}&quot; // é
eAcute.characters.count //字符数量为1
let combinedEAcute = &quot;\u{65}\u{301}&quot; //
combinedEAcute.characters.count //字符数量为1

</code></pre>

<blockquote>
<p>注意：</p>

<p>可扩展的字形群集可以由多个Unicode标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以Swift中的字符在一个字符串中并不一定占用相同的内存空间数量。因此，在没有获取字符串中的可扩展的字符群范围时，就不能计算出字符串的字符数量。如果在正在入里一个长字符串，需要注意count属性必须遍历全部的unicode标量，来确定字符串的字符数量</p>

<p>另外需要注意的时通过count属性返回的字符数量并不总是与包括相同字符的NSString的Length属性相同。NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是Unicode可扩展字符群集。作为佐证，当一个 NSString 的 length 属性被一个Swift的 String 值访问时，实际上是调用了 <code>utf16Count</code></p>
</blockquote>

<h2 id="toc_14">访问和修改字符串</h2>

<h3 id="toc_15">字符串索引</h3>

<p><code>String.Index</code>对应着字符串中的每一个<code>Character</code>的位置</p>

<p>因为字符串中每个<code>Character</code>是可扩展的字符群集,所以想要知道character的人确切位置就像从String开头遍历每一个Unicode标量直到结尾才行。因此，Swift字符串不能用整数做索引</p>

<p><code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引<br/>
<code>endIndex</code>属性可以可以获取<strong>最后一个<code>Character</code>的后一个位置的索引。</strong>因此<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的</p>

<p>可以使用<code>String</code>的<code>index(before:)</code>或<code>index(after:)</code>来获取前一个或者后一个,或者用<code>index(:_offsetBy:)</code>取得对应偏移量的索引</p>

<p>获取对应下标索引的字符:</p>

<pre><code class="language-swift">let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex]// G
greeting[greeting.index(after: greeting.endIndex)]// !
//当越界是或引发运行时的错误(可以在编译时就检测出来)
</code></pre>

<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符</p>

<pre><code class="language-swift">for index in greeting.characters.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
// 打印输出 &quot;G u t e n T a g ! &quot;
</code></pre>

<blockquote>
<p>我们在上面在<code>String</code>中获取的index的方法,可以用于在任意一个确认的并遵循<code>Collection</code>协议的类型里面(例如Array、Dictionary、Set)</p>
</blockquote>

<h3 id="toc_16">插入和删除</h3>

<p>调用<code>insert(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符，调用<code>insert(contentsOf:at:)</code>方法可以在一个字符串的指定索引插入一个段字符串。</p>

<pre><code class="language-swift">//注意必须是变量
var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, at: welcome.endIndex)
// welcome 变量现在等于 &quot;hello!&quot;
welcome.insert(contentsOf:&quot; there&quot;.characters, at: welcome.index(before: welcome.endIndex))
// welcome 变量现在等于 &quot;hello there!&quot;
</code></pre>

<p>调用<code>remove(at:)</code>方法可以在一个字符串的指定索引删除一个字符，调用<code>removeSubrange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>

<pre><code class="language-swift">welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 &quot;hello there&quot;
let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex
welcome.removeSubrange(range)
// welcome 现在等于 &quot;hello&quot;
</code></pre>

<blockquote>
<p><code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code>和<code>removeSubrange(_:)</code>方法在任意一个确认的并遵循<code>RangeReplaceableCollection</code>协议的类型里面，如上文所示是使用在 <code>String</code>中，您也可以使用在<code>Array</code>、<code>Dictionary</code>和<code>Set</code>中。</p>
</blockquote>

<h3 id="toc_17">子字符串</h3>

<pre><code class="language-swift">let greeting = &quot;Hello, world!&quot;
let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndex
let beginning = greeting[..&lt;index]
// beginning 的值为 &quot;Hello&quot;

// 把结果转化为 String 以便长期存储。
let newString = String(beginning)
</code></pre>

<p>当从String中获取一个SubString实例。Swift中的SubString绝大部分函数和String相同，可以使用相同的方式去操作。但是，与String不同的是，SubString只适合短时间操作字符串。</p>

<p>类似String，每个SubString也会在内存中保存字符集。而String和SubString的区别在性能优化上，SubString可以重用原String的内存空间或者另一个SubString的内存空间(String也有相同的优化，短时如果共享内存的话两者就会想等)。这对子字符串的优化意味着在修改String或者SubString之前都不需要去复制消耗内存。但是这也导致一个问题，因为SubString重用了原有内存的空间，原String的内存空间必须保留到SUbString不在使用为止</p>

<p><img src="media/14976096897839/15650786814829.jpg" alt="" style="width:500px;"/></p>

<h2 id="toc_18">比较字符串</h2>

<h3 id="toc_19">字符串/字符相等</h3>

<p>直接用 <code>==</code> 和 <code>!=</code>进行比较</p>

<p>判断标准等于的标准是:当有同样的语义和外观,就被认为是相等的,即使他们的可扩展字形群集可能由不同的<code>Unicode</code>标量构成</p>

<p>例如:<br/>
((U+00E9)标准等于((U+0065)(U+0301))) (都是<code>é</code>表示的有效方式)<br/>
U+0041(英语中的A)不等于U+0410(俄语中的A)尽管外观看着一样</p>

<h3 id="toc_20">前缀/后缀</h3>

<p>通过字符串的<code>hasPrefix(_:) / hasSuffix(_:)</code>方法来检查字符串是否用于特定前缀/后缀</p>

<h2 id="toc_21">字符串的Unicode表示</h2>

<p>当<code>Unicode</code>字符串写进文本文件或者其他存储时，<code>Unicode</code>会用几种<code>编码格式</code>编码(如：UTF-8 UTF-16 UTF-32) 每一个字符串中的小块编码都被称<code>代码单元</code></p>

<p>除了前面说过的用<code>for-in</code>对字符串遍历,然后访问每个<code>character</code>值的方式外:<br/>
其他三种<code>Unicode</code>兼容方式访问字符串</p>

<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的Unicode标量值集合，也就是字符串的UTF-32编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>

<p>let dogString = &quot;Dog‼🐶&quot;(其中“!!”为U+203C 🐶为U+1F436)</p>

<h4 id="toc_22">UTF-8表示</h4>

<p>通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示， 其为<code>String.UTF8View</code>类型的属性， <code>UTF8View</code>是无符号8位(UInt8)值的集合，每一个UInt8值都是一个字符的UTF-8表示</p>

<pre><code class="language-swift">for codeUnit in dogString.utf8 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)// 68 111 103 226 128 188 240 159 144 182
/*
前三个10进制 codeUnit 值 ( 68 , 111 , 103 ) 代表了字符 D 、 o 和 g ，它们的 UTF-8 表示与ASCII 表示相同。
 接下来的三个10进制 codeUnit 值 ( 226 , 128 , 188 ) 是 DOUBLE 
EXCLAMATION MARK 的3字节 UTF-8 表示。 
最后的四个 codeUnit 值 ( 240 , 159 , 144 , 182 ) 是 DOG FACE 的4字节UTF-8 表示。
*/
</code></pre>

<blockquote>
</blockquote>

<h4 id="toc_23">UTF-16表示</h4>

<p>与utf-8类似,访问其utf-16属性,是<code>String.UTF16View</code>类型(<code>UInt16</code>值集合)</p>

<pre><code class="language-swift">for codeUnit in dogString.utf16 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 55357 56374
</code></pre>

<h4 id="toc_24">Unicode标量表示</h4>

<p>通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的<code>Unicode</code>标量表示。为<code>UnicodeScalarView</code>类型的属性(<code>UnicodeScalar</code>类型的值的集合)。<br/>
<code>UnicodeScalar</code>是21位的<code>Unicode</code>代码点,拥有一个<code>value</code>属性，可以返回对应的21位数值，用 UInt32 来表示：</p>

<pre><code class="language-swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 128054
</code></pre>

<blockquote>
<p>我们平常代码中的Unicode编码就是这种21位<br/>
UTF-32也是编码一样为21位，因此swift中的有了unicodeScalars属性也就没有utf32属性</p>
</blockquote>

<p>每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值</p>

<pre><code class="language-swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar) &quot;, terminator: &quot;&quot;)
}
// D o g !! 🐶
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14974389141976.html">Swift 基本运算符</a></h1>
			<p class="meta"><time datetime="2017-06-14T19:15:14+08:00" 
			pubdate data-updated="true">06/14/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">赋值运算符</h2>

<pre><code class="language-swift">//赋值符可以赋值元组
let (x, y) = (1, 2)
// 现在 x 等于 1，y 等于 2
</code></pre>

<p>注意点:<br/>
与OC不同，赋值符不返回值,防止把想要判断相等运算符（ == ）的地方写成赋值符导致的错误</p>

<h2 id="toc_1">算术运算符</h2>

<pre><code class="language-swift">1 + 2       // 等于 3
5 - 3       // 等于 2
2 * 3       // 等于 6
10.0 / 2.5  // 等于 4.0

//加法运算符也可用于 String 的拼接
&quot;hello, &quot; + &quot;world&quot; // 等于 &quot;hello, world&quot;
</code></pre>

<p>注意:<br/>
与<code>OC</code>不同,<code>Swift</code>默认情况下不允许在数值运算中出现溢出情况.(可以使用<code>Swift</code>提供的溢出运算符实现溢出运算)</p>

<h2 id="toc_2">求余运算</h2>

<p>求余运算(<code>%</code>)在其他语言也叫取模运算</p>

<h3 id="toc_3">一元负号/正号运算符</h3>

<p>一元负/正号符（ -/+ ）写在操作数之前，中间没有空格。<br/>
负号或者正号可以抵消</p>

<h2 id="toc_4">组合赋值运算符</h2>

<p>例如:<br/>
<code>a += 2</code> //这组合赋值运算符也是没有返回值的（和赋值运算符一样）</p>

<blockquote>
<p>在Swift3 中已经移除了 ++ 或 -- 的自增 自减运算符</p>

<p>组合赋值运算符也没有返回值的 因此<code>let b = a += 2</code>的写法是错误的</p>
</blockquote>

<h2 id="toc_5">比较运算符</h2>

<p>和OC中是相同的,返回一个表达式是否成立的布尔值</p>

<blockquote>
<p><code>Swift</code> 也提供恒等（<code>===</code>）和不恒等（<code>!==</code>）这两个比较符来判断两个对象是否引用同一个对象实例</p>
</blockquote>

<p>注意:</p>

<p><strong>元组的比较方法:</strong><br/>
当元组中的值可以比较时，你也可以使用这些运算符来比较它们的大小。例如，因为<code>Int</code>和<code>String</code>类型的值可以比较，所以类型为<code>(Int, String)</code>的元组也可以被比较。相反，<code>Bool</code> 不能被比较，也意味着存有布尔类型的元组不能被比较</p>

<p>比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的</p>

<pre><code class="language-swift">//当比较到1小于2就判断为ture 不会再比较下去
(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true，因为 1 小于 2
(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;) // true，因为 3 等于 3，但是 apple 小于 bird
(4, &quot;dog&quot;) == (4, &quot;dog&quot;) // true，因为 4 等于 4，dog 等于 dog
</code></pre>

<blockquote>
<p>Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。</p>
</blockquote>

<h2 id="toc_6">三元运算符</h2>

<h2 id="toc_7">空合运算符</h2>

<p>空合运算符<code>（a ?? b）</code>将对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>。<br/>
表达式<code>a</code>必须是<code>Optional</code>类型<br/>
默认值<code>b</code>的类型必须要和<code>a</code>存储值的类型保持一致。</p>

<p>空合运算符相当于</p>

<pre><code class="language-swift">a != nil ? a! : b
</code></pre>

<blockquote>
<p>注意:</p>

<p>空合运算符也采用了短路求值,即当a为非空时,那么就不会再去计算b的值</p>
</blockquote>

<h2 id="toc_8">区间运算符</h2>

<h3 id="toc_9">闭区间运算符</h3>

<p><code>a...b</code>定义一个包含从a到b(包括a和b)</p>

<pre><code class="language-swift">for index in 1...5 {
    print(&quot;\(index) * 5 = \(index * 5)&quot;)
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
</code></pre>

<h3 id="toc_10">半开区间运算符</h3>

<p><code>a..&lt;b</code>定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间</p>

<h3 id="toc_11">单侧区间</h3>

<p>闭区间运算符 有另外一种表达形式，可以表示向一次无限延伸的区间。</p>

<p>例如: 包含了数组从索引2到结尾所有值的区间。</p>

<pre><code class="language-swift">Anna、Alex、Brian、Jack

for name in names[2...] {
    print(name)
}
// Brian
// Jack

for name in names[...2] {
    print(name)
}
// Anna
// Alex
// Brian
</code></pre>

<p>类似的，半开区间操作符也有单侧表达形式，附带它的最终值，最终值并不会落在区间内。</p>

<pre><code class="language-swift">for name in names[..&lt;2] {
    print(name)
}
// Anna
// Alex
</code></pre>

<blockquote>
<p>注意</p>

<p>不能遍历省略了初始值的单侧区间，因为这样遍历的开端并不明显。但是可以遍历一个省略了最终值的单侧区间，但是由于这种区间的无限延伸特定，请确保循环中存在结束的条件或分支</p>
</blockquote>

<h2 id="toc_12">逻辑运算符</h2>

<p>与<code>&amp;&amp;</code> 或<code>||</code> 非<code>!</code></p>

<blockquote>
<p>与或非运算也是使用短路计算的</p>
</blockquote>

<p>注意:<br/>
<code>Swift</code>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是左结合的，即从左向右读,优先计算左边,建议加上括号来增加代码可读性</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14968373667230.html">Swift 基础部分</a></h1>
			<p class="meta"><time datetime="2017-06-07T20:09:26+08:00" 
			pubdate data-updated="true">06/07/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Swift 包含了C和Objective-C上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。 Swift 还提供了三个基本的集合类型<code>Array</code> ，<code>Set</code> 和<code>Dictionary</code><br/>
除了我们熟悉的类型，<code>Swift</code>还增加了<code>Objective-C</code>中没有的高阶数据类型比如元组（<code>Tuple</code>）。<br/>
<code>Swift</code>还增加了可选（Optional）类型，用于处理值缺失的情况。</p>

<p><code>Swift</code>是一门类型安全的语言，这意味着<code>Swift</code>可以让你清楚地知道值的类型。</p>

<h2 id="toc_0">常量和变量</h2>

<p>常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>

<h3 id="toc_1">声明常量和变量</h3>

<p>用<code>let</code>来声明常量，用<code>var</code>来声明变量</p>

<pre><code class="language-swift">//一行中声明多个
var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<p>注意:<strong>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。</strong></p>

<h3 id="toc_2">类型标注</h3>

<p>声明常量或者变量的时候可以加上类型标注，在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。(声明时如果有初始值，Swift可以推断出这个常量或者变量的类型)</p>

<pre><code class="language-swift">//可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：
var red, green, blue: Double
</code></pre>

<h3 id="toc_3">常量和变量的命名</h3>

<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>

<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。（不推荐）</p>

<h3 id="toc_4">输出常量和变量</h3>

<p>用 <code>print(someValue, separator:, terminator:)</code> 函数来输出当前常量或变量的值:<br/>
<code>separator</code>用来设置各个值间的拼接字符串<br/>
<code>terminator</code>用来设置输出结果结束后的结束字符，默认为“\n”换行</p>

<pre><code class="language-swift">print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
//输出结果(并没有换行)
//111--222结束符 111--222结束符
</code></pre>

<p><code>Swift</code>用<strong>字符串插值</strong>（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，<code>Swift</code>会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>

<pre><code class="language-swift">/*
    若只是要print一个变量或者常量可以直接print，但是如果要将这个拼接到字符串中需要这
    样做
*/
print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)
// 输出 &quot;The current value of friendlyWelcome is Bonjour!
</code></pre>

<blockquote>
<p><code>print(_:separator:terminator:)</code>这个函数第一个参数为<code>_</code>即并没有设置标签,其他参数设置了标签并且有默认值因此是可选的</p>
</blockquote>

<h2 id="toc_5">注释</h2>

<p>单行注释用双正斜杠<code>（ // ）</code>作为起始标记:<br/>
多行注释用：</p>

<pre><code class="language-swift">/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>

<p>多行注释可以去嵌套注释，我们可以方便的注释掉大段代码 即使代码中已经包含注释(oc中是没有多行注释的)</p>

<h2 id="toc_6">分号</h2>

<p><code>Swift</code>并不需要在末尾添加分号,但是如果单行内写多条语句时,必须用分号分开;</p>

<h2 id="toc_7">整数</h2>

<p><code>Swift</code> 提供了8，16，32和64位的有符号和无符号整数类型(即分别为1、2、4、8字节)。<br/>
命名:比如8位无符号整数类型是 UInt8 ，32位有符号整数类型是 Int32 。</p>

<h3 id="toc_8">范围</h3>

<p>我们可以用不同整数类型的<code>min</code>和<code>max</code>属性获取对应类型的最小值和最大值：</p>

<pre><code class="language-swift">//返回的类型正是其对应类型
let minValue = UInt8.min // minValue 为 0，是 UInt8 类型
let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型
</code></pre>

<p>Swift提供了整数类型<code>Int</code>和<code>UInt</code>其长度和当前平台<code>原生字长</code>相同</p>

<p>补充:<br/>
尽量不要使用<code>UInt</code> ，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断</p>

<h2 id="toc_9">浮点数</h2>

<p><code>Swift</code>提供了两种有符号浮点数类型：</p>

<ul>
<li>Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float 表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>

<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择<code>Double</code>。</p>

<h2 id="toc_10">类型安全和类型推断</h2>

<p><code>Swift</code>是一个类型安全（type safe）的语言。因此它会在编译时进行类型检查,将不匹配的类型标记为错误。但是也不需要每个都显示的指定类型,编译器可以在编译代码的时候自动推断出表达式的类型。</p>

<pre><code class="language-swift">//当推断浮点数的类型时，Swift 总是会选择 Double 而不是 Float 
let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>

<p>如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型</p>

<pre><code class="language-swift">let anotherPi = 3 + 0.14159
// anotherPi 会被推测为 Double 类型
</code></pre>

<h2 id="toc_11">数值型字面量</h2>

<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是 <code>0b</code></li>
<li>一个八进制数，前缀是 <code>0o</code></li>
<li>一个十六进制数，前缀是 <code>0x</code></li>
</ul>

<p>对于浮点数用10进制或者16进制表示，可以用指数来表示，10进制的指数为<code>e</code>(可为大写或小写)，16进制使用大写或者小写的<code>p</code></p>

<pre><code class="language-swift">1.25e2 表示 1.25 × 10^2，等于 125.0 
1.25e-2 表示 1.25 × 10^-2，等于 0.0125
0xFp2 表示 15 × 2^2，等于 60.0
0xFp-2 表示 15 × 2^-2，等于 3.75
</code></pre>

<p>补充:<br/>
为了可读性：整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>

<pre><code class="language-swift">let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>

<h2 id="toc_12">数值型类型转换</h2>

<p>前面说过,即使知道整数常量或者变量为非负也推荐使用<code>Int</code>类型，这样可以保证我们的的变量或常量可以直接被复用并且可以匹配整数类字面量的类型推断</p>

<p>我们通常使用其他整数类型是为了处理外部明确长度的数据或者优化性能、内存。这样直接使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>

<h3 id="toc_13">整数转换</h3>

<p><code>Swift</code>任何时候都不会隐式进行类型转换，所以我们应该根据情况进行显式的进行类型装换，这样代码的转换意图也更清晰</p>

<pre><code class="language-swift">let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>

<p><code>SomeType(ofInitialValue)</code> 是调用<code>Swift</code>构造器并传入一个初始值的默认方法(但是也不能接受任意类型的值,只能传入<code>SomeType</code>内部有对应构造器的值)</p>

<h3 id="toc_14">整数和浮点数转换</h3>

<p>整数和浮点数之间可以互相转换</p>

<pre><code class="language-swift">let pi = Double(3);
let integerPi = Int(3.1415)
//这样转换的话会向下取整
//即浮点值会被截断
</code></pre>

<h2 id="toc_15">类型别名</h2>

<p>给现有类型定义另外一个名字,使用<code>typealias</code>关键字来定义类型别名<br/>
<code>typealias AudioSample = UInt16</code><br/>
<strong>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名</strong>：</p>

<h2 id="toc_16">布尔值</h2>

<p><code>Swift</code>提供基本布尔类型<code>Bool</code>，有两个布尔常量:<code>ture</code>和<code>false</code><br/>
Swift中的Bool是非常严格的必须为ture或者false，而不是OC中的非0为真</p>

<h2 id="toc_17">元组</h2>

<p>元组将多个值组合为一个复合值，其中可以为任意类型</p>

<p>元组只适用于我们临时组织数据,不适合创建复杂的数据结构，如果不是临时使用请使用类或者结构体</p>

<pre><code class="language-swift">//定义元组
let http404Error = (404, &quot;Not Found&quot;)
//元组解析 也可以将 (statusCode, statusMessage) 看为定义的元组名称
let (statusCode, statusMessage) = (404, &quot;Not Found&quot;)
//元组解析 利用 _ 忽略其他的部分
let (justTheStatusCode, _) = http404Error
print((statusCode, statusMessage).0, (statusMessage), http404Error.1)


let (status200Code, status200Message) = (statusCode: 200, description: &quot;OK&quot;)
status200Code
(status200Code, status200Message).1
//这种方式报错,因为用(status200Code, status200Message) 已经将元组内容部分解析,定义的名称已经被覆盖了
//(status200Code, status200Message).status200Code 
let status400 : (statusCode: Int, description: String) = (404, &quot;Not Found&quot;)
status400.statusCode
</code></pre>

<h2 id="toc_18">可选类型</h2>

<p>可选类型用来处理值可能缺失的情况</p>

<p><code>OC</code>中并没有这个类型,在oc中为了表达这个意思我们通常让方法返回一个特殊值(比如 <code>NSNotFound</code>)，来让我们对特殊值进行判断，<code>Swift</code>提供了一个可选类型可以按时任意类型值得缺失很方便.</p>

<p>可选类型的值: 要不有值为X 要不为没有值</p>

<pre><code class="language-swift">//我们将String强转为Int 因为并不是所有字符串都能转为整数,因此返回可选类型
let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;
</code></pre>

<p>问号表示是可选类型Int，就是有可能包含<code>Int</code>也有可能不包含值</p>

<h3 id="toc_19">nil</h3>

<p>在<code>Swift</code>中的<code>nil</code>和OC中并不同。 在OC中<code>nil</code>是一个指向不存在的对象的指针。而<code>Swift</code>中nil不是一个指针,是一个确定的值来表示值得缺失,任何可选状态都可被置为<code>nil</code>，不仅是对象类型。<strong><code>nil</code>只能设置可选类型的值,如果想设置一个常量或者变量,需要先将其设置为可选类型</strong></p>

<pre><code class="language-swift">var serverResponseCode: Int? = 404
serverResponseCode = nil
//对于未赋值的可选类型 默认值为 nil
var surveyAnswer: String?
</code></pre>

<h3 id="toc_20">if语句以及强行解析</h3>

<p>对于一个可选类型值,可以通过 在其后加上<code>!</code>强制解析来获取其值,但是对于不存在的值加！会导致错误,因此在强制解析前需要判断非空</p>

<pre><code class="language-swift">if convertedNumber != nil {
print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)
}
</code></pre>

<h3 id="toc_21">可选绑定</h3>

<p>上面强行解析后这个值还是可选类型,为了避免这种情况我们可以使用<strong>可选绑定</strong>,用着<code>if</code>或<code>while</code>语句中,通过判断可选类型是否有值,有值得话将其赋值给一个确定类型的变量或者常量,这样就可以使用这个变量或者常量来避免使用可选类型的值避免使用强行解析</p>

<blockquote>
<p>缺点是这样创建的常量或者变量只能在这个if语句中使用</p>
</blockquote>

<pre><code class="language-swift">if let actualNumber = Int(possibleNumber) {
print(&quot;\&#39;\(possibleNumber)\&#39; has an integer value of \(actualNumber)&quot;)
} else {
print(&quot;\&#39;\(possibleNumber)\&#39; could not be converted to an integer&quot;)
}
//如果 Int(possibleNumber)不是nil就可创建一个常量actualNumber指向这个值

</code></pre>

<h3 id="toc_22">隐式解析可选类型</h3>

<p>有时在可选类型第一次被赋值后,就可以确定其总是有值,这时候我们可以声明其为隐式解析可选类型来避免每次都判断解析<br/>
通过将可选类型后的 <code>?</code> 替换为<code>!</code>来声明隐式解析可选类型</p>

<blockquote>
<p>可以将隐式解析可选类型当做一个可以自动解析的可选类型<br/>
使用隐式解析必须确保这个值不会为空 否则和对空值进行强行解析一样会出错</p>
</blockquote>

<pre><code class="language-swift">let possibleString: String? = &quot;An optional string.&quot;
let forcedString: String = possibleString! // 需要感叹号来获取值

let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString // 不需要感叹号
</code></pre>

<h3 id="toc_23">错误处理</h3>

<p><code>Swift</code>允许我们在函数声明中通过添加 <code>throw</code>类型来判处错误消息<br/>
当我们调用一个可能抛出错误消息的函数时,应该在表达式前置<code>try</code>关键字</p>

<blockquote>
<p>这里只是简单了解</p>
</blockquote>

<pre><code class="language-swift">func makeASandwich() throws {
// ...
}
do {
    try makeASandwich()
    eatASandwich()//没有错误抛出会执行这个函数
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)//匹配的错误抛出 函数被调用并且会
}
</code></pre>

<h2 id="toc_24">断言</h2>

<p>有时我们需要在代码中判断某些条件是否满足条件来决定是否继续执行,这时候我们需要断言</p>

<h3 id="toc_25">使用断言进行调试</h3>

<p>断言会在运行时判断一个逻辑条件是否为<code>ture</code>。如果条件判断为<code>true</code>，代码运行会继续进<br/>
行；如果条件判断为<code>false</code> ，代码执行结束，你的应用被终止。</p>

<p>我们在调试环境中触发一个断言，可以检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>

<p>你可以使用全局<code>assert(_:_:file:line:)</code>函数来写一个断言.<br/>
向这个函数传入一个结果为 <code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>

<pre><code class="language-swift">let age = -3
assert(age &gt;= 0, &quot;A person&#39;s age cannot be less than zero&quot;)
// 因为 age &lt; 0，所以断言会触发
</code></pre>

<blockquote>
<p>当代码使用优化编译的时候，断言将会被禁用，例如在<code>Xcode</code>中，使用默认的<code>target Release</code>配置选项来<code>build</code>时，断言会被禁用。</p>
</blockquote>

<h3 id="toc_26">何时使用断言</h3>

<p>当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。</p>

<blockquote>
<p>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

<p>断言的适用情景:</p>

<ul>
<li>整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是 nil ，但是后面的代码运行需要一个非 nil 值。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14966582354331.html">swift简介</a></h1>
			<p class="meta"><time datetime="2017-06-05T18:23:55+08:00" 
			pubdate data-updated="true">06/05/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>Swift</code>采用了<code>Objective-C</code>的命名参数以及动态对象模型，可以无缝对接到现有的<code>Cocoa</code>框架，并且可以兼容<code>Objective-C</code>代码。在此基础之上，<code>Swift</code> 还有许多新特性并且支持过程式编程和面向对象编程。</p>

<p>特性:<br/>
程序入口:<br/>
<code>print(&quot;Hello, world!&quot;)</code><br/>
在<code>Swift</code>中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口 点，所以你也不需要<code>main()</code> 函数。</p>

<h2 id="toc_0">基础知识</h2>

<h3 id="toc_1">简单值</h3>

<p><strong>使用 <code>let</code> 来声明常量，使用 <code>var</code> 来声明变量</strong>。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能 为它赋值一次。</p>

<pre><code class="language-swift">let firstConstant = 10
var firstVariable:Double
</code></pre>

<p>在声明的同时赋值的话不需要声明类型,编译器可以推断出来，但是如果信息不够（没有初始值）,必须要在变量后声明类型;</p>

<p><strong>值永远不会被隐式转换为其他类型,如果要转换请显式转换</strong><br/>
整形转为字符串</p>

<pre><code class="language-swift">//显式强制类型装换
let width = 94
let widthLabel = &quot;The width is&quot; + String(width)
//使用 \() 来把一个浮点计算转换成字符串
let apples = 3
let appleSummary:String = &quot;I have \(apples) apples.&quot;
</code></pre>

<p>使用方括号<code>[]</code>来创建数组和字典，并使用<code>下标或者键(key)</code>来访问元素。最后一个元素后面允许有个逗号</p>

<pre><code class="language-swift">var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]
shoppingList[1] = &quot;bottle of water&quot;
var occupations = [
    &quot;Malcolm&quot;: &quot;Captain&quot;,
    &quot;Kaylee&quot;: &quot;Mechanic&quot;,
]
occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;
</code></pre>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="Swift-BaseLearning_2.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>