
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14940350647350.html">图像IO</a></h1>
			<p class="meta"><time datetime="2017-05-06T09:44:24+08:00" 
			pubdate data-updated="true">05/06/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>和绘图相关的是图像性能，我们研究如何从闪存驱动器或者网络中加载和显示图片</p>

<p>补充知识:<br/>
<a href="http://www.cocoachina.com/ios/20170227/18784.html">图片加载解压</a>原理知识学习<br/>
<strong>图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程</strong><br/>
我们平常看大的图片大小其实只是图片的二进制数据大小即原始文件大小<br/>
解压后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关:</p>

<blockquote>
<p>解压缩后的图片大小 = 图片的像素宽 30 * 图片的像素高 30 * 每个像素所占的字节数 4</p>
</blockquote>

<p>事实上不管是<code>JPEG</code>还是<code>PNG</code>图片，都是一种压缩的位图图形格式。只不过<code>PNG</code>图片是无损压缩，并且支持<code>alpha</code>通道，而<code>JPEG</code>图片则是有损压缩，可以指定<code>0-100%</code>的压缩比。值得一提的是，在苹果的<code>SDK</code> 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>

<pre><code class="language-objectivec">UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);
 
// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)            
UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);
</code></pre>

<p>在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作</p>

<h3 id="toc_0">加载和潜伏</h3>

<p>绘图实际消耗的时间并不是影响性能主要因素。图片消耗很大一部分内存,而且不太可能把需要显示的图片都保留在内存中,所以在应用运行时周期性的加载和卸载图片</p>

<p>图片文件的加载速度被<code>CPU</code>和<code>IO(输入输出)</code>同时影响。iOS设备中的闪存虽然比传统硬盘块,但是比RAM仍然慢了200倍，我们需要小心加载来避免延迟</p>

<ol>
<li><p>在程序生命周期不易察觉时来加载图片</p>
<p>比如启动或者屏幕切换<br/>
按下按钮和按钮响应时间之间最大延时大概200ms,而切换每帧动画16ms<br/>
可以程序首次启动加载图片,如果启动时间过长影响用户体验,超过20s苹果就会关闭你的应用了</p>
<p>但是有时候不适合提前加载所有图片,比如图片过多或者需要从网络远程下载图片</p></li>
</ol>

<h4 id="toc_1">线程加载</h4>

<p>对于在主线程加载图片(比如<code>[UIImage imageWithContentsOfFile:</code>)如果图片较大就会卡线程,我们需要在后台加载图片,可以使用<code>GCD</code>或者<code>NSOperationQueue</code>创建自定义线程，或者使用<code>CATiledLayer</code>,为了从远程网络加载图片，我们可以使用异步的<code>NSURLConnection</code>但是对本地存储的图片，并不十分有效。</p>

<h5 id="toc_2">GCD和 NSOperationQueue</h5>

<p>GCD（Grand Central Dispatch）和 NSOperationQueue 很类似，都给我们提供了队列闭包块来在线程中按一定顺序来执行。 NSOperationQueue 有一个Objecive-C接口（而不是使用GCD的全局C函数），同样在操作优先级和依赖关系上提供了很好的粒度控制，但是需要更多地设置代码。</p>

<p>下面是  我们在低优先级的后台队列而不是主线程用<code>GCD</code>加载图片</p>

<pre><code class="language-objectivec">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView
cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
//dequeue cell
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot;
forIndexPath:indexPath];
    //add image view
    const NSInteger imageTag = 99;
    UIImageView *imageView = (UIImageView *)[cell viewWithTag:imageTag];
    if (!imageView) {
        imageView = [[UIImageView alloc] initWithFrame: cell.contentView.bounds];
        imageView.tag = imageTag;
        [cell.contentView addSubview:imageView];
    }
//tag cell with index and clear current image
    cell.tag = indexPath.row;
    imageView.image = nil;
    //switch to background thread
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
    //load image
        NSInteger index = indexPath.row;
        NSString *imagePath = self.imagePaths[index];
        UIImage *image = [UIImage imageWithContentsOfFile:imagePath];
        //需要在主线程更新UI
        dispatch_async(dispatch_get_main_queue(), ^{
            if (index == cell.tag) {
                imageView.image = image; 
            }
        });
    });
    return cell;
}
</code></pre>

<p>由于视图在<code>UICollectionView</code>中是会重复利用的,因此我们加载图片时需要确定是否被不同索引重复利用。为<strong>避免图片加载到错误视图中,我们在加载前把单元格打上索引标签,然后在设置图片时检测标签是否改变</strong>.</p>

<h4 id="toc_3">延迟解压</h4>

<p>在上面我们认为 <strong>性能瓶颈在于 加载图片到内存中,其实这只是问题之一</strong>.</p>

<p><strong>一旦图片文件被加载就必须要进行解码，解码过程是一个相当复杂的任务，需要消耗非常长的时间。解码后的图片将同样使用相当大的内存</strong>。</p>

<p>用于加载的CPU时间与图片格式有关,<code>PNG</code>文件较大所以加载时间比<code>JPEG</code>更长,但是解码速度较快,而且<code>Xcode</code>会把<code>PNG</code>进行解码优化后引入工程.而<code>JPEG</code>图片较小,所以加载更快但是解压要消耗更长时间,因为<code>JPEG</code>解压算法比基于<code>zip</code>的<code>PNG</code>算法更加复杂</p>

<p>在加载图片时,<strong>iOS通常会在图片加载到内存之后,绘制之前解压,这通常是消耗时间问题所在</strong></p>

<blockquote>
<p>此处的解码和解压意义相同<br/>
避免延时加载方法:</p>
</blockquote>

<ol>
<li>我们可以用<code>UIImage</code>的 <code>+imageNamed: 方法</code>，它不同于<code>+imageWithContentsOfFile: （和其他别的 UIImage 加载方法）</code>它可以避免延时加载，会在加载图片后立刻解压.但是这个方法只对资源束中图片有效.</li>
<li>另一种立刻加载图片的方法就是把它设置成图层内容，或者是<code>UIImageView</code>的<code>image</code>属性,但是这都需要在主线程进行,不能提升性能.</li>
<li><p>绕过<code>UIKit</code>，像下面这样使用<code>ImageIO</code>框架</p>
<pre><code class="language-objectivec">NSInteger index = indexPath.row;
NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];<br/>
NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache: @YES};<br/>
CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);<br/>
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);<br/>
UIImage *image = [UIImage imageWithCGImage:imageRef];<br/>
CGImageRelease(imageRef);<br/>
CFRelease(source);
</code></pre>
<p>可以使用<code>kCGImageSourceShouldCache</code>来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。</p></li>
</ol>

<p>最后一种方式用<code>UIKit</code>加载图片,但是会立即绘制到<code>CGContext</code>中去.因为图片必须要在绘制之前解压,所以强制了解压的及时性,好处是绘制图片可以在后台线程执行,不会阻塞UI</p>

<p>强制解压提前渲染图片：</p>

<ul>
<li>将图片的一个像素绘制成一个像素大小的<code>CGContext</code>。这样仍会解压整张图片,但是绘制本身并没有消耗任何时间.加载的图片并不会在特定设备上为绘制做优化,所以可以在任何时间点绘制出来,iOS也就可以丢弃解压后的图片来节省内存</li>
<li>将整张图片绘制到<code>CGContext</code>中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一像素更需要复杂的计算,但是因此产生的图片将会为绘制做优化,而且由于原始压缩图片被抛弃了,iOS就不能够随时丢弃任何解压后的图片来节省内存了。</li>
</ul>

<p>注意苹果特别推荐了不要使用这些诡计来绕过标准图片解压逻辑（所以也是他们选择用默认处理方式的原因）,但是如果你使用很多大图来构建应用，那如果想提升性能，就只能和系统博弈了。</p>

<p>如果不使用<code>+ imageNamed:</code>，那么把整张图片绘制到<code>CGContext</code>可能是最佳的方式了。。尽管你可能认为多余的绘制相较别的解压技术而言性能不是很高，但是新创建的图片（在特定的设备上做过优化）可能比原始图片绘制的更快。</p>

<p>同样，如果想显示图片到比原始尺寸小的容器中，那么一次性在后台线程重新绘制到正确的尺寸会比每次显示的时候都做缩放会更有效</p>

<pre><code class="language-objectivec">//-collectionView:cellForItemAtIndexPath: 方法来重绘图片
UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];
...
//switch to background thread
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
//load image
    NSInteger index = indexPath.row;
    NSString *imagePath = self.imagePaths[index];
    UIImage *image = [UIImage imageWithContentsOfFile:imagePath];
    //redraw image using device context
    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, YES, 0);
    [image drawInRect:imageView.bounds];
    image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    //set image on main thread, but only if index still matches up
    dispatch_async(dispatch_get_main_queue(), ^{
        if (index == cell.tag) {
            imageView.image = image;
        }
    });
});
return cell;

</code></pre>

<h4 id="toc_4">CATiledLayer</h4>

<p>我们在学习<code>CALayer</code>一章，<code>CATiledLayer</code>可以用来异步加载和显示大型图片，而不阻塞用户输入。</p>

<p>我们同样可以用<code>CATiledLayer</code>在<code>UICollectionView</code>中为每个表格创建分离的<code>CATiledLayer</code>实例加载传动器图片，每个表格仅使用一个图层。</p>

<p>但是这样也有弊端:</p>

<ul>
<li><code>CATiledLayer</code>的队列和缓存算法没有暴露出来，所以我们只能祈祷它能匹配我们的需求</li>
<li><code>CATiledLayer</code>需要我们每次重绘图片到<code>CGContext</code>中，即使它已经解压缩，而且和我们单元格尺寸一样（因此可以直接用作图层内容，而不需要重绘）</li>
</ul>

<pre><code class="language-objectivec">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    //dequeue cell
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];
    //add the tiled layer
    CATiledLayer *tileLayer = [cell.contentView.layer.sublayers lastObject];
    if (!tileLayer) {
        tileLayer = [CATiledLayer layer];
        tileLayer.frame = cell.bounds;
        tileLayer.contentsScale = [UIScreen mainScreen].scale;
        tileLayer.tileSize = CGSizeMake(cell.bounds.size.width * [UIScreen mainScreen].scale, cell.bounds.size.height * [UIScreen mainScreen].scale);
        tileLayer.delegate = self;
        [tileLayer setValue:@(indexPath.row) forKey:@&quot;index&quot;];
        [cell.contentView.layer addSublayer:tileLayer];
    }
    //tag the layer with the correct index and reload
    tileLayer.contents = nil;
    [tileLayer setValue:@(indexPath.row) forKey:@&quot;index&quot;];
    [tileLayer setNeedsDisplay];
    return cell;
}

- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //get image index
    NSInteger index = [[layer valueForKey:@&quot;index&quot;] integerValue];
    //load tile image
    NSString *imagePath = self.imagePaths[index];
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];
    //calculate image rect
    CGFloat aspectRatio = tileImage.size.height / tileImage.size.width;
    CGRect imageRect = CGRectZero;
    imageRect.size.width = layer.bounds.size.width;
    imageRect.size.height = layer.bounds.size.height * aspectRatio;
    imageRect.origin.y = (layer.bounds.size.height - imageRect.size.height)/2;
    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:imageRect];
    UIGraphicsPopContext();
}

/**
CATiledLayer 的 tileSize 属性单位是像素，而不是点，所以为了保证瓦
片和表格尺寸一致，需要乘以屏幕比例因子。
在 - drawLayer:inContext: 方法中，我们需要知道图层属于哪一个 indexPath 以加载正确的图片。这里我们利用了 CALayer 的KVC来存储和检索任意的值，将图层和索引打标签
*/
</code></pre>

<p>这样确实可以很好的解决了性能问题，有个小问题是图片加载到屏幕后有个明显的淡入,我们可以通过<code>CATiledLayer</code>的<code>fadeDuration</code>属性来调整淡入速度,甚至直接不要这个淡入,但是这样没法根本上去出问题:因为<strong>图片从加载到准备绘制总是有个延时的，所以会导致滑动时图片的跳入</strong>.(不仅仅是<code>CATiledLayer</code>，我们使用<code>GCD</code>也是有这个问题的)</p>

<p>即使使用上述我们讨论的所有加载图片和缓存的技术，有时候仍然会发现实时加载大图还是有问题。就和13章中提到的那样，iPad上一整个视网膜屏图片分辨率达到了2048x1536，而且会消耗12MB的RAM（未压缩）。第三代iPad的硬件并不能支持1/60秒的帧率加载，解压和显示这种图片。即使用后台线程加载来避免动画卡顿，仍然解决不了问题。</p>

<p>我们可以在加载的同时显示一个占位图片，但这并没有根本解决问题，我们可以做到更好。</p>

<h4 id="toc_5">分辨率交换</h4>

<p>视网膜分辨率代表人眼在正常视角能分辨的最小像素尺寸.但是这只是对于静态像素来说的,当我们观察一个移动图片时,眼镜对细节不敏感,所以低分辨率图片和视网膜质量图片就没什么区别了.</p>

<p>因此我们需要快速加载和显示移动大图,可以在移动传送器的时候显示一张小图(或者低分辨率图片),然后在停止之后换为大图。这意味着我们需要存两份不同分辨率图片,不过我们在应用中为了支持retina和非retina屏,这本来就是要做的<br/>
对于那些没有可用的低分辨率图片，我们可以动态将大图绘制到较小的CGContext,然后存到某处复用</p>

<h3 id="toc_6">缓存</h3>

<p>如果很多图片要显示 最好不要提前把所有图片都加载进来,而应该在移出屏幕后立即销毁。我们可以通过选择性缓存来避免来回滚动时图片的重复加载.</p>

<p>缓存原理:存储昂贵计算后的结果(或者从闪存或者网络加载的文件)在内存中,以便后续使用.缓存本来就是一个权衡过程,消耗内存和提高性能的权衡</p>

<p>大多数情况下,iOS为我们做好了图片的缓存.</p>

<h4 id="toc_7">+ imageNamed:方法</h4>

<p>我们知道用这个方法加载图片可以立刻解压图片而不用等到绘制的时候,除此之外另外一个好处就是:<strong>它在内存中自动缓存了解压后的图片</strong>，即使你没有保留对他的任何使用</p>

<p>对于iOS中那些主要的图片(如图标、按钮和背景图片)，我们这是最简单有效的方式.在nib中的图片同样也是用这种机制。</p>

<p>当然它并不是适用任何情况,有时候我们还是要实现自己的缓存机制:</p>

<ul>
<li><code>[UIImage imageNamed:]</code>方法仅仅适用于在应用程序资源束目录下的图片，但是大多数图片都是从网络或者用户的相机中获取,这种方法也就不适用了</li>
<li><code>[UIImage imageNamed:]</code>如果用来缓存那些大图,iOS系统很可能会移除这些图片来节省内存，在切换页面时性能就会下降。所以我们队传送器的图片使用单独的缓存机制把它和应用图片的生命周期解耦</li>
<li><code>[UIImage imageNamed:]</code>缓存机制并不是公开,所以我们不能很好的控制它。例如不能检测图片是否已经缓存，不能设置缓存大小，也没法控制图片从缓存移除</li>
</ul>

<h4 id="toc_8">自定义缓存</h4>

<p>自定义一个缓存是非常困难的，需要涉及这些方面:</p>

<ul>
<li>选择一个合适的<code>缓存键 - 缓存键</code>用来做图片的唯一标识。如果实时创建图片,通常不好生成一个字符串来区分别的图片。在我们的图片传送器例子，我们可以用图片的文件名</li>
<li>提前缓存 - 当然你如果我们生成和加载的代价很大,我们会想第一次用到的时候再去加载和缓存.提前加载的逻辑是应用内就有的,但是在我们的例子中这也很好实现，因为对于给定位置和方向我们很容易判读出下一张出现的图片。</li>
<li>缓存失效 - 图片文件发生改变,我们需要怎么通知缓存更新呢。我们的例子中是存程序资源加载静态图片不需要考虑这些.对于那些可能会被修改和覆盖的图片来说我们通常给在图片缓存时打上一个时间戳当文件更新时来作比较</li>
<li>缓存回收 - 当内存不够时,我们需要用合适的算法来清空缓存.幸运的是我们可以用苹果提供的叫<code>NSCache</code>通用解决方案</li>
</ul>

<h4 id="toc_9">NSCache</h4>

<p><code>NSCache</code>和<code>NSDictionary</code>类似。你可以通过<code>- setObject:forKey:</code>和<code>- object:forKey:</code>方法分别来插入，检索。不同的是<code>NSCache</code>在系统低内存是自动丢弃存储对象</p>

<p><code>NSCache</code>用来判断何时丢弃对象的算法并没有在文档中给出，但是你可以使用<code>- setCountLimit:</code>方法设置缓存大小，以及<code>- setObject:forKey:cost:</code>来对每个存储的对象指定消耗的值来提供一些暗示。</p>

<p>指定消耗数值可以用来指定相对的重建成本。如果对大图指定一个大的消耗值，那么缓存就知道这些物体的存储更加昂贵，于是当有大的性能问题的时候才会丢弃这些物体。你也可以用<code>- setTotalCostLimit:</code>方法来指定全体缓存的尺寸。</p>

<p><code>NSCache</code>是一个普遍的缓存解决方案</p>

<p>使用图片缓存和提前加载来扩展之前的传送器案例:</p>

<pre><code class="language-objectivec">- (UIImage *)loadImageAtIndex:(NSUInteger)index
{
    //set up cache
    static NSCache *cache = nil;
    if (!cache) {
        cache = [[NSCache alloc] init];
    }
    //if already cached, return immediately
    UIImage *image = [cache objectForKey:@(index)];
    if (image) {
        return [image isKindOfClass:[NSNull class]]? nil: image;
    }
    //set placeholder to avoid reloading image multiple times
    [cache setObject:[NSNull null] forKey:@(index)];
    //switch to background thread
    dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
        //load image
        NSString *imagePath = self.imagePaths[index];
        UIImage *image = [UIImage imageWithContentsOfFile:imagePath];
        //redraw image using device context
        UIGraphicsBeginImageContextWithOptions(image.size, YES, 0);
        [image drawAtPoint:CGPointZero];
        image = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        //set image for correct image view
        dispatch_async(dispatch_get_main_queue(), ^{ //cache the image
            [cache setObject:image forKey:@(index)];
            //display the image
            NSIndexPath *indexPath = [NSIndexPath indexPathForItem: index inSection:0]; 
            UICollectionViewCell *cell = [self.collectionView cellForItemAtIndexPath:indexPath];
            UIImageView *imageView = [cell.contentView.subviews lastObject];
            imageView.image = image;
        });
    });
    //not loaded yet
    return nil;
    }
    
    //效果确实更好了
</code></pre>

<h3 id="toc_10">文件格式</h3>

<p><strong>图片加载性能取决于加载大图的时间和解压小图的权衡</strong>.<br/>
很多苹果文档都说<code>PNG</code>是<code>iOS</code>所有图片加载的最好算法，但这是<strong>极度误导的过时信息</strong>了</p>

<p><code>PNG</code>图片使用的无损压缩算法可以比使用<code>JPEG</code>的图片做到更快地解压，但是由于闪存访问的原因，这些加载的时间并没有什么区别。</p>

<p>经过测试:<br/>
<code>PNG</code>和<code>JPEG</code>压缩算法作用于两种不同的图片类型：<code>JPEG</code>对于噪点大的图片效果很好；但是<code>PNG</code>更适合于扁平颜色，锋利的线条或者一些渐变色的图片。</p>

<p><img src="media/14940350647350/14949362399011.jpg" alt=""/></p>

<p>但是<code>JPEG</code>图片并不是所有情况都适用，如果图片需要透明效果或者压缩之后细节损失很多,就需要用别的格式了</p>

<h4 id="toc_11">混合图片</h4>

<p>对于包含透明的图片来说，最好是使用压缩透明通道的PNG图片和压缩RGB部分的JPEG图片混合起来加载。这就对任何格式都适用了，而且无论从质量还是文件尺寸还是加载性能来说都和PNG和JPEG的图片相近。</p>

<pre><code class="language-objectivec">- (void)viewDidLoad
{
    [super viewDidLoad];
    //load color image
    UIImage *image = [UIImage imageNamed:@&quot;Snowman.jpg&quot;];
    //load mask image
    UIImage *mask = [UIImage imageNamed:@&quot;SnowmanMask.png&quot;];
    //convert mask to correct format
    CGColorSpaceRef graySpace = CGColorSpaceCreateDeviceGray();
    CGImageRef maskRef = CGImageCreateCopyWithColorSpace(mask.CGImage, graySpace);
    CGColorSpaceRelease(graySpace);
    //combine images
    CGImageRef resultRef = CGImageCreateWithMask(image.CGImage, maskRef);
    UIImage *result = [UIImage imageWithCGImage:resultRef];
    CGImageRelease(resultRef);
    CGImageRelease(maskRef);
    //display result
    self.imageView.image = result;
}
</code></pre>

<p>我们不可能对每张图片都使用两个独立文件:<br/>
我们可以用一个第三方的<a href="https://github.com/nicklockwood/JPNG">JPNG库</a>，对这个技术提供了开源可复用的实现,并且直接添加<code>+imageNamed:</code>和 <code>+imageWithContentsOfFile:</code>方法的支持</p>

<h4 id="toc_12">JPEG 2000</h4>

<p>除了JPEG和PNG之外iOS还支持别的一些格式，例如TIFF和GIF，但是由于他们质量压缩得更厉害，性能比JPEG和PNG糟糕的多，所以大多数情况并不用考虑。</p>

<p>苹果低调添加了对<code>JPEG 2000</code>图片格式的支持，虽然并不是很好的支持,但是<code>JPEG 2000</code>图片在（设备和模拟器）运行时会有效，而且比<code>JPEG</code>质量更好，同样也对透明通道有很好的支持。但是<code>JPEG 2000</code>图片在加载和显示图片方面明显要比<code>PNG</code>和<code>JPEG</code>慢得多，所以对图片大小比运行效率更敏感的时候，使用它是一个不错的选择。</p>

<h4 id="toc_13">PVRTC</h4>

<p>当前iOS设备都有用<code>Imagination Technologies PowerVR</code>图像芯片作为<code>GPU</code>，<code>PowerVR</code>芯片支持一种叫做<code>PVRTC</code>的标准图片压缩.</p>

<p>和其他大多数图片格式不同,PVRTC不用提前解压就可以直接绘制到屏幕上。意味着在加载图片之后不需要有解压操作，所以内存中的图片比其他图片格式大大减少了(这取决于压缩设置，大概只有1/60那么大)</p>

<p>弊端：</p>

<ul>
<li>虽然它加载时消耗的<code>RAM</code>少,但是文件比<code>JPEG</code>大，甚至比<code>PNG</code>还大</li>
<li><code>PVRTC</code>必须是二维正方形</li>
<li>质量并不好，尤其是透明图片</li>
<li>PVRTC不能用Core Graphics绘制，也不能在普通的 UIImageView 显示，也不能直接用作图层的内容。你必须要用作OpenGL纹理加载PVRTC图片，然后映射到一对三角板来在 CAEAGLLayer 或者 GLKView 中显示。</li>
<li>OpenGL纹理加载PVRTC图片开销很大</li>
<li>使用的是不对称压缩算法,尽管立即解压 但是压缩过程很漫长</li>
</ul>

<p>如果愿意使用<code>OpenGL</code>,也愿意提前生成图片,那么可以用<code>PVRTC</code>，将提供相对于别的可用格式来说非常高效的加载性能。</p>

<p>我们可以使用<a href="http://www.imgtec.com/powervr/insider/sdkdownloads">Imagination Technologies PVRTexTool</a>，</p>

<pre><code class="language-objectivec">//终端将PNG转换为PVRTC命令
/Applications/Imagination/PowerVR/GraphicsSDK/PVRTexTool/CL/OSX_x86/PVRTexToolCL -i {input_file_name}.png -o {output_file_name}.pvr -legacypvr -p -f PVRTC1_4 -q pvrtcbest
</code></pre>

<p>用<code>openGL</code>实现<code>UIImageView</code>功能： <a href="https://github.com/nicklockwood/GLView">GLView的库</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15003778819226.html">枚举</a></h1>
			<p class="meta"><time datetime="2017-07-18T19:38:01+08:00" 
			pubdate data-updated="true">07/18/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li><p>与C语言类似但不同，<code>Swift</code>中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p></li>
<li><p>枚举成员可以指定任意类型的关联值存储到枚举成员中</p></li>
<li><p>在 Swift 中，<strong>枚举类型</strong>是一等（first-class）类型。采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p></li>
</ol>

<h2 id="toc_0">枚举语法</h2>

<p>用<code>enum</code>关键字来创建枚举</p>

<pre><code class="language-swift">enum CompassPoint {
    case north
    case south
    case east
    case west
}

//多个成员可以在同一行 用 , 隔开
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>我们使用<code>case</code>来定义一个新的枚举成员值</p>

<blockquote>
<p>注意:</p>

<p>与OC不同,Swift枚举成员不会再创建时被赋予一个默认的整型值。这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的<code>CompassPoint</code>类型</p>
</blockquote>

<p>在<code>Swift</code>中每个枚举定义了一个全新的类型，与Swift中的其他类型一样,名字以大写字母开头</p>

<pre><code class="language-swift">var directionToHead = CompassPoint.west
//此时directionToHead类型可以被推断出来,我们可以直接使用 . 语法将其设置为另一个枚举值
directionToHead = .east
</code></pre>

<p>当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名。</p>

<h2 id="toc_1">用switch语句匹配枚举值</h2>

<p>在判断一个枚举类型值时,<code>switch</code>必须穷举所有情况，如果不需要匹配每个成员可以使用<code>default</code>分支</p>

<pre><code class="language-swift">let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print(&quot;Mostly harmless&quot;)
default:
    print(&quot;Not a safe place for humans&quot;)
}
// 打印 &quot;Mostly harmless”
</code></pre>

<h2 id="toc_2">枚举成员的遍历</h2>

<p>有时我们可能会需要得到一个包含所有枚举成员的集合。这时，可以这么实现:</p>

<p>令枚举遵循<code>CaseInterable</code>协议。Swift会生成一个<code>allClass</code>属性，用于表示一个包含枚举所有成员的集合。</p>

<pre><code class="language-swift">enum Beverage: CaseIterable {
    case coffee, tea, juice
}
let numberOfChoices = Beverage.allCases.count
print(&quot;\(numberOfChoices) beverages available&quot;)
// 打印“3 beverages available”
for beverage in Beverage.allCases {
    print(beverage)
}
</code></pre>

<h2 id="toc_3">关联值</h2>

<p>可以使用<code>Swift</code>的枚举来<strong>存储任意类型的关联值</strong>,枚举成员的关联值类型可以不同</p>

<pre><code class="language-swift">enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
</code></pre>

<p>这个枚举的意思是:定义一个枚举类型,其一个成员值是具有 <code>(Int，Int，Int，Int)</code>类型关联值的 upc，另一个是<code>String</code>类型关联值的qrcode。这个定义并不提供和任何Int或String类型的关联值，只是定义了，当Barcode常量和变量等于<code>barcode.upc</code>或<code>barcode.qrCode</code>时，可以存储的关联值类型</p>

<p>比如创建任意条形码类型</p>

<pre><code class="language-swift">//给其赋值关联的元组值
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
//赋值新的枚举关联字符串
productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)
//productBarcode同一时间只能存储这两个值中的一个
</code></pre>

<pre><code class="language-swift">switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case .qrCode(let productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 打印 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<p>我们可以提取出来关联值作为常量或变量</p>

<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>：</p>

<pre><code class="language-swift">switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case let .qrCode(productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 输出 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<h2 id="toc_4">原始值</h2>

<p>作为关联值的替代选择，枚举成员可以被<strong>默认值（称为原始值）预填充</strong>，这些原始值的类型必须相同。</p>

<pre><code class="language-swift">enum ASCIIControlCharacter: Character {
    case tab = &quot;\t&quot;
    case lineFeed = &quot;\n&quot;
    case carriageReturn = &quot;\r&quot;
}
</code></pre>

<p>枚举类型<code>ASCIIControlCharacter</code>的原始值类型被定义为<code>Character</code><br/>
每个原始值在枚举声明中必须是唯一的。</p>

<blockquote>
<p>注意：</p>

<p>原始值与关联值的不同，原始值是在定义枚举是预先填充的值，<br/>
对于特定的枚举成员其原始值不变<br/>
关联值是创建一个基于枚举成员的常量或变量时才设置的值,枚举成员的关联值可以变化</p>
</blockquote>

<h3 id="toc_5">原始值的隐式赋值</h3>

<p>当原始值为整数或者字符串类型的枚举时,此时不需要显式的为每个枚举成员设置原始值，Swift会自动为每个枚举成员设置原始值;</p>

<ol>
<li><p>原始值为整形枚举</p>
<pre><code class="language-swift">enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune<br/>
}
</code></pre>
<p>当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0</p></li>
<li><p>原始值为字符串类型</p>
<pre><code class="language-swift">enum CompassPoint: String {
    case north, south, east, west<br/>
}<br/>
//CompassPoint.south 拥有隐式原始值 south
</code></pre>
<p>使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称</p></li>
</ol>

<p>使用枚举成员的<code>rawValue</code>属性可以访问枚举成员初始值</p>

<pre><code class="language-swift">let earthsOrder = Planet.earth.rawValue
    // earthsOrder 值为 3
let sunsetDirection = CompassPoint.west.rawValue
    // sunsetDirection 值为 &quot;west&quot;
</code></pre>

<h3 id="toc_6">原始值初始化枚举实例</h3>

<p>定义枚举时使用原始值,会获得一个初始化方法,有一个<code>rawValue</code>类型为原始值类型的参数，返回一个枚举类型或为<code>nil</code></p>

<pre><code class="language-swift">let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet 类型为 Planet? 值为 Planet.uranus
//因为不一定都能找到匹配的行星  返回的是可选类型
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print(&quot;Mostly harmless&quot;)
    default:
        print(&quot;Not a safe place for humans&quot;)
    }
} else {
    print(&quot;There isn&#39;t a planet at position \(positionToFind)&quot;)
}
//找不到11代表的行星

</code></pre>

<blockquote>
<p>注意：</p>

<p>原始值构造器是一个可失败构造器  因为并不是每个原始值都有与之对应的枚举成员</p>
</blockquote>

<h2 id="toc_7">递归枚举</h2>

<p><strong>递归枚举</strong>也是是一种枚举类型，只是它<strong>有一个或多个成员使用该枚举类型实例作为关联值</strong><br/>
在使用递归枚举时，编译器会加上一个间接层。<br/>
可以在枚举成员前加<code>indirect</code>表示该成员可递归, 或者在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归</p>

<pre><code class="language-swift">enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}

indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}

//递归枚举使用
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

//递归函数中使用递归枚举
func evaluate(_ expression: ArithmeticExpression) -&gt; Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}
print(evaluate(product))//18
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15540375355169.html">Clang CFE</a></h1>
			<p class="meta"><time datetime="2019-03-31T21:05:35+08:00" 
			pubdate data-updated="true">03/31/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>常用的Clang前端组件和库</p>

<ul>
<li>LLVM Support Library: <code>LLVM libSupport</code>库提供了许多底层库和数据结果，包括命令行option处理，各种容器和系统抽象层，用于文件系统访问</li>
<li>The Clang &quot;Basic&quot; Library: 提供了追踪和操纵<code>source buffers</code>，<code>source buffers</code>的位置，<code>diagnostics</code>，<code>token</code>，抽象目标以及编译语言自己信息的<code>low-level</code>实用程序。还部分由可以用在其他非C语言比如<code>SourceLocation</code>、<code>SourceManager</code>,<code>Diagnositics</code>，<code>FileManager</code>等。其中Diagnositics这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码那些不正确，按照严重程度产生warning或error，每个诊断会有唯一ID,sourceLocation会负责管理</li>
<li>The Driver Library : 和Driver相关的库</li>
<li>Precompiled Header： Clang支持预编译Header的两个实现</li>
<li>The Frontend Library： 这个库包含在Clang库之上构建的功能，比如输出diagnosistics的几种方法</li>
<li>The Lexer and Preprocessor Library: 词法分析和预处理的库，包含了Token、Annotation、Tokens、TokenLexer、Lexer等词法类，还有Parser library和AST语法树相关的比如Type、ASTContext、QualType、DeclarationName、DeclContext以及CFG类</li>
<li>The Sema Library： 解析器调用此库时，会对输入进行语义分析。对有效的程序，Sema为解析构造一个AST</li>
<li>The CodeGen Lirary： 用AST作为输入，生成LLVM IR代码</li>
</ul>

<h2 id="toc_0">libClang</h2>

<h2 id="toc_1">Driver</h2>

<p>Driver是Clang面向用户的接口，用来解析Option设置，判断决定调用的工具链，最终完成整个编译过程</p>

<p>Driver 的流程是按照 ArgList - Actions - Jobs 来的<br/>
<img src="media/15540375355169/15540403081825.jpg" alt="" style="width:716px;"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15543581687703.html">苹果官方运行时源码</a></h1>
			<p class="meta"><time datetime="2019-04-04T14:09:28+08:00" 
			pubdate data-updated="true">04/04/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>苹果开放的<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/">源码</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15553791452907.html">autorelease && autorelease pool block</a></h1>
			<p class="meta"><time datetime="2019-04-16T09:45:45+08:00" 
			pubdate data-updated="true">04/16/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>autorelease pool block提供了一个允许我们延时<code>deallocated</code>对象的机制</p>

<h2 id="toc_0">autorelease</h2>

<p><code>NSAutoReleasePool</code>对象的生存周期相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>的实例方法，会在废弃NSAutorelease对象时，调用release方法</p>

<pre><code class="language-objectivec">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];
[pool drain]; //调用pool drain方法相当于调用[obj release]
</code></pre>

<p>在Cocoa框架也有很多可以返回autorelease对象的方法</p>

<pre><code class="language-objectivec">//返回autorelease对象
id array = [NSMutableArray Array];
//相当与
id array = [[[NSMutableArray alloc] init] autorelease];
</code></pre>

<h2 id="toc_1">autorelease 原理</h2>

<p>在NSAutoreleasePool维持了一个数组来保存autorelase的对象，[obj autorelease]方法实际上是调用了<code>NSAutoreleasePool</code>的<code>[NSAutoreleasePool addObject:obj]</code>方法，该方法会找到当前的pool并add到数组中，当调用<code>[pool drain]</code>时会废弃当前pool对象，并释放内部数组，因此内部所有对象都会被调用release方法</p>

<blockquote>
<p>可以使用<code>[NSAutoreleasePool showPools];</code>这个非公开方法查看现在的pool中对象状况,查看结果类似下面输出，可以用其查看对象是否被自动release</p>
</blockquote>

<pre><code class="language-objectivec">objc[41725]: ##############
objc[41725]: AUTORELEASE POOLS for thread 0x10cd6f5c0
objc[41725]: 2337 releases pending.
objc[41725]: [0x7ff2b4000000]  ................  PAGE (full)  (cold)
objc[41725]: [0x7ff2b4000038]    0x6000012fd180  __NSArrayI
objc[41725]: [0x7ff2b4000040]    0x6000024aa1c0  __NSSetI
objc[41725]: [0x7ff2b4000048]  ################  POOL 0x7ff2b4000048
objc[41725]: [0x7ff2b4000050]    0x6000007a8480  __NSCFString
...
objc[41725]: [0x7ff2b4000058]  ################  POOL 0x7ff2b4000058
objc[41725]: [0x7ff2b406ea10]  ################  POOL 0x7ff2b406ea10
objc[41725]: [0x7ff2b406ea18]    0x6000005a77c0  NSObject
objc[41725]: ##############
</code></pre>

<h2 id="toc_2">autorelease pool block</h2>

<p>在Cocoa框架中，主循环的RunLoop会对<code>NSAutoreleasePool</code>进行生成、持有和废弃，因此，通常，我们不需要创建自己的自动释放池，但是有些情况下我怕们需要这么做<br/>
在autorelease pool block结束时，所有在block内部收到<code>autorelease</code>消息的对象都会被发送一个<code>release</code>消息</p>

<p>autorelease pool block可以嵌套:</p>

<pre><code class="language-objectivec">@autoreleasepool {
    // . . .
    @autoreleasepool {
        // . . .
    }
    . . .
}
</code></pre>

<p>Cocoa中代码都是在自动释放池block中执行，否则会自动释放的对象未被释放造成内存泄漏。(因此，如果在自动释放池block外执行走动式房消息，Cocoa会报错)。AppKit或者UIKit框架都在自动释放池block中处理每个事件循环(详情见runLoop)。因此，通常不需要创建autorelease pool block，但是<strong>以下三种情况可能需要使用自己的自动释放池</strong>：</p>

<ul>
<li>假如编写不基于UI框架的程序，例如命令行工具</li>
<li>假如编写一个创建了很多临时对象的循环<br/>
可以再循环内的下一次迭代之前处理这些对象，有助于减少应用程序的最大内存占用量</li>
<li>如果你创建了一个辅助线程<br/>
当你的线程开始执行时，必须创建自己的自动释放池，否则你的应用程序有可能会内存泄漏</li>
</ul>

<h3 id="toc_3">使用本地自动释放池block减少峰值内存占用</h3>

<pre><code class="language-objectivec">NSArray *urls = &lt;# An array of file URLs #&gt;;
for (NSURL *url in urls) {
 
    @autoreleasepool {
        NSError *error;
        NSString *fileContents = [NSString stringWithContentsOfURL:url
                                         encoding:NSUTF8StringEncoding error:&amp;error];
        /* Process the string, creating and autoreleasing more objects. */
    }
}
</code></pre>

<p>在上面例子中，for循环每次循环的自动释放block结束时，将自动释放对象(例如:<code>fileContents</code>)发送release消息</p>

<p>在自动释放池block后，块中的自动释放对象不应该再向其发送消息或者返回。如果想要将其返回，则可以先将其<code>retain</code>然后在block外将其autorelease</p>

<pre><code class="language-objectivec">– (id)findMatchingObject:(id)anObject {
 
    id match;
    while (match == nil) {
        @autoreleasepool {
 
            /* Do a search that creates a lot of temporary objects. */
            match = [self expensiveSearchForObject:anObject];
 
            if (match != nil) {
                [match retain]; /* Keep match around. */
            }
        }
    }
 
    return [match autorelease];   /* Let match go and return it. */
}
</code></pre>

<h3 id="toc_4">线程和自动释放池block</h3>

<p><code>Cocoa</code>应用程序的每个线程都会维护自己的自动释放池堆栈。如果编写基于<code>Foundation</code>的程序或者分离线程，则你必须创建自己的autoreleasePool</p>

<p>如果应用程序或者线程长时间运行，则有可能产生大量自动释放对象，此时就需要使用自动释放池(例如主线程的UIKit和AppKit)；否则自动释放对象会累计，造成内存增加。但，如果你的线程没有进行Cocoa调用，则不需要使用自动释放池block</p>

<blockquote>
<p>注意:<br/>
<strong>如果使用POSIX线程API而不是NSThread创建辅助线程，则除非Cocoa处于多线程模式，否则不能使用Cocoa</strong>Cocoa仅在分离其第一个NSThread对象后才进入多线程模式。 要在辅助POSIX线程上使用Cocoa，您的应用程序必须首先分离至少一个NSThread对象，该对象可以立即退出。 您可以使用NSThread类方法isMultiThreaded测试Cocoa是否处于多线程模式。</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14877247419344.html">Objc Runtime</a></h1>
			<p class="meta"><time datetime="2017-02-22T08:52:21+08:00" 
			pubdate data-updated="true">02/22/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。<br/>
当然这就意味着OC的不仅仅需要一个编译器还需要一个运行时的系统来执行编译代码.这个运行时系统即<code>Objc Runtime</code>。<code>Objc Runtime</code>其实是一个<code>Runtime</code>库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="14877247419344.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14903384285214.html">显式动画</a></h1>
			<p class="meta"><time datetime="2017-03-24T14:53:48+08:00" 
			pubdate data-updated="true">03/24/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>隐式动画是在iOS平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础<br/>
显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画</p>

<h3 id="toc_0">属性动画</h3>

<p><code>core animation</code>里面有个很重要的类<code>CAPropertyAnimation</code>(属性动画)，它有两个子类，<code>CABasicAnimation</code>和<code>CAKeyFrameAnimation</code>。</p>

<h4 id="toc_1">属性动画</h4>

<p><code>CAAnimation</code>在动画结束时会属性会回到原值所以<br/>
我们在做了显式动画后可以用<code>CAAnimationDelegate</code>中<code>- animationDidStop:finished:</code>方法来更新图层属性（一般设置其为终值）,更新属性的时候我们需要一个新的事务并且禁用图层行为.否则会有两次动画.</p>

<pre><code class="language-objectivec">- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag
{
    //set the backgroundColor property to match animation toValue
    [CATransaction begin];
    [CATransaction setDisableActions:YES];
    self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;
    [CATransaction commit];
}
</code></pre>

<p>但是如果我们有多个动画这个代理回调是无法区分是哪个图层的调用.<br/>
1.因为这个代理传进来的动画的深拷贝,所以没有办法通过设置动画属性来分辨.<br/>
2.使用<code>-addAnimation:forKey:</code>给动画设置不同key,<code>-animationForKey:</code>找到对应的key来对比，可实现但是比较复杂<br/>
3.最简单的方法,<code>CAAnimation</code>实现了KVC,但是更像一个 NSDictionary ，可以让你<strong>随意设置键值对</strong>，即使和你使用的动画类所声明的属性并不匹配。</p>

<pre><code class="language-objectivec">//初始化动画时用KVC设置键值对
CABasicAnimation *animation = [CABasicAnimation animation];
[self updateHandsAnimated:NO];
animation.keyPath = @&quot;transform&quot;;
animation.toValue = [NSValue valueWithCATransform3D:transform];
animation.duration = 0.5;
animation.delegate = self;
[animation setValue:handView forKey:@&quot;handView&quot;];
[handView.layer addAnimation:animation forKey:nil];
- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag
{
    //通过kvc获取存储的值
    UIView *handView = [anim valueForKey:@&quot;handView&quot;];
    handView.layer.transform = [anim.toValue CATransform3DValue];
}
</code></pre>

<p><code>CABasicAnimation</code>只能作用于一个属性,只能有初始值和结束值</p>

<h4 id="toc_2">关键帧动画</h4>

<p><code>CABasicAnimation</code>揭示了大多数隐式动画背后依赖的机制,但是显式地给图层添加<code>CABasicAnimation</code>相较于<code>隐式动画</code>而言，只能说费力不讨好。</p>

<p><code>CAKeyframeAnimation</code>和<code>CABasicAnimation</code> 类似同样是<code>CAPropertyAnimation</code> 的一个子类它依然作用于单一的一个属性,但是它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>

<p><code>CAKeyframeAnimation</code>关键帧动画:只我们只需要绘制关键帧的动画，然后<code>Core Animation</code>在每帧之间进行插入。</p>

<pre><code class="language-objectivec">- (IBAction)changeColor
{
    //create a keyframe animation
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.duration = 2.0;
    animation.values = @[
    (__bridge id)[UIColor blueColor].CGColor,
    (__bridge id)[UIColor redColor].CGColor,
    (__bridge id)[UIColor greenColor].CGColor,
    (__bridge id)[UIColor blueColor].CGColor ];
    //apply animation to layer
    [self.colorLayer addAnimation:animation forKey:nil];
}
</code></pre>

<p>是因为<code>CAKeyframeAnimation</code>并不能自动把当前值作为第一帧（就像<code>CABasicAnimation</code> 那样把 <code>fromValue</code> 设为 <code>nil</code> ），所以动画会在开始的时候突然由原来色变为蓝色,结束时又突然由结束色变为原来色.</p>

<p>上面是使用<code>animation.values</code>来设置关键帧，我还可以用<code>path 属性</code>指定运动序列.<br/>
我们要绘制一个<code>CGPath</code>的三次贝塞尔曲线，可以通过使用一个基于C的<code>Core Graphics</code>绘图指令来创建，不过用<code>UIKit</code>提供的<code>UIBezierPath</code>类会更简单.</p>

<pre><code class="language-objectivec">UIBezierPath *bezierPath = [[UIBezierPath alloc] init];
[bezierPath moveToPoint:CGPointMake(0, 150)];
[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];
CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
animation.keyPath = @&quot;position&quot;;
animation.duration = 4.0;
animation.path = bezierPath.CGPath;
[shipLayer addAnimation:animation forKey:nil];
</code></pre>

<p>苹果很人性化的给我们提供了<code>rotationMode</code>属性,设置它为常量 <code>kCAAnimationRotateAuto</code>图层将会根据曲线的切线自动旋转。<br/>
<code>animation.rotationMode = kCAAnimationRotateAuto;</code></p>

<h4 id="toc_3">虚拟属性</h4>

<p>属性动画实际上是针对于关键路径而不是一个键,这就意味着可以对<code>子属性</code>甚至是<code>虚拟属性</code>做动画.</p>

<p>例如:想要对物体做旋转动画,需要作用于<code>transform</code> 属性，因为<code>CALayer</code>没有显式提供角度或者方向之类的属性</p>

<pre><code class="language-objectivec">CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform&quot;;
animation.duration = 2.0;
animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];
[shipLayer addAnimation:animation forKey:nil];
/**
这样确实会旋转180°但是如果我们把M_PI改为2*M_PI就不会旋转了
即使我们设置了byValue也无效,因为变换矩阵并不会像角度值一样叠加
*/
</code></pre>

<p>对于<code>CATransform3D</code>因为0度旋转和360度旋转的矩阵完全相同,所以<code>fromValue</code> = <code>toValue</code>因此不会旋转的</p>

<p>我们当然可以用关键帧动画,修改<code>transform</code>属性，实时地重新计算每个时间点的每个变换效果。这是非常复杂的，不推荐</p>

<p>推荐:<br/>
我们可以<br/>
对<code>transform.rotation</code>关键路径应用动画，而不是<code>transform</code>本身</p>

<pre><code class="language-objectivec">CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform.rotation&quot;;
animation.duration = 2.0;
animation.byValue = @(M_PI * 2);
[shipLayer addAnimation:animation forKey:nil];
</code></pre>

<p>这样我们就可以简单使用角度而不用复杂的矩阵,就可以使用<code>byValue</code>了. 还可以额外使用<code>transform.position</code> 或者<code>transform.scale</code></p>

<p><code>transform.rotation</code>属性其实并不存在,这是因为<code>CATransform3D</code>不是对象而是结构体，它就是一个 <code>CALayer</code> 用于处理动画变换的虚拟属性。当我们<code>transform.rotation</code>等虚拟属性做动画时，<code>Core Animation</code>自动地根据通过 <code>CAValueFunction</code> 来计算的值来更新<code>transform</code> 属性。<br/>
<code>CAValueFunction</code>用于把我们赋给虚拟的 <code>transform.rotation</code>简单浮点值转换成真正的用于摆放图层的<code>CATransform3D</code> 矩阵值。可以通过设置 <code>CAPropertyAnimation</code> 的<code>valueFunction</code>属性来改变，于是你设置的函数将会覆盖默认的函数。</p>

<h3 id="toc_4">动画组</h3>

<h4 id="toc_5">动画组</h4>

<p><code>属性动画</code>仅仅作用于单独的属性,<code>CAAnimationGroup</code>是另一个继承于 <code>CAAnimation</code> 的子类，它添加了一个 <code>animations</code> 数组的属性，用来组合别的动画。</p>

<pre><code class="language-objectivec">CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];
animation1.keyPath = @&quot;position&quot;;
animation1.path = bezierPath.CGPath;
animation1.rotationMode = kCAAnimationRotateAuto;
//create the color animation
CABasicAnimation *animation2 = [CABasicAnimation animation];
animation2.keyPath = @&quot;backgroundColor&quot;;
animation2.toValue = (__bridge id)[UIColor redColor].CGColor;
//create group animation
CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];
groupAnimation.animations = @[animation1, animation2];
groupAnimation.duration = 4.0;
//add the animation to the color layer
[colorLayer addAnimation:groupAnimation forKey:nil];
</code></pre>

<h3 id="toc_6">过渡</h3>

<p><strong>属性动画只对图层的可动画属性起作用</strong>，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。</p>

<p>因为隐式动画或者属性动画都只能对图层的可动画属性做动画,如果这个属性不可动画，这时候我们就需要<code>过渡</code>了。过渡动画会影响到整个图层的变化,它首先展示的之前的图层外观,然后通过一个交换过渡到新的外观.</p>

<p>我们用<code>CATransition</code>来创建过渡动画,它也是<code>CAAnimation</code>子类,有一个<code>type</code>和<code>subtype</code>来标识变换效果。</p>

<pre><code class="language-objectivec">//type:
kCATransitionFade//默认,淡入淡出
kCATransitionMoveIn //新图层从顶部滑入
kCATransitionPush //推出老图层
kCATransitionReveal //滑动出原图层，显示新外观,而不是滑动入新图层
//这是系统提供的,我们也可以自定义过渡动画效果
</code></pre>

<p><code>type</code>过渡类型都有一个默认的动画方向（从左侧滑入）,可以通过<code>subtype</code>控制方向</p>

<pre><code class="language-text">//subtype
kCATransitionFromRight
kCATransitionFromLeft//
kCATransitionFromTop
kCATransitionFromBottom
</code></pre>

<p><strong>注意</strong><br/>
与属性动画类似我们通过<code>-addAnimation:forKey:</code>方法，但是它对指定图层一次只能用一次<code>CATransition</code>，因此，过渡动画都会对它的键设置成“transition”，也就是常量 kCATransition 。</p>

<h4 id="toc_7">隐式过渡</h4>

<p>过渡动画和属性动画类似也是有隐式,如果设置了<code>CALayer</code>的<code>contents</code>属性,但是对于与视图关联的图层隐式过渡动画是被禁用的,但是如果是自己创建的图层<code>contents</code>图片做的改动都会自动附上淡入淡出的动画。</p>

<p><strong>注意</strong><br/>
虽然我们用<code>过渡动画</code>来对图层的某些不可动画属性做动画,但是也不是说过渡动画不能对可动画属性做动画.</p>

<pre><code class="language-objectivec">    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionPush;
    transition.subtype = kCATransitionFromRight;
    [self.containerView.layer addAnimation:transition forKey:nil];
    self.containerView.backgroundColor = [UIColor redColor];
</code></pre>

<h4 id="toc_8">图层树动画</h4>

<p>添加过渡动画<code>不需要指定属性</code>,它涉及到整个图层树的改变,因此我们可以在即使不能准确得知图层改变什么的情况下对图层做动画.</p>

<p>确保<code>CATransition</code>添加到的图层在过渡动画发生时不会在树状结构中被移除，否则<code>CATransition</code>将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的<code>superlayer</code>。</p>

<h4 id="toc_9">自定义动画</h4>

<p><code>UIView</code>也有提供过渡动画函数:<br/>
 <code>UIView +transitionFromView:toView:duration:options:completion:</code>和 <code>+transiti<br/>
onWithView:duration:options:animations:</code></p>

<p>这些过渡方法中<code>options</code>参数可以由如下常量指定：</p>

<pre><code class="language-objectivec">UIViewAnimationOptionTransitionFlipFromLeft//以Y轴从左向右旋转
UIViewAnimationOptionTransitionFlipFromRight
UIViewAnimationOptionTransitionCurlUp//从上向下翻页效果
UIViewAnimationOptionTransitionCurlDown
UIViewAnimationOptionTransitionCrossDissolve//溶解渐变效果
UIViewAnimationOptionTransitionFlipFromTop//以X轴从下向上旋转
UIViewAnimationOptionTransitionFlipFromBottom
</code></pre>

<p>因此只需要根据要实现效果<code>CATransition</code>还是<code>UIView</code>的过渡方法就行了.</p>

<p>如果真的要实现自定义的过渡效果:<br/>
因为过渡动画的原则就是对原始的图层外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果。如果我们会对图层截图,就可以用属性动画来代替过渡动画了.</p>

<p>对图层截图的方法:<code>CALayer</code>有一个 <code>- renderInContext:</code>方法，可以通过把它绘制到<code>Core Graphics</code>的上下文中捕获当前内容的图片，然后在另外的视图中显示出来。如果我们把这个截屏视图置于原始视图之上，就可以遮住真实视图的所有变化，于是重新创建了一个简单的过渡效果。</p>

<pre><code class="language-objectivec">- (IBAction)performTransition
{
    //preserve the current view snapshot
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);
    [self.view.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();
    //insert snapshot view in front of this one
    UIView *coverView = [[UIImageView alloc] initWithImage:coverImage];
    coverView.frame = self.view.bounds;
    [self.view addSubview:coverView];
    //update the view (we&#39;ll simply randomize the layer background color)
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.view.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
    //perform animation (anything you like)
    [UIView animateWithDuration:1.0 animations:^{
        //scale, rotate and fade the view
        CGAffineTransform transform = CGAffineTransformMakeScale(0.01, 0.01);
        transform = CGAffineTransformRotate(transform, M_PI_2);
        coverView.transform = transform;
        coverView.alpha = 0.0;
    } completion:^(BOOL finished) {
        //remove the cover view now we&#39;re finished with it
        [coverView removeFromSuperview];
    }];
}
</code></pre>

<p><strong>注意</strong><br/>
<code>- renderInContext:</code>捕获了图层的图片和子图层，但是不能对子图层正确地处理变换效果，而且对视频和OpenGL内容也不起作用。但是用<code>CATransition</code>，或者用私有的截屏方式就没有这个限制了。</p>

<h3 id="toc_10">动画过程中取消动画</h3>

<p>添加动画:<code>-addAnimation:forKey:</code><br/>
检索动画:<code>- (CAAnimation *)animationForKey:(NSString *)key</code><br/>
<em>不支持动画过程中修改动画</em><br/>
移除指定动画:<code>- (void)removeAnimationForKey:(NSString *)key;</code><br/>
移除所有动画:<code>- (void)removeAllAnimations;</code></p>

<p><strong>注意</strong><br/>
一般说来，动画在结束之后被自动移除，除非设置<code>removedOnCompletion</code>为<code>NO</code>，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14993105877642.html">闭包</a></h1>
			<p class="meta"><time datetime="2017-07-06T11:09:47+08:00" 
			pubdate data-updated="true">07/06/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>闭包是自包含的函数代码块,可以在代码中被传递和使用<br/>
<code>Swift</code>中的闭包与<code>C</code>和<code>Objective-C</code>中的代码块（<code>blocks</code>）以及其他一些编程语言中的匿名函数比较相似</p>

<p><strong>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</strong></p>

<blockquote>
<p>在函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包</p>
</blockquote>

<p>闭包的形式：</p>

<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>

<p>闭包可以进行一定语法优化，常见优化:</p>

<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回<code>单表达式</code>闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>

<h2 id="toc_0">闭包表达式</h2>

<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。</p>

<h3 id="toc_1">sorted方法</h3>

<p><code>Swift</code>的<code>sorted(by:)</code>方法根据提供的排序的闭包函数.将数组排序后返回一个同样大小排序后的数组,原数组不变</p>

<p><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code><br/>
对于数组这个用于排序的闭包函数类型为<code>(String, String) -&gt; Bool</code>通过返回bool值决定第一个参数在前还是在后</p>

<pre><code class="language-swift">func backward(_ s1: String, _ s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversedNames = names.sorted(by: backward)
// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]
</code></pre>

<p>为了写<code>return s1 &gt; s2</code>这么简单的表达式却需要写函数太过繁琐,我们可以使用闭包表达式语法</p>

<h3 id="toc_2">闭包表达式语法</h3>

<pre><code class="language-swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>闭包表达式参数 可以是<code>in-out</code>参数，但不能设定默认值。可以使用可变参数但是要放到参数最后</p>

<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。（<code>in</code>前为闭包定义,后为闭包函数体）</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<h3 id="toc_3">根据上下文推断类型</h3>

<p>因为这个闭包函数的作为方法参数传入,因此其类型已经确定为<code>(String, String) -&gt; Bool</code>,因此我们可以省略这些类型声明,因为可以被正确推断出来</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
//我们将闭包作为函数或方法的参数时,其类型总是可以推断出来的
//推荐完整格式闭包,增加代码可读性
</code></pre>

<h3 id="toc_4">单表达式闭包隐式返回</h3>

<p>如果闭包内只有一行单一表达式,并且明确了需要的返回类型,可以省略<code>return</code>关键字</p>

<pre><code class="language-swift">//
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<h3 id="toc_5">参数名称缩写</h3>

<p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数</p>

<p>如果使用参数名称缩写,那么在闭包定义中也可以省略参数列表,对应的参数名称缩写的类型也可以推断出来,这样的话<code>in</code>关键字也可以省略</p>

<pre><code class="language-swift">//此时闭包表达式只剩下闭包函数体
reversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<blockquote>
<p>注意</p>

<p>只有在必要中</p>
</blockquote>

<h3 id="toc_6">运算符方法</h3>

<p><code>Swift</code>的<code>String</code>类型定义了关于大于号<code>（ &gt; ）</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断出你想使用大于号的字符串函数实现：</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: &gt;)
</code></pre>

<h2 id="toc_7">尾随闭包</h2>

<p>如果要将一个很长的闭包作为函数最后一个参数,可以使用<code>尾随闭包</code>的方式来调用函数<br/>
尾随闭包是书写在函数圆括号之后的闭包表达式，使用尾随闭包可以不用写出它的参数标签</p>

<pre><code class="language-swift">func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
    // 函数体部分
}
// 以下是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure(closure: {
    // 闭包主体部分
})
// 以下是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
    // 闭包主体部分
}

reversedNames = names.sorted() { $0 &gt; $1 }
//如果闭包函数是函数的唯一参数我们还可以省略（）
reversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<pre><code class="language-swift">//举栗子
let strings = numbers.map {
    (number) -&gt; String in
    var number = number
    var output = &quot;&quot;
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number &gt; 0
    return output
}
// strings 常量被推断为字符串类型数组，即 [String]
// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]
</code></pre>

<h2 id="toc_8">值捕获</h2>

<p>闭包可以在被定义的上下文捕获常量或变量,即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值</p>

<p>最简单的捕获值的闭包形式是嵌套函数</p>

<pre><code class="language-swift">func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementer() -&gt; Int {
        runningTotal += amount
    return runningTotal
    }
    return incrementer
}
</code></pre>

<p><code>makeIncrementer</code>的返回类型是<code>() -&gt; Int</code>说明要返回一个函数</p>

<p>对于嵌套函数<code>incrementer()</code>并没有参数，而是捕获了<code>runningTotal</code>和<code>amount</code>变量的引用.捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>

<blockquote>
<p>注意</p>

<p>为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。</p>

<p>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>

<pre><code class="language-swift">let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()// 返回的值为10
incrementByTen()// 返回的值为20
incrementByTen()// 返回的值为30
</code></pre>

<p>这个常量函数每次调用都会将<code>runningTotal</code>变量增加<code>10</code></p>

<h2 id="toc_9">闭包是引用类型</h2>

<p><code>函数</code>和<code>闭包</code>都是引用类型，因此我们设置的常量或者变量是设置的对应函数或闭包的引用，而不是闭包内容本身</p>

<h2 id="toc_10">逃逸闭包</h2>

<p>将闭包作为参数传递到另一个函数中,但是这个闭包在函数返回后才执行,则这个闭包从函数中<code>逃逸</code>，我们可以通过在函数名之前标注<code>@escaping</code>表示这个闭包允许<code>逃逸</code></p>

<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。例如：逃逸闭包我们常用于在一个函数需要异步执行操作,通常会让函数返回,在异步操作完成后再调用执行这个闭包,因为闭包需要在函数返回之后被调用,所以需要逃逸闭包</p>

<p>逃逸闭包必须将函数参数标记为<code>@escaping</code>，否则会得到一个编译错误</p>

<pre><code class="language-swift">var completionHandlers: [() -&gt; Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {
    completionHandlers.append(completionHandler)
}

func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {
    closure()
}
class SomeClass {
    var x = 10
    func doSomething() {
        //逃逸闭包
        someFunctionWithEscapingClosure { self.x = 100 }
        //非逃逸闭包
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
let instance = SomeClass()
instance.doSomething()
print(instance.x)
// 打印出 &quot;200&quot;
completionHandlers.first?()
print(instance.x)
</code></pre>

<p><strong>在逃逸闭包中 你需要显式的引用<code>self</code></strong></p>

<h2 id="toc_11">自动闭包</h2>

<p>一种自动创建的闭包，用于包装传递给函数作为参数的表达式。不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这样帮我们省略掉花括号,用一个普通表达式代替显式的闭包</p>

<p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受自动闭包作为它的<code>condition</code>参数和 <code>message</code>参数；它的<code>condition</code>参数仅会在<code>debug</code>模式下被求值，它的<code>message</code>参数仅当 <code>condition</code>参数为<code>false</code>时被计算求值。</p>

<p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。</p>

<pre><code class="language-swift">var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
print(customersInLine.count)
// 打印出“5”

//这句返回一个闭包 因此不会立即执行删除操作
//customerProvider 的 类型并不是 String  而是 （）=&gt;String
let customerProvider = { customersInLine.remove(at: 0) }
print(customersInLine.count)
// 打印出“5”
//执行闭包
print(&quot;Now serving \(customerProvider())!&quot;)
// Prints &quot;Now serving Chris!&quot;
print(customersInLine.count)
// 打印出“4”
</code></pre>

<p>当使用<code>@autoclosure</code>标记为接收自动闭包，此时可以将该函数当做接受String类型参数的函数来调用</p>

<pre><code class="language-swift">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
//未使用自动闭包
func serve(customer customerProvider: () -&gt; String) {
    print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: { customersInLine.remove(at: 0) } )
// 打印出 &quot;Now serving Alex!&quot;

//使用自动闭包
func serve(customer customerProvider: @autoclosure () -&gt; String) {
print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: customersInLine.remove(at: 0))
</code></pre>

<blockquote>
<p>注意</p>

<p>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的</p>
</blockquote>

<pre><code class="language-swift">//可以通过同时加上@autoclosure @escaping 自动闭包可以“逃逸”
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {
    customerProviders.append(customerProvider)
}
</code></pre>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_25.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_23.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>