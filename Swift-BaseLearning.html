
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  Swift基础知识 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15059300219793.html">高级运算符</a></h1>
			<p class="meta"><time datetime="2017-09-21T01:53:41+08:00" 
			pubdate data-updated="true">09/21/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">位运算符</h2>

<p><code>Swift</code>支持C语言中全部位运算符</p>

<h3 id="toc_1">按位取反运算符 <code>~</code></h3>

<pre><code class="language-swift">let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits // 等于 0b11110000
</code></pre>

<h3 id="toc_2">按位与运算符 <code>&amp;</code></h3>

<h3 id="toc_3">按位或运算符 <code>|</code></h3>

<p>两个数的对应位中有任意一个为1时，返回的对应位就为1</p>

<h3 id="toc_4">按位异或运算符 <code>^</code></h3>

<p>当两个数对应位不相同时，返回1</p>

<h3 id="toc_5">按位移位运算符</h3>

<p>左移<code>&lt;&lt;</code>  右移<code>&gt;&gt;</code></p>

<p>无符号整数的移位运算是:<br/>
<strong>逻辑移位</strong>:对于移除整型存储范围的位都会被舍弃</p>

<pre><code class="language-swift">let pink: UInt32 = 0xCC6699
let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16 // redComponent 是 0xCC，即 204
let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102
let blueComponent = pink &amp; 0x0000FF // blueComponent 是 0x99，即 153
</code></pre>

<p>有符号整数的移位运算:<br/>
<strong>算术移位</strong>:当对整数进行按位右移时，对于移位产生的空白位使用符号位进行填充（逻辑移位中为0填充）,左移规则与逻辑移位相同</p>

<h2 id="toc_6">溢出运算符</h2>

<p><code>Swift</code>中的运算符默认不会溢出,溢出会被捕获并且报告为错误。</p>

<pre><code class="language-swift">var potentialOverflow = Int16.max
// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数
potentialOverflow += 1
// 这里会报错
</code></pre>

<p>我们可以选在数值溢出时采用阶段处理，而不报错：采用已出运算符(以&amp;开头)</p>

<p><code>&amp;+</code> <code>&amp;-</code> <code>&amp;*</code></p>

<blockquote>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
</blockquote>

<h2 id="toc_7">优先级和结合性</h2>

<p>注意:<br/>
<code>Swift</code>中的优先级与C语言中完全不一致</p>

<h2 id="toc_8">运算符函数</h2>

<p><em>类和结构体</em>可以为现有的运算符提供自定义实现--&gt;<strong>运算符重载</strong></p>

<pre><code class="language-swift">struct Vector2D {
    var x = 0.0, y = 0.0
}
extension Vector2D {
    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y + right.y)
    }
}
</code></pre>

<p>对于结构体<code>Vector2.0</code>，运算符函数被定义为类方法,名字与要重载的<code>+</code>一致</p>

<p>因为加法运算并不是一个向量必须的功能，因此这个类被定义在扩展而不是原结构体声明中</p>

<p>这个函数被定义为全局的,因此任意<code>Vector2D</code>示例都可以使用这个运算符:</p>

<pre><code class="language-swift">let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)
</code></pre>

<h3 id="toc_9">前缀和后缀运算符</h3>

<p>不仅加法似的中缀运算符,类和结构体也可以提供单目运算符实现</p>

<pre><code class="language-swift">extension Vector2D {
//prefix表明是前缀运算符的实现
    static prefix func - (vector: Vector2D) -&gt; Vector2D {
        return Vector2D(x: -vector.x, y: -vector.y)
    }
}

let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例
let alsoPositive = -negative
// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例
</code></pre>

<p>实现单目运算符需要用<code>prefix</code>或者<code>postfix</code>来指明前缀后后缀</p>

<h3 id="toc_10">复合赋值运算符</h3>

<p>对于复合赋值运算符例如:<code>+=</code> <code>-=</code><br/>
需要在实现时将做参数设置为<code>inout</code>类型，这样参数值可以在函数中被修改</p>

<pre><code class="language-swift">extension Vector2D {
    static func += (left: inout Vector2D, right: Vector2D) {
        left = left + right
    }
}
</code></pre>

<blockquote>
<p>不能对默认的赋值运算符<code>=</code>进行重载。只能重载组合赋值运算符，也无法对三目运算符进行重载</p>
</blockquote>

<h3 id="toc_11">等价运算符</h3>

<p>通过对自定义类或结构体进行<code>==</code>或<code>!=</code>运算符实现来判断其是否“相等”</p>

<pre><code class="language-swift">//实现方法与中缀运算符相同
extension Vector2D {
    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {
        return (left.x == right.x) &amp;&amp; (left.y == right.y)
    }
    static func != (left: Vector2D, right: Vector2D) -&gt; Bool {
        return !(left == right)
    }
}
</code></pre>

<h2 id="toc_12">自定义运算符</h2>

<p>除了实现标准运算符外还可以声明和实现<strong>自定义的运算符</strong></p>

<p>新的运算符要使用<code>operator</code>关键字在全局作用域内进行定义，同时还要指定<code>prefix</code>、<code>infix</code>或者<code>postfix</code>修饰符：</p>

<pre><code class="language-swift">prefix operator +++ {}
//定义了+++的前缀运算符  全局作用域
//这个运算符现在没有任何意义
</code></pre>

<p>我们针对<code>Vector2D</code>结构体来实现<code>+++</code>运算符</p>

<pre><code class="language-swift">extension Vector2D {
    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {
        vector += vector
        return vector
    }
}
//我们将+++实现为前面重载的运算符+=自身的值
</code></pre>

<h3 id="toc_13">自定义中缀运算符优先级</h3>

<p>每个自定义中缀运算符都属于某个优先级组。这个优先级组指定了这个运算符和其他中缀运算符的优先级和结合性</p>

<pre><code class="language-swift">//自定义中缀运算符+- 属于AdditionPrecedence优先组
infix operator +-: AdditionPrecedence

extension Vector2D {
    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y - right.y)
    }
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)
</code></pre>

<p><code>AdditionPrecedence</code>优先组为<code>+</code><code>-</code>等默认的优先级组</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15057532270985.html">访问控制</a></h1>
			<p class="meta"><time datetime="2017-09-19T00:47:07+08:00" 
			pubdate data-updated="true">09/19/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>访问控制：限定其他源文件或者模块代码对你的代码的访问级别</p>

<ul>
<li>明确的给单个类型(类,结构体,枚举)设置访问级别</li>
<li>给类型的属性、方法、构造器、下标等设置访问级别</li>
<li>限定协议在一定范围使用，包括协议中的全局变量、常亮、函数</li>
</ul>

<p><code>Swift</code>有显式提供多种访问级别，也有为场景提供了默认的访问级别</p>

<h2 id="toc_0">模块和源文件</h2>

<p><strong><code>Swift</code>中的访问控制基于模块和源文件</strong></p>

<p><mark>模块</mark>指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用<code>import</code>关键字导入另外一个模块。</p>

<p>在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。</p>

<p><mark>源文件</mark>就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>

<h2 id="toc_1">访问级别</h2>

<p><code>Swift</code>提供了5种访问级别</p>

<ul>
<li><strong>开放访问和公开访问</strong>(open、public):可以访问同一模块源文件中的任何实体，在模块外也可以导入该模块来访问源文件中的所有实体。我们通常将框架中的某个接口可以被任何使用时,设置为此级别</li>
<li><strong>内部访问</strong>(internal)：可以访问同一模块源文件的任何实体，但是不能从外部访问该模块源文件中的实体。用于某接口只在应用程序或者内部使用时</li>
<li><strong>文件私有访问限制</strong>(filepart)：限值实体只能被所定义的<em>文件</em>内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
<li><strong>私有访问限值</strong>(private)： 限值实体只能在所定义的<em>作用域</em>使用,需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
</ul>

<p>Open为最高访问级别(限制最少)  Private为最低访问级别 限制最多</p>

<p>Open和Public区别:(Open只作用于类和类的成员)</p>

<ul>
<li>Public或者其他更严访问级别的类，只能在它们定义的模块内部被继承。</li>
<li>Public或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。</li>
<li>Open的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</li>
<li>Open的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</li>
</ul>

<p>把一个类标记为Open，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</p>

<h3 id="toc_2">访问级别基本原则</h3>

<p><strong>基本原则：实体不可以在某个实体中定义访问级别更低（限制更多）的实体</strong></p>

<p>例如:函数的访问级别不能高于他的参数类型或者返回类型的访问级别。</p>

<h3 id="toc_3">默认访问级别</h3>

<p>如果不为代码中的实体指定访问级别,默认为<code>internal</code>级别。<br/>
大多数情况下我们不需要显示指定实体的访问级别</p>

<h3 id="toc_4">单target应用程序的访问级别</h3>

<p>对于单目标应用程序,应用的所有功能都为该应用进行服务而不需要提供给其他应用或者模块进行使用,因此使用默认的<code>internal</code>即可。也可以使用文件私有访问或者私有访问级别来进行一些功能的实现细节的隐藏</p>

<h3 id="toc_5">框架访问级别</h3>

<p>在开发框架时需要将对外的接口定义为Open或者Public级别，即为对外的接口API</p>

<blockquote>
<p>注意</p>

<p>框架内部实现仍使用默认的内部访问级别internal，当需要对框架内部其他部分隐藏的细节可以使用<code>private</code>或者<code>fileprivate</code>。对于框架对外api部分，需要设置为<code>open</code>或<code>public</code></p>
</blockquote>

<h3 id="toc_6">单元测试目标的访问级别</h3>

<p>当我们用单元测试目标去访问程序代码，为了访问那些非公开访问或者开发访问代码,可以在导入的应用程序模块的语句前使用<code>@testable</code>特性，然后在允许测试的编译设置<code>（Build Options -&gt; Enable Testability）</code>下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p>

<h2 id="toc_7">访问控制语法</h2>

<pre><code class="language-swift">//声明实体访问级别
public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}
public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}
//默认为内部访问级别
class SomeInternalClass {} // 隐式内部访问级别
var someInternalConstant = 0 // 隐式内部访问级别
</code></pre>

<h2 id="toc_8">自定义类型</h2>

<p>在自定义类型时指定访问的级别，然后这个类型就在访问级别限制范围内进行使用</p>

<p><mark>定义的类型访问级别会影响到类型成员(属性、方法、构造器、下标)的默认访问级别</mark>。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。</p>

<blockquote>
<p>注意：</p>

<p>必须显式指定才能将成员设置为公开访问类型，避免不消息暴露内部使用接口</p>
</blockquote>

<h3 id="toc_9">元组类型</h3>

<p>元组的访问级别 是由元组中访问级别最严格的类型来约定。</p>

<blockquote>
<p>注意</p>

<p>元组不同股类、结构体、枚举、函数那样有单独的定义。其访问级别在被使用时自动推断出，而无法明确指定</p>
</blockquote>

<h3 id="toc_10">函数类型</h3>

<p>函数的访问类型由访问级别最严格的参数类型或者返回类型的访问级别决定</p>

<p>如果访问级别不复合函数定义的环境的默认访问级别，那么就需要明确指定该函数的访问级别</p>

<pre><code class="language-swift">//定义一个函数
func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
}
/**
    这样是无法通过编译的,这个函数返回了一个元组,元组中包含了两个自定义类，根据元组访问
    级别,元组为privite的，因此函数也为private访问级别，因此并不是默认的internal级
    别，因此需要用private修饰符明确指出函数访问级别
*/

private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // 此处是函数实现部分
}
</code></pre>

<h3 id="toc_11">枚举类型</h3>

<p>枚举成员的访问级别与枚举类型相同，不能单独指定美剧成员的访问级别</p>

<h4 id="toc_12">原始值和关联值</h4>

<p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。</p>

<p>例如不能在<code>internal</code>的枚举中定义<code>private</code>的原始值类型</p>

<h3 id="toc_13">嵌套类型</h3>

<p>如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>

<h2 id="toc_14">子类</h2>

<p><strong>子类的访问级别也不能高于父类</strong></p>

<p>可以通过重写为继承来的类成员(方法、属性、下标、构造器等)提供更高的访问级别</p>

<pre><code class="language-swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {}
}
//类B继承自A，重写了类A中的方法将访问级别指定为更高的访问级别  
//将someMethod方法 由private级别重写为internal级别
</code></pre>

<p>我们甚至可以在子类中，用子成员去访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内(即，在同一源文件中访问父类<code>fileprivate</code>级别的成员，在同一模块中内访问父类<code>internal</code>级别成员)</p>

<pre><code class="language-swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
//子类中访问父类中级别更低成员（保证操作在相应访问级别的限值范围内）
</code></pre>

<h3 id="toc_15">常亮、变量、属性、下标</h3>

<p>常量、变量、属性不能有比类型（成员的定义类型）更高的访问级别，</p>

<p>下标也不能有比索引类型或返回类型更高的访问级别</p>

<h3 id="toc_16">Getter和Setter</h3>

<p>常量、变量、属性、下标的<code>Getters</code>和<code>Setters</code>的访问级别和它们所属类型的访问级别相同</p>

<p><code>Setter</code>的访问级别可以低于<code>Getter</code>的访问级别，这样就可以控制变量、属性或下标的读写权限。<br/>
在var或者subscript关键字之前，可以通过添加<code>fileprivate(set)</code>、<code>private(set)</code>、<code>internal(set)</code>来为写入指定更低权限</p>

<blockquote>
<p>注意：</p>

<p>这个规则同时适用于存储型和计算型属性。<br/>
即使你不明确指定存储型的<code>Getter</code>和<code>Seeter</code>，<code>Swift</code>也会隐式为其创建<code>Getter</code>和<code>Setter</code>，用于访问该属性的后备存储。<br/>
使用<code>fileprivate(set)</code>,<code>private(set)</code>和<code>internal(set)</code>可以改变<code>Setter</code>的访问级别，这对计算属性同样适用</p>
</blockquote>

<pre><code class="language-swift">struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = &quot;&quot; {
        didSet {
            numberOfEdits += 1
        }
    }
}
</code></pre>

<p>因为结构体的<code>numberOfEdits</code>属性采用了<code>private(set)</code>修饰符，意味着<code>numberOfEdits</code>属性只能在结构体定义中赋值。此时<code>numberOfEdits</code>属性<code>Getter</code>依然是是默认的访问级别<code>internal</code>，但是<code>Setter</code>的访问级别是<code>private</code>，这表示该属性只能在内部修改，而在结构体外部则表现为一个只读属性。</p>

<h2 id="toc_17">构造器</h2>

<p>自定义构造器的访问级别可以低于或等于其所属的的类型的访问级别</p>

<p>但是<mark>必要构造器</mark>的访问级别必须和所属的类型的访问级别相同</p>

<h3 id="toc_18">默认构造器</h3>

<p>默认构造器的访问级别和所属类型的访问级别相同，除非类型的访问级别是<code>public</code>。<br/>
当类型级别为<code>public</code>，那么默认构造器的访问级别将为<code>internal</code><br/>
如果想要在其他模块使用<code>public</code>的无参构造器，你只能自己提供一个</p>

<h3 id="toc_19">结构体默认的成员逐一构造器</h3>

<p>如果结构体中任意存储型属性的访问级别为<code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是<code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>

<p>与默认构造器类似，如果希望一个<code>public</code>级别的结构体也能在其他模块中使用默认的成员逐一构造器，你依然只能自己提供一个public级别的成员逐一构造器</p>

<h2 id="toc_20">协议</h2>

<p>在定义协议时指定协议的访问级别,限制协议只能在适当访问级别范围内被遵循</p>

<p>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别，这样才能确保该协议的所有要求对于任意遵循着都将会可用</p>

<blockquote>
<p>注意：</p>

<p>如果定义一个public级别的协议，则其协议的所有实现也会是public级别的。不同于其他类型，例如，当类型时<code>public</code>级别，其成员的访问级别却只是<code>internal</code></p>
</blockquote>

<h3 id="toc_21">协议继承</h3>

<p>如果定义一个继承自其他协议的新协议，那么该新协议的访问级别最高只能和父协议相同，而不能高于父协议</p>

<h3 id="toc_22">协议遵循</h3>

<ol>
<li><p>一个类型可以遵循级别比它更低的协议。<br/>
例如，你可以定义一个<code>public</code>级别类型，它可以在其他模块中使用，同时它也可以采纳一个<code>internal</code>级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。</p></li>
<li><p>遵循协议的上下文级别是类型和协议中级别中较小的那个。<br/>
例如：类型是public级别，但它要遵循的协议是<code>internal</code>级别，那么这个类型对该协议的遵循上下文就是internal级别</p></li>
<li><p>当编写或者扩展一个类型让它遵循一个协议时，必须保证该类型对协议中每个要求的实现，至少与遵循协议的上下文级别一致。<br/>
例如：一个public类型遵循一个internal协议，这个类型对协议的所有实现至少都已应该是internal级别的</p></li>
</ol>

<h2 id="toc_23">Extension</h2>

<ol>
<li>可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别</li>
<li>可以明确指定扩展的访问级别(例如：<code>private extension</code>)，从而给扩展中成员一个新的访问级别,但是新的默认访问级别仍会被单独指定的级别覆盖</li>
</ol>

<h3 id="toc_24">通过扩展添加协议一致性</h3>

<p>通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>

<h3 id="toc_25">Extension的私有成员</h3>

<p>扩展同一文件内的类、结构体或者枚举，extension里的代码会表现的和声明在元类型里一模一样。</p>

<ul>
<li>在类型的声明里声明一个私有成员，在同一文件的extension里访问</li>
<li>在extension里声明一个私有成员，在同一文件的另一个extension里访问</li>
<li>在extension里声明一个私有成员，在同一文件的类型声明里访问</li>
</ul>

<h2 id="toc_26">泛型</h2>

<p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>

<h2 id="toc_27">类型别名</h2>

<p>定义的任何类型别名都会被当做不同的类型，以便进行访问控制。<br/>
类型别名的访问级别不可高于其表示的类型的访问级别。</p>

<p>例如： private 级别的类型别名可以作为 private、file-private、internal、public 或者 open 类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal、file-private 或 private 类型的别名。</p>

<blockquote>
<p>注意：</p>

<p>这条规则 也适用于为满足协议遵循而将类型别名用于关联类型的情况</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15660380397380.html">内存安全</a></h1>
			<p class="meta"><time datetime="2019-08-17T18:33:59+08:00" 
			pubdate data-updated="true">08/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>默认情况下，<code>Swift</code>会阻止代码里的不安全行为。例如，变量在使用前完成初始化，在内存回收后无法被访问，并且数组的索引会做越界检查。</p>

<p>因为<code>Swift</code>管理内存，大部分时间 并不需要考虑内存访问的事情。然而，理解潜在冲突也是很重要的，可以避免写出访问冲突的代码。如果代码确实存在冲突，那在编译时或者运行时会得到错误。</p>

<h2 id="toc_0">理解内存访问冲突</h2>

<p>内存的访问，会发生在你给变量赋值，或者传递参数给函数时。<br/>
而内存的访问冲突发生在代码多个访问同时访问同一个内存地址，造成的不可预计或者不一致的行为。</p>

<h2 id="toc_1">内存访问性质</h2>

<p>内存访问冲突会发生在以下两个访问符合情况时:</p>

<ul>
<li>至少有一个是写访问</li>
<li>访问的是统一存储地址</li>
<li>访问在时间线上部分重叠</li>
</ul>

<p>内存的访问时长，要么是瞬时的，要么是长期的。主要区别在于，别的代码有没有可能在访问期间同时访问，也就是时间线上的重叠。一个长期访问可以被别的长期或者瞬时访问重叠</p>

<p>重叠访问主要出现在使用<code>in-out</code>参数的函数或方法  或者结构体的<code>mutating</code>方法里。</p>

<h2 id="toc_2">In-Out参数的访问冲突</h2>

<p>一个函数会对它所有的in-out参数进行长期写访问。in-out参数的写访问会在所有非in-out参数处理完成后开始，直到函数执行完毕位置。如果有多个in-out参数，则写访问开始的顺序和参数顺序一致。</p>

<ol>
<li><p>不能在访问以in-out形式传入后的原变量，即使作用域原则和访问权限允许--任何访问原变量的行为都会造成冲突<br/>
<img src="media/15660380397380/15661846253994.jpg" alt="" style="width:600px;"/></p>
<p>解决方案是 显示的拷贝一份<code>stepSize</code>：</p>
<pre><code class="language-swift">// 显式拷贝
var copyOfStepSize = stepSize<br/>
increment(&amp;copyOfStepSize)<br/>
// 更新原来的值<br/>
stepSize = copyOfStepSize<br/>
// stepSize 现在的值是 2
</code></pre></li>
<li><p>当向同一函数的多个in-out参数里传入同一个变量也会产生冲突，</p>
<pre><code class="language-swift">func balance(_ x: inout Int, _ y: inout Int) {
let sum = x + y<br/>
x = sum / 2<br/>
y = sum - x<br/>
}<br/>
var playerOneScore = 42<br/>
var playerTwoScore = 30<br/>
balance(&amp;playerOneScore, &amp;playerTwoScore)  // 正常<br/>
balance(&amp;playerOneScore, &amp;playerOneScore)<br/>
// 错误：playerOneScore 访问冲突
</code></pre>
<p>将 playerOneScore 作为参数同时传入就会产生冲突，因为它会发起两个写访问，同时访 问同一个的存储地址</p></li>
</ol>

<blockquote>
<p>注意:</p>

<p>因为操作符也是函数，它们也会对in-out参数进行长期访问</p>
</blockquote>

<h3 id="toc_3">方法里self的访问冲突</h3>

<p>一个结构体的<code>mutating</code>方法会在调用期间对<code>self</code>进行写访问</p>

<pre><code class="language-swift">extension Player {
    mutating func shareHealth(with teammate: inout Player) {
        balance(&amp;teammate.health, &amp;health)
    }
}

var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)
var maria = Player(name: &quot;Maria&quot;, health: 5, energy: 10)
oscar.shareHealth(with: &amp;maria)  // 正常
</code></pre>

<p><img src="media/15660380397380/15661951218602.jpg" alt="" style="width:600px;"/></p>

<p>但是当如果</p>

<pre><code class="language-swift">oscar.shareHealth(with: &amp;oscar)
// 错误：oscar 访问冲突
</code></pre>

<p>因为 mutating方法在调用期间需要对self发起访问，而同时in-out参数也需要写访问。在方法里，<code>self</code>和<code>teammate</code>指向统一存储地址。对同一块内存进行访问，并且重叠，就会产生冲突。</p>

<h2 id="toc_4">属性的访问冲突</h2>

<p>结构体、元组和枚举都是值类型，由多个独立的值构成，所以修改值的一部分都是对于整个值的修改，意味着其中一个属性的读和写访问都需要访问整一个值。</p>

<ol>
<li><p>对元组元素的写访问重写会产生冲突</p>
<pre><code class="language-swift">var playerInformation = (health: 10, energy: 20)
balance(&amp;playerInformation.health, &amp;playerInformation.energy)<br/>
// 错误：playerInformation 的属性访问冲突
</code></pre>
<p>所以，在任何情况下，对于元组元素的写访问都需要对整个元组发起写访问。</p></li>
<li><p>对存储在全局变量的结构体属性写访问重叠</p>
<pre><code class="language-swift">var holly = Player(name: &quot;Holly&quot;, health: 10, energy: 10)
balance(&amp;holly.health, &amp;holly.energy)  // 错误
</code></pre>
<p>大多数对于结构体属性的访问都会安全的重叠。例如，将上面例子的变量改为本地变量而非全局变量，编译器即可保证其是安全的</p>
<pre><code class="language-swift">func someFunction() {
    var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)<br/>
    balance(&amp;oscar.health, &amp;oscar.energy)  // 正常<br/>
}
</code></pre>
<p>此时编译器可以保证内存安全，因为两个存储尚需经任何情况下都不会互相影响。</p></li>
</ol>

<p>限制结构体属性的重叠访问对于保证内存安全不是必要的。保证内存安全是必要的，但因为访问独占权的要求比内存安全还要更严格——意味着即使有些代码违反了访问独占权的原则，也是内存安全的，所以如果编译器可以保证这种非专属的访问是安全的，那 Swift 就会允许这种行为的代码运行。特别是当你遵循下面的原则时，它可以保证结构体属性的重叠访问是安全的：</p>

<ul>
<li>你访问的是实例的存储属性，而不是计算属性或类的属性</li>
<li>结构体是本地变量的值，而非全局变量</li>
<li>结构体要么没有被闭包捕获，要么只被非逃逸闭包捕获了</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15028525854956.html">自动引用计数</a></h1>
			<p class="meta"><time datetime="2017-08-16T11:03:05+08:00" 
			pubdate data-updated="true">08/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>与<code>OC</code>相同 <code>Swift</code>使用自动引用计数(ARC)来跟踪和管理应用程序内存</p>

<blockquote>
<p>注意</p>

<p>引用计数仅仅应用于类的实例。结构体和枚举是值类型，不是引用类型，也不是通过引用的方式存储和传递的</p>
</blockquote>

<h2 id="toc_0">工作机制</h2>

<p>创建类的实例时,<code>ARC</code>会分配一块内存来存储实例信息.不再使用该实例,ARC将其释放.当是实例被释放后，其方法或属性均不能被访问或调用。<br/>
因此，为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>

<h2 id="toc_1">循环强引用</h2>

<p>如果两个类实例互相引用,那么类实例的强引用数永远不能变为0，这就是<strong>循环强引用</strong></p>

<h2 id="toc_2">解决循环强引用方法</h2>

<p>解决办法: <strong>弱引用</strong> <strong>无主引用</strong></p>

<p>将循环引用中一个实例对另外的实例不保持强引用</p>

<p>当其他的实例有更短的生命周期时,使用弱引用，即其 实例 析构在先时; 当其他实例有相同或者更长的声明周期时,请使用无主引用</p>

<h3 id="toc_3">弱引用</h3>

<p>弱引用不会对其引用的实例保持强引用，因而不会阻止<code>ARC</code>销毁被引用的实例。</p>

<p>声明属性或变量时,在前面加上<code>weak</code>关键字表明是个弱引用</p>

<p><code>ARC</code>会在引用的实例被销毁后自动将其赋值为<code>nil</code>.并且弱引用可以允许它们的值运行时赋值为<code>nil</code>，所以会被定义为可选类型变量而不是常量</p>

<p>弱引用为可选类型变量,可以通过检查是否为nil,防止访问已经销毁的实例的引用</p>

<blockquote>
<p>注意</p>

<p>在<code>ARC</code>设置弱引用为<code>nil</code>时,属性观察不会被触发</p>
</blockquote>

<pre><code class="language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}

var john: Person?
var unit4A: Apartment?
john = Person(name: &quot;John Appleseed&quot;)
unit4A = Apartment(unit: &quot;4A&quot;)
john!.apartment = unit4A
unit4A!.tenant = john
//因为Apartment 中 的 tenant 属性为弱引用,因此即使这样也不会产生循环引用

john = nil
// 打印 “John Appleseed is being deinitialized”

unit4A = nil
// 打印 “Apartment 4A is being deinitialized”

</code></pre>

<p>变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息</p>

<blockquote>
<p>注意:</p>

<p>在使用垃圾收集的系统里</p>
</blockquote>

<h3 id="toc_4">无主引用</h3>

<p>在属性前加<code>unowned</code>关键字进行声明无主引用</p>

<p>与弱引用类似,无主引用不会保持住引用的实例<br/>
与弱引用不同,<strong>无主引用用在与其他实例有相同或者更长声明周期时使用</strong></p>

<p>无主引用为非可选类型,因此<code>ARC</code>无法在实例被销毁后将无主引用设置为<code>nil</code></p>

<blockquote>
<p>注意:</p>

<p>使用无主引用，必须<strong>保证引用始终指向一个未销毁的实例</strong><br/>
试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误</p>
</blockquote>

<p>举个栗子:<br/>
<code>Customer</code>客户和<code>CreditCard</code>银行卡之间的关系,两个类都将另外一个类的实例作为自身属性,关系是客户可能没有银行卡,但是银行卡一定有客户,因此将银行卡的<code>customer</code>设置为无主引用</p>

<pre><code class="language-swift">
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64 //确保在32、64位机器上均可以保存16位的卡号
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}


var john: Customer?
john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)

john = nil
// 打印 “John Appleseed is being deinitialized”
// 打印 ”Card #1234567890123456 is being deinitialized”

</code></pre>

<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对 <code>Customer</code>实例的无主引用</p>

<blockquote>
<p>注意:</p>

<p>上面是展示如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况(例如：处于次年功能方面原因)，Swift还提供了不安全的无主引用。与所有的不安全操作类似，需要负责检查代码确保其安全性。可以通过<code>unowned(unsafe)</code>声明不安全的无主引用。如果视图在实力被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作</p>
</blockquote>

<h3 id="toc_5">无主引用以及隐式解析可选属性</h3>

<pre><code class="language-swift">class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>

<p>我们在<code>Country</code>的<code>capitalCity</code>属性声明为<code>City!</code>隐式解析可选类型的属性,表明像其他可选类型一样，默认值为<code>nil</code>，但是不需要展开他的值就能访问</p>

<p>因为<code>capitalCity</code>的默认值为默认为<code>nil</code>，因此在构造country时,当name赋值以后,初始化就完成了,此时我们就能把这个初始化的<code>country</code>实例传递给<code>City</code>来构造City实例</p>

<h2 id="toc_6">闭包引起的循环强引用</h2>

<p>闭包和类 类似,都是引用类型,因此,将闭包赋值为某属性时,是将这个闭包的引用赋值给属性,因此当闭包体中访问实例的某个属性时,就会造成循环引用</p>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<blockquote>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为<code>HTML</code>输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>

<p><strong>闭包捕获列表</strong>解决闭包引起的循环引用</p>

<p>对于一个类的闭包属性,想要改变这个属性的行为,可以通过给这个属性再赋值一个闭包</p>

<p><code>HTMLElement</code>有类和作为<code>asHTML</code>默认值的闭包之间的循环强引用</p>

<p>此时<code>HTMLElement</code>实例和它的闭包是不会被销毁和释放的</p>

<blockquote>
<p>注意:</p>

<p>虽然闭包中多次使用<code>self</code>，但是它只捕获<code>HTMLElement</code>实例的一个强引用</p>
</blockquote>

<h2 id="toc_7">解决闭包引起的循环强引用</h2>

<p>在定义闭包时同时定义<strong>捕获列表</strong>作为闭包的一部分，捕获列表定义了闭包体内捕获一个或多个引用类型的规则.声明捕获的引用为弱引用或者无主引用,而不是强引用</p>

<blockquote>
<p>注意:</p>

<p><code>Swift</code>规定:在闭包中使用<code>self</code>的成员，要使用<code>self.someProperty</code>或者<code>self.someMethod()</code>，而不是使用<code>someProperty</code>或<code>someMethod()</code><br/>
这是为了提醒你 一不小心就捕获了self</p>
</blockquote>

<h3 id="toc_8">定义捕获列表</h3>

<p>捕获列表由一对元素组成,一个是<code>weak</code>或<code>unowned</code>关键字,另一个是类实例的引用如<code>self</code>或初始化的变量.</p>

<p>在方括号中用逗号隔开</p>

<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面:</p>

<pre><code class="language-swift">lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // 这里是闭包的函数体
}
</code></pre>

<pre><code class="language-swift">
/**
如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，
那么可以把捕获列表和关键字 in 放在闭包最开始的地方
*/

lazy var someClosure: Void -&gt; String = {
    [unowned self, weak delegate = self.delegate!] in
    // 这里是闭包的函数体
}

</code></pre>

<h3 id="toc_9">弱引用和无主引用</h3>

<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为<code>无主引用</code>。(即被捕获的引用不会变为nil使用无主引用)<br/>
在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>，弱引用总是可选类型,在引用的实例被销毁后自动置为<code>nil</code></p>

<blockquote>
<p>注意</p>

<p>如果被捕获的引用绝对不会变成nil,应该用无主引用，而不是弱引用</p>
</blockquote>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<p>在<code>asHTML</code>闭包中多了一个捕获列表，<code>[unowned self]</code>将self声明为无主引用<br/>
这时候没有了循环引用,我们就可以销毁<code>HTMLElement</code>实例了</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15659410303124.html">不透明类型</a></h1>
			<p class="meta"><time datetime="2019-08-16T15:37:10+08:00" 
			pubdate data-updated="true">08/16/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>具有不透明返回类型的函数或方法会隐藏返回值的类型信息。此时，函数不再提供具体的类型作为返回类型，而是根据它支持的协议来描述返回值。</p>

<p>在处理模块和调用代码之间关系时，异常类型信息非常有用，此时返回的底层数据类型仍然可以保持私有。而且不同于返回协议类型，不透明类型可以保证类型一致性--表一起能获取到类型信息，但是模块使用者却不能获取到</p>

<h2 id="toc_0">不透明类型解决的问题</h2>

<h2 id="toc_1">返回不透明类型</h2>

<p>可以认为不透明类型和泛型相反。</p>

<p>泛型允许调用一个方法，为这个方法的形参和返回值制定一个与实现无关的类型，例如</p>

<pre><code class="language-swift">func max&lt;T&gt;(_ x: T, _ y: T) -&gt; T where T: Comparable { ... }
</code></pre>

<p>类型T由调用方法的代码决定，函数内部也要通过通用的方式写代码，才能应对调用者传入的各种类型</p>

<p>返回不透明类型函数中，不透明类型允许函数实现时，选择一个与调用代码无关的返回类型，比如：下面例子返回了一个梯形，但是却没直接输出梯形的底层类型</p>

<pre><code class="language-swift">struct Square: Shape {
    var size: Int
    func draw() -&gt; String {
        let line = String(repeating: &quot;*&quot;, count: size)
        let result = Array&lt;String&gt;(repeating: line, count: size)
        return result.joined(separator: &quot;\n&quot;)
    }
}

func makeTrapezoid() -&gt; some Shape {
    let top = Triangle(size: 2)
    let middle = Square(size: 2)
    let bottom = FlippedShape(shape: top)
    let trapezoid = JoinedShape(
        top: top,
        bottom: JoinedShape(top: middle, bottom: bottom)
    )
    return trapezoid
}
let trapezoid = makeTrapezoid()
print(trapezoid.draw())
</code></pre>

<p>返回值定义为<code>some Shape</code>；因此，该函数返回遵循<code>Shape</code>协议的给定类型，而不需要指定任何具体类型。<br/>
这样写<code>makeTrapezoid()</code>函数可以表明它公共接口的基本性质 --返回的是一个几何图形 -- 而不是部分的公共接口生成的特殊类型。</p>

<p><code>makeTrapezoid()</code>函数可以返回任意它需要的类型，只要其遵循<code>Shape</code>协议即可，类似泛型函数的实现代码，其调用代码需要采用通用的方式，使其返回的任何<code>Shape</code>类型值都能被正常使用</p>

<pre><code class="language-swift">//泛型和不透明类型相结合
func flip&lt;T: Shape&gt;(_ shape: T) -&gt; some Shape {
    return FlippedShape(shape: shape)
}
</code></pre>

<blockquote>
<p>注意:</p>

<p>如果函数内部有多个地方返回不透明类型，那么需要保证返回的均为同一类型，否则会报错</p>
</blockquote>

<h2 id="toc_2">不透明类型和协议类型区别</h2>

<p>虽然使用不透明类型作为函数返回值，看起来和返回协议类型非常相似，但这两者有一个主要区别，就在于是否需要保证类型一致性。</p>

<p>一个不透明类型只能对应一个具体的类型，即使函数调用者并不知道是哪种类型。<br/>
协议类型可以对应多个类型，只要他们遵循同一协议<br/>
不透明类型则比啊留了底层类型的唯一性，swift能够推断出来关联类型</p>

<pre><code class="language-swift">protocol Container {
    associatedtype Item
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}
extension Array: Container { }

// 错误：有关联类型的协议不能作为返回类型。
func makeProtocolContainer&lt;T&gt;(item: T) -&gt; Container {
    return [item]
}

// 错误：没有足够多的信息来推断 C 的类型。
func makeProtocolContainer&lt;T, C: Container&gt;(item: T) -&gt; C {
    return [item]
}


func makeOpaqueContainer&lt;T&gt;(item: T) -&gt; some Container {
    return [item]
}
let opaqueContainer = makeOpaqueContainer(item: 12)
let twelve = opaqueContainer[0]
print(type(of: twelve))
// 输出 &quot;Int&quot;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15052932669633.html">泛型</a></h1>
			<p class="meta"><time datetime="2017-09-13T17:01:06+08:00" 
			pubdate data-updated="true">09/13/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>泛型:</strong>根据自定义的需求，编写适用于任意类型，灵活可复用的函数和类型<br/>
避免编写重复代码，使用清晰抽象的方式表达意图</p>

<h2 id="toc_0">泛型函数</h2>

<p>泛型函数适用与任何类型</p>

<pre><code class="language-swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>泛型函数:</p>

<ol>
<li>使用<code>占位符</code>类型名来代替<code>实际类型名</code>(这里用字母<code>T</code>表示),这里并没有指明T必须是什么类型,而是a与b类型相同,在实际调用时才根据传入类型决定<code>T</code>所代表的类型</li>
<li>泛型函数在函数名后紧跟着<code>&lt;T&gt;</code>，尖括号用来告诉swift，<code>T</code>是函数定义内的一个占位类型，因此swift不会去查找名为T的实际类型</li>
</ol>

<p>因此，函数<code>swapTwoInts(_:_:)</code>可以接受任意相同类型的参数</p>

<h2 id="toc_1">类型参数</h2>

<p>类型参数指定并命名一个占位类型,紧随在函数名后,用尖括号括起来(如:<code>&lt;T&gt;</code>),也可以提供多个参数用逗号隔开</p>

<p>当类型参数被指定后，可以用指定的类型参数作为函数的参数类型或返回类型，甚至可以用作函数主体中的注释类型</p>

<p>类型参数会在函数被调用时被实际类型所替代</p>

<p>可以提供多个类型参数，写在尖括号汇总，并用逗号隔开</p>

<h2 id="toc_2">命名类型参数</h2>

<p>我们可以使用有意义的单词来表明类型参数和泛型函数关系,当没有联系时,通常使用单个字母来命名</p>

<blockquote>
<p>注意</p>

<p>使用大写字母开头的驼峰命名法来为类型参数命名</p>
</blockquote>

<h2 id="toc_3">泛型类型</h2>

<p><strong>泛型类型：</strong>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型,类型于<code>Array</code>和<code>Dictionary</code></p>

<pre><code class="language-swift">//泛型 Stack（栈型） 结构体
struct Stack&lt;Element&gt; {
    var items = [Element]()
    mutating func push(item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
}
</code></pre>

<p>使用占位类型<code>Element</code>，这个类型参数包裹在紧随结构体名的一对尖括号里（<code>&lt;Element&gt;</code>）,类型参数用来初始化数组,用来作为<code>push</code><code>pop</code>方法的参数</p>

<p><code>Element</code>为待提供类型定义了一个占位名。这种待提供类型可以在结构体的定义中通过<code>Element</code>来引用</p>

<ul>
<li>使用Element类型初始化items数组进行初始化</li>
<li>指定<code>push</code>方法的参数</li>
<li>指定<code>pop</code>方法的返回值类型</li>
</ul>

<p><code>Stack</code>是泛型类型,可以创建任意有效类型栈<br/>
可以通过在尖括号写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例</p>

<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push(&quot;uno&quot;)
stackOfStrings.push(&quot;dos&quot;)
let fromTheTop = stackOfStrings.pop()
</code></pre>

<h2 id="toc_4">泛型扩展</h2>

<p>当对泛型类型进行扩展时，并不需要提供类型参数列表作为定义的一部分。<br/>
可以在扩展中直接使用原始类型中声明的参数列表,并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<pre><code class="language-swift">//扩展泛型类型增加只读的计算属性
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>

<p>返回`<code>item</code>数组的最后一个元素</p>

<p>扩展中直接使用了已有的类型参数<code>Element</code></p>

<h2 id="toc_5">类型约束</h2>

<p>类型约束指定类型参数必须继承自指定类、遵循特定的协议或协议组合</p>

<p>对泛型函数或泛型类型中添加特定的类型参数，这在某些情况下是非常有用的<br/>
例如:<code>Dictionary</code>类型约束了字典中的键必须是可哈希的（符合<code>Hashable协议</code>），也就是必须有唯一的方法表示它，才能根据键进行判断</p>

<h3 id="toc_6">类型约束语法</h3>

<p>在类型参数名后放置类名或协议名用冒号隔开，来定义类型约束</p>

<pre><code class="language-swift">//类型约束的泛型函数
//T必须是SomeClass的子类，而U必须遵循SomeProtocol协议
func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
</code></pre>

<p>约束T必须是SomeClass的子类，要求U必须遵循SomeProtocol的</p>

<h3 id="toc_7">类型约束实践</h3>

<p>我们新建一个泛型函数来从实现从数组中查找特定元素的功能;</p>

<pre><code class="language-swift">//从数组中查找特定自字符串的非泛型函数
func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}


//泛型类型
func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
        return index
        }
    }
    return nil
}
</code></pre>

<p>上面的泛型函数，是无法通过编译的，因为不是任何类型都可以用<code>==</code>进行比较<br/>
Swift定义了一个<code>Equatable</code>协议,所有遵守改协议的类型都必须实现<code>==或!=</code>，从而对该类型任意值进行比较</p>

<pre><code class="language-swift">//此时泛型函数可以成功编译了
func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>

<h2 id="toc_8">关联类型</h2>

<p>定义协议时，声明一个或者多个关联类型作为协议的一部分</p>

<p><strong>关联类型</strong>为协议中的的某个类型提供占位符名称，而其实际类型在协议被采纳时才会被指定</p>

<p>用<code>associatedtype</code>关键字指定<strong>关联类型</strong></p>

<pre><code class="language-swift">protocol Container {
    associatedtype ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>

<p>在协议中声明了一个关联类型<code>ItemType</code>,来保证在不知道容器中元素的具体类型情况下行为能够正确执行</p>

<pre><code class="language-swift">//定义类型遵循Contain协议
Struct IntStack: Container {
    // IntStack 的原始实现部分
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // Container 协议的实现部分
    typealias ItemType = Int//可以省略，swift会根据协议的实现推断出类型
        mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}

</code></pre>

<p><code>IntStack</code>结构体实现了<code>Container</code>协议的三个要求，此外在实现其要求时，指定<code>Item</code>为<code>Int</code>类型，即<code>typealias ItemType = Int</code>来转换协议中的关联类型<br/>
当然，这个是可以省略的，Swift可以根据方法推断出<code>ItemType</code>类型</p>

<h3 id="toc_9">扩展存在的类型来指定关联类型</h3>

<p>对于Contain协议，Swift中的Array已经默认提供了协议中要求，因此我们只需要声明Array遵循该协议就可以扩展<code>Array</code></p>

<pre><code class="language-swift">//我们只需要扩展Array来使其遵循该协议即可
extension Array: Container {}
</code></pre>

<h3 id="toc_10">在关联类型约束里使用协议</h3>

<pre><code class="language-swift">protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -&gt; Suffix
}
</code></pre>

<p><code>Suffix</code>是一个关联类型，有两个约束: </p>

<ol>
<li>必须遵循SuffixableContainer协议</li>
<li>他的<code>Item</code>类型必须和容器里的<code>Item</code>类型相同</li>
</ol>

<h2 id="toc_11">泛型Where语句</h2>

<p>对关联类型添加约束是非常有用的。可以通过定义一个泛型<code>where</code>语句来实现。通过泛型where子句让关联类型遵循特定协议，以及某个特定的类型参数和关联参数必须相同</p>

<p>通过将<code>where</code>关键字紧跟在类型参数列表后来定义where子句，where子句后跟一个或者多个针对关联类型的约束，以及一个或者多个类型参数和关联类型间的相等关系。</p>

<p>可以在函数体或者类型的大括号之前添加<code>where</code>子句</p>

<pre><code class="language-swift">func allItemsMatch&lt;C1: Container, C2: Container&gt;
(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {
        // 检查两个容器含有相同数量的元素
        if someContainer.count != anotherContainer.count {
            return false
        }
        // 检查每一对元素是否相等
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
            return false
        }
    }
    // 所有元素都匹配，返回 true
    return true
}
</code></pre>

<p>这个函数的类型参数列表还定义对两个类型参数的要求:</p>

<ul>
<li>C1必须符合<code>Container</code>协议</li>
<li>C2必须符合<code>Containner</code>协议</li>
<li>C1的Item必须和C2的Item类型相同</li>
<li>C1的Item必须符合Equtable协议<br/>
前两个要求定义在函数的类型参数列表里，后两个要求定义在函数的泛型where分句中</li>
</ul>

<h3 id="toc_12">具有Where子句的扩展</h3>

<p>可以使用泛型where子句 作为扩展的一部分。</p>

<pre><code class="language-swift">//扩展泛型Stack结构体
extension Stack where Element: Equatable {
    func isTop(_ item: Element) -&gt; Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}

//扩展协议
extension Container where Item: Equatable {
    func startsWith(_ item: Item) -&gt; Bool {
        return count &gt;= 1 &amp;&amp; self[0] == item
    }
}

</code></pre>

<h3 id="toc_13">具有泛型Where子句的关联类型</h3>

<p>可以在关联类型后面加上具有泛型where的子句。</p>

<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }

    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
    func makeIterator() -&gt; Iterator
}
</code></pre>

<p>迭代器<code>Iterator</code>的泛型<code>where</code>子句要求:无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。</p>

<p>当一个协议继承另外一个协议，通过在协议声明中，包含<code>where</code>子句，来添加一个约束到被继承协议的关联类型。</p>

<pre><code class="language-swift">protocol ComparableContainer: Container where Item: Comparable { }
</code></pre>

<h3 id="toc_14">泛型下标</h3>

<p>下标也可以是泛型，能够包含泛型<code>where</code>语句。<br/>
可以在 subscript 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 where 子句</p>

<pre><code class="language-swift">extension Container {
    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]
        where Indices.Iterator.Element == Int {
            var result = [Item]()
            for index in indices {
                result.append(self[index])
            }
            return result
    }
}
</code></pre>

<ul>
<li>泛型参数 Indices，必须是符合标准库中的 Sequence 协议</li>
<li>下标使用的单一的参数，indices，必须是 Indices实例</li>
<li>泛型 where 子句要求 Sequence（Indices）的迭代器，其所有的元素都是 Int 类型</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15047511695312.html">协议</a></h1>
			<p class="meta"><time datetime="2017-09-07T10:26:09+08:00" 
			pubdate data-updated="true">09/07/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>类和结构体、枚举都可以遵循协议,并为协议定义的这些要求提供实现<br/>
除了遵循协议的类型必须实现外还可以对协议进行扩展，通过扩展来实现一部分要求或者添加附加功能</p>

<h2 id="toc_0">协议语法</h2>

<p>协议的定义:</p>

<pre><code class="language-swift">protocol SomeProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<p>自定义类型遵循某个协议,定义类型时,可以在类型名称后加上协议名称,中间用<code>:</code>分割,多个协议之间用<code>,</code>分割</p>

<pre><code class="language-swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 这里是结构体的定义部分
}
</code></pre>

<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>

<pre><code class="language-swift">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 这里是类的定义部分
}
</code></pre>

<h2 id="toc_1">属性要求</h2>

<ul>
<li>协议可以指定遵循协议的类型提供特定名称和类型的实例属性或类型属性。</li>
<li>协议不指定属性是存储属性还是计算属性，只指定属性名称和类型</li>
<li>协议指定属性是可读的还是可读写的</li>
</ul>

<blockquote>
<p>注意:</p>

<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。<br/>
如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的</p>
</blockquote>

<p>协议总是用<code>var</code>关键字来声明变量属性，在类型声明后加上<code>{ set get }</code>来表示属性是可读可写的，可读属性则用<code>{ get }</code>来表示</p>

<pre><code class="language-swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>在协议中定义类型属性时，使用<code>static</code>关键字作为前缀。当类类型遵循协议时,除了<code>static</code>关键字,还可以使用<code>class</code>关键字声明类型属性:</p>

<pre><code class="language-swift">protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>

<h2 id="toc_2">方法要求</h2>

<p>遵循协议的类型实现某些指定的实例方法或类方法</p>

<ul>
<li>方法像普通方法一样放在协议的定义中,但是不需要大括号和方法体</li>
<li>与普通方法类似可以在方法中提供可变参数,但是不能为参数提供默认值</li>
<li>在协议中定义类方法时，总是使用<code>static</code>关键字为前缀.当类类型遵循协议时，除了<code>static</code>关键字，还可以使用<code>class</code>关键字作为前缀</li>
</ul>

<pre><code class="language-swift">protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<pre><code class="language-swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
</code></pre>

<h2 id="toc_3">Mutating方法要求</h2>

<p>如果在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加<code>mutating</code>关键字,使得结构体和枚举能够遵循此协议并满足方法要求</p>

<blockquote>
<p>注意</p>

<p>在实现协议的<code>mutating</code>方法时，若是类类型则不用写<code>mutating</code>关键字，而若是结构体或枚举必须写<code>mutating</code>关键字</p>
</blockquote>

<pre><code class="language-swift">protocol Togglable {
    mutating func toggle()
}

//定义在两种状态间切换的枚举
enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = .On
        case On:
            self = .Off
        }
    }
}
</code></pre>

<h2 id="toc_4">构造器要求</h2>

<p><strong>协议可以要求遵循协议的类型实现指定的构造器</strong></p>

<pre><code class="language-swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h3 id="toc_5">构造器要求在类中的实现</h3>

<p>遵循协议的类实现构造器.不论指定构造器或者便利构造器都必须在实现加上<code>required</code>修饰符</p>

<pre><code class="language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<p>使用<code>required</code>修饰符可以确保所有子类也必须提供此构造器实现，即符合协议</p>

<p>注意:</p>

<blockquote>
<p>如果类被标记为<code>final</code>，就不需要在协议构造器中使用<code>required</code>修饰符,因为<code>final</code>类不会有子类</p>
</blockquote>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求,那么重写上需要同时加上<code>required</code>和<code>override</code>修饰符</p>

<pre><code class="language-swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // 这里是构造器的实现部分
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为遵循协议，需要加上 required
    // 因为继承自父类，需要加上 override
    required override init() {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<h3 id="toc_6">可失败构造器要求</h3>

<p>协议还可以为遵循协议的类型定义可失败构造器要求</p>

<p>遵循协议的类型可以通过可失败构造器<code>（init?）</code>或非可失败构造器<code>（init）</code>来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器<code>（init</code>或隐式解包可失败构造器<code>（init!）</code>来满足</p>

<h2 id="toc_7">协议作为类型</h2>

<p>协议可以作为功能完备的类型来使用:</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>

<p>协议作为一种类型,因此与它类型的命名写法相同 应该使用驼峰写法</p>

<pre><code class="language-swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>类<code>Dice</code>中含有属性<code>generator</code>为<code>RandomNumberGenerator</code>协议类型,因此遵循了<code>RandomNumberGenerator</code>协议类型的实例都可以赋值给<code>generator</code></p>

<p>在类中有<code>roll</code>的实例方法,调用<code>generator</code>的<code>random()</code>方法来生成一个<code>[0.0,1.0)</code>区间内的随机数</p>

<h2 id="toc_8">委托（代理）模式</h2>

<hr/>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例.<br/>
委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。<br/>
委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型</p>

<hr/>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>我们可以通过扩展代码来为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中相应要求</p>

<blockquote>
<p>通过扩展使已有类型遵循并符合协议时,该类型的所有实例也会获得协议中定义的各项功能</p>
</blockquote>

<pre><code class="language-swift">protocol TextRepresentable {
    var textualDescription: String { get }
}

extension Dice: TextRepresentable {
    var textualDescription: String {
        return &quot;A \(sides)-sided dice&quot;
    }
}
</code></pre>

<p>扩展来遵循并符合协议与原始定义中效果相同</p>

<h2 id="toc_10">有条件遵循协议</h2>

<p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。</p>

<p>可以通过在扩展类型时列出限制让泛型类型有条件的遵循某协议。在你采纳协议的名字后面写泛型where分句。</p>

<pre><code class="language-swift">extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
</code></pre>

<h2 id="toc_11">通过扩展遵循协议</h2>

<p>有时一个类型已经符合了协议的要求，但是没声明采纳该协议，可以通过空的扩展使其采纳该协议:</p>

<pre><code class="language-swift">struct Hamster {
    var name: String
    var textualDescription: String {
        return &quot;A hamster named \(name)&quot;
    }
}

extension Hamster: TextRepresentable {}
</code></pre>

<h2 id="toc_12">协议类型的集合</h2>

<p>协议类型可以在数组或字典这样的集合使用</p>

<p><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></p>

<h2 id="toc_13">协议的继承</h2>

<p>协议可以继承一个或多个其他协议,可以在继承协议基础上增加新的要求.协议继承语法与类相似,多个协议用逗号分割：</p>

<pre><code class="language-swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<h2 id="toc_14">类类型专属协议</h2>

<p>通过添加<code>AnyObject</code>关键字到协议的继承列表，可以限制协议只能被类类型采纳(以及非结构体或者非枚举的类型)</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<h2 id="toc_15">协议合成</h2>

<p>有时我们需要一个类型遵循多个协议，此时可以使用协议组合来复合多个协议到一个要求中。<br/>
协议组合并不定义任何新的协议类型  </p>

<p>协议组合采用<code>SomeProtocol &amp; AnotherProtocol</code>的格式进行组合,可以泪如任意数量的协议<br/>
除了协议列表，协议组合也能包含类类型，这允许你表明一个需要的父类</p>

<pre><code class="language-swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}

func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)
}

let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
wishHappyBirthday(to: birthdayPerson)// “Happy birthday Malcolm - you&#39;re 21!”
</code></pre>

<h2 id="toc_16">检查协议一致性</h2>

<p>使用<code>is</code>和<code>as</code>检查协议的一致性,即是否符合某协议，并且可以转换到指定的协议类型,与类型检查和转换用法相同:</p>

<ul>
<li><code>is</code>用来检查实例是否符合某个协议，若符合则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>as?</code>返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回<code>nil</code></li>
<li><code>as!</code>将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误</li>
</ul>

<pre><code class="language-swift">protocol HasArea {
    var area: Double { get }
}

for object in objects {
    if let objectWithArea = object as? HasArea {
        print(&quot;Area is \(objectWithArea.area)&quot;)
    } else {
        print(&quot;Something that doesn&#39;t have an area&quot;)
    }
}
</code></pre>

<p>判断元素是否符合<code>HasArea</code>协议后将<code>as?</code>操作符通过可选绑定，绑定到<code>objectWithArea</code>常量上进行访问</p>

<blockquote>
<p>在数据中的元素类型并不会因为强转而丢失类型信息,只是在被赋值为<code>objectWithArea</code>时，被视为<code>HasArea</code>类型，因此只有<code>area</code>属性可以被访问</p>
</blockquote>

<h2 id="toc_17">可选的协议要求</h2>

<p>协议可以被定位可选要求，此时遵循协议的类型可以选择是否实现这些要求。</p>

<p>协议中使用<code>option</code>关键字作为前缀来标记可选要求，<br/>
可选要求用在需要和OC打交道的代码中<br/>
协议和可选要求都必须带上<code>@objc</code>属性<br/>
标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议</p>

<blockquote>
<p>注意:</p>

<p>当使用可选要求时，协议中的可选的方法或属性会自动变成可选的（函数的话整个函数类型是可选的而不是函数的返回值）</p>
</blockquote>

<p>可选要求 可以通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似<code>someoptionMethond?(someArgument)</code>，可以再可选方法名后加上<code>?</code>调用可选方法(因为此时其方法时可选的而不是其返回值是可选的)</p>

<pre><code class="language-swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code class="language-swift">class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
    //此处无法确定是否存在dataSource 以及 datasource是否遵循了协议 因此需要两层的可选链式调用
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>

<p>通过可选链式调用可选协议</p>

<p><code>CounterDataSource</code>的简单实现</p>

<pre><code class="language-swift">//继承自OC的NSObject
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

//@objc类
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>

<h2 id="toc_18">协议扩展</h2>

<p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的&quot;实现&quot;.<br/>
此时可以基于协议本身实现这些功能,而不需要给每个遵循协议的类型进行重复的实现或者使用全局函数</p>

<pre><code class="language-swift">//定义一个协议
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
//为协议进行协议扩展
extension RandomNumberGenerator {
    func randomBool() -&gt; Bool {
        return random() &gt; 0.5
    }
}
</code></pre>

<p>所有遵循该协议的类型 都能获得扩展所增加的方法实现</p>

<h3 id="toc_19">提供默认实现</h3>

<p>可以通过协议扩展来为协议中的的要求属性、方法、下标等提供默认实现。<br/>
如果遵循该协议的类型提供了自己的实现,那么这些自定义实现会代替扩展中的默认实现而被使用</p>

<h3 id="toc_20">为协议扩展添加限制条件</h3>

<p>我们上面有条件的遵循了某些协议，除此之外在协议扩展的时候也可以加一些限制条件,此时只有满足这些条件的时候，遵循协议的类型才能获取协议扩展提供的默认实现</p>

<p>将这些限制条件写在扩展协议名字之后,并且使用<code>where</code>字句描述</p>

<pre><code class="language-swift">/**
扩展Collection协议,适用于集合中的元素遵循Equatable协议的情况
*/
extension Collection where Element: Equatable {
    func allEqual() -&gt; Bool {
        for element in self {
            if element != self.first {
                return false
            }
        }
        return true
    }
}
//只有集合中的元素都一致   allEequal方法才返回true
</code></pre>

<blockquote>
<p>注意:</p>

<p>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多、最匹配限制的实现</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15042587690391.html">扩展</a></h1>
			<p class="meta"><time datetime="2017-09-01T17:39:29+08:00" 
			pubdate data-updated="true">09/01/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>扩展</strong>可以为一个已有的类、结构体、枚举类型或者协议类型添加新功能</p>

<p>拥有不需要访问被扩展类型源代码就能完成扩展的能力(即逆向建模)</p>

<blockquote>
<p>注意</p>

<p>Swift的扩展和OC中的分类功能很相似,但是Swift中的分类是没有名字的</p>
</blockquote>

<p><strong>Swift中的扩展可功能</strong>:</p>

<ul>
<li>添加计算型属性和计算类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>

<p>在swift中，甚至可以对协议进行扩展、提供协议其需要的实现，或者添加额外的功能给遵循的类型所使用</p>

<blockquote>
<p>注意</p>

<p>扩展只能添加新的功能不能重写已有功能</p>
</blockquote>

<h2 id="toc_0">扩展语法</h2>

<p>用关键字<code>extension</code>声明扩展:</p>

<pre><code class="language-swift">extension SomeType {
    // 为 SomeType 添加的新功能写到这里
}
</code></pre>

<p>扩展一个已有类型,使其采纳一个或多个协议</p>

<pre><code class="language-swift">extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>

<blockquote>
<p>注意:</p>

<p>对于一个现有类型，如果定义一个扩展来添加新的功能，那么这个类型的所有实例都可以使用这个新功能。包括那些在扩展定以前就存在的实例。</p>
</blockquote>

<h2 id="toc_1">计算型属性</h2>

<pre><code class="language-swift">extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print(&quot;One inch is \(oneInch) meters&quot;)
    // 打印 “One inch is 0.0254 meters”
let threeFeet = 3.ft
print(&quot;Three feet is \(threeFeet) meters&quot;)
    // 打印 “Three feet is 0.914399970739201 meters”
</code></pre>

<p>扩展<code>Double</code>类型,增加计算型属性,实现距离转换<br/>
上面的属性是只读的计算型属性,省略了<code>get</code>关键字</p>

<blockquote>
<p>注意:</p>

<p>可以增加新的计算型属性,但是不能增加存储型属性，也不能为已有属性添加属性观察器</p>
</blockquote>

<h2 id="toc_2">构造器</h2>

<p>扩展可以为已有类型添加新的构造器。</p>

<p>扩展能为<strong>类</strong>添加新的便利构造器,但是不能为类添加新的指定构造器或者析构器。指定构造器和析构器必须由类的原始实现提供</p>

<blockquote>
<p>注意:</p>

<p>如果使用扩展给<strong>值类型</strong>添加构造器只适用于给所有的存储属性提供默认值，并且没有定义任何自定义构造器，那么你将可以在该值类型扩展的构造器中使用默认构造器和逐一成员构造器。但是如果将构造器写在值类型的原始视线中，那么就属于在扩展中添加构造器</p>

<p>如果通过扩展提供一个新的构造器 那么有责任确保每个通过构造器创建的实例都是初始化完整的</p>
</blockquote>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>因为<code>Rect</code>没有指定构造器,存储属性也都有默认值,因此获得一个逐一成员构造器和默认构造器，</p>

<pre><code class="language-swift">extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        //调用结构体的逐一成员构造器
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<h2 id="toc_3">方法</h2>

<p>为已有类型添加新的实例方法和类型方法</p>

<pre><code class="language-swift">extension Int {
    func repetitions(task: () -&gt; Void) {
        for _ in 0..&lt;self {
            task()
        }
    }
}
//为Int类型添加一个名为`repetitions`的实例方法
//这个方法接受一个`()-&gt;Void`类型的单参数，没有参数也没有返回值的函数
</code></pre>

<h3 id="toc_4">可变实例方法</h3>

<p>扩展中添加的实例方法也可以修改该实例本身，对于值类型即结构体或者枚举修改<code>self</code>或其属性的方法就必须将该实例方法标注为<code>mutating</code>(类似原始实现)</p>

<pre><code class="language-swift">extension Int {
    mutating func square() {
        self = self * self
    }
}
</code></pre>

<h2 id="toc_5">下标</h2>

<p>扩展为已有类型添加下标.</p>

<pre><code class="language-swift">extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
        for _ in 0..&lt;digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// 返回 5
746381295[1]
// 返回 9
//取的下标越界时自动用0补充
746381295[9]
// 返回 0，即等同于：
0746381295[9]
</code></pre>

<p>上面的例子为<code>Int</code>增加下标方法，<code>[n]</code>返回十进制数字从右向左数的第<code>n</code>个数字</p>

<h2 id="toc_6">嵌套类型</h2>

<p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型:</p>

<pre><code class="language-swift">extension Int {
    enum Kind {
    case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
</code></pre>

<p>为<code>Int</code>添加了一个嵌套枚举,来表明特定整数的类型，即正数、负数或零</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="Swift-BaseLearning_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>