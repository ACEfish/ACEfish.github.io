
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  Swift基础知识 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15047511695312.html">协议</a></h1>
			<p class="meta"><time datetime="2017-09-07T10:26:09+08:00" 
			pubdate data-updated="true">2017/9/7</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>类和结构体、枚举都可以遵循协议,并为协议定义的这些要求提供实现<br/>
除了遵循协议的类型必须实现外还可以对协议进行扩展，通过扩展来实现一部分要求或者添加附加功能</p>

<h2 id="toc_0">协议语法</h2>

<p>协议的定义:</p>

<pre><code class="language-swift">protocol SomeProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<p>自定义类型遵循某个协议,定义类型时,可以在类型名称后加上协议名称,中间用<code>:</code>分割,多个协议之间用<code>,</code>分割</p>

<pre><code class="language-swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 这里是结构体的定义部分
}
</code></pre>

<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>

<pre><code class="language-swift">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 这里是类的定义部分
}
</code></pre>

<h2 id="toc_1">属性要求</h2>

<ul>
<li>协议可以指定遵循协议的类型提供特定名称和类型的实例属性或类型属性。</li>
<li>协议不指定属性是存储属性还是计算属性，只指定属性名称和类型</li>
<li>协议指定属性是可读的还是可读写的</li>
</ul>

<blockquote>
<p>注意:</p>

<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。<br/>
如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的</p>
</blockquote>

<p>协议总是用<code>var</code>关键字来声明变量属性，在类型声明后加上<code>{ set get }</code>来表示属性是可读可写的，可读属性则用<code>{ get }</code>来表示</p>

<pre><code class="language-swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>在协议中定义类型属性时，使用<code>static</code>关键字作为前缀。当类类型遵循协议时,除了<code>static</code>关键字,还可以使用<code>class</code>关键字声明类型属性:</p>

<pre><code class="language-swift">protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>

<h2 id="toc_2">方法要求</h2>

<p>遵循协议的类型实现某些指定的实例方法或类方法</p>

<ul>
<li>方法像普通方法一样放在协议的定义中,但是不需要大括号和方法体</li>
<li>与普通方法类似可以在方法中提供可变参数,但是不能为参数提供默认值</li>
<li>在协议中定义类方法时，总是使用<code>static</code>关键字为前缀.当类类型遵循协议时，除了<code>static</code>关键字，还可以使用<code>class</code>关键字作为前缀</li>
</ul>

<pre><code class="language-swift">protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<pre><code class="language-swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
</code></pre>

<h2 id="toc_3">Mutating方法要求</h2>

<p>如果在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加<code>mutating</code>关键字,使得结构体和枚举能够遵循此协议并满足方法要求</p>

<blockquote>
<p>注意</p>

<p>在实现协议的<code>mutating</code>方法时，若是类类型则不用写<code>mutating</code>关键字，而若是结构体或枚举必须写<code>mutating</code>关键字</p>
</blockquote>

<pre><code class="language-swift">protocol Togglable {
    mutating func toggle()
}

//定义在两种状态间切换的枚举
enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = .On
        case On:
            self = .Off
        }
    }
}
</code></pre>

<h2 id="toc_4">构造器要求</h2>

<p><strong>协议可以要求遵循协议的类型实现指定的构造器</strong></p>

<pre><code class="language-swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h3 id="toc_5">构造器要求在类中的实现</h3>

<p>遵循协议的类实现构造器.不论指定构造器或者便利构造器都必须在实现加上<code>required</code>修饰符</p>

<pre><code class="language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<p>使用<code>required</code>修饰符可以确保所有子类也必须提供此构造器实现，即符合协议</p>

<p>注意:</p>

<blockquote>
<p>如果类被标记为<code>final</code>，就不需要在协议构造器中使用<code>required</code>修饰符,因为<code>final</code>类不会有子类</p>
</blockquote>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求,那么重写上需要同时加上<code>required</code>和<code>override</code>修饰符</p>

<pre><code class="language-swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // 这里是构造器的实现部分
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为遵循协议，需要加上 required
    // 因为继承自父类，需要加上 override
    required override init() {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<h3 id="toc_6">可失败构造器要求</h3>

<p>协议还可以为遵循协议的类型定义可失败构造器要求</p>

<p>遵循协议的类型可以通过可失败构造器<code>（init?）</code>或非可失败构造器<code>（init）</code>来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器<code>（init</code>或隐式解包可失败构造器<code>（init!）</code>来满足</p>

<h2 id="toc_7">协议作为类型</h2>

<p>协议可以作为功能完备的类型来使用:</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>

<p>协议作为一种类型,因此与它类型的命名写法相同 应该使用驼峰写法</p>

<pre><code class="language-swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>类<code>Dice</code>中含有属性<code>generator</code>为<code>RandomNumberGenerator</code>协议类型,因此遵循了<code>RandomNumberGenerator</code>协议类型的实例都可以赋值给<code>generator</code></p>

<p>在类中有<code>roll</code>的实例方法,调用<code>generator</code>的<code>random()</code>方法来生成一个<code>[0.0,1.0)</code>区间内的随机数</p>

<h2 id="toc_8">委托（代理）模式</h2>

<hr/>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例.<br/>
委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。<br/>
委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型</p>

<hr/>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>我们可以通过扩展代码来为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中相应要求</p>

<blockquote>
<p>通过扩展使已有类型遵循并符合协议时,该类型的所有实例也会获得协议中定义的各项功能</p>
</blockquote>

<pre><code class="language-swift">protocol TextRepresentable {
    var textualDescription: String { get }
}

extension Dice: TextRepresentable {
    var textualDescription: String {
        return &quot;A \(sides)-sided dice&quot;
    }
}
</code></pre>

<p>扩展来遵循并符合协议与原始定义中效果相同</p>

<h2 id="toc_10">有条件遵循协议</h2>

<p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。</p>

<p>可以通过在扩展类型时列出限制让泛型类型有条件的遵循某协议。在你采纳协议的名字后面写泛型where分句。</p>

<pre><code class="language-swift">extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
</code></pre>

<h2 id="toc_11">通过扩展遵循协议</h2>

<p>有时一个类型已经符合了协议的要求，但是没声明采纳该协议，可以通过空的扩展使其采纳该协议:</p>

<pre><code class="language-swift">struct Hamster {
    var name: String
    var textualDescription: String {
        return &quot;A hamster named \(name)&quot;
    }
}

extension Hamster: TextRepresentable {}
</code></pre>

<h2 id="toc_12">协议类型的集合</h2>

<p>协议类型可以在数组或字典这样的集合使用</p>

<p><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></p>

<h2 id="toc_13">协议的继承</h2>

<p>协议可以继承一个或多个其他协议,可以在继承协议基础上增加新的要求.协议继承语法与类相似,多个协议用逗号分割：</p>

<pre><code class="language-swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<h2 id="toc_14">类类型专属协议</h2>

<p>通过添加<code>AnyObject</code>关键字到协议的继承列表，可以限制协议只能被类类型采纳(以及非结构体或者非枚举的类型)</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<h2 id="toc_15">协议合成</h2>

<p>有时我们需要一个类型遵循多个协议，此时可以使用协议组合来复合多个协议到一个要求中。<br/>
协议组合并不定义任何新的协议类型  </p>

<p>协议组合采用<code>SomeProtocol &amp; AnotherProtocol</code>的格式进行组合,可以泪如任意数量的协议<br/>
除了协议列表，协议组合也能包含类类型，这允许你表明一个需要的父类</p>

<pre><code class="language-swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}

func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)
}

let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
wishHappyBirthday(to: birthdayPerson)// “Happy birthday Malcolm - you&#39;re 21!”
</code></pre>

<h2 id="toc_16">检查协议一致性</h2>

<p>使用<code>is</code>和<code>as</code>检查协议的一致性,即是否符合某协议，并且可以转换到指定的协议类型,与类型检查和转换用法相同:</p>

<ul>
<li><code>is</code>用来检查实例是否符合某个协议，若符合则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>as?</code>返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回<code>nil</code></li>
<li><code>as!</code>将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误</li>
</ul>

<pre><code class="language-swift">protocol HasArea {
    var area: Double { get }
}

for object in objects {
    if let objectWithArea = object as? HasArea {
        print(&quot;Area is \(objectWithArea.area)&quot;)
    } else {
        print(&quot;Something that doesn&#39;t have an area&quot;)
    }
}
</code></pre>

<p>判断元素是否符合<code>HasArea</code>协议后将<code>as?</code>操作符通过可选绑定，绑定到<code>objectWithArea</code>常量上进行访问</p>

<blockquote>
<p>在数据中的元素类型并不会因为强转而丢失类型信息,只是在被赋值为<code>objectWithArea</code>时，被视为<code>HasArea</code>类型，因此只有<code>area</code>属性可以被访问</p>
</blockquote>

<h2 id="toc_17">可选的协议要求</h2>

<p>协议可以被定位可选要求，此时遵循协议的类型可以选择是否实现这些要求。</p>

<p>协议中使用<code>option</code>关键字作为前缀来标记可选要求，<br/>
可选要求用在需要和OC打交道的代码中<br/>
协议和可选要求都必须带上<code>@objc</code>属性<br/>
标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议</p>

<blockquote>
<p>注意:</p>

<p>当使用可选要求时，协议中的可选的方法或属性会自动变成可选的（函数的话整个函数类型是可选的而不是函数的返回值）</p>
</blockquote>

<p>可选要求 可以通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似<code>someoptionMethond?(someArgument)</code>，可以再可选方法名后加上<code>?</code>调用可选方法(因为此时其方法时可选的而不是其返回值是可选的)</p>

<pre><code class="language-swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code class="language-swift">class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
    //此处无法确定是否存在dataSource 以及 datasource是否遵循了协议 因此需要两层的可选链式调用
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>

<p>通过可选链式调用可选协议</p>

<p><code>CounterDataSource</code>的简单实现</p>

<pre><code class="language-swift">//继承自OC的NSObject
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

//@objc类
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>

<h2 id="toc_18">协议扩展</h2>

<p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的&quot;实现&quot;.<br/>
此时可以基于协议本身实现这些功能,而不需要给每个遵循协议的类型进行重复的实现或者使用全局函数</p>

<pre><code class="language-swift">//定义一个协议
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
//为协议进行协议扩展
extension RandomNumberGenerator {
    func randomBool() -&gt; Bool {
        return random() &gt; 0.5
    }
}
</code></pre>

<p>所有遵循该协议的类型 都能获得扩展所增加的方法实现</p>

<h3 id="toc_19">提供默认实现</h3>

<p>可以通过协议扩展来为协议中的的要求属性、方法、下标等提供默认实现。<br/>
如果遵循该协议的类型提供了自己的实现,那么这些自定义实现会代替扩展中的默认实现而被使用</p>

<h3 id="toc_20">为协议扩展添加限制条件</h3>

<p>我们上面有条件的遵循了某些协议，除此之外在协议扩展的时候也可以加一些限制条件,此时只有满足这些条件的时候，遵循协议的类型才能获取协议扩展提供的默认实现</p>

<p>将这些限制条件写在扩展协议名字之后,并且使用<code>where</code>字句描述</p>

<pre><code class="language-swift">/**
扩展Collection协议,适用于集合中的元素遵循Equatable协议的情况
*/
extension Collection where Element: Equatable {
    func allEqual() -&gt; Bool {
        for element in self {
            if element != self.first {
                return false
            }
        }
        return true
    }
}
//只有集合中的元素都一致   allEequal方法才返回true
</code></pre>

<blockquote>
<p>注意:</p>

<p>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多、最匹配限制的实现</p>
</blockquote>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="Swift-BaseLearning_7.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="Swift-BaseLearning_5.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="iOS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9D%97%E7%9F%A5%E8%AF%86.html"><strong>iOS 开发模块知识&nbsp;(172)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91.html">iOS编译&nbsp;(20)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&Block.html">内存管理&Block&nbsp;(18)</a>&nbsp;&nbsp;
	        
	        	<a href="RunTime.html">runtime&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="Concurrent-Programming.html">多线程&nbsp;(19)</a>&nbsp;&nbsp;
	        
	        	<a href="GPU&&%E6%B8%B2%E6%9F%93.html">GPU&&渲染&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0.html">架构学习&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0.html">第三方项目学习&nbsp;(20)</a>&nbsp;&nbsp;
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(10)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%B5%8B%E8%AF%95.html">调试&&测试&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0.html">模块化知识学习&nbsp;(26)</a>&nbsp;&nbsp;
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9.html">知识点&nbsp;(10)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%A1%A5%E5%85%85-1.html">补充&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift.html"><strong>Swift初学笔记&nbsp;(28)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Swift-BaseLearning.html">Swift基础知识&nbsp;(28)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOSDevelop.html"><strong>iOSDevelop&nbsp;(27)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(14)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86.html">iOS开发知识&nbsp;(12)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html"><strong>算法学习&nbsp;(2)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">算法读书笔记&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15680194937623.html">AFSecurityPolicy</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15680125238227.html">AFNetworkReachabilityManager</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15677400518331.html">AFURLSerialization</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15676621460215.html">AFURLSessionManager</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15675682575589.html">AFNetworking</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>