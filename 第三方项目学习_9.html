
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  第三方项目学习 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15693141187091.html">Teture的便捷性</a></h1>
			<p class="meta"><time datetime="2019-09-24T16:35:18+08:00" 
			pubdate data-updated="true">2019/9/24</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Hit Test Slop</h2>

<p><code>ASDisplayNode</code>提供了<code>UIEdgeInset</code>类型的属性，当设置为非0的inset时，提高点击命中范围，使其更容易点击或执行手势</p>

<p>因为<code>ASDisplayNode</code>是所有node的基类，因此所有的<code>texture</code>node都有这个属性</p>

<blockquote>
<p>注意</p>

<p>这个属性影响了<code>-hitTest</code>和<code>-pointInside</code>，所以在重写这个方法时 建议调用<code>super</code></p>
</blockquote>

<p>节点捕获触摸事件的能力受到父节点的边界和父级<code>hitTestSlop</code>属性的限制。如果你想让子项的<code>hitTestSlop</code>扩展到父项的边界之外，只需要扩展父节点的<code>hitTestSlop</code>即可</p>

<p>示例：<br/>
当有一个文本节点作为按钮时，通常，文本节点高度通常不会达到要求的最低44的点击高度，此时，可以计算出区域差，并对标签应用inset来增加点击区域</p>

<pre><code class="language-objectivec">ASTextNode *textNode = [[ASTextNode alloc] init];
CGFloat padding = (44.0 - button.bounds.size.height)/2.0;
textNode.hitTestSlop = UIEdgeInsetsMake(-padding, 0, -padding, 0);
</code></pre>

<h2 id="toc_1">批量获取API</h2>

<p>Texture的批量获取API，用于批量获取数据块。这个通常在会写在<code>-scrollViewDidScroll:</code>方法中，但是<code>Texture</code>提供了更结构化的机制</p>

<p>默认，当用户滑动table或者collection，当那里距离屏幕底部2个屏幕远时，会试着获取更多的数据。我们可以通过调整<code>ASTableView</code>或者<code>ASCollectionView</code>的<code>leadingScreensForBatching</code>属性</p>

<pre><code class="language-objectivec">tableNode.view.leadingScreensForBatching = 3.0;  // overriding default of 2.0
</code></pre>

<h3 id="toc_2">代理方法</h3>

<p>实现该代理方法  决定是否需要加载新内容数据</p>

<pre><code class="language-objectivec">- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode
{
  if (_weNeedMoreContent) {
    return YES;
  }

  return NO;
}
</code></pre>

<p>当用户滚动到批量获取范围时，会调用该方法，我们通常根据是否还有数据需要获取来决定是否需要会进行批量获取请求，当返回YES时 就会进行接下来的步骤:</p>

<pre><code class="language-objectivec">-tableNode:willBeginBatchFetchWithContext:
-collectionNode:willBeginBatchFetchWithContext:
</code></pre>

<p>我们在这个方法中 执行数据获取(从网络或者本地数据库获取数据)</p>

<blockquote>
<p>注意</p>

<p>这个方法总是在后台线程中调用，意味着如果需要工作在主线程中，就需要dispatch其到主线程</p>
</blockquote>

<pre><code class="language-objectivec">- (void)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context 
{
  // Fetch data most of the time asynchronously from an API or local database
  NSArray *newPhotos = [SomeSource getNewPhotos];

  // Insert data into table or collection node
  [self insertNewRowsInTableNode:newPhotos];

  // Decide if it&#39;s still necessary to trigger more batch fetches in the future
  _stillDataToFetch = ...;

  // Properly finish the batch fetch
  [context completeBatchFetching:YES];
}
</code></pre>

<p>当完成数据获取时，需要调用<code>-completeBatchFetching:</code>方法传递参数YES来通知已经结束数据获取。这确保了批量获取机制可以同步进行，并且下次批量获取可以发生了。只有传递YES，context才知道可以尝试另外一批更新。</p>

<h2 id="toc_3">自动节点管理</h2>

<p><a href="https://texturegroup.org/docs/automatic-subnode-mgmt.html">自动节点管理</a></p>

<p>当我们需要使用<code>Layout Transition api</code>时，就需要启用自动节点管理功能。然而，不需要动画的功能，也会从代码量的减小中受益</p>

<p>启用了自动节点管理功能，说明我们不再需要再调用<code>addNode</code>或者<code>removeNode</code>方法。节点的存在与否完全由<code>layoutSpecThatFits:</code>方法决定</p>

<h3 id="toc_4">更新ASLayoutSpec</h3>

<p>当需要更改<code>ASLayoutSepec</code>时，我们需要手动调用<code>setNeedLayout</code>。这个等效于<code>Transition Layout API</code>中的<code>transitionLayout: duration:0</code>。</p>

<p>正确构造的<code>ASLayoutSpec</code>知道需要添加、删除或设置动画的子节点。</p>

<blockquote>
<p>注意</p>

<p>在启用的自动节点管理后，就不能再调用<code>addSubnode:</code>和<code>removeFromSupernode</code>方法</p>
</blockquote>

<h2 id="toc_5">反转</h2>

<p><code>ASTableNide</code>和<code>ASCollectionNide</code>具有BOOL类型的反转属性，当设置为YES时，将自动反转内容可以自下向上布局(即indexPath为(0,0)的位于底部)，这对于聊天应用是十分方便的，而且仅需要一个属性</p>

<pre><code class="language-objectivec"> CGFloat inset = [self topBarsHeight];
 self.tableNode.view.contentInset = UIEdgeInsetsMake(0, 0, inset, 0);
 self.tableNode.view.scrollIndicatorInsets = UIEdgeInsetsMake(0, 0, inset, 0);
  
</code></pre>

<h2 id="toc_6">图像修改block</h2>

<p>大多数时候，我们在主线程进行大量修改图像外观的操作，我们当然希望将其移动到后台</p>

<p>通过给<code>imageNode</code>设置<code>imageModificationBlock</code>,定义一系列的转换，这些转换与imageNode上设置的图像异步发生</p>

<pre><code class="language-objectivec">//举例
_backgroundImageNode.imageModificationBlock = ^(UIImage *image) {
    UIImage *newImage = [image applyBlurWithRadius:30
        tintColor:[UIColor colorWithWhite:0.5 alpha:0.3]
        saturationDeltaFactor:1.8
        maskImage:nil];
    return newImage ?: image;
};

//some time later...

_backgroundImageNode.image = someImage;
</code></pre>

<p>此时，每当把照片分配给imageNode前，都需要进行异步处理</p>

<h3 id="toc_7">添加图像效果</h3>

<p>利用<code>imageModificationBlock</code>给图像添加效果是很有效的，当提供了block时，可以再显示阶段对图像执行绘制操作。由于显示是在后台执行的，因此不会阻塞主线程</p>

<p><code>imageModificationBlock</code>可以非常方便的用于添加各种图像效果</p>

<p>举个例子：<br/>
我们有一个图像节点，并且<code>imageNode</code>需要被切圆角。我们可以提供一个<code>imageModificationBlock</code>，可以方便的将传入的图像切圆并且返回</p>

<pre><code class="language-objectivec">- (instancetype)init
{
// ...
  _userAvatarImageNode.imageModificationBlock = ^UIImage *(UIImage *image) {
    CGSize profileImageSize = CGSizeMake(USER_IMAGE_HEIGHT, USER_IMAGE_HEIGHT);
    return [image makeCircularImageWithSize:profileImageSize];
  };
  // ...
}

//绘图代码抽象为UIImage的匪类中
@implementation UIImage (Additions)
- (UIImage *)makeCircularImageWithSize:(CGSize)size
{
  // make a CGRect with the image&#39;s size
  CGRect circleRect = (CGRect) {CGPointZero, size};

  // begin the image context since we&#39;re not in a drawRect:
  UIGraphicsBeginImageContextWithOptions(circleRect.size, NO, 0);

  // create a UIBezierPath circle
  UIBezierPath *circle = [UIBezierPath bezierPathWithRoundedRect:circleRect cornerRadius:circleRect.size.width/2];

  // clip to the circle
  [circle addClip];

  // draw the image in the circleRect *AFTER* the context is clipped
  [self drawInRect:circleRect];

  // get an image from the image context
  UIImage *roundedImage = UIGraphicsGetImageFromCurrentImageContext();

  // end the image context since we&#39;re not in a drawRect:
  UIGraphicsEndImageContext();

  return roundedImage;
}
@end
</code></pre>

<h2 id="toc_8">Placeholders</h2>

<p>任何<code>ASDisplayNode</code>的子类都实现了<code>-placeholderImage</code>方法，提供了一个覆盖内容的的占位图，直到node内容显示。<br/>
通过设置<code>.placeholderEnabled = YES</code>以及可选属性<code>.placeholderFadeDuration</code><br/>
对于image drawing，使用node的<code>.calculateSize</code>属性</p>

<blockquote>
<p>注意</p>

<p>因为<code>placeholderImage</code>函数有可能在后台调用，因此我们需要保证其线程安全。注意，利用 <code>-[UIImage imageNamed:]</code>使用image asset不是线程安全,可以代替的使用<code>-[UIImage imageWithContentsOfFile:]</code></p>
</blockquote>

<p><code>Texture</code>中的<code>UIImage + ASConvenience</code>类别方法是创建占位符图像的理想资源，包括圆形，矩形，单色或简单的方角图像。</p>

<h3 id="toc_9">.neverShowPlaceholders</h3>

<h3 id="toc_10">ASNetworkImageNode also have Default Images</h3>

<p>对于<code>ASNetworkImageNode</code>除了展位图像还有 <code>.defaultImage</code>属性。虽然占位符是暂时的，但如果图像节点.URL属性是nil或者URL加载失败，则默认图像将保留。建议使用默认图像</p>

<h2 id="toc_11">Accessibility</h2>

<h2 id="toc_12">UICollectionViewCell的互通性</h2>

<p><code>Texture</code>提供了<code>UICollectionViewCell</code>和<code>ASCellNodes</code>的互通性</p>

<blockquote>
<p>注意</p>

<p>UIKit中的cell即使混杂在<code>ASCollectionNode</code>中，也并不会有类似<code>ASCellNodes</code>的便捷收益(类似，预加载，异步布局，异步绘图等)</p>
</blockquote>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="第三方项目学习_10.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="第三方项目学习_8.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="iOS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9D%97%E7%9F%A5%E8%AF%86.html"><strong>iOS 开发模块知识&nbsp;(188)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%BD%91%E7%BB%9C.html">网络&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91.html">iOS编译&nbsp;(20)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&Block.html">内存管理&Block&nbsp;(18)</a>&nbsp;&nbsp;
	        
	        	<a href="RunTime.html">runtime&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="Concurrent-Programming.html">多线程&nbsp;(19)</a>&nbsp;&nbsp;
	        
	        	<a href="GPU&&%E6%B8%B2%E6%9F%93.html">GPU&&渲染&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0.html">架构学习&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0.html">第三方项目学习&nbsp;(34)</a>&nbsp;&nbsp;
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(10)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%B5%8B%E8%AF%95.html">调试&&测试&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0.html">模块化知识学习&nbsp;(26)</a>&nbsp;&nbsp;
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9.html">知识点&nbsp;(10)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%A1%A5%E5%85%85-1.html">补充&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift.html"><strong>Swift初学笔记&nbsp;(28)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Swift-BaseLearning.html">Swift基础知识&nbsp;(28)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOSDevelop.html"><strong>iOSDevelop&nbsp;(27)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(14)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86.html">iOS开发知识&nbsp;(12)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html"><strong>算法学习&nbsp;(2)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">算法读书笔记&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15698393226216.html">Nodes</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>