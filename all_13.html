
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15350771796806.html">CGColorSpace</a></h1>
			<p class="meta"><time datetime="2018-08-24T10:19:39+08:00" 
			pubdate data-updated="true">08/24/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>表示指定的颜色值</p>

<pre><code class="language-objectivec">CGColorSpaceRef
//一个配置文件，指定如何解释显示的颜色值。
</code></pre>

<h2 id="toc_0">概述</h2>

<p>颜色空间是多维的，每个维度表示特定的颜色分量。例如，RGB颜色空间的颜色有R,G,B三个三个维度.颜色空间的的每个维度强度由浮点值表示，其范围和含义取决于所讨论的颜色空间</p>

<p>我们通过正确指定的颜色空间可以确保图像具有一致的外观</p>

<p><code>Core Graphics</code>支持多种颜色空间：</p>

<ol>
<li>与设备无关的颜色空间: 校准的色彩空间。 确保在不同设备上现实的颜色相同,</li>
<li>与设备相关的颜色空间: 依赖于设备的颜色空间与特定设备的颜色表示系统相关联。</li>
<li>特殊的颜色空间: 使用索引和对应的基色空间 索引颜色空间包含了最多256个颜色表以及每个颜色表的条目都制定基色空间的一种颜色</li>
</ol>

<h3 id="toc_1">创建与设备无关的颜色空间</h3>

<p>为了创建与设备无关的颜色空间，我们需要提供白色参考点，黑色参考点以及特殊设备的gamma值</p>

<ol>
<li><p>创建标准的灰度色彩空间</p>
<p><code>CGColorSpaceCreateCalibratedGray</code></p>
<p>创建与设备无关的灰度颜色空间，表示相对于参考白点的颜色</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateCalibratedGray(const CGFloat *whitePoint, const CGFloat *blackPoint, CGFloat gamma);
whitePoint :   3个数字的数组,制定了在CIE 1931 XYZ-space颜色系统中漫反射白点的3刺激值 (对色彩学不熟悉)<br/>
blackPoint :   3个数字的数组,制定了在CIE 1931 XYZ-space颜色系统中漫反射黑点的3刺激值 <br/>
gamma ： 适合于成像设备的伽马值。<br/>
返回一个新的灰色色彩空间,需要主动调用`CGColorSpaceRelease`来释放
</code></pre></li>
<li><p>创建校准的RGB颜色空间<br/>
<code>CGColorSpaceCreateCalibratedRGB</code></p>
<p>创建与设备无关的RGB颜色空间，表示相对于参考白点的颜色。 此白点基于输出设备可以生成的最白光。 与设备无关的颜色空间中的颜色在不同设备上显示时应该相同，只要设备的功能允许。<br/>
对于需要详细伽玛的色彩空间，例如sRGB或ITU-R BT.709中使用的分段传递函数，可以使用函数<code>CGColorSpaceCreateICCBased</code>，因为它可以准确地表示这些伽玛曲线。</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateCalibratedRGB(const CGFloat *whitePoint, const CGFloat *blackPoint, const CGFloat *gamma, const CGFloat *matrix);
whitePoint：<br/>
blackPoint<br/>
gamma: 一个由3个数字组成的数组，用于指定颜色空间的红色，绿色和蓝色分量的伽玛值。<br/>
matrix： 9个数字的数组，指定相对于最终XYZ表示的颜色空间的伽马修改的RGB值的线性解释。<br/>
返回一个新的RGB色彩空间,需要主动调用`CGColorSpaceRelease`来释放
</code></pre></li>
<li><p>创建根绝ICC颜色配置文件的规范<br/>
<code>CGColorSpaceCreateICCBased</code></p>
<p>根据ICC颜色配置文件创建基于ICC的色彩空间</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateICCBased(size_t nComponents, const CGFloat *range, CGDataProviderRef profile, CGColorSpaceRef alternate);
</code></pre></li>
<li><p>创建根据 CIE L<em>a</em>b标准与人类感知相关颜色</p>
<p><code>CGColorSpaceCreateLab</code><br/>
<code>CIE L * a * b</code>*空间是Munsell颜色表示系统（一种通过色调，值和饱和度或“色度”值指定颜色的系统）的非线性变换，旨在将感知色差与定量距离相匹配 在色彩空间。 L *分量表示亮度值，a *分量表示从绿色到红色的值，b *分量表示从蓝色到黄色的值。 这大致对应于人脑被认为解码颜色的方式。 与设备无关的颜色空间中的颜色在不同设备上显示时应该相同，只要设备的功能允许。</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateLab(const CGFloat *whitePoint, const CGFloat *blackPoint, const CGFloat *range);
whitePoint:<br/>
blackPoint:<br/>
range:一个由4个数字组成的数组，用于指定颜色空间的a *和b *组件的有效值范围。 a *组件表示从绿色到红色的值，b *组件表示从蓝色到黄色的值。
</code></pre></li>
</ol>

<h2 id="toc_2">创建通用或者与设备相关的颜色空间</h2>

<p>当在不同的输出设备上显示时，设备颜色空间中的颜色经常显得不同。 因此，在保持颜色很重要时，不建议使用设备颜色空间</p>

<ol>
<li><p>CMYK颜色空间</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateDeviceCMYK(void);
使用完后需要主动调用CGColorSpaceRelease进行释放
</code></pre></li>
<li><p>灰度颜色空间</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateDeviceGray(void);
</code></pre></li>
<li><p>RGB颜色空间</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void);
</code></pre></li>
<li><p>特定平台的颜色空间</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateWithPlatformColorSpace(const void *ref);
platformColorSpace：指向特定于平台的颜色空间的通用指针。 在macOS中，传递CMProfileRef-a ColorSync配置文件。 Quartz仅在函数调用期间使用此指针（和基础信息）
</code></pre></li>
</ol>

<h2 id="toc_3">创建特殊颜色空间</h2>

<ol>
<li><p>创建索引颜色空间，由颜色查找表指定的颜色组成。</p>
<p>索引颜色空间包含最多255个条目的颜色表，以及颜色表条目映射到的基色空间。 颜色表中的每个条目都指定基色空间中的一种颜色。 索引颜色空间中的值被视为颜色空间的颜色表的索引。 表中的数据采用网格格式。 （例如，对于RGB颜色空间，值为R，G，B，R，G，B等。）</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateIndexed(CGColorSpaceRef baseSpace, size_t lastIndex, const unsigned char *colorTable);
baseSpace:颜色索引表基于的 基色颜色空间<br/>
lastIndex: 索引表的最大下标值 必须&lt;=255<br/>
colorTable: m *（lastIndex + 1）个字节的数组，其中m是基色空间中的颜色分量数。 每个字节是0到255范围内的无符号整数，它被缩放到基色空间中相应颜色分量的范围。
</code></pre></li>
<li><p>创建图案颜色空间</p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreatePattern(CGColorSpaceRef baseSpace);
baseSpace:对于蒙版图案，底层颜色空间指定要通过蒙版绘制的颜色。 对于彩色图案，您应该传递NULL。
</code></pre></li>
<li><p>创建指定类型的Quartz颜色空间</p>
<p>我们可以使用此函数创建通用的颜色空间等,查看<a href="https://developer.apple.com/documentation/coregraphics/cgcolorspace/color_space_names?language=objc">Color Space Name</a></p>
<pre><code class="language-objectivec">CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name);
name：颜色空间名称
</code></pre></li>
</ol>

<h2 id="toc_4">颜色空间的引用和释放</h2>

<pre><code class="language-objectivec">//减少颜色空间的引用计数
void CGColorSpaceRelease(CGColorSpaceRef space);

//增加颜色空间的引用计数
CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space);

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15350068830702.html">CGBlendMode</a></h1>
			<p class="meta"><time datetime="2018-08-23T14:48:03+08:00" 
			pubdate data-updated="true">08/23/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>用于图像的合成操作</p>

<p>不同的混合模式常量表示不同的混合模式,这些混合模式的等式中的符号表示:<br/>
<code>R</code>:表示混合结果 <code>S</code>:是源颜色 包括alpha通道  <code>D</code>:是目标颜色 包括alpha通道 <br/>
<code>Ra</code>,<code>Sa</code>,<code>Da</code>是R,S,D的alpha分量</p>

<p>因此例如: <br/>
<code>kCGBlendModeDestinationIn</code> <code>R = D*Sa</code>  表示 结果=目标颜色和原色的透明度加成</p>

<p>所有枚举:</p>

<pre><code class="language-objectivec">switch (blendMode) {  
        case kCGBlendModeNormal: {  
            strMsg = @&quot;kCGBlendModeNormal: 正常；也是默认的模式。前景图会覆盖背景图&quot;;  
            break;  
        }  
        case kCGBlendModeMultiply: {  
            strMsg = @&quot;kCGBlendModeMultiply: 正片叠底；混合了前景和背景的颜色，最终颜色比原先的都暗&quot;;  
            break;  
        }  
        case kCGBlendModeScreen: {  
            strMsg = @&quot;kCGBlendModeScreen: 滤色；把前景和背景图的颜色先反过来，然后混合&quot;;  
            break;  
        }  
        case kCGBlendModeOverlay: {  
            strMsg = @&quot;kCGBlendModeOverlay: 覆盖；能保留灰度信息，结合kCGBlendModeSaturation能保留透明度信息，在imageWithBlendMode方法中两次执行drawInRect方法实现我们基本需求&quot;;  
            break;  
        }  
        case kCGBlendModeDarken: {  
            strMsg = @&quot;kCGBlendModeDarken: 变暗&quot;;   //将线条色变为黑色，背景色设置为目的色
            break;  
        }  
        case kCGBlendModeLighten: {  
            strMsg = @&quot;kCGBlendModeLighten: 变亮&quot;;  
            break;  
        }  
        case kCGBlendModeColorDodge: {  
            strMsg = @&quot;kCGBlendModeColorDodge: 颜色变淡&quot;;  
            break;  
        }  
        case kCGBlendModeColorBurn: {  
            strMsg = @&quot;kCGBlendModeColorBurn: 颜色加深&quot;;  //线条颜色（原本）加深，背景色设置为目的色
            break;  
        }  
        case kCGBlendModeSoftLight: {  
            strMsg = @&quot;kCGBlendModeSoftLight: 柔光&quot;;  
            break;  
        }  
        case kCGBlendModeHardLight: {  
            strMsg = @&quot;kCGBlendModeHardLight: 强光&quot;;  //全为目的色
            break;  
        }  
        case kCGBlendModeDifference: {  
            strMsg = @&quot;kCGBlendModeDifference: 插值&quot;;  
            break;  
        }  
        case kCGBlendModeExclusion: {  
            strMsg = @&quot;kCGBlendModeExclusion: 排除&quot;;  
            break;  
        }  
        case kCGBlendModeHue: {  
            strMsg = @&quot;kCGBlendModeHue: 色调&quot;;  
            break;  
        }  
        case kCGBlendModeSaturation: {  
            strMsg = @&quot;kCGBlendModeSaturation: 饱和度&quot;;  
            break;  
        }  
        case kCGBlendModeColor: {  
            strMsg = @&quot;kCGBlendModeColor: 颜色&quot;;   //感觉将图片线条色设置为白色，背景色设置为目的色，之后再再图片上加一个有透明度的目的色
            break;  
        }  
        case kCGBlendModeLuminosity: {  
            strMsg = @&quot;kCGBlendModeLuminosity: 亮度&quot;;  
            break;  
        }  
            //Apple额外定义的枚举  
            //R: premultiplied result, 表示混合结果  
            //S: Source, 表示源颜色(Sa对应透明度值: 0.0-1.0)  
            //D: destination colors with alpha, 表示带透明度的目标颜色(Da对应透明度值: 0.0-1.0)  
        case kCGBlendModeClear: {  
            strMsg = @&quot;kCGBlendModeClear: R = 0&quot;; //1.清空（如果图标背景色为白色则为全白） 
            break;  
        }  
        case kCGBlendModeCopy: {  
            strMsg = @&quot;kCGBlendModeCopy: R = S&quot;;  //2全色覆盖整个图片
            break;  
        }  
        case kCGBlendModeSourceIn: {  
            strMsg = @&quot;kCGBlendModeSourceIn: R = S*Da&quot;;  //3.线条变色
            break;  
        }  
        case kCGBlendModeSourceOut: {  
            strMsg = @&quot;kCGBlendModeSourceOut: R = S*(1 - Da)&quot;;  //4.背景变为目的色,线条自动变为白色（比如图标线条原为蓝色，会自动变为白色）
            break;  
        }  
        case kCGBlendModeSourceAtop: {  
            strMsg = @&quot;kCGBlendModeSourceAtop: R = S*Da + D*(1 - Sa)&quot;;   //5.线条变色，目前感觉和SourceIn效果一致
            break;  
        }  
        case kCGBlendModeDestinationOver: {  
            strMsg = @&quot;kCGBlendModeDestinationOver: R = S*(1 - Da) + D&quot;;  //6.背景色变为目的色，线条色不变
            break;  
        }  
        case kCGBlendModeDestinationIn: {  
            strMsg = @&quot;kCGBlendModeDestinationIn: R = D*Sa；能保留透明度信息&quot;;  //7.只看到线条色（本色），无其他颜色
            break;  
        }  
        case kCGBlendModeDestinationOut: {  
            strMsg = @&quot;kCGBlendModeDestinationOut: R = D*(1 - Sa)&quot;;     //8.空白什么都没哟
            break;  
        }  
        case kCGBlendModeDestinationAtop: {  
            strMsg = @&quot;kCGBlendModeDestinationAtop: R = S*(1 - Da) + D*Sa&quot;;  //9.会把整个矩形的背景填充目的色（如图9系列）原色保留
            break;  
        }  
        case kCGBlendModeXOR: {  
            strMsg = @&quot;kCGBlendModeXOR: R = S*(1 - Da) + D*(1 - Sa)&quot;;  //10.线条变白，背景色变为目的色
            break;  
        }  
        case kCGBlendModePlusDarker: {  
            strMsg = @&quot;kCGBlendModePlusDarker: R = MAX(0, (1 - D) + (1 - S))&quot;;  //11.线条变为黑色， 背景色变为目的色
            break;  
        }  
        case kCGBlendModePlusLighter: {  
            strMsg = @&quot;kCGBlendModePlusLighter: R = MIN(1, S + D)（最后一种混合模式）&quot;;  //12.线条变为白色（混合色：如color为红色，就是偏粉色的白，有一定透明度的感觉）
            break;  
        }  
        default: {  
            break;  
        }  

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15332875866545.html">常见内置模块</a></h1>
			<p class="meta"><time datetime="2018-08-03T17:13:06+08:00" 
			pubdate data-updated="true">08/03/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>datetime是Python处理日期和时间的标准库。</p>

<p><code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类</p>

<h2 id="toc_0">datetime</h2>

<pre><code class="language-text">from datetime import datetime 

now=datetime.now() # 获取当前时间
print(now)  # 2018-08-03 15:06:09.944095
print(type(now)) # &lt;class &#39;datetime.datetime&#39;&gt;

date1=datetime(2015, 10, 8, 1, 11)  # 创建指定日期时间
print(date1)  # 2015-10-08 01:11:00

# 在计算机中 时间使用数字(时间戳)表示的

timestamp=date1.timestamp() #将datetime转为时间戳
print(timestamp) # 1444237860.0

date2=datetime.fromtimestamp(timestamp) # 将时间戳转为本地时间
date3=datetime.utcfromtimestamp(timestamp) #将时间转为UTC时间
print(date2)  # 2015-10-08 01:11:00
print(date3) # 2015-10-07 17:11:00

# str转date
date4=datetime.strptime(&quot;2015-6-1 18:19:59&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;) 
print(date4) # 2015-06-01 18:19:59

# date转str
str1=date4.strftime(&quot;%a, %b %d %H:%M&quot;)
print(str1)  # Mon, Jun 01 18:19


# 时间增减
from datetime import datetime, timedelta

now1=datetime.now()
newdate1=now1+timedelta(hours=12)  # 增加12小时的时间
newdate2=now1-timedelta(days=2, minutes=50)
print(newdate1) # 2018-08-04 04:09:26.450345
print(newdate2) # 2018-08-01 16:25:14.299462



# datetime 有一个时区属性tzinfo 但是默认为 None 因此无法区分时间的时区 我们可以给其设置一个时区，帮助区分是哪个时区的时间

from datetime import datetime, timedelta, timezone

tz_utc_8=timezone(timedelta(hours=8))
print(tz_utc_8)  # UTC+08:00

print(now) # 2018-08-03 17:26:29.846861
date_utc_8=now.replace(tzinfo=tz_utc_8)

print(date_utc_8)  # 2018-08-03 17:26:29.846861+08:00

# 获取当前的utc时间 并且加上utc时区信息
utc_dt=datetime.utcnow().replace(tzinfo=timezone.utc)
print(utc_dt) # 2018-08-03 09:30:57.959514+00:00
print(datetime.utcnow()) # 2018-08-03 09:30:57.959525
print(timezone.utc) # UTC

# 将utc时间转为北京时区时间
bj_dt=utc_dt.astimezone(timezone(timedelta(hours=8)))
print(bj_dt) # 2018-08-03 17:39:22.703278+08:00
</code></pre>

<blockquote>
<p><code>datetime</code>有一个时区属性<code>tzinfo</code> 但是默认为 <code>None</code> 因此无法区分时间的时区 我们可以给其设置一个时区，帮助区分是哪个时区的时间</p>

<p>任何带时区新的<code>date</code> 都可以转换时间</p>

<p>要存储<code>datetime</code>，最佳方法是将其转换为<code>timestamp</code>再存储，因为<code>timestamp</code>的值与时区完全无关</p>
</blockquote>

<h2 id="toc_1">collections</h2>

<p>内置的一个集合模块 提供了许多有用的集合类</p>

<h3 id="toc_2">namedtuple</h3>

<p>是一个用来创建自定义的<code>tuple</code>对象，规定了元素个数,可以用属性而不是索引来引用<code>tuple</code>中的元素</p>

<pre><code class="language-python">
from collections import namedtuple
Point=namedtuple(&quot;point&quot;, [&quot;x&quot;, &quot;y&quot;])
p1=Point(2, 3)

print(&quot;坐标为 %s %s&quot; % (p1.x, p1.y)) # 坐标为 2 3

isinstance(p1, Point) #True
</code></pre>

<h3 id="toc_3">deque</h3>

<p>为了弥补<code>list</code>线性存储插入和删除元素慢,<code>deque</code>是双向列表，适合于队列和栈，除了实现了list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，可以方便的向头部添加或删除数据</p>

<pre><code class="language-python">from collections import deque
q1=deque([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])
q1.append(&quot;x&quot;)
q1.appendleft(&quot;y&quot;)
print(q1)  # deque([&#39;y&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;x&#39;])
</code></pre>

<h3 id="toc_4">defaultdict</h3>

<p>当<code>dict</code>中引用的key不存在时,返回默认值<br/>
<strong>默认值</strong>是调用函数返回的，而函数在创建defaultdict对象时传入。</p>

<pre><code class="language-python">from collections import defaultdict
dd1=defaultdict(lambda:&quot;defaultValue&quot;)
dd1[&quot;key1&quot;]=&quot;abc&quot;
print(dd1[&quot;key1&quot;]) # abc
print(dd1[&quot;key2&quot;]) # defaultValue
</code></pre>

<h3 id="toc_5">OrderedDict</h3>

<p><code>dict</code>是无序的 如果要保持<code>key</code>顺序 可以使用<code>OrderedDict</code>,<code>OrderedDict</code>会按照插入的顺序排除</p>

<h3 id="toc_6">Counter</h3>

<p>简单的计数器，也是<code>dict</code>的一个子类</p>

<pre><code class="language-python">from collections import Counter
c1=OrderedDict()
for char in &quot;programming&quot;:
    c1[char]=c1[char]+1
print(c1)
# Counter({&#39;r&#39;: 2, &#39;g&#39;: 2, &#39;m&#39;: 2, &#39;p&#39;: 1, &#39;o&#39;: 1, &#39;a&#39;: 1, &#39;i&#39;: 1, &#39;n&#39;: 1})
</code></pre>

<h2 id="toc_7">base64</h2>

<p><code>base64</code>将3字节的数据编码为4字节,长度增加了33%,如果不足的话会用<code>0x00</code>在末尾补全，然后在末尾加同样数量的<code>=</code>标识，这样解码的时候会自动去掉</p>

<p><code>Python</code>内置的有<code>base64</code>编码方法<br/>
由于标准的base64编码后可能出现字符+和/ 不能在url中作为参数，因此可以受用<code>url safe</code>的base64，将+和/换位-和_</p>

<pre><code class="language-python">import base64
b64encodestr1=base64.b64encode(b&quot;binary\x00string&quot;)
print(b64encodestr1) # b&#39;YmluYXJ5AHN0cmluZw==&#39;
b64decodestr2=base64.b64decode(b64encodestr1)
print(b64decodestr2) # b&#39;binary\x00string&#39;

#urlsafe_b64encode
base64encodestr2=base64.b64encode(b&quot;i\xb7\x1d\xfb\xef\xff&quot;)
print(base64encodestr2) # b&#39;abcd++//&#39;
base64urlsafeencode=base64.urlsafe_b64encode(b&quot;i\xb7\x1d\xfb\xef\xff&quot;)
print(base64urlsafeencode) # b&#39;abcd--__&#39;
</code></pre>

<h2 id="toc_8">struct</h2>

<p>python内置了<code>struct</code>模块来解决<code>bytes</code>和其它二进制数据类型的转换</p>

<pre><code class="language-python">import struct
struct1=struct.pack(&quot;&gt;I&quot;, 10240099)
print(struct1) # b&#39;\x00\x9c@c&#39;

struct2=struct.unpack(&quot;&gt;IH&quot;, b&quot;\xf0\xf0\xf0\xf0\x80\x80&quot;)
print(struct2) # (4042322160, 32896)
</code></pre>

<p>参数中<code>&gt;</code>表示网络序的大端， I：4字节无符号整数  H：2字节无符号整数</p>

<h2 id="toc_9">hashlib</h2>

<p>python提供摘要算法,包括MD5 SHA1等</p>

<p>MD5摘要</p>

<pre><code class="language-python">import hashlib
#md5()可以不加参数 然后update()内容 如果内容过多也可以多次 update
md5=hashlib.md5(&quot;到付奥佛八奥保护管安排表佛八&quot;.encode(&quot;utf-8&quot;))
md5.update(&quot;dddd&quot;.encode(&quot;utf-8&quot;))
print(md5.hexdigest()) # a459918710ca186970b2ed69cedee466
</code></pre>

<p>SHA1摘要</p>

<pre><code class="language-python">import hashlib

sha1 = hashlib.sha1()
sha1.update(&#39;how to use sha1 in &#39;.encode(&#39;utf-8&#39;))
sha1.update(&#39;python hashlib?&#39;.encode(&#39;utf-8&#39;))
print(sha1.hexdigest())
</code></pre>

<h2 id="toc_10">hmac</h2>

<p>只是简单的摘要哈希的话，有被黑客破译的风险,这时候我们经常需要做加盐处理</p>

<pre><code class="language-python">import hmac
message=b&quot;Hello, world&quot;
key=b&quot;secert&quot;
h=hmac.new(key, message, digestmod=&quot;MD5&quot;)
print(h.hexdigest())  # 4f05d03996e3c5c96ccde51100246253
</code></pre>

<h2 id="toc_11">itertools</h2>

<p><code>itertools</code>提供了有用于操作迭代对象的函数</p>

<pre><code class="language-python">import itertools
# 创建几个 无限重复序列


natuals=itertools.count(1) # 1 2 3 4 ....
cs=itertools.cycle(&quot;ABc&quot;) # A B C A B C ...
ns=itertools.repeat(&quot;A&quot;) # A A A A A A ...
# 可以加第二个参数 指定重复次数
ns=itertools.repeat(&quot;A&quot;, 3) # A A A

</code></pre>

<h3 id="toc_12">takewhile()</h3>

<p>对于itertools无限序列,通常用<code>takewhile()</code>截取有用序列</p>

<pre><code class="language-python">natuals1=itertools.count(1)
result1=itertools.takewhile(lambda x : x&lt;4, natuals1)
print(list(result1)) # [1, 2, 3]
</code></pre>

<h3 id="toc_13">chain()</h3>

<p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器</p>

<pre><code class="language-python">for c in itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;):
     print(c)
# 迭代效果：&#39;A&#39; &#39;B&#39; &#39;C&#39; &#39;X&#39; &#39;Y&#39; &#39;Z&#39;
</code></pre>

<h3 id="toc_14">groupby()</h3>

<p>groupby()把迭代器中相邻的重复元素挑出来放在一起：</p>

<pre><code class="language-python">for key, group in itertools.groupby(&#39;AAABBBCCAAA&#39;):
     print(key, list(group))

A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;]
C [&#39;C&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;]

# 挑选规则实际上是通过函数完成的
for key, group in itertools.groupby(&#39;AaaBBbcCAAa&#39;, lambda c: c.upper()):
     print(key, list(group))

A [&#39;A&#39;, &#39;a&#39;, &#39;a&#39;]
B [&#39;B&#39;, &#39;B&#39;, &#39;b&#39;]
C [&#39;c&#39;, &#39;C&#39;]
A [&#39;A&#39;, &#39;A&#39;, &#39;a&#39;]
</code></pre>

<h2 id="toc_15">contextlib</h2>

<p>对于读写文件我们已经使用过<code>with()</code>语句 其实只要实现了上下文管理都可以使用with语句</p>

<h2 id="toc_16">urllib</h2>

<p><code>urllib</code>内建模块提供了操作url功能</p>

<h3 id="toc_17">get</h3>

<h3 id="toc_18">POST</h3>

<h2 id="toc_19">XML</h2>

<p>操作XML通常有两种方法:DOM和SAX<br/><br/>
DOM会把整个XML读入内存，可以解析遍历树的任何节点，缺点是占用内存大，解析慢<br/>
SAX是流模式，边读边解析,占用内存小，解析快，缺点是需要自己处理事件<br/>
通常选择SAX 因为DOM太耗内存</p>

<pre><code class="language-python">from xml.parsers.expat import ParserCreate

class DefaultSaxHandler(object):
    def start_element(self, name, attrs):
        print(&#39;sax:start_element: %s, attrs: %s&#39; % (name, str(attrs)))

    def end_element(self, name):
        print(&#39;sax:end_element: %s&#39; % name)

    def char_data(self, text):
        print(&#39;sax:char_data: %s&#39; % text)

xml = r&#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&#39;&#39;&#39;

handler = DefaultSaxHandler()
parser = ParserCreate()
parser.StartElementHandler = handler.start_element
parser.EndElementHandler = handler.end_element
parser.CharacterDataHandler = handler.char_data
parser.Parse(xml)
</code></pre>

<blockquote>
<p>需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。</p>

<p>因为XML解析太复杂 建议你改用JSON</p>
</blockquote>

<h2 id="toc_20">HTMLParser</h2>

<p>当需要解析HTML内容时，因为HTML的语法没有XML那么严格,所以不能用标准的<code>DOM</code>或<code>SAX</code>解析，python提供了<code>HTMLParser</code>来解析HTML</p>

<pre><code class="language-python">from html.parser import HTMLParser
from html.entities import name2codepoint

class MyHTMLParser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        print(&#39;&lt;%s&gt;&#39; % tag)

    def handle_endtag(self, tag):
        print(&#39;&lt;/%s&gt;&#39; % tag)

    def handle_startendtag(self, tag, attrs):
        print(&#39;&lt;%s/&gt;&#39; % tag)

    def handle_data(self, data):
        print(data)

    def handle_comment(self, data):
        print(&#39;&lt;!--&#39;, data, &#39;--&gt;&#39;)

    def handle_entityref(self, name):
        print(&#39;&amp;%s;&#39; % name)

    def handle_charref(self, name):
        print(&#39;&amp;#%s;&#39; % name)

parser = MyHTMLParser()
parser.feed(&#39;&#39;&#39;&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;!-- test html parser --&gt;
    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;&#39;&#39;&#39;)
</code></pre>

<blockquote>
<p><code>feed()</code>方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p>

<p>特殊字符有两种，一种是英文表示的<code>&amp;nbsp</code>;，一种是数字表示的<code>&amp;#1234</code>;，这两种字符都可以通过Parser解析出来。</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15331955872244.html">常用第三方模块</a></h1>
			<p class="meta"><time datetime="2018-08-02T15:39:47+08:00" 
			pubdate data-updated="true">08/02/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Pillow</h2>

<pre><code class="language-python">from PIL import Image, ImageFilter

image1=Image.open(&quot;/Users/fish/Desktop/pyTestImage.jpg&quot;)
print(image1)
print(image1.size)
print(&quot;图像尺寸为宽%s 高%s&quot; % image1.size)
(w, h)=image1.size
image1.thumbnail((w//2, h//2))
print(&quot;调整后的图片大小%s %s&quot; % image1.size)
image1.save(&quot;/Users/fish/Desktop/thumbnail.jpg&quot;, &quot;jpeg&quot;)


image2=Image.open(&quot;/Users/fish/Desktop/pyTestImage.jpg&quot;)
image2=image2.filter(ImageFilter.BLUR)
image2.save(&quot;/Users/fish/Desktop/blur.jpg&quot;, &quot;jpeg&quot;)


from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random

#获取随机字母
def randomChar():
    return chr(random.randint(65,90))  #获取随机整数

#随机颜色
def randomColor1():
    return (random.randint(64,255), random.randint(64,255), random.randint(64,255))

def randomColor2():
    return (random.randint(32,127), random.randint(32,127), random.randint(32,127))

width=60*4
height=60
image=Image.new(&quot;RGB&quot;, (width, height), (255, 255, 255))
#创建font对象
font=ImageFont.truetype(&#39;Arial.ttf&#39;, 36,  layout_engine=&quot;LAYOUT_RAQM&quot;)
#创建Draw对象
draw=ImageDraw.Draw(image)
#填充每个像素
for x in range(width):
    for y in range(height):
        draw.point((x,y), fill=randomColor1())
#输出文字

for t in range(4):
    draw.text((60*t+10, 10), randomChar(), font=font, fill=randomColor2())

image.save(&quot;/Users/fish/Desktop/randomChar.jpg&quot;, &quot;jpeg&quot;)
</code></pre>

<h2 id="toc_1">requests</h2>

<pre><code class="language-python">import requests
r1=requests.get(&quot;http://www.uidt.net/&quot;)
r1.encoding = &#39;utf-8&#39; 
print(r1.status_code)
print(r1.encoding)
print(r1.headers)
# 获取网页内容
with open(&quot;./douban.html&quot;, &quot;w&quot;) as f1:
    f1.write(r1.text)


r2 = requests.get(&#39;https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json&#39;)
# 获取请求的相应内容
print(r2.json())

</code></pre>

<h2 id="toc_2">chardet</h2>

<p>用来检测编码 </p>

<pre><code class="language-python">import chardet
# 当获得bytes时 可以推测其所用的编码

data = &#39;离离原上草，一岁一枯荣&#39;.encode(&#39;gbk&#39;)
result=chardet.detect(data)
print(result)
# {&#39;encoding&#39;: &#39;GB2312&#39;, &#39;confidence&#39;: 0.7407407407407407, &#39;language&#39;: &#39;Chinese&#39;}

</code></pre>

<h2 id="toc_3">psutil</h2>

<p>这个模块可以跨平台使用<br/>
获取当前系统的CPU信息，内存信息、磁盘信息、网络信息、进程信息</p>

<pre><code class="language-text">#!/usr/bin/env python3

import psutil
print(psutil.cpu_count())  #CPU逻辑数量

print(psutil.cpu_count(logical=False))  #CPU物理核心数量

print(psutil.cpu_times())  #cpu的用户/系统/空闲时间
# scputimes(user=7590.65, nice=0.0, system=5399.27, idle=265297.75)

# 内存信息

vm=psutil.virtual_memory() #获取物理内存
print(vm)
# svmem(total=17179869184, available=2889986048, percent=83.2, used=12674203648, free=1946497024, active=8977154048, inactive=943489024, wired=2753560576)

swapm=psutil.swap_memory() # 交换内存
print(swapm)
# sswap(total=1073741824, used=176685056, free=897056768, percent=16.5, sin=10144088064, sout=4096)


# 磁盘信息

disk_part=psutil.disk_partitions() # 磁盘分区信息
print(disk_part)
# [sdiskpart(device=&#39;/dev/disk1s1&#39;, mountpoint=&#39;/&#39;, fstype=&#39;apfs&#39;, opts=&#39;rw,local,rootfs,dovolfs,journaled,multilabel&#39;), sdiskpart(device=&#39;/dev/disk1s4&#39;, mountpoint=&#39;/private/var/vm&#39;, fstype=&#39;apfs&#39;, opts=&#39;rw,noexec,local,dovolfs,dontbrowse,journaled,multilabel,noatime&#39;)]

# &quot;/&quot;代表磁盘
disk_usage=psutil.disk_usage(&quot;/&quot;) # 磁盘使用情况 
print(disk_usage)
# sdiskusage(total=499963170816, used=175103643648, free=322010931200, percent=35.2)

disk_io=psutil.disk_io_counters() # 磁盘IO
print(disk_io)
# sdiskio(read_count=569221, write_count=820812, read_bytes=17523716096, write_bytes=19005095936, read_time=262887, write_time=473538)


net_io=psutil.net_io_counters() # 获取网络读写字节／包的个数
print(net_io)
# snetio(bytes_sent=111684608, bytes_recv=2494911488, packets_sent=1122158, packets_recv=1953957, errin=0, errout=0, dropin=0, dropout=0)
 
net_address=psutil.net_if_addrs() # 获取网络接口信息
print(net_address)

net_status=psutil.net_if_stats() # 获取网络接口状态
print(&quot;所有网络接口状态:&quot;)
print(net_status)


# net_connectinfo=psutil.net_connections() # 需要root权限 sudo执行python
# print(&quot;当前网络连接信息:&quot;)
# print(net_connectinfo)


all_pid=psutil.pids() #获取所有进程id
print(all_pid)

process=psutil.Process(11377) # 获取id对应进程
print(process.name()) # 获取对应进程名字 
# Python

print(process.exe()) #进程exe路径
# /usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/Resources/Python.app/Contents/MacOS/Python

print(process.cwd()) #进程工作目录

print(process.cmdline()) # 进程启动的命令行

print(process.ppid()) # 父进程的pid

print(process.parent()) # 父进程

print(process.children()) # 子进程列表

print(process.status()) # 进程状态

print(process.username()) # 进程用户名

print(process.create_time()) # 进程创建时间

print(process.terminal()) # 进程终端

print(process.cpu_times()) # 进程使用的cpu时间

print(process.memory_info()) # 进程使用内存

print(process.open_files()) # 进程打开的文件

print(process.connections()) # 进程相关网络连接

print(process.num_threads()) # 进程的线程数量

# print(process.threads()) # 所有线程

print(process.environ()) # 进程环境变量

print(process.terminate()) # 结束进程

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15331933928026.html">正则表达式</a></h1>
			<p class="meta"><time datetime="2018-08-02T15:03:12+08:00" 
			pubdate data-updated="true">08/02/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">re模块</h2>

<h3 id="toc_1">匹配</h3>

<p><code>Python</code>中提供了<code>re</code>模块，包含了所有正则表达式的功能</p>

<blockquote>
<p>由于python字符串和正则表达式都使用<code>\</code>作为转义符，为了避免麻烦,我们推荐用<code>r</code>前缀来写<code>python</code>字符串就不用考虑转义问题</p>
</blockquote>

<pre><code class="language-python">
import re
result1=re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;)
# 匹配成功返回 Match对象 否则返回None
print(result1) # &lt;_sre.SRE_Match object; span=(0, 9), match=&#39;010-12345&#39;&gt;

result2=re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;0qq10-12345&#39;)
print(result2) #None
if result2:
    print(&quot;匹配成功&quot;)
else: 
    print(&quot;匹配失败&quot;)
</code></pre>

<h3 id="toc_2">切分字符串</h3>

<pre><code class="language-python"># 用任意多个空格切分字符串
re.split(r&#39;\s+&#39;, &#39;a b   c&#39;) # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

# 用空格或者空格加逗号分隔字符串
re.split(r&#39;[\s\,]+&#39;, &#39;a,b, c  d&#39;) # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre>

<h3 id="toc_3">分组</h3>

<p>正则表达式的分组功能，其表达式中的<code>()</code>就是要提取的分组</p>

<pre><code class="language-python">m = re.match(r&#39;^(\d{3})-(\d{3,8})$&#39;, &#39;010-12345&#39;)

m.group(0) #&#39;010-12345&#39;
 m.group(1) # &#39;010&#39;
 m.group(2) # &#39;12345&#39;
</code></pre>

<p><code>group(0)</code>永远是原始字符串</p>

<h3 id="toc_4">贪婪匹配</h3>

<p>正则表达式默认是贪婪匹配,匹配尽可能多的字符创</p>

<pre><code class="language-python">re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups()
# (&#39;102300&#39;, &#39;&#39;)
# 因为\d+ 贪婪匹配导致0*匹配到空字符串

re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups() # (&#39;1023&#39;, &#39;00&#39;)
# 添加了？让\d+处于非贪婪匹配

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15331071952550.html">进程&&线程</a></h1>
			<p class="meta"><time datetime="2018-08-01T15:06:35+08:00" 
			pubdate data-updated="true">08/01/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-python">print(&#39;Process (%s) start...&#39; % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    #子进程
    print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))
else:
    print(&#39;I (%s) just created a child process (%s).&#39; % (os.getpid(), pid))
    
# Process (28301) start...
# I (28301) just created a child process (28302).
# I am child process (28302) and my parent is 28301.
</code></pre>

<h2 id="toc_0">multiprocessing（多进程）</h2>

<p>因为在windows是没有<code>fork</code>调用的，所以为了跨平台支持,可以使用<code>multiprocessing</code>跨平台的多进程模块<br/>
<code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象</p>

<pre><code class="language-python">
from multiprocessing import Process
import os

def run_proc(name):
    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))

print(&quot;parent process %s&quot; % os.getpid())
p=Process(target=run_proc, args=(&quot;test&quot;,)) #创建子进程
print(&quot;child process will start&quot;)  
p.start()# 启动子进程
p.join() # 等待子进程结束后继续运行
print(&quot;child process end&quot;)

# parent process 28492
# child process will start
# Run child process test (28493)...
# child process end

</code></pre>

<blockquote>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
</blockquote>

<h3 id="toc_1">Pool（进程池）</h3>

<pre><code class="language-python">from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))

if __name__==&#39;__main__&#39;:
    print(&#39;Parent process %s.&#39; % os.getpid())
    p = Pool(4) #设置同事可以执行4个进程
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print(&#39;Waiting for all subprocesses done...&#39;)
    p.close() # 调用close()之后就不能继续添加新的Process了
    p.join()  # 对Pool对象调用join()会等待所有子进程执行完毕，在
    print(&#39;All subprocesses done.&#39;)
</code></pre>

<h3 id="toc_2">subprocess 子进程</h3>

<p><code>subprocess</code>模块 允许我们创建子进程,连接其输入、输出、错误通道</p>

<pre><code class="language-python">import subprocess

print(&#39;$ nslookup www.python.org&#39;)
r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])
# 相当于在命令行执行  nslookup www.python.org
print(&#39;Exit code:&#39;, r)


# 子进程还需要输入，则可以通过communicate()方法输入：
import subprocess

print(&#39;$ nslookup&#39;)
p = subprocess.Popen([&#39;nslookup&#39;], stdin=·, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)
print(output.decode(&#39;utf-8&#39;))
print(&#39;Exit code:&#39;, p.returncode)

</code></pre>

<h3 id="toc_3">进程间通信</h3>

<p>进程间通信，可以通过<code>mutiprocessing</code>提供的<code>Queue</code>和<code>pipes</code>等方式交换数据</p>

<pre><code class="language-python"># 一个queue 可以往里 读写数据 实现数据交换共享

from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)
        print(&#39;Get %s from queue.&#39; % value)

if __name__==&#39;__main__&#39;:
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
</code></pre>

<blockquote>
<p>父进程所有Python对象都必须通过pickle序列化再传到子进程去</p>
</blockquote>

<h2 id="toc_4">多线程</h2>

<p>我们通常使用<code>threading</code>模块操作线程</p>

<p>启动线程: 就是将要执行的任务任务函数传入创建<code>Thread</code>实例，然后<code>start()</code>开始执行</p>

<pre><code class="language-python">import time, threading

# 新线程执行的代码:
def loop():
    print(&#39;thread %s is running...&#39; % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))
        time.sleep(1)
    print(&#39;thread %s ended.&#39; % threading.current_thread().name)

print(&#39;thread %s is running...&#39; % threading.current_thread().name)
#
t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)
t.start()
t.join()
print(&#39;thread %s ended.&#39; % threading.current_thread().name)
</code></pre>

<blockquote>
<p><code>Python</code>的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>
</blockquote>

<h3 id="toc_5">Lock</h3>

<p>避免多线程对数据读写的冲突，需要lock</p>

<pre><code class="language-python">balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire() #当有多个线程执行时，只有一个县城能成功获取锁
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
</code></pre>

<h3 id="toc_6">多核问题</h3>

<p>Python由于历史遗留问题,同一进程的不同线程其实只能用到一个cpu核,即使启动了多个线程</p>

<blockquote>
<p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>

<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
</blockquote>

<h2 id="toc_7">ThreadLocal</h2>

<p>多线程中，为不同线程绑定不同数据时,可以使用<code>ThreadLocal</code></p>

<pre><code class="language-python">import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target= process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre>

<p>每个线程可以读写<code>ThreadLocal</code>对象的属性,但是互不影响，只操作自己线程对应值，互不干扰，也不用管理锁的问题</p>

<blockquote>
<p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p>
</blockquote>

<h3 id="toc_8">分布式进程</h3>

<p>在<code>Thread</code>和<code>Process</code>中应该优先选择<code>Process</code>，因为其更稳定，而且可以分布到多台机器上，而<code>Thread</code>只能分不到同一台机器的多个CPU上</p>

<p>在<code>mutiprocessing</code>的子模块<code>manager</code>支持把多进程分布到多台机器</p>

<p>一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15329386758024.html">IO编程</a></h1>
			<p class="meta"><time datetime="2018-07-30T16:17:55+08:00" 
			pubdate data-updated="true">07/30/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code class="language-python">f = open(&#39;/Users/fish/Desktop/readme.txt&#39;, &#39;r&#39;)
content=f.read() 
print(content)
f.close()
</code></pre>

<p>文件使用完必须关闭，文件对象会占用系统资源，操作系统同时能打开文件数量也是有限的<br/>
为了保证每次不论是否文件读碟出现<code>IOError</code>出错 都能正确关闭文件，通常这么写:</p>

<pre><code class="language-python">try:
    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)
    print(f.read())
finally:
    if f:
        f.close()

# 使用 python的with语句来自动帮我们调用close()方法
#与try...finall..效果相同代码更简洁

with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre>

<p><code>read()</code>方法会一次性读取全部内容,如果文件过大会挑战内存<br/>
<code>read(size)</code>每次最多读取size字节的内容<br/>
<code>readline()</code>每次读取一行内容<br/>
<code>readlines()</code>一次性读取所有行,返回一个<code>list</code></p>

<blockquote>
<p>类似文件这种 open()函数返回可以read()的对象，均称为 file-like Object，除此之外还有内存的字节流、网络流、自定义流</p>
</blockquote>

<h3 id="toc_0">二进制文件</h3>

<p>默认读取的为UTF-8编码的文本文件,如果为二进制文件,需要用<code>rb</code>模式打开</p>

<pre><code class="language-python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)
&gt;&gt;&gt; f.read()
# b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节
</code></pre>

<h3 id="toc_1">其它编码格式</h3>

<p>对于非<code>UTF-8</code>编码的文本文件,需要<code>open()</code>函数需要传入<code>encoding</code>参数</p>

<pre><code class="language-python">f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)
</code></pre>

<p>当编码不规范，文本中夹杂着非法编码字符时，会发生转码错误(<code>UnicodeDecodeError</code>)，此时可以通过加入参数<code>errors</code>来指定处理方式，常用的为直接忽略</p>

<pre><code class="language-python">f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)
</code></pre>

<h3 id="toc_2">写文件</h3>

<p>写文件也是调用<code>open()</code>函数 只是传入的标识符为<code>w</code>或者<code>wb</code>表示写文本文件或写二进制文件</p>

<pre><code class="language-python">f3 = open(&#39;/Users/fish/Desktop/readme.txt&#39;, &#39;wb&#39;)
f3.write(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
f3.close()
</code></pre>

<blockquote>
<p>与读文件相同要记得调用<code>close()</code>方法,否则可能有部分未写入</p>
</blockquote>

<p>与读文件相同,可以通过<code>with</code>语句 确保自动调用close()方法</p>

<pre><code class="language-python">with open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) as f:
    f.write(&#39;Hello, world!&#39;)
</code></pre>

<blockquote>
<p>通过<code>encoding</code>参数将字符转为指定编码<br/>
<code>w</code>默认为覆盖模式 <code>a</code>是append模式</p>
</blockquote>

<h2 id="toc_3">StringIO 和 BytesIO</h2>

<p>内存中进行读写</p>

<pre><code class="language-python">from io import StringIO

f4=StringIO(&quot;初始\n 字符串&quot;)
f4.write(&quot;hello,&quot;)
f4.write(&quot; &quot;)
f4.write(&quot;world!&quot;)

print(f4.getvalue())  # getvalue()方法用于获得写入后的内容
#hello, world!

from io import BytesIO
f5=BytesIO()
f5.write(&quot;中文&quot;.encode(&quot;utf-8&quot;))
print(f5.getvalue())
# b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
</code></pre>

<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：<br/>
和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>

<pre><code class="language-python">from io import StringIO
f = StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)
while True:
     s = f.readline()
     if s == &#39;&#39;:
         break
     print(s.strip())

# Hello!
# Hi!
# Goodbye!

from io import BytesIO
f = BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
f.read()
# b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;

</code></pre>

<h2 id="toc_4">操作文件和目录</h2>

<p>操作文件和目录<br/>
通过<code>os</code>模块提供的功能</p>

<pre><code class="language-python">import os
os.name # posix 操作系统类型(posix表示是Linux、Unix、Mac OS，nt表示是Windows)

os.uname() #查看详细的系统信息
#posix.uname_result(sysname=&#39;Darwin&#39;, nodename=&#39;fishdeMacBook-Pro.local&#39;, release=&#39;17.5.0&#39;, version=&#39;Darwin Kernel Version 17.5.0: Fri Apr 13 19:32:32 PDT 2018; root:xnu-4570.51.2~1/RELEASE_X86_64&#39;, machine=&#39;x86_64&#39;)
</code></pre>

<h3 id="toc_5">环境变量</h3>

<pre><code class="language-python">os.environ #操作系统定义的全部环境变量
os.environ.get(&quot;PATH&quot;) # 获取某个环境变量值
os.environ.get(&#39;x&#39;, &#39;default&#39;) # 
</code></pre>

<h3 id="toc_6">操作文件和目录</h3>

<p>操作文件和目录的函数 在<code>os</code>和<code>os.path</code>中</p>

<pre><code class="language-python">import os

currentPath=os.path.abspath(&quot;.&quot;)  # .表示当前路径
print(currentPath) # /Users/fish/Desktop/LYY/Python

joinDir=os.path.join(&quot;/Users/fish/Desktop&quot;, &quot;testDir&quot;) #在目录下新建目录 获取新目录路径
print(joinDir) # /Users/fish/Desktop/testDir

splitDir=os.path.split(&quot;/Users/fish/Desktop/testDir&quot;)
print(splitDir) #(&#39;/Users/fish/Desktop&#39;, &#39;testDir&#39;)  获取最后一部分文件或目录
splitext=os.path.splitext(&quot;/Users/fish/Desktop/testDir&quot;) #获取扩展名 如果最后一部分为目录 则为空
print(splitext) # (&#39;/Users/fish/Desktop/testDir/readme&#39;, &#39;.txt&#39;)

os.mkdir(&quot;/Users/fish/Desktop/testDir2&quot;) #新建目录
os.rmdir(&quot;/Users/fish/Desktop/testDir2&quot;) #删除目录

os.path.join(&quot;/Users/fish/Desktop&quot;, &quot;readme.txt&quot;)
os.rename(&#39;/Users/fish/Desktop/readme.txt&#39;, &#39;/Users/fish/Desktop/readme.py&#39;)  # 重命名文件
os.remove(&#39;/Users/fish/Desktop/readme.py&#39;) # 删除文件

dirlist=os.listdir(&quot;.&quot;) #获取当前目录下的所有文件夹列表
os.path.isdir(&quot;.&quot;) # 判断是否为文件夹目录

</code></pre>

<p>当合并路径时,不要直接拼接字符串，通过<code>os.path.join()</code>函数可以正确处理不用操作系统的路径分隔符.<br/>
同理，拆分字符串时通过<code>os.path.split()</code>函数，可以把路径拆分为两部分，后一部分总是最后级别的目录或文件名<br/>
<code>os.path.splitext()</code>可以直接让你得到文件扩展名</p>

<blockquote>
<p>在<code>os</code>模块中并没有复制文件函数,可以再<code>shutil</code>模块中提供了<code>copyfile()</code>函数等使用的文件操作函数</p>
</blockquote>

<h2 id="toc_7">序列化</h2>

<p>Python通过<code>pickle</code>模块实现序列化</p>

<pre><code class="language-python">import pickle
#序列化
dict1=dict(name=&quot;Bob&quot;, age=24, score=88)
data=pickle.dumps(dict1)
print(data) #b&#39;\x80\x03}q\...\x04KXu.&#39;

#直接将序列化的内容写入文件
file1=open(&quot;/Users/fish/Desktop/readme.txt&quot;, &quot;wb&quot;)
pickle.dump(dict1, file1)
file1.close()

#  将文件从磁盘读到内存后使用pickle.loads()方法反序列化出对象， 
#  也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象
file2=open(&quot;/Users/fish/Desktop/readme.txt&quot;, &quot;rb&quot;)
dict2=pickle.load(file2)
file2.close()
print(dict2) #{&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 24, &#39;score&#39;: 88}


</code></pre>

<h3 id="toc_8">JSON</h3>

<p>dict可以转为json序列化</p>

<pre><code class="language-python">import json
print(json.dumps(dict1)) # {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 24, &quot;score&quot;: 88}

file1=open(&quot;/Users/fish/Desktop/readme.txt&quot;, &quot;w&quot;)
json.dump(dict1, file1)
file1.close()  # 文件内容为 {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 24, &quot;score&quot;: 88}
</code></pre>

<p>将class 序列化为 json</p>

<pre><code class="language-python">import json

#序列化  原理是先将class转为dict 然后将dict序列化json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;Bob&#39;, 20, 88)

#专门写一个转换函数 将 class 转为json
def student2dict(std):
    return {
        &#39;name&#39;: std.name,
        &#39;age&#39;: std.age,
        &#39;score&#39;: std.score
    }
# 传入更多参数来 指定序列化规则
print(json.dumps(s, default=student2dict))  #{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}

# 可以这么写 对大多数class都有__dict__属性来存储实例变量(__slots__除外)
print(json.dumps(s, default=lambda obj: obj.__dict__))

# 反序列化  原理为将json反序列化为dict 然后转为 class实例

def dict2student(d):
    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])
json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
print(json.loads(json_str, object_hook=dict2student))

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15325716345284.html">错误、调试、测试</a></h1>
			<p class="meta"><time datetime="2018-07-26T10:20:34+08:00" 
			pubdate data-updated="true">07/26/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">错误处理</h2>

<h3 id="toc_1">try</h3>

<pre><code class="language-python">try:
    print(&quot;try...&quot;)
    result=10/0
    print(&quot;result 10/0=&quot;, result)
except Exception as e:  #捕获所有的异常
    # raise  #raise 语句不带参数 就会把错误原样抛出
    print(&quot;error+&quot;, e)
else:
    print(&quot;no erro&quot;) #没有错误发生时 执行
finally:
    print(&quot;finally...&quot;)

print(&quot;end...&quot;)

# try...
# error+ division by zero
# finally...
# end...

</code></pre>

<p>根据捕捉不用类型的错误</p>

<pre><code class="language-python">try:
    print(&#39;try...&#39;)
    r = 10 / int(&#39;a&#39;)
    print(&#39;result:&#39;, r)
except ValueError as e:   #如果int()函数发生错误
    print(&#39;ValueError:&#39;, e)
except ZeroDivisionError as e:  # 发现除数为0错误
    print(&#39;ZeroDivisionError:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
</code></pre>

<p>Python的错误也是class,所有错误继承自<code>BaseException</code>，所以使用<code>exception</code>时可以捕获所有其子类错误</p>

<blockquote>
<p>捕获错误可以跨越多层调用,</p>

<p>如果错误没有被捕获,就会一级一级往上抛出,最后被Python解释器捕获,打印错误信息并退出程序的执行</p>

<p>发生错误时可以通过分析错误的调用异常栈，定位错误的位置信息</p>
</blockquote>

<h3 id="toc_2">抛出错误</h3>

<p>自定义错误类，抛出错误，尽量使用内置的错误类型,只有在必要时才需要定义自己的错误类型</p>

<h2 id="toc_3">调试</h2>

<h3 id="toc_4">断言</h3>

<p>断言使用<code>assert</code>关键字</p>

<pre><code class="language-python">def my_func_div(s):
    n=int(s)
    assert n!=0, &quot;n is zero&quot;
    return 10/n

my_func_div(&quot;0&quot;)

# AssertionError: n is zero
</code></pre>

<p>断言失败,<code>assert</code>语句会抛出<code>AssertionError</code><br/>
Python解释器可以通过 添加参数<code>- O</code> 参数关闭所有assert 这时<code>assert</code>就可看做pass</p>

<h3 id="toc_5">logging</h3>

<p>logging不会抛出错误，而且可以输出到文件<br/>
logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p>

<pre><code class="language-python">import logging
logging.basicConfig(level=logging.INFO)

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print(10 / n)
</code></pre>

<blockquote>
<p>logging语句允许指定记录信息的级别,共有<code>debug</code> <code>info</code> <code>warning</code> <code>error</code>这几个级别,当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
</blockquote>

<h3 id="toc_6">pdb 单步调试</h3>

<p><code>pdb</code>是python解释器的调试器,可以让程序但不执行，可以随时查看运行的状态</p>

<pre><code class="language-python">s = &#39;0&#39;
n = int(s)
print(10 / n)
</code></pre>

<p><code>python -m pdb xxx.py</code></p>

<p><img src="media/15325716345284/15329379992787.jpg" alt="" style="width:803px;"/><br/>
<img src="media/15325716345284/15329380931674.jpg" alt="" style="width:806px;"/><br/>
输入 <code>l</code>  查看diamante<br/>
<code>n</code> 单步执行代码<br/>
<code>p 变量名</code> 查看变量当前值<br/>
<code>q</code> 结束调试</p>

<h3 id="toc_7">pdb.set_trace() 断点</h3>

<p><code>import pdb</code> 在可能出错的地方放<code>pdb.set_trace()</code>就设置了一个断点,程序会在断点处进入pdb调试环境  可以用<code>c</code>继续执行</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_14.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_12.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B&&Runloop.html"><strong>多线程&&Runloop&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="RunLoop.html">RunLoop&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html">线程安全&&锁&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="KVC&&KVO.html">KVC&&KVO&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&&block.html"><strong>内存管理&&block&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">OC高级编程-内存管理&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="block%E5%AD%A6%E4%B9%A0.html">block学习&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">官方文档-内存管理&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%8B%BE%E9%81%97.html">内存管理-拾遗&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&&%E7%BB%84%E4%BB%B6%E5%8C%96.html"><strong>设计模式&&组件化&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html">设计模式架构谈(摘录)&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html">组件化开发学习&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BC%96%E8%AF%91&&dyld&&Mach-O.html"><strong>编译&&dyld&&Mach-O&nbsp;(19)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html">iOS编译流程&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html">dyld(程序启动)&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html">Mach-O文件了解&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86.html"><strong>模块化知识&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS-CoreAnimation.html">iOS-CoreAnimation&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="CoreGraphic.html">CoreGraphic&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="ARKit.html">ARKit&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"><strong>第三方项目学习和使用&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="AFNetworking.html">AFNetworking&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="AsyncDisplayKit.html">AsyncDisplayKit&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="ReactnativeCocoa.html">ReactnativeCocoa&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="PromiseKit.html">PromiseKit&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96.html"><strong>项目监控和优化&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html">APP体积优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html">启动优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%B0%83%E8%AF%95&&%E6%B5%8B%E8%AF%95.html"><strong>调试&&测试&nbsp;(6)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="LLDB.html">LLDB&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html">自动化测试&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="git.html">git&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>