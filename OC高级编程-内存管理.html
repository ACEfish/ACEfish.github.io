
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  OC高级编程-内存管理 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15665293554942.html">ARC的实现</a></h1>
			<p class="meta"><time datetime="2019-08-23T11:02:35+08:00" 
			pubdate data-updated="true">08/23/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>苹果官方说明中称，ARC是由编译器进行内存管理，但实际上只有编译器是无法完全胜任的，还需要<code>Object-C</code>运行时库的协助</p>

<h3 id="toc_0">__strong修饰符实现</h3>

<p>赋值给<code>__strong</code>修饰符在程序中实际运行</p>

<pre><code class="language-objectivec">{
    id __strong obj = [[NSObject alloc] init]
}
//编译器的模拟代码
id obj =  objc_msgSend(NSObject, @selector(alloc))
objc_msgSend(obj, @selector(init))
objc_release(obj)
</code></pre>

<p>编译器在变量超出作用域时  自动插入了release方法</p>

<p>调用<code>alloc/new/copy/mutableCopy</code>以外开头的方法，</p>

<pre><code class="language-objectivec">+(id) array {
    return [[NSMUtableArray alloc] init]
}

//编译器的模拟代码
+ (id)array {
    id obj = objc_msgSend(NSMutableArray, @selector(alloc))
    objc_msgSend(obj, @selector(init))
    return objc_autoreleaseReturnValue(obj)
}
</code></pre>

<pre><code class="language-objectivec">{
    id __strong obj = [NSMutableArray  array];
}

//编译器的模拟代码
id obj = objc_msgSend(NSMutableArray, @selector(array))
objc_retainAutoreleasedReturnValue(obj)
objc_release(obj)
</code></pre>

<p><code>objc_retainAutoreleasedReturnValue()</code>和<code>objc_autoreleaseReturnValue()</code>是成对存在的，用于最优化程序运行</p>

<p><code>objc_autoreleaseReturnValue</code>与<code>objc_autorelease</code>函数不同，其功能不仅仅是指注册对象到<code>autoreleasepool</code>中，而是会检查使用该函数的方法或函数调用方的执行命令列表，如果调用方在调用了该函数时接着调用了<code>objc_retainAutoreleaseReturnValue()</code>函数，那么就不将函数注册到autoreleasepool中，而是直接传递到方法或函数的调用方。</p>

<p><code>objc_retainAutoreleasedReturnValue</code>函数与<code>objc_retain</code>函数不通过，即使不注册到autoreleasepool中而返回对象也能正确获取函数</p>

<h3 id="toc_1">__weak修饰符</h3>

<pre><code class="language-objectivec">{
    id __weak obj1 = obj;
}

//模拟源代码
id obj1；
objc_initWeak(&amp;obj1, obj)
objc_destroyWeak(&amp;obj1)
</code></pre>

<p>initWeak初始化附有__weak修饰符的变量，其等效于</p>

<pre><code class="language-objectivec">objc_initWeak(&amp;obj1, obj)
//等效于 将__weak修饰符变量初始化为0后，调用storeWeak
obj1 = 0
objc_storeWeak(&amp;obj1, obj)
</code></pre>

<p>objc_destroryWeak 函数 释放该变量 等效于</p>

<pre><code class="language-objectivec">objc_destroyWeak(&amp;obj1)
//等效于 
objc_storeWeak(&amp;obj1, 0)
</code></pre>

<p><code>objc_storeWeak()</code>函数 将第二参数的赋值对象的地址作为键值，将第一参数附有__weak修饰符的变量地址注册到<code>weak</code>表中。如果第二参数为0 则将变量的地址从weak表中删除</p>

<p>weak表与引用计数表相同 作为hash表(散列表)实现。由于一个对象可以同时赋值给多个附有__weak修饰符的变量，因此将废弃地址的键值进行搜索就能高速获取所有对应的__weak修饰变量的地址</p>

<h4 id="toc_2">1. 若附有__weak修饰符的变量所引用的对象被废弃，则将nil赋值给该变量</h4>

<p>当废弃没人持有的对象时，对象通过objc_release函数释放，流程</p>

<ol>
<li>objc_release</li>
<li>引用计数为0所以执行dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating</li>
</ol>

<p>其中<code>objc_clear_deallocating</code>函数的动作如下:</p>

<ol>
<li>从表中获取废弃对象的地址为键值的记录</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址为键值的记录</li>
</ol>

<p>此时，当附有__weak修饰符引用的独享被废弃时，该变量会被自动置空为nil</p>

<blockquote>
<p>注意</p>

<p>由上面步骤可知，当大量使用附有 __weak修饰符的变量时，会消耗相应的cpu资源。因此尽量在只需要避免循环引用时使用 __weak修饰符</p>
</blockquote>

<h4 id="toc_3">2. 使用附有__weak修饰符变量，即是访问注册到autoreleasepool中的对象</h4>

<pre><code class="language-objectivec">{
    id __weak obj1 = obj;
    NSLog(@“%@”， obj1)
}

//模拟代码
id obj1;
objc_initWeak(&amp;obj1, obj)
id tmp = objc_loadWeakRetained(&amp;obj1)
objc_autorelease(tmp)
NSLog(@&quot;%@&quot;, tmp)
objc_destroyWeak(&amp;obj1)
</code></pre>

<p>在使用__weak修饰符的变量时，增加了</p>

<ol>
<li><code>objc_loadWeakRetained</code>函数 取出__weak修饰的变量并且retain</li>
<li><code>objc_autorelease</code>函数将对象注册到autoreleasepool中</li>
</ol>

<p>因此在使用__weak修饰的变量所引用的对象，被注册到autorelasepool中，在@autorelase结束之前都可以放心使用</p>

<blockquote>
<p>注意</p>

<p>当 大量使用 weak修饰修饰的对象时，就会大量注册到autorelasepool中对象，因此在使用__weak修饰符修饰的对象时，尽量先赋值给 __strong修饰符的对象再使用，这样就只注册到autoreleasepool中一次</p>
</blockquote>

<h4 id="toc_4">3. 特殊的不能使用__weak的情况</h4>

<ol>
<li>NSMachPort类不支持__weak修饰符 这些类重写了retain/relesase并且实现独自的引用计数</li>
<li>不支持__weak修饰符的类，其类声明中 附加了<code>__attribute__((objc_arc_weak_reference_unavailabel))</code></li>
<li>类自己实现了 <code>allocsWeakReference</code>方法返回NO  则不能使用__weak修饰符</li>
<li>类自己实现<code>retainWeakReference</code>方法 返回NO 则该变量为nil</li>
</ol>

<h3 id="toc_5">__autoreleasing修饰符</h3>

<p>将对象赋值给附有__autoreleasing修饰符 相当于ARC无效时调用对象的autorelase方法</p>

<pre><code class="language-objectivec">@autoreleasepool{
    id __autorelasing obj = [[NSObject alloc] init]
}

//模拟源代码
id pool = objc_autoreleasePoolPush()
id obj = objc_msgSend(NSObject, @selector(alloc))
objc_msgSend(obj, @selector(init))
objc_autorelase(obj)
objc_autoreleasepoolPop(pool)
</code></pre>

<p>调用<code>alloc/new/copy/mutableCopy</code>之外的方法</p>

<pre><code class="language-objectivec">@autorelasepool{
    id __autoreleasing obj = [NSMutableArray array]
}

//编译器的模拟代码
id pool = objc_autoreleasePoolPush()
id obj = objc_msgSend(NSMutableArray, @selector(array))
objc_retainAutoreleaseReturnValue(obj)
objc_autorelase(objc)
objc_autoreleasepoolPop(pool)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15554809772320.html">ARC中类属性小结</a></h1>
			<p class="meta"><time datetime="2019-04-17T14:02:57+08:00" 
			pubdate data-updated="true">04/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>属性声明和所有权修饰符</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>所有权修饰符</th>
</tr>
</thead>

<tbody>
<tr>
<td>assign</td>
<td><strong>unsafe</strong>unretained修饰符</td>
</tr>
<tr>
<td>copy</td>
<td>__strong修饰符(但赋值的是被复制的对象)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong修饰符</td>
</tr>
<tr>
<td>strong</td>
<td>__strong修饰符</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__ unsafe__unretained修饰符</td>
</tr>
<tr>
<td>weak</td>
<td>__weak修饰符</td>
</tr>
</tbody>
</table>

<blockquote>
<p>注意</p>

<p>copy不只是简单的赋值，赋值的是通过NSCopying协议定义的copyWithZone:方法返复制的对象</p>
</blockquote>

<p>在声明成员变量时必须与属性中的所有权修饰符一致，否则会报编译错误</p>

<pre><code class="language-objectivec">{
    NSString * __weak _strProperty;
}

@property (nonatomic, weak) NSString *strProperty;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15554693626882.html">Foundation、Core Foundation框架对象</a></h1>
			<p class="meta"><time datetime="2019-04-17T10:49:22+08:00" 
			pubdate data-updated="true">04/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>Core Foundation</code>对象主要在用C语言编写的<code>Core Foundation</code>框架中，并使用引用计数对象。Core Foundation框架中的retain/release分别为<code>CFRetain()、CFRelease()</code>(CF对象不属于ARC内存管理)<br/>
CF对象和foundation对象很区别很小，只是生成框架不同，连着可以互相在不同框架中使用。因为两者几乎没有区别可以使用简单的C语言即可互相转换。这种转换不需要额外的CPU资源消耗，因此称之为<strong>免费桥</strong></p>

<blockquote>
<p>Core Foundation变量没有ARC，因此对其操作均为手动引用计数</p>
</blockquote>

<h2 id="toc_0">id和void *的转换</h2>

<p>在ARC无效时，可以简单的进行赋值</p>

<pre><code class="language-objectivec">id obj = [[NSObject alloc] init];
void *obj1 = obj; //简单的赋值 此时obj1不持有该对象
[obj release];
</code></pre>

<p>但是在ARC环境下，需要进行转换</p>

<pre><code class="language-objectivec">id obj = [[NSObject alloc] init];
void *obj1 = (__bridge void *)(obj);
</code></pre>

<p><code>__bridge</code>是最简单的转换 只是单纯的赋值，并不负责内存管理，导致其安全性很低，很容易访问悬空指针，因此不推荐这么使用</p>

<p><strong>除了 <code>__bridge</code>外还有<code>__bridge_retained</code>和<code>__bridge_transfer</code>转换</strong><br/>
<code>__bridge_retained</code>:使要赋值的变量也持有所赋值的变量(对象引用计数+1)</p>

<pre><code class="language-objectivec">//ARC有效时
id obj = [[NSObject alloc] init];
void *p = (__bridge_retained void *)(obj);
//等效于 ARC无效于
id obj = [[NSObject alloc] init];
void *p = obj;
[(id)p retain];
</code></pre>

<p><code>__bridge_transfer</code>: 与其相反，被转换的变量在所持有的对象在该变量被赋值给转换目标后即释放(对象引用计数-1)</p>

<pre><code class="language-objectivec">//ARC有效时
id obj1 = (__bridge_transfer id)(p);
//等效于 ARC无效于
id obj = (id)p;
[obj retain];
[(id)p release];
</code></pre>

<p><code>Core Foundation</code>中提供了<code>Toll-Free-Bridge</code>函数:</p>

<pre><code class="language-objectivec">CFTypeRef _Nullable CFBridgingRetain(id _Nullable X) {
    return (__bridge_retained CFTypeRef)X;
}

 id _Nullable CFBridgingRelease(CFTypeRef CF_CONSUMED _Nullable X) {
    return (__bridge_transfer id)X;
}
</code></pre>

<p>示例：</p>

<pre><code class="language-objectivec">CFMutableArrayRef cfObject = NULL;
{
    id obj = [[NSMutableArray alloc] init];
    cfObject = CFBridgingRetain(obj);
    CFShow(cfObject);
    printf(&quot;retain count %ld\n&quot;, (long)CFGetRetainCount(cfObject)); //2
}
printf(&quot;出了作用域范围引用计数%ld\n&quot;, (long)CFGetRetainCount(cfObject));//1
CFRelease(cfObject);
</code></pre>

<p><code>Foundation</code>框架产生的OC对象也可以作为<code>Core Foundation</code>框架对象使用</p>

<pre><code class="language-objectivec">CFMutableArrayRef cfObject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);
printf(&quot;retain count %ld\n&quot;, (long)CFGetRetainCount(cfObject)); //1
id obj = CFBridgingRelease(cfObject); 
printf(&quot;转换后的retain count %ld\n&quot;, (long)CFGetRetainCount(cfObject)); // 1
NSLog(@&quot;class = %@&quot;, obj);
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15554670188763.html">ARC使用规则</a></h1>
			<p class="meta"><time datetime="2019-04-17T10:10:18+08:00" 
			pubdate data-updated="true">04/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1. ARC有效时 禁止使用retain或者release代码</h2>

<h2 id="toc_1">2. 不能使用NSAllocateObject/NSDeallocObject代码</h2>

<pre><code class="language-text">使用alloc方法会通过`NSAllocateObject`函数生成并持有对象，但是在ARC有效时禁止使用类似函数
</code></pre>

<h2 id="toc_2">3. 要遵守内存管理命名规则</h2>

<ol>
<li>在ARC和非ARC环境下，以<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>开头的方法 应该返回调用者应当持有的对象</li>
<li>在ARC环境下 以<code>init</code>开头的方法必须为构造器方法</li>
</ol>

<h2 id="toc_3">4. 不要显式调用dealloc</h2>

<pre><code class="language-text">在ARC有效时，不需要调用`super dealloc`
</code></pre>

<h2 id="toc_4">5. 用@autoreleasepool 代替 NSAutoreleasePool</h2>

<p>在ARC无效时也推荐使用@autoreleasepool block</p>

<h2 id="toc_5">6. 不能使用NSZone</h2>

<h2 id="toc_6">7. 对象型变量不能作为C语言结构体成员</h2>

<pre><code class="language-text">因为OC变量由编译器负责ARC的生命周期，但是C语言中没有对结构体成员的生存周期。因此，如果要在结构体中使用OC变量，可以将变量显式转换为`void *`类型（见下一条），或者使用`__unsafe__retained`修饰符(使用此修饰符表示其不属于编译器内存管理的对象)
</code></pre>

<h2 id="toc_7">8. 显式转换id和void *</h2>

<p>详情见CoreFoundation和Foundation对象转换</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15553988088853.html">ARC的修饰符</a></h1>
			<p class="meta"><time datetime="2019-04-16T15:13:28+08:00" 
			pubdate data-updated="true">04/16/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在ARC有效的环境下，其内存管理规则和手动计数相同</p>

<ul>
<li>自己生成对象，自己持有</li>
<li>非自己生成对象，自己也能持有</li>
<li>自己持有的对象不再需要时释放</li>
<li>非自己持有的对象无法释放</li>
</ul>

<h2 id="toc_0">所有权修饰符</h2>

<p>OC中的变量类型有对象类型(即指向OC类的指针<code>NSObject *</code>)和<code>id</code>类型(用于隐藏对象类型类名部分，相当于C语言中的void *)</p>

<p>在ARC有效时，id类型和对象类型与C语言的其他类型不同，必须加上所有权修饰符</p>

<ul>
<li>__strong 修饰符</li>
<li>__weak修饰符</li>
<li>__unsafe __unretained修饰符</li>
<li>__autoreleasing修饰符</li>
</ul>

<h2 id="toc_1">__strong修饰符</h2>

<p><code>__strong</code>修饰符是id类型和对象类型的默认修饰符,即</p>

<pre><code class="language-objectivec">id obj = [[NSObject alloc] init];
//等效于
id __strong obj = [[NSObject alloc] init];
//或者
__strong id obj = [[NSObject alloc] init];
</code></pre>

<p>__strong修饰符的内存管理:</p>

<ol>
<li><code>__strong</code>修饰符的变量赋值对象，即可完成对自己生成或非自己生成对象的强引用</li>
<li>当变量超出作用域被废弃、变量所属对象废弃(赋值nil)或者变量赋值即会释放对原有对象的强引用，相当于对对象执行release操作</li>
</ol>

<p>而当对象没有了所有者 就会被销毁</p>

<p>示例如下:</p>

<pre><code class="language-objectivec">//1.
{
    //取得非自己生成并持有的对象
    id __strong obj = [NSMutableArray array];
    //因为obj为强引用 所以自己持有对象
}
//此时变量obj超出作用域被废弃时，强引用失效，所以自动释放自己持有的对象

//2.
{
    //取得自己生成并持有的对象
    id __strong obj = [[NSObject alloc] init];
    //因为obj为强引用 所以自己持有对象
}
/*
* 此时变量obj超出作用域，强引用失效，所以自动释放自己持有的对象
* 对象所有者不存在，因此废弃该对象
*/ 

//3. 

id __strong obj0 = [[NSObject alloc] init];
//obj0强引用对象A
id __strong obj1 = [[NSObject alloc] init];
//obj1强引用对象B
obj0 = 0bj1;
//obj0强引用对象B，此时对对象A强引用失效，对象A没有所有者因此废弃对象A
obj0 = nil;
//因为obj0被赋值nil，因此其对对象B的强引用失效 此时对象B的强引用只剩下obj1
</code></pre>

<p>OC的类成员变量和方法参数上也可以附有__strong修饰符的变量</p>

<pre><code class="language-objectivec">@interface Test: NSObject 
{
    id __strong obj_;
}

- (void)setObject:(id __strong)obj；

@implementation Test
...
@end
</code></pre>

<blockquote>
<p>注意：</p>

<p>__ strong、__weak、__autoreleasing修饰符，会将修饰符修饰的变量自动初始化为nil</p>
</blockquote>

<h2 id="toc_2">__weak修饰符</h2>

<p>主要用来避免使用强引用导致的循环引用</p>

<p>循环引用很容易发生内存泄漏，内存泄漏就是应当废弃的对象在吃啊出其生存周期后继续存在</p>

<p><code>__weak</code>提供弱引用，并不持有对象实例</p>

<p>错误使用:</p>

<pre><code class="language-objectivec">id __weak obj = [[NSObject alloc] init]; //编译器会报警高
//这种情况下 obj并不持有生成的对象，而是持有对象的弱引用，所以对象会立即释放
</code></pre>

<p>正确使用</p>

<pre><code class="language-objectivec">{
    id __strong obj = [[NSObject alloc] init];
    id __weak obj1 = obj;
}
</code></pre>

<p><code>__weak</code>修饰符修饰的变量当持有某个对象的弱引用时，若该对象被废弃(没有了持有者)，则弱引用<strong>自动失效并处于值为nil</strong>状态</p>

<h2 id="toc_3">__ unsafe__unretained修饰符</h2>

<p>是不安全的修饰符。因为<code>__weak</code>只能用在iOS5之上的版本，所以在iOS4就只能使用<code>__unsafe__retained</code>修饰符</p>

<p><code>__unsafe__unretained</code>变量修饰的对象不属于编译器的内存管理对象</p>

<pre><code class="language-objectivec">//__unsafe__retained与__weak类似，并不持有生成对象所以对象会立即释放
id __weak obj = [[NSObject alloc] init]; //编译器会报警高
</code></pre>

<p><strong>unsafe</strong>retained变量修饰的对象当销毁时不会自动置nil，因此有可能访问悬空指针</p>

<p>因此，不要使用这个修饰符</p>

<h2 id="toc_4">__autoreleasing修饰符</h2>

<p>在arc有效的情况下 即将autorelease方法变为``</p>

<pre><code class="language-objectivec">//非ARC环境下
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init]; 
[obj autorelease];
[pool drain];
//ARC环境下
@autoreleasepool {
    id __autoreleasing obj = [[NSObject alloc] init];
}
</code></pre>

<blockquote>
<p>注意</p>

<p>@autoreleasepool {}在非ARC环境下也能使用 推荐@autoreleasepool来表示自动释放池，提高程序的可读性</p>
</blockquote>

<p>就像我们几乎不显式的写<code>__strong</code>修饰符一样 我们也几乎不显式的附加<code>__autoreleasing</code>修饰符。编译器会自动帮我们添加<code>__autoreleasing</code>修饰符，例如以下情况：</p>

<ol>
<li><p>编译器会自动将返回值注册到autorelease pool</p>
<p>编译器会检查方法名，如果使用<code>alloc/new/copy/mutableCopy</code>以外开头的方法，则自动将返回值注册到`autorelease pool中</p>
<pre><code class="language-objectivec">+ (id)array {
return [[NSMutableArray alloc] init]<br/>
}<br/>
//等效于<br/>
+ (id)array {<br/>
id __strong obj = [[NSMutableArray alloc] init];<br/>
return obj;<br/>
}
</code></pre>
<p>obj由于return会使对象变量超出作用域，所以自己持有的强引用被释放，但该函数以对象作为返回值，编译器会自动帮其注册到autorelease pool中</p></li>
<li><p>访问__weak修饰的变量一定要访问注册的到autoreleapool的对象</p>
<p>因为<code>__weak</code>只持有对象弱引用，在访问过程中，对象有可能销毁，而把对象注册到<code>autorelease pool</code>就能保证对象在访问结束前不会被销毁</p>
<pre><code class="language-objectivec">id __weak obj0 = obj1;
NSLog(@&quot;class = %@&quot;, [obj0 class]);<br/>
//等效于<br/>
id __weak obj0 = obj1;<br/>
id __autoreleasing tmp = obj1;<br/>
NSLog(@&quot;class = %@&quot;, [tmp class]);
</code></pre></li>
<li><p>id的指针或者对象指针会默认加上__autoreleasing修饰符<br/>
id的指针<code>id *obj</code>和<code>NSObject **obj</code>在没有显式指定时会被附加上<code>__autoreleasing</code>修饰符</p>
<p>例如:</p>
<pre><code class="language-obj"> - (nullable instancetype)dataWithContentsOfFile:(NSString *)path ... error:(NSError **)errorPtr;
//相当于<br/>
- (nullable instancetype)dataWithContentsOfFile:(NSString *)path... error:(NSError * __autoreleasing *)errorPtr;
</code></pre>
<p>使用__autoreleasing修饰的变量作为对象取得参数就和用非自己生成对象方法取得返回值的对象完全一样，会注册到<code>autorelease pool</code>中</p>
<pre><code class="language-objectivec">//源码应该类似这个样子
- (nullable instancetype)dataWithContentsOfFile:(NSString *)path... error:(NSError * __autoreleasing *)errorPtr {<br/>
    *error = [[NSError alloc] initWithDomain:MyAppDomin code:errorCode userInfo:nil];<br/>
}
</code></pre>
<p>在使用过程中应该注意，保持赋值互相对象的修饰符一致:</p>
<pre><code class="language-objectivec">NSError * __autoreleasing error;//修改修饰符为__autoreleasing保持一致进行赋值
NSError **pError = &amp;error;<br/>
//或者<br/>
NSError * error;<br/>
NSError * __strong *pError = &amp;error;
</code></pre>
<p>在下面的NSError **参数赋值了一个__strong对象变量也没报错，是因为编译器自动帮我们做了转换</p>
<pre><code class="language-objectivec">NSError * error;
    id obj = [NSData dataWithContentsOfFile:@&quot;&quot; options:0 error:&amp;error];<br/>
//编译器帮我们转化为了<br/>
NSError __strong *error;<br/>
NSError __autoreleasing *tmp = error;<br/>
id obj = [NSData dataWithContentsOfFile:@&quot;&quot; options:0 error:&amp;tmp];
</code></pre></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15663537912476.html">引用计数</a></h1>
			<p class="meta"><time datetime="2019-08-21T10:16:31+08:00" 
			pubdate data-updated="true">08/21/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">引用计数规则</h2>

<h3 id="toc_1">自己生成的对象 自己持有</h3>

<p>使用以下名称开头的方法名，意味自己生成的对象只有自己持有：</p>

<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>

<pre><code class="language-objectivec">id obj = [[NSObject alloc] init]
id obj = [NSObject new]
</code></pre>

<p>自己生成并持有对象，指向生成并持有对象的指针被复制给变量<code>obj</code></p>

<h3 id="toc_2">非自己生成的对象 自己也能持有</h3>

<p>用上面👆所述的几个方法之外取得的对象，因为是非自己生成并持有的，所以自己并不是对象的持有者</p>

<pre><code class="language-objectivec">//取得的对象存在 但是自己并不持有该对象
id obj = [NSMutableArray array]

//自己持有该对象
[obj  retain]
</code></pre>

<p>通过<code>retain</code>方法  非自己生成的对象跟用<code>alloc/new/copy/mutablecopy</code>一样，称为自己持有的对象</p>

<h3 id="toc_3">不再需要自己持有的对象时释放</h3>

<p>自己持有的对象，一旦不再需要，持有者有义务释放该对象，释放使用<code>release</code>方法</p>

<ol>
<li><p>自己生成并持有对象 自己释放</p>
<pre><code class="language-objectivec">//自己生成并持有对象
id obj = [[NSObject alloc] init]<br/>
//释放对象<br/>
[obj release]<br/>
/*<br/>
* 释放对象<br/>
* 指向对象的指针仍然被保留在变量obj中，貌似能够访问<br/>
* 但对象一经释放绝对不可访问<br/>
*/
</code></pre></li>
<li><p>非自己生成并持有的对象 也可以通过<code>release</code>释放</p>
<pre><code class="language-objectivec">//取的对象 但是自己并不持有
id obj = [[NSObject alloc] init]<br/>
//自己持有对象<br/>
[obj retain]<br/>
//释放对象<br/>
[obj release]
</code></pre>
<p>用retian方法持有的对象 一旦不再寻妖 务必用<code>release</code>方法进行释放</p></li>
<li><p>调用<code>alloc/new/copy/mutablecopy</code>开头方法生成对象，并将其返回该方法调用方</p>
<pre><code class="language-objectivec">-(id)allocObject {
    //自己生成并且持有对象<br/>
    id obj = [[NSObject alloc] init]<br/>
    return obj<br/>
}<br/>
//自己持有对象<br/>
id obj1 = [obj0 allocObject]
</code></pre>
<p>原封不动的返回alloc方法生成并且持有的对象 就能让调用方也持有该对象<br/>
<code>allocObject</code>是符合前面的命名规则的  因此调用该方法也能自己生成并且持有该对象</p></li>
<li><p>调用非<code>alloc/new/copy/mutablecopy</code>开头方法生成对象</p>
<p>此类型的方法 就是我们常用的<code>[NSArray array]</code>方法类似</p>
<pre><code class="language-objectivec">-(id)object {
//自己生成并持有对象<br/>
id obj = [[NSObject alloc] init]<br/>
//取得对象存在 但自己不持有对象<br/>
[obj autorelease]<br/>
//返回对象<br/>
return obj<br/>
}<br/>
//取得的对象存在 但是自己不持有对象<br/>
id obj1 = [obj0 object]<br/>
//自己持有对象<br/>
[obj1 retain]
</code></pre>
<p>使用<code>autorelease</code>方法，可以取得对象存在，但自己不持有对象。<br/>
<code>autorelease</code>，使对象在超出指定生存范围时 能自动并且正确释放</p>
<blockquote>
<p>注意</p>
<p>这些谁都不持有的对象的方法名不能以<code>alloc/new/copy/mutablecopy</code>开头</p>
</blockquote></li>
</ol>

<h3 id="toc_4">无法释放非自己持有的对象</h3>

<p>用<code>alloc/new/copy/mutablecopy</code>开头获得的对象 或者  <code>retain</code>方法持有的对象 持有者是自己<br/>
当持有者是自己时 在不需要的时候将其释放  除此之外，得到的而对象绝对不能释放</p>

<h2 id="toc_5">alloc/retain/release/dealloc实现过程</h2>

<h3 id="toc_6">GUNStep中的实现方式</h3>

<p>用alloc类方法初始化对象时，初始化开辟内存大小为对象大小加上一个 记录引用计数的结构体大小的空间。</p>

<p>用该结构体中的<code>retained</code>整数来保存引用计数，并将其写到对象内存头部。通过对该结构体中的数值进行操作，来获取、增加、减少引用数值</p>

<ul>
<li>在<code>Object-C</code>对象存有引用计数这一数值</li>
<li>调用alloc方法或retain方法 引用计数加1</li>
<li>调用release后  引用计数减1</li>
<li>引用计数为0  调用dealloc方法废弃该对象</li>
</ul>

<h3 id="toc_7">苹果的实现</h3>

<p>在<code>NSObject</code>类方法上设置断点，列出<code>alloc</code>方法执行的函数</p>

<pre><code class="language-objectivec">+alloc
+allocWithZone
class_creatInstance
calloc
</code></pre>

<p>alloc方法先调用<code>+allocWithZone</code>方法，然后调用运行时中的<code>class_createInstance</code>函数，最后调用<code>calloc</code>来分配内存块</p>

<p><code>retaincount/retain/release</code>操作的实现  apple是维护了以个散列表(引用计数表)来管理引用计数<br/>
散列表中 键值为内存块地址的散列值</p>

<h2 id="toc_8">autorelease</h2>

<p><code>autorelease</code>像C语言的自动变量那样来对待对象实例，当超出作用域，对象实例release方法被调用，编程人员可以设定变量的作用域</p>

<pre><code class="language-objectivec">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]
id obj = [[NSObject alloc] init]
[obj autorelease]
//等效于执行了 [obj release]
[pool drain]
</code></pre>

<p>在Cocoa框架中，相当于程序主循环的<code>NSRunLoop</code>或者在其他程序可运行的地方，对<code>NSAutoreleasePool</code>对象进行生成，持有和废弃处理。因此，程序开发者不一定非要使用<code>NSAutoreleasePool</code>对象进行开发处理工作</p>

<blockquote>
<p>注意:</p>

<p>虽然runloop会自动废弃<code>NSRunloop</code>对象，但是在大量产生对象时 也会产生内存不足的现象，需要在使用完后，手动及时释放对象</p>
</blockquote>

<p>在cocoa框架中，很多类方法 用于返回autorelease对象</p>

<pre><code class="language-objectivec">id array = [NSMutableArray arrayWithCapacity:1];
//相当于以下源代码
id array = [[NSMutableArray arrayWithCapacity:1] autorelease];
</code></pre>

<blockquote>
<p>注意</p>

<p>在OC中 也就是Foundation框架时，无论调用那一个对象的autorelease方法，实现上是调用NSObject类的autorelease实例方法。但是对于NSAutoreleasePool类，该方法已经被重载，因此运行时会报错</p>
</blockquote>

<h3 id="toc_9">autorelease的实现</h3>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B&&Runloop.html"><strong>多线程&&Runloop&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="RunLoop.html">RunLoop&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html">线程安全&&锁&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="KVC&&KVO.html">KVC&&KVO&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&&block.html"><strong>内存管理&&block&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">OC高级编程-内存管理&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="block%E5%AD%A6%E4%B9%A0.html">block学习&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">官方文档-内存管理&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%8B%BE%E9%81%97.html">内存管理-拾遗&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&&%E7%BB%84%E4%BB%B6%E5%8C%96.html"><strong>设计模式&&组件化&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html">设计模式架构谈(摘录)&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html">组件化开发学习&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BC%96%E8%AF%91&&dyld&&Mach-O.html"><strong>编译&&dyld&&Mach-O&nbsp;(19)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html">iOS编译流程&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html">dyld(程序启动)&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html">Mach-O文件了解&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86.html"><strong>模块化知识&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS-CoreAnimation.html">iOS-CoreAnimation&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="CoreGraphic.html">CoreGraphic&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="ARKit.html">ARKit&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"><strong>第三方项目学习和使用&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="AFNetworking.html">AFNetworking&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="AsyncDisplayKit.html">AsyncDisplayKit&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="ReactnativeCocoa.html">ReactnativeCocoa&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="PromiseKit.html">PromiseKit&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96.html"><strong>项目监控和优化&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html">APP体积优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html">启动优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%B0%83%E8%AF%95&&%E6%B5%8B%E8%AF%95.html"><strong>调试&&测试&nbsp;(6)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="LLDB.html">LLDB&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html">自动化测试&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="git.html">git&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>