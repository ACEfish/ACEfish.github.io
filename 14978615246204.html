
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  集合类型 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div>
	<article class="hentry" role="article">
	<header>
			  	<h1 class="entry-title">集合类型</h1>
				<p class="meta"><time datetime="2017-06-19T16:38:44+08:00" pubdate data-updated="true">06/19/2017</time></p>
			 </header>
		  	<div class="entry-content">
			  	<p><code>Swift</code>语言提供<code>Array</code>(有序数据集)、<code>Set</code>(无序不重复数据集)和<code>Dictionary</code>(无序键值对)三种基本的集合类型用来存储集合数据</p>

<p><code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确<br/>
Swift 的Arrays、Sets和Dictionaries类型被实现为<code>泛型集合</code>。</p>

<blockquote>
<p>数组类型<code>Array&lt;Int&gt;</code> 简化形式 <code>[Int]</code><br/>
集合类型<code>Set&lt;Int&gt;</code> 无简化形式<br/>
字典类型<code>Dictionary&lt;Int, String&gt;</code> 简化 <code>[Int: String]</code><br/>
Array继承<code>RangeReplaceableCollection</code>协议 因此可以使用我们前面说的<code>index索引</code>和<code>insert方法</code><br/>
创建空的集合数据 就是 <code>类型()</code></p>
</blockquote>

<h2 id="toc_0">集合可变性</h2>

<p>当集合为变量，集合是可变的,当不需要集合改变时建议创建为不可变的let,有利于优化</p>

<h2 id="toc_1">数组Array</h2>

<p>存储同一类型值,可以重复</p>

<blockquote>
<p>注意</p>

<p>Swift 的Array类型被桥接到Foundation中的NSArray类</p>

<h3 id="toc_2">创建空数组</h3>
</blockquote>

<pre><code class="language-swift">var someInts = [Int]()//创建空数组
通过构造函数的类型，数组可以推断为[Int]
//创建特定数据类型的空数组
var someInt1 = [[Int]]()//创建类型为整形数组的空数组
</code></pre>

<blockquote>
<p>数组的类型表达为 [Int]  表示一个类型为[Int]的数组</p>
</blockquote>

<pre><code class="language-swift">someInts.append(3)
//可以从上面推断出数组为Int类型数组,因此可以直接创建空数组
someInts = []
//直接创建空数组
</code></pre>

<h3 id="toc_3">带有默认值的数组</h3>

<p>创建特定大小并且所有数据都被默认构造数组方法</p>

<pre><code class="language-swift">var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]
</code></pre>

<h3 id="toc_4">通过两个数组相加创建一个数组</h3>

<p>可以用<code>+</code>将两种相同数据类型数组组合为一个新的数组,新的数组类型与这两个数组类型相同</p>

<pre><code class="language-swift">var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>

<h3 id="toc_5">用数组字面量构造数组</h3>

<p>用数组字面量来进行数组构造,这是用一个或者多个数值构造数组</p>

<pre><code class="language-swift">[value 1, value 2, value 3]
// shoppingList 已经被构造并且拥有两个初始项。
var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]
var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] //可以不用声明类型 可以推断为String类型
</code></pre>

<h3 id="toc_6">访问和修改数组</h3>

<ol>
<li>使用数组的只读<code>count</code>属性来获取数组中数据项数量</li>
<li><p>用布尔<code>isEmpty</code>检查数组是否为空 即<code>count</code>属性是否为<code>0</code></p>
<pre><code class="language-swift">if shoppingList.isEmpty {
    print(&quot;The shopping list is empty.&quot;)<br/>
} else {<br/>
    print(&quot;The shopping list is not empty.&quot;)<br/>
}<br/>
// 打印“The shopping list is not empty.”（shoppinglist 不是空的）
</code></pre></li>
<li><p>使用<code>append(_:)</code>方法在数组后添加一个新的数组项</p>
<pre><code class="language-swift">shoppingList.append(&quot;Flour&quot;) //只能添加一项
</code></pre></li>
<li><p>用加法赋值运算符<code>+=</code>在数组后添加一个或多个相同类型数据项<br/>
<code>shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]</code></p></li>
<li><p>用下标来获取数组中数据项</p>
<pre><code class="language-swift">var firstItem = shoppingList[0]//获取数组中第一项
</code></pre></li>
<li><p>用下标改变一个或多个下标索引对应色数据值</p>
<pre><code class="language-swift">shoppingList[0] = &quot;Six eggs&quot;//
shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]//改变一系列值 即使新数据和原 有数据的数量不一致
</code></pre>
<blockquote>
<p>注意:</p>
<p>不能用下标访问的形式在数组尾部添加新项</p>
</blockquote></li>
<li><p>用<code>insert(_:at:)</code>方法在某个索引之前添加新的数据项</p></li>
<li><p>移除<br/>
使用<code>remove(at:)</code>方法来移除数组中的某一项,并返回被移除的值</p>
<pre><code class="language-swift">let mapleSyrup = shoppingList.remove(at: 0)
// 索引值为0的数据项被移除<br/>
// mapleSyrup 常量的值等于被移除数据项“Maple Syrup”
</code></pre>
<p><code>removeLast()</code>移除数组最后一项<br/>
<code>removeFirst()</code>移除数组最后一项</p>
<blockquote>
<p>注意</p>
<p>通过约见执行访问或修改数组数据，会引起运行期错误</p>
</blockquote></li>
</ol>

<h3 id="toc_7">遍历数组</h3>

<p>用<code>for-in</code>进行遍历</p>

<pre><code class="language-swift">for item in shoppingList {
    print(item)//单独的变量或常量可以直接print
}
</code></pre>

<p>用数组的<code>enumerated()</code>,在遍历时获取每个数据项的索引和值,返回由索引和数组值组成的元组</p>

<pre><code class="language-swift">for (index, value) in shoppingList.enumerated() {
    print(&quot;Item \(String(index + 1)): \(value)&quot;)
}
/*
    shoppingList.enumerated()返回就是一个sorted后 以元组形式返回
*/
</code></pre>

<blockquote>
<p>数组也继承了<code>collection</code>协议</p>
</blockquote>

<h2 id="toc_8">集合Set</h2>

<p>存储相同类型并且没有确定顺序的值</p>

<blockquote>
<p>注意</p>

<p>Swift的Set类型被桥接到Foundation中的NSSet类</p>
</blockquote>

<h3 id="toc_9">集合类型的哈希值</h3>

<p>一个类型为了存储在集合中，该类型必须是可哈希化的,即该类型必须提供一个方法来计算它的哈希值(哈希值是<code>Int</code>类型的)，相等对象的哈希值必须相同(<code>a==b因此a.hashValue == b.hashValue</code>).</p>

<p>Swift 的所有基本类型(比如<code>String , Int , Double 和 Bool</code>)默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值默认也是可哈希化的。</p>

<blockquote>
<p>注意</p>

<p>可以自定义一个遵循<code>Hashable</code>协议的自定义类型，作为集合值类型或者字典键的类型。这个协议需要提供一个<code>Int</code>的可读属性<code>hashValue</code>.<code>hashValue</code>属性返回的值并不需要在同一程序的不同执行周期或者不同程序之间保持相同。<br/>
其次，因为<code>Hashable</code>协议符合<code>Equatable</code>协议，所以遵循该协议的类型也必须提供一个&quot;是否相等&quot;运算符(<code>==</code>)的实现。</p>
</blockquote>

<h3 id="toc_10">集合类型写法/表达</h3>

<p>Swift 中的<code>Set</code>类型被写为 <code>Set&lt;Element&gt;</code>(<code>Element</code>表示<code>Set</code>中允许存储的类型)，它并没有类似数组的等价简化形式</p>

<h3 id="toc_11">空的集合</h3>

<pre><code class="language-swift">var letters = Set&lt;Character&gt;()
</code></pre>

<pre><code class="language-swift">letters.insert(&quot;a&quot;)//通过这 我们可以推断出为一个Set&lt;Character&gt;类型集合
letters = []//我们可以直接设置其为空的Set  其类型还是Set&lt;Character&gt; 
</code></pre>

<h3 id="toc_12">用数组字面量创建集合</h3>

<pre><code class="language-swift">//有三个初始值
var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>

<p>我们用数组字面量的形式初始化这个<code>Set</code>.我们从数组字面量没有办法推断出为<code>Set</code>类型,因此必须显示声明,但是可以推断出Set中元素类型,因此我们可以简化为</p>

<pre><code class="language-swift">var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>

<h3 id="toc_13">访问和修改一个集合</h3>

<p>1.只读属性<code>count</code>获取集合中个数</p>

<p>2.布尔属性<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为 0</p>

<p>3.<code>insert(_:)</code>方法来添加一个新元素</p>

<pre><code class="language-swift">favoriteGenres.insert(&quot;Jazz&quot;)
/**
    返回一个元组(inserted: Bool, memberAfterInserted: String)
*/
</code></pre>

<p>4.<code>remove(_:)</code>方法去删除一个元素<br/><br/>
    如果删除的是集合中的一个元素，则删除并返回它，但是如果集合中不包含它，就返回<code>nil</code><br/>
    <code>removeAll()</code>删除所有元素</p>

<p>5.<code>contains(_:)</code>方法去检查<code>Set</code>中是否包含一个特定的值</p>

<pre><code class="language-swift">    if favoriteGenres.contains(&quot;Funk&quot;) {
        print(&quot;I get up on the good foot.&quot;)
    } else {
        print(&quot;It&#39;s too funky in here.&quot;)
    }
</code></pre>

<p>6.用<code>for-in</code>遍历</p>

<pre><code class="language-swift">    for genre in favoriteGenres {
        print(&quot;\(genre)&quot;)
    }
</code></pre>

<p>7.排序<br/>
<code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个<code>Set</code>中的值可以使用<code>sorted()</code>方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符<code>&#39;&lt;&#39;</code>对元素进行比较的结果来确定</p>

<pre><code class="language-swift">    for genre in favoriteGenres.sorted() {
        print(&quot;(genre)&quot;)
    }
</code></pre>

<blockquote>
<p>sorted()后返回的是数组<br/>
sorted()返回排序后数组 数据源不变 sort()不返回数组将数据源变为排序后的数组(Set没有这方法,Array有)</p>
</blockquote>

<h2 id="toc_14">集合操作</h2>

<h3 id="toc_15">基本集合操作</h3>

<p>用<code>intersection(_:)</code>计算两个集合相交部分 ---- 交集<br/>
用<code>symmetricDifference(_:)</code>计算两个集合中不同部分 ---- <br/>
用<code>union(_:)</code>方法合并两个集合 --- 并集<br/>
用<code>subtracting(_:)</code>方法根据在本集合不在另外集合中的部分 --- 补集</p>

<pre><code class="language-swift">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
oddDigits.union(evenDigits).sort()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre>

<h3 id="toc_16">集合成员关系以及相等</h3>

<ol>
<li>用<code>==</code>判断两个集合是否包含完全相同的值</li>
<li>用<code>isSubset(of:)</code>判断是不是两外一个集合的子集</li>
<li>用<code>isSuperset(of:)</code>判断另外一个集合是不是本集合的子集</li>
<li>用<code>isStrictSubset(of:)</code>或<code>isStrictSuperset(of:)</code>判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等</li>
<li>用<code>isDisjoint(with:)</code>判断两个集合是否没有交集（没有相同的值）</li>
</ol>

<h2 id="toc_17">字典</h2>

<p>存储多个相同类型的值的容器</p>

<h3 id="toc_18">字典类型表达语法</h3>

<p><code>Swift</code>的字典使用<code>Dictionary&lt;Key, Value&gt;</code>定义，<code>Key</code>是键的类型,<code>Value</code>是值所对应的数据类型<br/>
<code>[Key: Value]</code>通常我们使用这种简化形式</p>

<blockquote>
<p>一个字典的 Key 类型必须遵循<code>Hashable</code>协议，就像<code>Set</code>的值类型,因为在字典中键也是唯一的,需要利用哈希值进行判断相等</p>
</blockquote>

<h3 id="toc_19">创建一个空字典</h3>

<pre><code class="language-swift">var namesOfIntegers = [Int: String]()//创建一个[Int: String] 类型的空字典
</code></pre>

<p>如果上下文已经知道类型信息</p>

<pre><code class="language-swift">namesOfIntegers = [:]//创建一个[Int: String] 类型的空字典
</code></pre>

<h3 id="toc_20">用字典字面量创建字典</h3>

<pre><code class="language-swift">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
//因为swift可以推断出为[String : String]类型 因此可以不同显示声明
var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
</code></pre>

<h3 id="toc_21">访问和修改字典</h3>

<p>1.只读属性<code>count</code>来获取字典的数据项数量</p>

<pre><code class="language-swift">print(&quot;The dictionary of airports contains (airports.count) items.&quot;)
// 打印 &quot;The dictionary of airports contains 2 items.&quot;（这个字典有两个数据项）
</code></pre>

<p>2.<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为 0 </p>

<p>3.可以在字典中使用下标语法来添加新的数据项<br/>
4.在字典中使用下标语法来改变特定键对应的值</p>

<pre><code class="language-swift">airports[&quot;LHR&quot;] = &quot;London&quot;
//若不存在键&quot;LHR&quot; 即为添加新的数据项 否则为改变键对应值
</code></pre>

<p>5.<code>updateValue(_:forKey:)</code>方法作为替代下标语法的方式，可以设置或者更新特定键对应的值(当存在键时即为更新值 否则为设置值)<br/>
<code>updateValue(_:forKey:)</code>方法会返回更新值之前的原值，所以对应值的类型的可选值(因为可能没有oldvalue)，可以根据此来判断更新是否成功</p>

<pre><code class="language-swift">if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {
    print(&quot;The old value for DUB was (oldValue).&quot;)
}
// 输出 &quot;The old value for DUB was Dublin.&quot;
</code></pre>

<p>6.下标语法来在字典中检索特定键对应的值,因为可能不存在这个键，因此返回的为可选类型</p>

<pre><code class="language-swift">if let airportName = airports[&quot;DUB&quot;] {
    print(&quot;The name of the airport is (airportName).&quot;)
} else {
    print(&quot;That airport is not in the airports dictionary.&quot;)
}
</code></pre>

<p>7.通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对</p>

<pre><code class="language-swift">airports[&quot;APL&quot;] = &quot;Apple Internation&quot;
// &quot;Apple Internation&quot; 不是真的 APL 机场, 删除它
airports[&quot;APL&quot;] = nil
// APL 现在被移除了
</code></pre>

<p>8.<code>removeValue(forKey:)</code>也可以用来在字典中移除键值对<br/>
在键值对存在的情况下会移除该键值对并且返回被移除的值 或者在没有值的情况下返回<code>nil</code></p>

<pre><code class="language-swift">if let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) {
    print(&quot;The removed airport&#39;s name is (removedValue).&quot;)
} else {
    print(&quot;The airports dictionary does not contain a value for DUB.&quot;)
}
</code></pre>

<h3 id="toc_22">字典遍历</h3>

<p><code>for-in</code>遍历字典中的键值对，字典中的数据项都以<code>(key, value)</code>元组形式返回</p>

<pre><code class="language-swift">for (airportCode, airportName) in airports {
    print(&quot;\(airportCode): \(airportName)&quot;)
}
</code></pre>

<p>通过访问<code>keys</code>或者<code>values</code>属性，我们也可以遍历字典的键或者值</p>

<pre><code class="language-swift">for airportCode in airports.keys {
    print(&quot;Airport code: (airportCode)&quot;)
}
for airportName in airports.values {
print(&quot;Airport name: (airportName)&quot;)
}
</code></pre>

<p>我们可以直接使用<code>keys</code>或者<code>values</code>属性构造一个新数组</p>

<pre><code class="language-swift">let airportCodes: [String] = airports.keys
// airportCodes 是 [&quot;YYZ&quot;, &quot;LHR&quot;]
let airportNames: [String] = airports.values
// airportNames 是 [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]
let airportCodes = airports.keys.sorted()

//创建键或者值的新数组
</code></pre>

<blockquote>
<p><code>Swift</code>的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的<code>keys</code>或<code>values</code>属性使用<code>sorted()</code>方法</p>
</blockquote>

			</div>

		
	  
		<footer>
		 <p class="meta">

			<strong>Categories:</strong>&nbsp; 
			<span class="categories">
			
			    <a class='category' href='Swift-BaseLearning.html'>Swift基础知识</a>&nbsp;
			 
			</span>
		    </p>
		    <p class="meta">
		      
		 </p>
	    
		<div class="sharing">
		  
          

          

		</div>

	    <p class="meta">
	    
	        <a class="basic-alignment left" href="14924196525709.html" 
	        title="Previous Post: 性能调优">&laquo; 性能调优</a>
	    
	    
	        <a class="basic-alignment right" href="15331791133617.html" 
	        title="Next Post: NetworkExtension">NetworkExtension &raquo;</a>
	    
	    </p>
	  </footer>
	</article>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>