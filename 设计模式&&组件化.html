
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  设计模式&&组件化 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541349160713.html">常用工程架构</a></h1>
			<p class="meta"><time datetime="2019-04-02T00:08:36+08:00" 
			pubdate data-updated="true">04/02/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>学习自<a href="https://github.com/ming1016/study/wiki/%E6%9E%84%E5%BB%BAiOS%E7%A8%B3%E5%AE%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%97%B6%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9%E7%9A%84%E6%80%9D%E8%80%83">构建iOS稳定应用架构时方案选择的思考</a></p>

<p>主要分为基础层和展现层两大层结构,主要思想是将基础层的最下一层当做零部件，将业务层最下层当做组装大部件，通过流程串起来形成一个完整的产品，做零件时按照做出一个就扔进对应基础层的篮子里思路来，目录结构也可以按照这种来进行。这两大层的最下层按照零件拆得越小越容易应对需求变化越容易保护巩固上层的思路来就好。</p>

<pre><code class="language-text">基础层
－ 网络
－－ 收发数据
－－－单例（持续使用数据）
－－－本地（缓存和持续化存储数据对业务的封装输出）
－－－单次使用（API接口Model封装输出和业务逻辑封装的ViewModel，将这些做为业务零件）
－ 存储
－－－ NSUserDefault（对轻量需要存储的添加下一层业务零件封装）
－－－ keychain（对安全级别较高需要存储的添加下一层业务零件封装）
－－－ 文件存储（对时效需求短的需要存储的添加下一层业务零件封装）
－－－ 数据库存储（对数据量大的需要存储的添加下一层业务零件封装，业务层上一层加一层封装CoreData或SQLite方便日后切换数据库用）
－ 动画（下层将动画框架输出成各个可以复用的动画功能小零件）
－ 视图风格
－ 列表控件
－－ 上拉加载更多
－－ 下拉刷新
－－ GuideView
－ WebView控件
－ AlertView
－ iOS系统空间封装
－－ 拍照控件
－－ 通讯录
－ 二维码
－ 语音
－ 安全
－ 支付
－ 统计
－ 日志

展现层
－ 首页
－－ 订阅
－－ 扫描二维码
－－ 发布视频
－ 列表
－－ 时间轴列表
－－－ Listview头部封面
－－－ 外链情况Cell
－－－ 图片Cell
－－－ 广告插入Cell
－－－ 留言评论
－－－ 赞区域
－－ 我的列表
－－ 订阅列表
－－ 文章列表
－ 详细页
－－ 分享
－－ 内容区
－－ 评论
－ 登录
－－ 注册
－－ 登录
－－ 忘记密码
－－ 条款
－－ 上传头像
－－ 个人信息修改
</code></pre>

<p>基础层中各个模块上层可以使用类似CocoaPod或Cathage方式，下一层再对其引用进行业务封装。</p>

<p>这里注意最下层需要拆的粒度越细越好。减少横向依赖。类似Common这样的东西可以拆到基础层的对应模块里，比如说配置文件里和统计相关的放到基础层的统计里，网络相关的放到网络里，颜色字体放到视图风格里，不要都堆在一个文件里。<strong>再或者是各种第三方的Category也放到对应的组里，比如说UIView+Additions和UIColor+Expanded就放到视图风格这个模块中，不要专门搞个Category放所有的Category。</strong></p>

<h2 id="toc_0">MVVM</h2>

<p>MVVM正好介于VIPER和MVCS之间，从ViewController里拆出来的ViewModel能够将数据经过逻辑处理用于View的显示，View有操作用过ReactiveCocoa将信号传给ViewModel来处理。</p>

<p>MVVM按照先前对应用的结构分层，会将View和ViewController放到展现层的最下面的两层里，将ViewModel和Model放到基础层对应模块的最下面一层中。最后要说的是无论选择哪种，只要是按照减少ViewController大小，将改胖的地方放到Model或View都是可以的，</p>

<p>一个模块很简单就用MVC，一般复杂就用MVVM，要是项目本身业务非常庞大可以整体采用VIPER来进行ViewController的完全拆分。</p>

<p><img src="media/15541349160713/15541355614614.jpg" alt="" style="width:773px;"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15537640909732.html">MVVM的思考</a></h1>
			<p class="meta"><time datetime="2019-03-28T17:08:10+08:00" 
			pubdate data-updated="true">03/28/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>MVC总结</p>

<p>M应该做的事：</p>

<ul>
<li>给ViewController提供数据</li>
<li>给ViewController存储数据提供接口</li>
<li>响应数据请求一般来是ViewController的</li>
<li>提供经过抽象的业务基本组件，供Controller调度(比如常用的dataModel)</li>
</ul>

<blockquote>
<p>M不应该这是dataModel 而是整个Model层</p>
</blockquote>

<p>C应该做的事：</p>

<ul>
<li>管理View Container的生命周期</li>
<li>负责生成所有的View实例，并放入View Container</li>
<li>监听来自View与业务有关的事件来操作View或者model</li>
</ul>

<p>V应该做的事：</p>

<ul>
<li>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。</li>
<li>界面元素表达</li>
</ul>

<h2 id="toc_0">MVVM要考虑的问题</h2>

<ol>
<li>MVVM具体应该怎么写 各个部分应该负责那些事儿不 </li>
<li>View和VM是否不应该持有 </li>
<li>网络请求应该写在什么地方，请求是否应该放在C中</li>
<li>MVVM中的数据流应该怎么流动 </li>
<li>VM应该和M直接交互吗？还是需要通过C调度，VM和M直接交互会不会导致VM和具体业务产生强烈耦合，导致VM的可移植性降低？ </li>
<li>M中放置对数据的增、删、改、查</li>
<li>VM是不是只做抽象数据和形象数据的转化，即可能将查到的数据转化为View展示需要的形式（即数据转换），而不应该对后台数据做任何处理 ，因为这是M应该做的事</li>
<li>VM只处理View需要展示的数据</li>
</ol>

<h2 id="toc_1">MVVM学习</h2>

<p>本文来自<a href="https://draveness.me/mvx">浅谈 MVC、MVP 和 MVVM 架构模式</a></p>

<p>MVP是MVC变种，采用了Presenter将视图和模型进行了解耦，采用了监督控制器，将视图层和模型层的一些属性进行了绑定</p>

<p>MVVM 采用了PresentModel理念，PM即将视图的所有全部状态和行为抽象为一个模型，为视图层提供了一个接口，PM通过引入展示模型，将模型层中的数据和复杂的业务逻辑封装为简单的数据并暴露给视图，让视图和展示模型中的属性进行同步。<br/>
展示模型PM中包含所有的视图渲染需要的动态信息，包括视图的内容（text、color）、组件是否启用（enable），除此之外还会将一些方法暴露给视图用于某些事件的响应</p>

<p>在PM模式中，同一个展示模型可以与多个领域对象交互，多个视图可以使用相同的展示模型，但是每一个视图只能持有一个展示模型。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15537578174693.html">本地持久化</a></h1>
			<p class="meta"><time datetime="2019-03-28T15:23:37+08:00" 
			pubdate data-updated="true">03/28/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>文章看自<a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">这里</a></p>

<p>model和model层的区别，model可以称为dataModel 只是业务数据建模形式的一种<br/>
<img src="media/15537578174693/15537578741705.jpg" alt="" style="width:1109px;"/></p>

<p><a href="https://github.com/casatwy/CTPersistance">参考CTPersistance的持久层和业务层交互</a><br/>
<img src="media/15537578174693/15537586256064.jpg" alt="" style="width:1176px;"/></p>

<p>dataCenter协调持久层和业务层，他通过调用持久层的弱业务逻辑，来给业务层提供强业务逻辑数据</p>

<p>Virtual Record就是前面提到的一个既能够被业务层理解，也能够被持久层理解的数据载体。Virtual Record事实上并不是一个对象，它只是一个protocol，这就是它Virtual的原因。一个对象只要实现了Virtual Record，它就可以直接被持久层当作Record进行操作，所以它也是一个Record。连起来就是Virtual Record了。所以，Virtual Record的实现者可以是任何对象，这个对象一般都是业务层对象。</p>

<p>datacenter一般被Controller持有，因此不适合作为单例，datacenter可以根据业务作出分化，每个业务提供一个dataCenter然后在相关controller下去调度</p>

<p>通过dataCenter可以将强业务逻辑和若业务逻辑区分开</p>

<h3 id="toc_0">总结</h3>

<p>在交互方案设计中，需要区别强业务逻辑和弱业务逻辑，把传统的dataModel区分为Table和Record，由DataCenter去实现强业务，Table去实现弱业务。由于DataCenter是强业务相关，所以在实际编码中，业务工程师负责创建DataCenter，并向业务层提供业务友好的方法，然后再在DataCenter中操作Table来完成业务层交付的需求</p>

<p>在具体与业务层交互时，采用Virtual Record的设计思路来设计Record，由具体的业务对象来实现Virtual Record，以它作为DataCenter和业务层之间的数据媒介进行交互。而不是使用传统的数据模型来与业务层做交互。</p>

<h2 id="toc_1">数据同步方案</h2>

<p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html">自行参阅</a></p>

<h3 id="toc_2">单向数据同步</h3>

<p>主要针对消息类应用</p>

<ol>
<li>改造的时候添加identifier(操作的唯一标识，而不是数据的唯一标识)，isDirty，isDeleted字段。如果在请求期间依旧允许对数据做操作，那么就要把identifier和primaryKey再放到一个新的表中</li>
<li>每次生成数据之后对应生成一个identifier，然后只要是针对数据的操作，就修改一次isDirty或isDeleted，然后发起请求带上identifier和操作指令去告知服务器执行相关的操作。如果是复杂的同步方式，那么每一次修改数据时就新生成一次identifier，然后再发起请求带上相关数据告知服务器</li>
<li>服务器根据请求包的identifier等数据执行操作，操作完毕回复给客户端确认</li>
<li>收到服务器的确认包之后，根据服务器给到的identifier（有的时候也会有tablename，取决于你的具体实现）找到对应的记录，如果是删除操作，直接把数据删除就好。如果是插入和更新操作，就把isDirty置为NO。如果有额外的表记录了更新操作，直接把identifier对应的这个操作记录删掉就行。</li>
</ol>

<h3 id="toc_3">双向数据同步</h3>

<p>主要针对笔记、日程类应用</p>

<h4 id="toc_4">封装操作对象</h4>

<p>需要通过封装操作对象,封装的对象中需要有:</p>

<ol>
<li>操作的唯一标识</li>
<li>数据的唯一标识</li>
<li>操作的类型</li>
<li>具体的数据，主要是在Insert和Update的时候会用到</li>
<li>操作的依赖标识</li>
<li>用户执行这项操作时的时间戳</li>
</ol>

<h4 id="toc_5">增加待操作数据表和待同步数据表</h4>

<h4 id="toc_6">拉去待执行列表实际</h4>

<ol>
<li>每次要把本地数据丢到服务器去同步之前，都要拉取一次待执行列表，执行完毕之后再上传本地同步数据</li>
<li>每次进入相关页面的时候都更新一次，看有没有新的操作</li>
<li>对实时性要求比较高的，要么客户端本地起一个线程做轮询，要么服务器通过长链接将待执行操作推送过来</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15536759822609.html">读 戴铭--项目架构设计</a></h1>
			<p class="meta"><time datetime="2019-03-27T16:39:42+08:00" 
			pubdate data-updated="true">03/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>当我们的项目和业务较小时，我们可以使用MVC、MVP、MVVM等设计模式进行开发，而当需求量和规模达到一定程度后，就需要考虑项目的架构设计合理性了</p>

<p>首先要考虑的是： 模块粒度怎么划分？ 如何分层？ 多团队如何协作？</p>

<p>模块粒度划分的标准或者原则:</p>

<ul>
<li>Single responsibility principle 单一功能原则：对象功能要单一，不要在一个对象里添加很多功能。</li>
<li>Open–closed principle 开闭原则：扩展是开放的，修改是封闭的。</li>
<li>Liskov substitution principle 里氏替换原则：子类对象是可以替代基类对象的。</li>
<li>Interface segregation principle 接口隔离原则：接口的用途要单一，不要在一个接口上根据不同入参数实现不同功能</li>
<li> Dependency inversion principle 依赖反转原则：方法应该依赖抽象，不要依赖实例。iOS 开发的高层业务方法依赖于协议</li>
</ul>

<p>组件化设计，需要对iOS的组件解耦，其并不是要求每个组件间都没有耦合，组件之间也可以有上下层依赖关系，但是层数不要过多，最多不超过3层<br/>
例如: </p>

<pre><code class="language-text">1. 底层是业务无关的基础组件
2. 中间是通用业务组件
3. 最上层是迭代业务组件，更新频率高
</code></pre>

<p>当然也不是要把所有功能都做成组件，只有业务功能等成熟时，有时间有机会时，进行改造</p>

<p>解耦的精髓在于业务逻辑能够独立出来，并不是形式上的解除编译上的耦合，我们更需要关心的是在划分组件时做到同层级解耦合，上下层依赖清晰</p>

<p>在协议式架构和中间者式架构中，我们选择中间者式的架构，可以更好的管控和扩展</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15536741821323.html">Beehive学习</a></h1>
			<p class="meta"><time datetime="2019-03-27T16:09:42+08:00" 
			pubdate data-updated="true">03/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">看此第三方库get到的新姿势</h3>

<ol>
<li><p>BHAnnotation中的数据存储<br/>
当我们想要在项目工程任何地方可以方便的的存储数据 而在其他地方方便的获取数据时，我们可以采用此方法，将数据存在data数据段中，指定数据段中，而在需要时 直接从指定的段中取出</p>
<pre><code class="language-c">__attribute__((used, section(&quot;name&quot;)))
char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot; &quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;
</code></pre>
<p>section的作用:<br/>
编译器编译源代码后生成的文件叫目标文件，从文件结构上来说，它已经是编译后可执行的文件格式，只是还没有经过链接的过程。可执行文件(Executable)主要是Windows下的PE(Portable Executable)和Linux的ELF(Executable Linkable Format)，它们也都是COFF(Common file format)格式的变种。程序源程序代码被编译之后会主要分成两个段：程序指令和程序数据。代码段属于程序指令，数据段和.bss段属于数据段。</p>
<p>.data数据段里面保存的都是初始化过的全局静态变量和局部静态变量。.rodata段存放的是只读数据，一般都是const修饰的变量和字符串常量。.bss段存放的是未初始化的全局变量和局部静态变量。代码段就在.text段。<br/>
此时我们就指定数据存储在data数据段的sectionName的段中<br/>
<img src="media/15536741821323/15536750915461.png" alt=""/></p></li>
<li><p>constructor函数、dyld加载 <br/>
在程序加载执行是，即main()函数执行之前，其实发生很多事情，就会有一系列方法执行<br/>
dyld即是在程序加载之前执行</p>
<pre><code class="language-objectivec">__attribute__((constructor))
void initProphet() {<br/>
    _dyld_register_func_for_add_image(dyld_callback);<br/>
}
</code></pre></li>
<li><p>程序加载时间记录分析 类似<code>BHTimeProfiler</code></p></li>
<li class="task-list-item"><p><input disabled="disabled" type="checkbox" />     我们在日常开发中应该有类似的工具 帮助我们查看需要的执行时间</p></li>
<li></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15536896283260.html">网络层架构</a></h1>
			<p class="meta"><time datetime="2019-03-27T20:27:08+08:00" 
			pubdate data-updated="true">03/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>文章看自<a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">这里</a></p>

<h2 id="toc_0">网络层设计需要注意</h2>

<h3 id="toc_1">1. 以什么样的方式将数据交付给业务层</h3>

<p>Delegate block notification</p>

<p>尽量不要使用notification，这要会导致可能的跨层访问导致耦合性增加；notification的一对多关系，导致问题难以追踪</p>

<p>block比较难追踪、维护；block会延长对象的生命周期；</p>

<p>在离散场景下，因为每次回调时做的任务，在每次回调时都是一致的，因此不要用block，使用delegate最好<br/>
在集约型调用时，因为每次请求类型都不一样，回调做的业务也不一致，因此使用block较好</p>

<p>在网络请求和网络层接受请求地方，采用block没问题，但是在获得数据交给业务方时，最好还是通过delegate去通知业务方,因为使用block的话 会导致调用请求的逻辑和获得结果的处理逻辑在同一个地方，代码变长，同时包含调用前和调用后的两部分逻辑，一次使用delegate，请求API地方只写请求的逻辑，在回调地方 只写回调的逻辑</p>

<h3 id="toc_2">2.交付什么样的数给业务层</h3>

<p>不要交付直接转换好的对象模型给业务层，可以交付json或者NSDictionary或者array，然后业务层通过特定的工具类转换为自己需要的数据(这个工具类可能是遵循了同一个协议的很多类，每个类有自己的转换方法，以及转换结果)</p>

<p>如果直接下发模型给业务层，那么在API请求层可能会有很多转换性能消耗，而且需要引入很多模型类，导致维护灾难</p>

<p>使用统一的工具类转换: 1. 可以使转换的逻辑集中，2. 将数据网络请求的数据直接转换为我们View需要展示的方便的数据，一步到位 3. 可以将业务数据和业务隔离，如果业务逻辑有修改，直接修改或者替换这个工具类即可，而UI有修改时，也不影响该转换工具类</p>

<p>转化出来的数据是直接可用的数据，不限定于dictionary或者model，也可以是view或者tableCell等</p>

<h3 id="toc_3">3.调用API应该是集约型还是离散型</h3>

<p>集约型: 所有api调用的是同一个类<br/>
离散型: 每一个请求api对应初始化一个请求类的对象</p>

<p>推荐离散型原因:</p>

<ol>
<li>可以方便做到正在进行的请求的取消</li>
<li>离散型可以针对不同的请求做不同的处理方式</li>
<li>当请求的着陆点消失时，离散型可以直接在请求类中感知并取消请求<br/>
如果是离散型的API调用，取消请求的代码写到APIManager里面就可以了，然后随着ViewController的回收进程，APIManager也会被跟着回收，这部分代码就得到了调用的机会。</li>
<li>离散型的请求可以给业务方提供更灵活性</li>
</ol>

<p>综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求。</p>

<p>关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。</p>

<p>当我们不得已要实现继承时，最好使用协议方式来规范子类的重载方法，使用IOP方式来限制派生类的重载</p>

<p>总结</p>

<ol>
<li>使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问</li>
<li>提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多</li>
<li>网络层上部分使用离散型设计，下部分使用集约型设计</li>
<li>设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱</li>
</ol>

<h2 id="toc_4">网络层的安全</h2>

<h2 id="toc_5">网络层优化方案</h2>

<p>优化入手切点:</p>

<ol>
<li>针对链路建立环节的优化</li>
<li>针对链路传输数据量的优化</li>
<li>针对链路复用的优化</li>
</ol>

<h3 id="toc_6">针对链路建立环节的优化</h3>

<p>请求建立的步骤：</p>

<ol>
<li>发起请求</li>
<li>DNS解析得到域名</li>
<li>根据IP进行3次或者4次(HTTPS)握手</li>
</ol>

<p>优化方案1.1： 缓存一些时效性比较长数据，减少请求发起的次数，将把API名字和参数拼成一个字符串然后取MD5作为key，存储对应数据； 清除数据策略:超时清理或者缓存数据过大清理，可以根据APP的操作日志决定；缓存可以存储在内存中，或者磁盘上<br/>
优化方案1.2： 减少请求发起的次数；1）比如多次下拉刷新，在一次请求没落地前剩下的没必要继续请求发送了 2）而类似条件筛选的，就可以取消前面的发送的请求 3）对于某些请求，没必要频繁发送的，可以先在本地记录，等数据满多少条后，上传数据；app每次启动时，上传上次的一流数据</p>

<p>优化方案2.1: 因为移动端的信号源常变，因此DNS链路的缓存经常变化，导致缓存的作用一般，另外因为很多应用app网络请求操作，属于你的app的DNS缓存很快被其他应用使用、覆盖，因此在解析DNS时，会耗费时间，优化方案就是：直接使用ip请求</p>

<p>对于建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，我们需要想办法让用户在最适合他的IP上给他提供服务，那么就针对我们绕过DNS服务的手段有一个额外要求：尽可能不要让用户使用对他来说很慢的IP。</p>

<p>所以综上所述，方案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。</p>

<pre><code class="language-objectivec">针对建立连接的优化手段其实是跟DNS域名解析的优化手段是一样的。不过这需要你的服务器提供
服务的网络情况要多，一般现在的服务器都是双网卡，电信和网通。由于中国特色的互联网ISP分
布，南北网络之间存在瓶颈，而我们App针对链接的优化手段主要就是着手于如何减轻这个瓶颈对
App产生的影响，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果。

我们一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的
手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API
来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。

</code></pre>

<h3 id="toc_7">针对链接复用的优化</h3>

<h2 id="toc_8">自己的一些思考</h2>

<ol>
<li><p>转化网络层下发数据的一些思考:<br/>
业务层通过特定的工具类转换为自己需要的数据(这个工具类可能是遵循了同一个协议的很多类，每个类有自己的转换方法，以及转换结果)</p></li>
<li><p>使用离散型请求，关于多模块共享数据</p>
<p>我们可以使用离散型请求，在业务层获取到数据后，如果该数据需要共享，则可以业务层告诉一个共享模块(单例模块)，将此数据存储（此共享模块数据Model层，提供数据的存。取、删、该等功能）</p></li>
<li></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15536843996723.html">View层的架构</a></h1>
			<p class="meta"><time datetime="2019-03-27T18:59:59+08:00" 
			pubdate data-updated="true">03/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>文章看自<a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">这里</a></p>

<h2 id="toc_0">View层组织注意事项</h2>

<ol>
<li><p><code>ViewController</code>中的书写规范</p>
<ul>
<li>在<code>viewDidLoad</code>中做<code>addSubViews</code>和布局</li>
<li>getter和setter放到最后避免影响业务逻辑阅读</li>
<li>将代理都写到一个delegate区域中，并且加上对应protocol名字</li>
<li>为按钮点击事件等，单独开一个<code>event response</code>的区域</li>
</ul></li>
<li><p>建议使用全代码 不使用xib或者storyboard</p></li>
<li><p>不建议统一派生<code>ViewController</code>，可以使用<code>AOP</code>或者使用NSObject的load函数(在应用启动时自动监听)，实现要实现的功能 --- 尽量不要使用继承</p></li>
<li><p>能不放在Controller中做的事情就尽量不要放在Controller中做</p></li>
</ol>

<h2 id="toc_1">View层应避免</h2>

<ol>
<li>代码不规范导致混乱</li>
<li>过多继承导致复杂的依赖关系</li>
<li>横向依赖</li>
<li>架构设计失去传承</li>
</ol>

<h2 id="toc_2">制作好的View架构</h2>

<p>要做一个View层架构，主要就是从以下三方面入手：</p>

<p>制定良好的规范<br/>
选择好合适的模式（MVC、MVCS、MVVM、VIPER）<br/>
根据业务情况针对ViewController做好拆分，提供一些小工具方便开发</p>

<h2 id="toc_3">MVC MVVM等设计模式</h2>

<p>这些设计模式其实是 规定了架构中的3个角色:数据管理者，数据加工者，数据展示者,之间的数据如何交换</p>

<h3 id="toc_4">对mvc的一些总结</h3>

<p>M应该做的事：</p>

<ul>
<li>给ViewController提供数据</li>
<li>给ViewController存储数据提供接口</li>
<li>响应数据请求一般来时C的</li>
<li>提供经过抽象的业务基本组件，供Controller调度</li>
</ul>

<blockquote>
<p>M不应该这是dataModel 而是整个Model层</p>
</blockquote>

<p>C应该做的事：</p>

<ul>
<li>管理View Container的生命周期</li>
<li>负责生成所有的View实例，并放入View Container</li>
<li>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。</li>
</ul>

<p>V应该做的事：</p>

<ul>
<li>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。</li>
<li>界面元素表达</li>
</ul>

<h2 id="toc_5">MVVM</h2>

<p>MVVM把数据加工的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。</p>

<p>MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel。</p>

<p>MVVM<br/>
viewmodel需要做的就是将json等数据转换为能给view用的model<br/>
Model层 这里的model层包括数据model层、网络请求层、数据存储层、</p>

<p>C负责View和ViewModel数据的绑定</p>

<p>MVVM就是讲MVC的C中的数据处理逻辑抽出来了</p>

<blockquote>
<p>对于API的调用应该放在VM还是C中，看情况而定，如果你的请求独立于C，请求时不需要再联系ViewController就可以放在VM中，否则的话在VM中调用逻辑混乱，最好放在C中</p>

<p>RAC的目的1：View并不适合直接持有ViewModel。第二个目的就在于，ViewModel有可能并不是只服务于特定的一个View，使用更加松散的绑定关系能够降低ViewModel和View之间的耦合度</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15536896276061.html">架构</a></h1>
			<p class="meta"><time datetime="2019-03-27T20:27:07+08:00" 
			pubdate data-updated="true">03/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">好的架构需要解决的问题</h2>

<ul>
<li>可以方便的调用网络API，保证各种网络环境都能体验良好</li>
<li>有效的组织页面代码，减少业务代码的耦合度，和复杂度，提高开发效率</li>
<li>合理安排本地数据的存储，减少性能消耗</li>
<li>可以动态化部署，不发版本就修复bug</li>
<li>方便收集用户数据</li>
<li>合理组织和划分模块</li>
<li>自动化打包和提供QA测试工具</li>
<li>可以打点 跑单元测试 跑性能测试 （先测量后优化）</li>
</ul>

<h2 id="toc_1">好的架构的特点</h2>

<ul>
<li>代码整洁，分类明确，没有common等</li>
<li>代码明确 不许文档就能读懂使用</li>
<li>思路和方法统一，不要多元和善变</li>
<li>不要有横向依赖，尽量不要有跨层访问</li>
<li>该限制的要限制，该灵活的需要灵活</li>
<li>易测试 易拓展</li>
<li>保持一定超前性  不论是技术或者产品设计</li>
<li>接口少 接口参数少</li>
<li>高性能（）</li>
</ul>

<h2 id="toc_2">架构分层</h2>

<p>模块关系逻辑上的分层: 这是从模块的功能划分上来说的<br/>
三层架构（用的更多）: 展现层（数据展示者）、业务层（数据加工者）、数据层（数据管理者）<br/>
四层架构: 展现层、业务层、网络层、本地数据层</p>

<p>数据流动架构分层有MVC或者MVVM等等</p>

<p>这两种只是从不同的角度描述架构分层的问题 并没有什么具体联系</p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B&&Runloop.html"><strong>多线程&&Runloop&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="RunLoop.html">RunLoop&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html">线程安全&&锁&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="KVC&&KVO.html">KVC&&KVO&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&&block.html"><strong>内存管理&&block&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">OC高级编程-内存管理&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="block%E5%AD%A6%E4%B9%A0.html">block学习&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">官方文档-内存管理&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%8B%BE%E9%81%97.html">内存管理-拾遗&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&&%E7%BB%84%E4%BB%B6%E5%8C%96.html"><strong>设计模式&&组件化&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html">设计模式架构谈(摘录)&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html">组件化开发学习&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BC%96%E8%AF%91&&dyld&&Mach-O.html"><strong>编译&&dyld&&Mach-O&nbsp;(19)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html">iOS编译流程&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html">dyld(程序启动)&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html">Mach-O文件了解&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86.html"><strong>模块化知识&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS-CoreAnimation.html">iOS-CoreAnimation&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="CoreGraphic.html">CoreGraphic&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="ARKit.html">ARKit&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"><strong>第三方项目学习和使用&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="AFNetworking.html">AFNetworking&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="AsyncDisplayKit.html">AsyncDisplayKit&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="ReactnativeCocoa.html">ReactnativeCocoa&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="PromiseKit.html">PromiseKit&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96.html"><strong>项目监控和优化&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html">APP体积优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html">启动优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%B0%83%E8%AF%95&&%E6%B5%8B%E8%AF%95.html"><strong>调试&&测试&nbsp;(6)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="LLDB.html">LLDB&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html">自动化测试&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="git.html">git&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>