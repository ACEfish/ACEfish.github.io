<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  ACEfish的博客
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="ACEfish的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:acefish.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; ACEfish的博客</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="iOSDevelop.html">iOSDevelop</a></li>
        
            <li><a href="2017%E5%B9%B4%E3%80%82%E3%80%82%E3%80%82.html">2017年。。。</a></li>
        
            <li><a href="English.html">English</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14873831706932.html">
                
                  <h1>OCMock</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">Mock介绍</h3>

<p>对于一些不容易构造或不容易获取的对象，此时你可以创建一个虚拟的对象（mock object）来完成测试。</p>

<h3 id="toc_1">OCMock介绍</h3>

<p><a href="http://ocmock.org/features/">官方网站</a><br/>
根据要mock的对象的class来创建一个对应的对象，并且设置好该对象的属性和调用预定方法后的动作（例如返回一个值，调用代码块，发送消息等等），然后将其记录到一个数组中，接下来开发者主动调用该方法，最后做一个verify（验证），从而判断该方法是否被调用，或者调用过程中是否抛出异常等。</p>

<h4 id="toc_2">1.OCMock中简单使用</h4>

<ol>
<li><p>class mock一个对象</p>

<pre><code class="language-Object-c">id mockClass = OCMClassMock([SomeClass class]);
//创建mock object当做类的实例
</code></pre></li>
<li><p>Stubbing methods that return objects<br/>
<code>Object-c<br/>
/**<br/>
意的就是有参数的方法，参数是可以具体指定的，也就是说只有满足你指定的具体参数的调用才会被mock指定的返回值。例子中的[OCMArg any]是指任意参数。<br/>
*/<br/>
//没有参数的方法<br/>
OCMStub([mockClass someMethod]).andReturn(anObject);<br/>
//有参数的方法<br/>
OCMStub([mockClass someMethod:[OCMArg any]]).andReturn(anObject);<br/>
</code><br/>
注意:<br/>
<strong>OCMock会在mock实例上没有找到相同名字的实例方法的时候去找同名的类方法。</strong></p></li>
<li><p>Verify-after-running<br/>
有些时候需要验证我们执行的代码流程是否调用了某个外部的方法，这个时候用OCMock就比较简单来实现。如果没有调用过这个方法的话，会立即抛一个异常出来。</p>

<pre><code class="language-Object-c">id mockClass = OCMClassMock([SomeClass class]);
//...
//some code
//...
OCMVerify([mockClass someMethod]);
</code></pre></li>
<li><p>验证mock方法没有被调用<br/>
验证代码没有调用某个方法<br/>
如果方法被调用了，就将isCalled设置为YES，这样最后assert的时候就会报错。<br/>
<code>Object-c<br/>
static BOOL isCalled = false;<br/>
id mockClass = OCMClassMock([SomeClass class]);<br/>
OCMStub([mockClass someMethod]).andDo(^(NSInvocation *invocation){<br/>
isCalled = YES;<br/>
});<br/>
//...<br/>
//some code<br/>
//...<br/>
XCTAssertFalse(isCalled);<br/>
</code></p></li>
<li><p>验证mock方法传入的参数<br/>
验证传递给外部调用的参数是否符合预期</p>

<pre><code class="language-Objec-c">id mockClass = OCMClassMock([SomeClass class]);
OCMStub([mockClass someMethod:[OCMArg checkWithBlock:^BOOL(id obj) {
//...
//some code
//...
return YES;
]]);
</code></pre></li>
<li><p>mock单例</p>

<p>如果我们mock的类是个单例的话，那么使用之前的方法进行mock是不会生效的。不过OCMock提供了一个很简单的解决方法，那就是调用单例返回mock</p>

<pre><code class="language-Object-c">id mockClass = OCMClassMock([SomeClass class]);
OCMStub([mockClass instanceMethod]).andReturn(mockClass);
</code></pre></li>
<li><p>The any constraint</p>

<pre><code class="language-Object-c">OCMStub([mock someMethodWithAnArgument:[OCMArg any]])
OCMStub([mock someMethodWithPointerArgument:[OCMArg anyPointer]])
OCMStub([mock someMethodWithSelectorArgument:[OCMArg anySelector]])

</code></pre></li>
<li><p>处理block参数<br/>
OCMock也可以处理block回调参数。block回调通常用于网络代码，数据库代码，或者在任何异步操作中。在这个例子中，思考下下面的方法：<br/>
<code>- (void)downloadWeatherDataForZip:(NSString *)zip callback:(void (^)(NSDictionary *response))callback;</code></p></li>
</ol>

<p>在这个例子中，我们有一个下载天气压缩数据的方法，并且把下载下来的dictionary代理到一个block的回调中。在测试中，我们通过预定义的天气数据来测试回调处理。这也是明智的测试失败场景。你永远不会知道网络上会返回你什么东西！</p>

<pre><code class="language-Object">OCMStub([groupModelMock downloadWeatherDataForZip:@&quot;80304&quot; callback:[OCMArg any]]]).andDo(^(NSInvocation *invocation){
        //2. declare a block with same signature
        void (^weatherStubResponse)(NSDictionary *dict);
        //3. link argument 3 with with our block callback
        [invoke getArgument:&amp;weatherStubResponse atIndex:3];
        //4. invoke block with pre-defined input
        NSDictionary *testResponse = @{@&quot;high&quot;: 43 , @&quot;low&quot;: 12};
        weatherStubResponse(groupMemberMock);
    });
    /**
        1.这个mock对象使用带NSInvocation参数的“andDo”方法。一个NSInvocation对象代表一
        个‘objectivetified’（实在不知道这个什么鬼）表现的方法调用。通过这个NSinvocation对
        象，使得拦截传递给我们的方法的block参数变得可能。
        2.用与我们测试的方法中相同的方法签名声明一个block参数。
        3.NSInvocation实例方法&quot;getArgument:atIndex:&quot;将赋值后的块函数传递都原始函数中定义
        的块函数中。注意：在Objective-C中，传递给任意方法的前两个参数都是“self”和“_cmd”.这是
        一个运行时的小功能以及用下标来获取NSInvocation参数时我们需要考虑的东西。
        4.最后，传递这个回调的预定义字典。
    */
</code></pre>

<h4 id="toc_3">2.OCMock简单示例</h4>

<p><img src="media/14873831706932/14873839517952.png" alt=""/></p>

<p>示例2：</p>

<pre><code class="language-Object-c">- (void)testStrictMock3{

    id classMock = OCMClassMock([TweetView class]);

    //设置期望或预设，这个classMock需要执行addTweet方法且参数不为nil。  不然的话会抛出异常
    //OCMExpect([classMock addTweet:[OCMArg isNotNil]]);
    //OCMStub([classMock addTweet:[OCMArg isNotNil]]);

    /* 如果不执行以下代码的话会抛出异常 */
    Tweet *testTweet = [[Tweet alloc] init];
    testTweet.userName = @&quot;齐滇大圣&quot;;
    [classMock addTweet:testTweet];

    OCMVerifyAll(classMock);
}
</code></pre>

<p>这表示一种友好的mock，不会在没有OCMExpect或OCMStub设置类的所有方法时抛出异常。以上代码把OCMExpect和OCMStub注释掉时不会报错。</p>

<p>还有一种表示严格的mock：OCMStrictClassMock，如果把OCMExpect和OCMStub注释掉时会报错，它要求你执行类中的所有方法，所以比较适合用来测试必须实现的方法，代码如下：</p>

<pre><code class="language-Object-c">- (void)testStrictMock3{
    id classMock = OCMStrictClassMock([TweetView class]);
    //OCMExpect([classMock addTweet:[OCMArg isNotNil]]);
    //OCMStub([classMock addTweet:[OCMArg isNotNil]]);

    Tweet *testTweet = [[Tweet alloc] init];
    testTweet.userName = @&quot;齐滇大圣&quot;;
    [classMock addTweet:testTweet]; 

    OCMVerifyAll(classMock);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%B5%8B%E8%AF%95.html'>测试</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14873195104181.html">
                
                  <h1>NSRunLoop</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在<code>主 dispatch/operation</code>队列中， <code>run loop</code> 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p>

<p><strong>一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的</strong><br/>
在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置<code>计时器</code>、使用<code>NSURLConnection</code>或者调用 <code>performSelector:withObject:afterDelay:</code>，其实背后都是 run loop 在处理这些异步任务。</p>

<p>run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行的一种聪明的做法。<br/>
* NSDefalutRunLoopMode : 默认Mode, 通常主线程在这个模式下运行<br/>
* UITrackingRunLoopMode : 滑动ScrollView是会切换到这个模式<br/>
* NSRunLoopCommonModes: 包括上面两个模式</p>

<p>例1:滑动ScrollView后系统把RunLoop切换为UITrackingRunLoopMode,因此加载默认模式中的定时器并不会执行,只有滚动停止回到默认模式才会继续执行。我们可以把定时器设为 <code>NSRunLoopCommonModes</code>的模式，并添加到 run loop 中；<br/>
<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>

<p>例2:当tableview的cell从网络异步加载图片, 加载完成后在主线程刷新显示图片, 这时滑动tableview会造成卡顿. 通常的思路是tableview滑动的时候延迟加载图片, 等停止滑动时再显示图片. 这里我们可以通过RunLoop来实现.<br/>
<code>[self.cellImageView performSelector:@sector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]];</code></p>

<p>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于<a href="https://objccn.io/issue-2-2/">常见的后台实践</a>的文章里阐述了一些关于这种模式的很好的例子。</p>

<p>如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14873150230777.html">
                
                  <h1>并发编程基础知识</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>基础容易混淆知识:</p>

<ol>
<li><p>串行(Serial) VS. 并行(Concurrent)<br/>
串行和并行描述的是任务和任务之间的执行方式. 串行是任务A执行完了任务B才能执行, 它们俩只能顺序   执行. 并行则是任务A和任务B可以同时执行.</p></li>
<li><p>同步(Synchronous) VS. 异步(Asynchronous)<br/>
同步和异步描述的其实就是函数什么时候返回. 比如用来下载图片的函数A: {download image}, 同步函数只有在image下载结束之后才返回, 下载的这段时间函数A只能搬个小板凳在那儿坐等... 而异步函数, 立即返回. 图片会去下载, 但函数A不会去等它完成. So, 异步函数不会堵塞当前线程去执行下一个函数!</p></li>
<li><p>并发(Concurrency) VS. 并行(Parallelism)</p>

<blockquote>
<p>并发是程序的属性(property of the program), 而并行是计算机的属性(property of the machine).<br/>
<img src="media/14873150230777/14873157020644.png" alt=""/></p>
</blockquote>

<p>并行和并发都是用来让不同的任务可以&quot;同时执行&quot;, 只是并发是伪同时, 而并行是真同时. 假设你有任务T1和任务T2(这里的任务可以是进程也可以是线程):</p>

<blockquote>
<p>其实我们平常说的并发编程包括狭义上的&quot;并行&quot;和&quot;并发&quot;, 你不能保证你的代码会被并行执行, 但你可以以并发的方式设计你的代码. 系统会判断在某一个时刻是否有可用的core(多核CPU核心), 如果有就并行(parallelism)执行, 否则就用context switch来分时并发(concurrency)执行. 最后再以Ray大神的话结尾: Parallelism requires Concurrency, but Concurrency does not guarantee Parallelism!</p>
</blockquote></li>
</ol>

<h1 id="toc_0">iOS多线程</h1>

<h2 id="toc_1">1.Pthrea</h2>

<p>可以自己了解</p>

<h2 id="toc_2">2.NSThread</h2>

<p>经过苹果封装后直接面对对象的，可以直接操控线程对象，但是生命周期需要我们自己管理，偶尔使用。例如<strong>NSThrea mainthread</strong>可以获取当前线程类，知道当前线程的各种属性用于调试  </p>

<h3 id="toc_3">创建线程并启动</h3>

<ul>
<li>先创建再启动<br/>
<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];
[thread start];</code></li>
<li><p>创建并启动<br/><br/>
<code>[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];</code>  </p>

<ul>
<li>用oc方法创建启动（不安全）<br/>
<code>[self performSelectorInBackground:@selector(run:) withObject:nil];</code><br/></li>
<li><p>其他方法  </p>

<p>//取消线程</p>

<ul>
<li>(void)cancel;</li>
</ul>

<p>//启动线程<br/>
- (void)start;</p>

<p>//判断某个线程的状态的属性<br/>
@property (readonly, getter=isExecuting) BOOL executing;<br/>
@property (readonly, getter=isFinished) BOOL finished;<br/>
@property (readonly, getter=isCancelled) BOOL cancelled;</p>

<p>//设置和获取线程名字<br/>
-(void)setName:(NSString *)n;<br/>
-(NSString *)name;</p>

<p>//获取当前线程信息<br/>
+ (NSThread *)currentThread;</p>

<p>//获取主线程信息<br/>
+ (NSThread *)mainThread;</p>

<p>//使当前线程暂停一段时间，或者暂停到某个时刻<br/>
+ (void)sleepForTimeInterval:(NSTimeInterval)time;<br/>
+ (void)sleepUntilDate:(NSDate *)date; </p></li>
</ul></li>
</ul>

<h2 id="toc_4">3.GCD</h2>

<p>Grand Central Dispatch,是苹果为多核并行运算提出的解决办法，或自动管理线程生命周期</p>

<h3 id="toc_5">任务和队列</h3>

<p>这是在GCD中此案有的重要概念：<strong>任务</strong>和<strong>队列</strong><br/>
* 任务：即即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： <strong>同步执行</strong> 和 <strong>异步执行</strong>，他们之间的区别是<strong><em>是否会创建新的线程</em></strong>。     </p>

<pre><code>    同步（sync）和异步（async）的主要区别是在于会不会阻塞当前线程，直到block中任务执行完毕；  
    同步就是阻塞当前线程并等待block中的任务执行完毕，然后线程会继续向下执行，异步操作当前线程会继续向下执行
</code></pre>

<ul>
<li>队列：用于存放任务。一共有两种队列，串行和并行队列
<strong>串行队列</strong>：放在串行队列中的任务，GCD会FIFO的取出来，执行，然后取出下一个<br/></li>
</ul>

<p><strong>并行队列</strong>：在并行队列中的任务，GCD也会FIFO的取出来，但不同的是，取出来一个后就会放到别的线程，然后取出来再放到另一个线程，取的动作很快，看起来所有是同时执行。注意：GCD会根据系统资源控制并行数量，所以如果任务很多，并不会让人物同时执行  </p>

<h3 id="toc_6">创建队列</h3>

<ul>
<li><h5 id="toc_7">主队列</h5>

<p>特殊的 串行队列。它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。</p>

<pre><code>     //OBJECTIVE-C
    dispatch_queue_t queue = ispatch_get_main_queue();

      //SWIFT
      let queue = ispatch_get_main_queue()  
</code></pre></li>
<li><h5 id="toc_8">自己创建的队列</h5>

<p>自己可以创建 串行队列, 也可以创建 并行队列。看下面的代码（代码已更新），它有两个参数，第一个上面已经说了，第二个才是最重要的。第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>

<p>queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, NULL);<br/>
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL);<br/>
  //并行队列<br/>
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</p>

<p>//SWIFT<br/>
  //串行队列<br/>
  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, nil);<br/>
  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL)<br/>
  //并行队列<br/>
  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT)</p></li>
<li><h4 id="toc_9">全局并行队列</h4>

<p>一般只要是并行任务都加到这个队列<br/>
  //OBJECTIVE-C<br/>
  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>//SWIFT<br/>
  let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</p></li>
</ul>

<h3 id="toc_10">创建任务</h3>

<ul>
<li><h5 id="toc_11">同步任务：会阻塞当前线程</h5>

<pre><code>dispatch_sync(&lt;#queue#&gt;, ^{
</code></pre>

<p>//code here<br/>
  NSLog(@&quot;%@&quot;, [NSThread currentThread]);<br/>
    });</p></li>
<li><h5 id="toc_12">异步任务：不会阻塞当前线程</h5>

<pre><code>dispatch_async(&lt;#queue#&gt;, ^{
    //code here
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
});
</code></pre></li>
</ul>

<h3 id="toc_13">更好的理解同步异步以及各种队列的使用</h3>

<pre><code>同步任务会阻塞当前线程，然后把block块中的任务放到指定队列中执行，等到block任务完成后会让当前线程继续往下执行  
同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回.
</code></pre>

<h3 id="toc_14">队列组的使用</h3>

<p>可以将很多丢列添加到一个组中，这样的话，当这个组中所有任务都执行完了，队列会通过一个方法通知我们  </p>

<pre><code>//1.创建队列组
dispatch_group_t group = dispatch_group_create();
//2.创建队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue, ^{
    for (NSInteger i = 0; i &lt; 3; i++) {
        NSLog(@&quot;group-01 - %@&quot;, [NSThread currentThread]);
    }
});

//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue(), ^{
    for (NSInteger i = 0; i &lt; 8; i++) {
        NSLog(@&quot;group-02 - %@&quot;, [NSThread currentThread]);
    }
});

//3.3.执行5次循环
dispatch_group_async(group, queue, ^{
    for (NSInteger i = 0; i &lt; 5; i++) {
        NSLog(@&quot;group-03 - %@&quot;, [NSThread currentThread]);
    }
});

//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@&quot;完成 - %@&quot;, [NSThread currentThread]);
});
SWIFT
//1.创建队列组
let group = dispatch_group_create()
//2.创建队列
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue) { () -&gt; Void in
    for _ in 0..&lt;3 {
        NSLog(&quot;group-01 - %@&quot;, NSThread.currentThread())
    }
}

//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue()) { () -&gt; Void in
    for _ in 0..&lt;8 {
        NSLog(&quot;group-02 - %@&quot;, NSThread.currentThread())
    }
}

//3.3.执行5次循环
dispatch_group_async(group, queue) { () -&gt; Void in
    for _ in 0..&lt;5 {
        NSLog(&quot;group-03 - %@&quot;, NSThread.currentThread())
    }
}

//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue()) { () -&gt; Void in
    NSLog(&quot;完成 - %@&quot;, NSThread.currentThread())
}
</code></pre>

<p><strong>关于GCD还有两点要说的</strong><br/><br/>
* <code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</code><br/><br/>
这个方法重点是传入的queue，当你传入的queue是通过<code>DISPATCH_QUEUE_CONCURRENT</code>参数自己创建的queue时，这个方法会阻塞这个queue（注意是阻塞queue，而不是阻塞当前线程），一直等到这个queue中排在他前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，是这个queue中排在他后面的任务继续执行。但是如果你传入的是其他queue，那他和dispatch_async一样了<br/><br/>
* <code>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</code><br/><br/>
这个方法的使用和上一个一样，传入自定义的并发队列（<strong>DISPATCH_QUEUE_CONCURRENT</strong>），会阻塞queue，不同的是这个方法还会阻塞当前线程，，但是如果你传入其他queue就和dispatch_sync一样了  </p>

<h3 id="toc_15">线程同步</h3>

<ul>
<li><h5 id="toc_16">互斥锁：</h5>

<p>给需要同步的代码加一个互斥锁保证每次只有一个线程访问此代码块</p>

<pre><code>    //OBJECTIVE-C
    @synchronized(self) {
        //需要执行的代码块
    }
    //SWIFT
    objc_sync_enter(self)
    //需要执行的代码块
    objc_sync_exit(self)
</code></pre></li>
<li><h5 id="toc_17">同步执行：</h5>

<p>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 <code>GCD</code> 和 <code>NSOperation</code> 两种方案，我都写出来。</p>

<pre><code>//OBJECTIVE-C
      //GCD
      //需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中
      dispatch_sync(queue, ^{
          NSInteger ticket = lastTicket;
          [NSThread sleepForTimeInterval:0.1];
          NSLog(@&quot;%ld - %@&quot;,ticket, [NSThread currentThread]);
          ticket -= 1;
          lastTicket = ticket;
      });

      //NSOperation &amp; NSOperationQueue
      //重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中
      //       2. 设置 queue 的 maxConcurrentOperationCount 为 1
      //       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！

      NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
          NSInteger ticket = lastTicket;
          [NSThread sleepForTimeInterval:1];
          NSLog(@&quot;%ld - %@&quot;,ticket, [NSThread currentThread]);
          ticket -= 1;
          lastTicket = ticket;
      }];

      [queue addOperation:operation];

      [operation waitUntilFinished];

      //后续要做的事
</code></pre></li>
<li><h5 id="toc_18">延迟执行：</h5>

<pre><code>//OBJECTIVE-C（这个方法在swift中去掉了）
    // 3秒后自动调用self的run:方法，并且传递参数：@&quot;abc&quot;
    [self performSelector:@selector(run:) withObject:@&quot;abc&quot; afterDelay:3];
    //GCD
    // 创建队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 设置延时，单位秒
    double delay = 3; 

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
        // 3秒后需要执行的任务
    });
</code></pre></li>
<li><h5 id="toc_19">单例模式：</h5>

<pre><code>OBJECTIVE-C
    @interface Tool : NSObject &lt;NSCopying&gt;

    + (instancetype)sharedTool;

    @end

    @implementation Tool

    static id _instance;

    + (instancetype)sharedTool {
        static dispatch_once_t onceToken;
        dispatch_once(&amp;onceToken, ^{
            _instance = [[Tool alloc] init];
        });

        return _instance;
    }

    @end
    swift
        class Tool: NSObject {
        static let sharedTool = Tool()

        // 私有化构造方法，阻止其他对象使用这个类的默认的&#39;()&#39;构造方法
        private override init() {}
        }
</code></pre></li>
</ul>

<h3 id="toc_20">从其他线程回到主线程的方法</h3>

<ul>
<li><h5 id="toc_21">NSThread</h5>

<pre><code>//Objective-C
[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];

//Swift
//swift 取消了 performSelector 方法。
</code></pre></li>
<li><h5 id="toc_22">GCD</h5>

<pre><code>//Objective-C
dispatch_async(dispatch_get_main_queue(), ^{

});

//Swift
dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in

})
</code></pre></li>
<li><h5 id="toc_23">NSOperationQueue</h5>

<pre><code>//Objective-C
[[NSOperationQueue mainQueue] addOperationWithBlock:^{

}];

//Swift
NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in

}
</code></pre></li>
</ul>

<h2 id="toc_24">评论补充</h2>

<pre><code>同步派发(sync)会尽可能地在当前线程派发任务.但如果在其他队列往主队列同步派发,任务会在主线程执行.
异步派发(async)也不绝对会另开线程.例如在主线程异步派发到主线程,派发依旧是异步的,任务也会在主线程执行.
我感觉同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回.

无论串行还是并发队列,任务启动顺序都是按照 FIFO 的,只是并发队列允许同一时间有多个任务执行都在执行.

创建队列

也可以自己创建并发队列.
dispatch_queue_create(&quot;我是私有串行队列&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_queue_create(&quot;我是私有并发队列&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_async(dispatch_get_main_queue()) {
// Swift 中用尾闭包写法感觉更美观.
}

关于同步,还有这么个东西:
dispatch_barrier_async(privateConcurrentQueue, ^{
// 写入操作会确保队列前面的操作执行完毕才开始,并会阻塞队列中后来的操作.
});

dispatch_sync(privateConcurrentQueue, ^{
// 只要没有写入操作,多个读取操作是相对并行的.
});
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14873146865194.html">
                
                  <h1>[NSOperation](http://www.jianshu.com/p/4b1d77054b35)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>与GCD相比好处:<br/>
1. NSOperation是基于GCD之上的更高一层封装, 拥有更多的API(e.g. suspend, resume, cancel等等).<br/>
2. 在NSOperationQueue中, 可以指定各个NSOperation之间的依赖关系<br/>
3. 用KVO可以方便的监测NSOperation的状态(isExecuted, isFinished, isCancelled).<br/>
4. 更高的可定制能力, 你可以继承NSOperation实现可复用的逻辑模块.</p>

<h2 id="toc_0">NSOperation和NSOperationQueue</h2>

<p>NSOpration是苹果公司对GCD的封装，NSOperation和MSOprationQueue分别对应GCD中的任务和队列<br/><br/>
因此操作步骤如下：<br/><br/>
1. 将要执行的任务封装到NSOperation对象中<br/>
2. 将任务添加到一个NSOprationQueue对象中</p>

<h3 id="toc_1">添加任务</h3>

<p><code>NSOperation</code>是一个抽象类，所以不能封装任务。但他有两个子类可以封装任务。分别为：NSInvocationOperation和NSBlockOperation。创建之后需要start启动，默认<strong>在当前队列同步执行</strong>当然也可以用<code>cancle</code>在中途取消任务</p>

<p>在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作:</p>

<pre><code>//1.创建NSInvocationOperation对象
  NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];

  //2.开始执行
  [operation start];   
</code></pre>

<pre><code class="language-Object-c">/**[]()
    在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，
    NSInvocationOperation在主线程执行操作，并没有开启新线程。
*/
</code></pre>

<pre><code>   在swift中这种方法是不是类型安全的（推荐第二种）


//1.创建NSBlockOperation对象
  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@&quot;%@&quot;, [NSThread currentThread]);
  }];

  //2.开始任务
  [operation start];
</code></pre>

<p>默认会在当前线程中执行。但是<code>NSBlockOperation</code>还有一个方法<code>addExecutionBlock:</code>，通过这个方法会给Operation添加多个执行Block。这样的话Operation中的任务会并发执行，他会在主线程和其他多个线程执行这些任务<br/><br/>
    ```Object-c<br/>
     //1.创建NSBlockOperation对象<br/>
      NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:<sup>{</sup><br/>
          NSLog(@&quot;%@&quot;, [NSThread currentThread]);<br/>
      }];</p>

<pre><code>  //添加多个Block
  for (NSInteger i = 0; i &lt; 5; i++) {
      [operation addExecutionBlock:^{
          NSLog(@&quot;第%ld次：%@&quot;, i, [NSThread currentThread]);
      }];
  }

  //2.开始任务
  [operation start];
  /**
    可以看出，blockOperationWithBlock:方法中的操作是在主线程中执行的，而
    addExecutionBlock:方法中的操作是在其他线程中执行的。
  */
```
</code></pre>

<hr/>

<h2 id="toc_2">自定义Operation</h2>

<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。<br/>
在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作，并没有开启新线程。</p>

<p>注意:<br/>
<code>NSOperation</code>可以自己独立执行(直接调用<code>[operation start]</code>), 也可以放到<code>NSOperationQueue</code>里面执行, 这两种情况下是否并发执行是不同的.</p>

<h5 id="toc_3">1. non-concurrent</h5>

<p>NSOperation默认是非并发的(non-concurrent),果你把operation放到某个线程执行, 它会一直block住该线程, 直到<code>operation finished</code>.<br/>
对于非并发的operation你只需要继承NSOperation, 然后重写main()方法即可<br/>
示例:下载一张:</p>

<pre><code class="language-Object-c">/**
    由于NSOperation是可以cancel的, 所以你需要在operation程序内部执行过程中判断当前
    operation是否已经被cancel了(isCancelled). 如果已经被cancel那就不往下执行了. 当你在外面
    调用[operation cancel]后, isCancelled会被置为YES.
*/

@implementation YourOperation 

- (void)main 
{
    @autoreleasepool {

        if (self.isCancelled) return;

        NSData *imageData = [[NSData alloc] initWithContentsOfURL:imageURL];

        if (self.isCancelled) { imageData = nil; return; }

        if (imageData) {
            UIImage *downloadedImage = [UIImage imageWithData:imageData];
        }

        imageData = nil;

        if (self.isCancelled) return;

        [self.delegate performSelectorOnMainThread:@selector(imageDownloaderDidFinish:)                                                                  
                                        withObject:downloadedImage
                                     waitUntilDone:NO];
    }
}

@end
</code></pre>

<h5 id="toc_4">1. Concurrent</h5>

<p>NSOperation有三个状态量isCancelled, isExecuting和isFinished. isCancelled上面解释过. main函数执行完成后, isExecuting会被置为NO, 而isFinished则被置为YES.</p>

<p>那肿么实现并发(concurrent)的NSOperation呢? 也很简单:<br/>
1). 重写isConcurrent函数, 返回YES, 这个告诉系统各单位注意了我这个operation是要并发的.<br/>
2). 重写start()函数.<br/>
3). 重写isExecuting和isFinished函数<br/>
4). 有必要时需要重写isCanceled函数</p>

<blockquote>
<p>为什么在并发情况下需要自己来设定isExecuting和isFinished这两个状态量呢? 因为在并发情况下系统不知道operation什么时候finished, operation里面的task一般来说是异步执行的, 也就是start函数返回了operation不一定就是finish了, 这个你自己来控制, 你什么时候将isFinished置为YES(发送相应的KVO消息), operation就什么时候完成了.</p>
</blockquote>

<pre><code class="language-Object-c">- (BOOL)isConcurrent {
    return YES;
}

- (void)start 
{
    [self willChangeValueForKey:@&quot;isExecuting&quot;];
    _isExecuting = YES;
    [self didChangeValueForKey:@&quot;isExecuting&quot;];

    NSURLRequest * request = [NSURLRequest requestWithURL:imageURL];
    _connection = [[NSURLConnection alloc] initWithRequest:request
                                                  delegate:self];
    if (_connection == nil) [self finish];
}

- (void)finish
{
    self.connection = nil;

    [self willChangeValueForKey:@&quot;isExecuting&quot;];
    [self willChangeValueForKey:@&quot;isFinished&quot;];

    _isExecuting = NO;
    _isFinished = YES;

    [self didChangeValueForKey:@&quot;isExecuting&quot;];
    [self didChangeValueForKey:@&quot;isFinished&quot;];
}

#pragma mark - NSURLConnection delegate
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
    // to do something...
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    // to do something...
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
    [self finish];
}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
    [self finish];
}

@end
</code></pre>

<p>还有以下几点需要注意:<br/>
*  operation的executing和finished状态量需要用willChangeValueForKey/didChangeValueForKey来触发KVO消息.<br/>
*  在调用完NSURLConnection之后start函数就返回了, 后面就坐等connection的回调了<br/>
*  在connection的didFinish或didFail回调里面设置operation的finish状态, 告诉系统operation执行完毕了.</p>

<p><strong>注意:</strong><br/>
如果你是在主线程调用的这个并发的operation, 那一切都是非常的perfect, 就算你当前在操作UI也不影响operation的下载操作. BUT, 如果你是在子线程调用的, 或者把operation加到了非main queue, 那么问题来了, 你会发现这货的NSURLConnection delegate不走了.</p>

<blockquote>
<p>这是runLoop的原因，主线程会自动创建一个RunLoop来保证程序一直运行. 但子线程默认不创建NSRunLoop, 所以子线程的任务一旦返回, 线程就over了.上面的并发operation当start函数返回后子线程就退出了, 当NSURLConnection的delegate回调时, 线程已经木有了, 所以你也就收不到回调了. 为了保证子线程持续live(等待connection回调), 你需要在子线程中加入RunLoop, 来保证它不会被kill掉.<br/>
详细关于RunLoop的知识可以查看 <a href="%5B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%81NSThread&amp;GCD&amp;NSOpration&amp;runLoop%5D(14871584203378.html)">并发编程Runloop</a></p>
</blockquote>

<p>对于这个问题:我们解决办法<br/>
1. 让start函数在主线程运行(即使[operation start]是在子线程调用的).</p>

<pre><code>```Object-c
- (void)start 
{
    if (![NSThread isMainThread]) {
        [self performSelectorOnMainThread:@selector(start)
                           withObject:nil
                        waitUntilDone:NO];
        return;
 }
    // set up NSURLConnection...
}

或者

   - (void)start
   {
       [[NSOperationQueue mainQueue] addOperationWithBlock:^{
       self.connection = [NSURLConnection connectionWithRequest:self.request delegate:self];
       }];
   }

```
</code></pre>

<ol>
<li><p>方法二是:让<code>operation</code>的start函数在子线程运行, 但是我们为它创建一个RunLoop. 然后把<code>URL connection schedule</code>到上面去. （这种方法不推荐）</p>

<pre><code class="language-Object-c">    //参考AFNetWorking的做法
    + (void)networkRequestThreadEntryPoint:(id)__unused object 
    {
        @autoreleasepool {
            [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];
            NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
            [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
            [runLoop run];
        }
    }

    + (NSThread *)networkRequestThread 
    {
        static NSThread *_networkRequestThread = nil;
        static dispatch_once_t oncePredicate;
        dispatch_once(&amp;oncePredicate, ^{
            _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
            [_networkRequestThread start];
        });
        return _networkRequestThread;
    }

    - (void)start 
    {
        [self.lock lock];
        if ([self isCancelled]) {
            [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
        } else if ([self isReady]) {
            self.state = AFOperationExecutingState;
            [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
        }
        [self.lock unlock];
    }
</code></pre>

<p>AFNetworking创建了一个新的子线程(在子线程中调用NSRunLoop *runloop = [NSRunLoop currentRunLoop]; 获取RunLoop对象的时候, 就会创建RunLoop), 然后把它加到RunLoop里面来保证它一直运行.</p>

<blockquote>
<p>这边我们可以简单的判断下当前start()的线程是子线程还是主线程, 如果是子线程则调用[NSRunLoop currentRunLoop]创新RunLoop, 否则就直接调用[NSRunLoop mainRunLoop], 当然在主线程下就没必要调用[runLoop run]了, 因为它本来就是一直run的.<br/>
我们还可以使用CFRunLoop来启动和停止RunLoop<br/>
<code>[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop]<br/>
                       forMode:NSRunLoopCommonModes];<br/>
CFRunLoopRun();<br/>
</code><br/>
等到该Operation结束的时候, 一定要记得调用<strong>CFRunLoopStop()</strong>停止当前线程的RunLoop, 让当前线程在operation finished之后可以退出.</p>
</blockquote></li>
</ol>

<hr/>

<h2 id="toc_5">NSOperationQueue</h2>

<p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 <code>start()</code> 方法来启动这个任务，但是这样做他们默认是 同步执行 的。就算是 <code>addExecutionBlock</code> 方法，也会在 当前线程和其他线程 中执行，也就是说还是会占用当前线程。这是就要用到队列 <code>NSOperationQueue</code> 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 <code>start()</code> 方法</p>

<p>一旦NSOperation被add到Queue里面那么我们就不care它自身是不是并发设计的了, 因为被add到Queue里面的operation必定是并发的. 而且我们可以设置Queue的maxConcurrentOperationCount来指定最大的并发数(也就是几个operation可以同时被执行, <strong>如果这个值设为1, 那这个Queue就是串行队列了</strong>).<br/>
 Queue会为每一个add到队列里面的operation创建一个线程来运行其start函数, 这样每个start都分布在不同的线程里面来实现operation们的并发执行.<br/>
注意:<br/>
** 我们这边所说的并发都是指NSOperation之间的并发(多个operation同时执行), 如果maxConcurrentOperationCount设置为1或者把operation放到[NSOperationQueue mainQueue]里面执行, 那它们只会顺序(Serial)执行, 当然就不可能并发了.**</p>

<h5 id="toc_6">* 主队列</h5>

<p>细心同学会发现，每套多线程方案都会有一个主线程。这是一个特殊的线程必须串行。凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行<br/><br/>
    //OBJECTIVE-C<br/>
    NSOperationQueue *queue = [NSOperationQueue mainQueue];</p>

<pre><code>//SWIFT
let queue = NSOperationQueue.mainQueue()
</code></pre>

<h5 id="toc_7">* 其他队列</h5>

<p>通过初始化产生的队列就是其他队列了，其他队列不需要名字<br/>
<strong>注意：</strong>其他队列会在其他线程中并行执行<br/>
```Object-c<br/>
    //1.创建一个其他队列<br/><br/>
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</p>

<pre><code>//2.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}];

//3.添加多个Block
for (NSInteger i = 0; i &lt; 5; i++) {
    [operation addExecutionBlock:^{
        NSLog(@&quot;第%ld次：%@&quot;, i, [NSThread currentThread]);
    }];
}

//4.队列添加任务
[queue addOperation:operation];
/**
   NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行
   NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行
*/
</code></pre>

<pre><code>
`- (void)addOperationWithBlock:(void (^)(void))block;`
无需先创建任务，在block中添加任务，直接将任务block加入到队列中,能够开启新线程，进行并发执行。

****
这时如果我们想要任务在其他线程串行执行  
`NSOperationQueue`有个参数`maxConcurrentOperationCount`最大并发数，设置为1时就是串行了  
`maxConcurrentOperationCount`默认情况下为-1，表示不进行限制，默认为并发执行。
`maxConcurrentOperationCount`大于1时，进行并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整
###操作依赖
`NSOperation`还有个实用功能添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:

```Object-c
    //1.任务一：下载图片
    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;下载图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //2.任务二：打水印
    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;打水印   - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //3.任务三：上传图片
    NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;上传图片 - %@&quot;, [NSThread currentThread]);
        [NSThread sleepForTimeInterval:1.0];
    }];
    
    //4.设置依赖
    [operation2 addDependency:operation1];      //任务二依赖任务一
    [operation3 addDependency:operation2];      //任务三依赖任务二
    
    //5.创建队列并加入任务
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];
</code></pre>

<p>注意不能添加互相依赖否则会锁死<br/><br/>
可以用<code>removeDependency</code>来解除依赖</p>

<p><strong>注意:</strong><br/>
如果我在子线程调用[operation start]函数, 或者把operation放到非MainQueue里面执行, 但是在operation的内部把start抛到主线程来执行(利用主线程的main run loop), 那多个operation其实不都是要在主线程执行的么, 这样还能并发? Luckily, 仍然是并发执行的,当然这个并发指的是狭义并发也就是主线程进行伪并行<br/>
<img src="media/14873146865194/14873217004353.jpg" alt=""/></p>

<hr/>

<h3 id="toc_8">其他方法</h3>

<ul>
<li><h5 id="toc_9">NSOperation</h5>

<pre><code>BOOL executing; //判断任务是否正在执行

BOOL finished; //判断任务是否完成

void (^completionBlock)(void); //用来设置完成后需要执行的操作

- (void)cancel; //取消任务 `NSOperation`提供的方法，可取消单个操作

- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕
</code></pre></li>
<li><h5 id="toc_10">NSOperationQueue</h5>

<pre><code>NSUInteger operationCount; //获取队列的任务数

- (void)cancelAllOperations; //取消队列中所有的任务

- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕

[queue setSuspended:YES]; // 暂停queue

[queue setSuspended:NO]; // 继续queue
</code></pre></li>
</ul>

<hr/>

<h3 id="toc_11">与君共勉</h3>

<p><img src="media/14873146865194/14876658479087.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14873143857948.html">
                
                  <h1>学习内容</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/14873143857948/14873143944782.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='2017%E5%B9%B4%E3%80%82%E3%80%82%E3%80%82.html'>2017年。。。</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_2.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_4.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>ACEfish的博客</h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="iOSDevelop.html"><strong>iOSDevelop</strong></a>
        
            <a href="2017%E5%B9%B4%E3%80%82%E3%80%82%E3%80%82.html"><strong>2017年。。。</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14896343426276.html">专用图层</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14894054496048.html"></a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14892022301750.html">图层几何学、视觉效果</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14892022094971.html">Core Animation</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14891313543932.html">小知识记录</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
