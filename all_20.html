
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15659410303124.html">不透明类型</a></h1>
			<p class="meta"><time datetime="2019-08-16T15:37:10+08:00" 
			pubdate data-updated="true">08/16/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>具有不透明返回类型的函数或方法会隐藏返回值的类型信息。此时，函数不再提供具体的类型作为返回类型，而是根据它支持的协议来描述返回值。</p>

<p>在处理模块和调用代码之间关系时，异常类型信息非常有用，此时返回的底层数据类型仍然可以保持私有。而且不同于返回协议类型，不透明类型可以保证类型一致性--表一起能获取到类型信息，但是模块使用者却不能获取到</p>

<h2 id="toc_0">不透明类型解决的问题</h2>

<h2 id="toc_1">返回不透明类型</h2>

<p>可以认为不透明类型和泛型相反。</p>

<p>泛型允许调用一个方法，为这个方法的形参和返回值制定一个与实现无关的类型，例如</p>

<pre><code class="language-swift">func max&lt;T&gt;(_ x: T, _ y: T) -&gt; T where T: Comparable { ... }
</code></pre>

<p>类型T由调用方法的代码决定，函数内部也要通过通用的方式写代码，才能应对调用者传入的各种类型</p>

<p>返回不透明类型函数中，不透明类型允许函数实现时，选择一个与调用代码无关的返回类型，比如：下面例子返回了一个梯形，但是却没直接输出梯形的底层类型</p>

<pre><code class="language-swift">struct Square: Shape {
    var size: Int
    func draw() -&gt; String {
        let line = String(repeating: &quot;*&quot;, count: size)
        let result = Array&lt;String&gt;(repeating: line, count: size)
        return result.joined(separator: &quot;\n&quot;)
    }
}

func makeTrapezoid() -&gt; some Shape {
    let top = Triangle(size: 2)
    let middle = Square(size: 2)
    let bottom = FlippedShape(shape: top)
    let trapezoid = JoinedShape(
        top: top,
        bottom: JoinedShape(top: middle, bottom: bottom)
    )
    return trapezoid
}
let trapezoid = makeTrapezoid()
print(trapezoid.draw())
</code></pre>

<p>返回值定义为<code>some Shape</code>；因此，该函数返回遵循<code>Shape</code>协议的给定类型，而不需要指定任何具体类型。<br/>
这样写<code>makeTrapezoid()</code>函数可以表明它公共接口的基本性质 --返回的是一个几何图形 -- 而不是部分的公共接口生成的特殊类型。</p>

<p><code>makeTrapezoid()</code>函数可以返回任意它需要的类型，只要其遵循<code>Shape</code>协议即可，类似泛型函数的实现代码，其调用代码需要采用通用的方式，使其返回的任何<code>Shape</code>类型值都能被正常使用</p>

<pre><code class="language-swift">//泛型和不透明类型相结合
func flip&lt;T: Shape&gt;(_ shape: T) -&gt; some Shape {
    return FlippedShape(shape: shape)
}
</code></pre>

<blockquote>
<p>注意:</p>

<p>如果函数内部有多个地方返回不透明类型，那么需要保证返回的均为同一类型，否则会报错</p>
</blockquote>

<h2 id="toc_2">不透明类型和协议类型区别</h2>

<p>虽然使用不透明类型作为函数返回值，看起来和返回协议类型非常相似，但这两者有一个主要区别，就在于是否需要保证类型一致性。</p>

<p>一个不透明类型只能对应一个具体的类型，即使函数调用者并不知道是哪种类型。<br/>
协议类型可以对应多个类型，只要他们遵循同一协议<br/>
不透明类型则比啊留了底层类型的唯一性，swift能够推断出来关联类型</p>

<pre><code class="language-swift">protocol Container {
    associatedtype Item
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }
}
extension Array: Container { }

// 错误：有关联类型的协议不能作为返回类型。
func makeProtocolContainer&lt;T&gt;(item: T) -&gt; Container {
    return [item]
}

// 错误：没有足够多的信息来推断 C 的类型。
func makeProtocolContainer&lt;T, C: Container&gt;(item: T) -&gt; C {
    return [item]
}


func makeOpaqueContainer&lt;T&gt;(item: T) -&gt; some Container {
    return [item]
}
let opaqueContainer = makeOpaqueContainer(item: 12)
let twelve = opaqueContainer[0]
print(type(of: twelve))
// 输出 &quot;Int&quot;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15052932669633.html">泛型</a></h1>
			<p class="meta"><time datetime="2017-09-13T17:01:06+08:00" 
			pubdate data-updated="true">09/13/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>泛型:</strong>根据自定义的需求，编写适用于任意类型，灵活可复用的函数和类型<br/>
避免编写重复代码，使用清晰抽象的方式表达意图</p>

<h2 id="toc_0">泛型函数</h2>

<p>泛型函数适用与任何类型</p>

<pre><code class="language-swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>泛型函数:</p>

<ol>
<li>使用<code>占位符</code>类型名来代替<code>实际类型名</code>(这里用字母<code>T</code>表示),这里并没有指明T必须是什么类型,而是a与b类型相同,在实际调用时才根据传入类型决定<code>T</code>所代表的类型</li>
<li>泛型函数在函数名后紧跟着<code>&lt;T&gt;</code>，尖括号用来告诉swift，<code>T</code>是函数定义内的一个占位类型，因此swift不会去查找名为T的实际类型</li>
</ol>

<p>因此，函数<code>swapTwoInts(_:_:)</code>可以接受任意相同类型的参数</p>

<h2 id="toc_1">类型参数</h2>

<p>类型参数指定并命名一个占位类型,紧随在函数名后,用尖括号括起来(如:<code>&lt;T&gt;</code>),也可以提供多个参数用逗号隔开</p>

<p>当类型参数被指定后，可以用指定的类型参数作为函数的参数类型或返回类型，甚至可以用作函数主体中的注释类型</p>

<p>类型参数会在函数被调用时被实际类型所替代</p>

<p>可以提供多个类型参数，写在尖括号汇总，并用逗号隔开</p>

<h2 id="toc_2">命名类型参数</h2>

<p>我们可以使用有意义的单词来表明类型参数和泛型函数关系,当没有联系时,通常使用单个字母来命名</p>

<blockquote>
<p>注意</p>

<p>使用大写字母开头的驼峰命名法来为类型参数命名</p>
</blockquote>

<h2 id="toc_3">泛型类型</h2>

<p><strong>泛型类型：</strong>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型,类型于<code>Array</code>和<code>Dictionary</code></p>

<pre><code class="language-swift">//泛型 Stack（栈型） 结构体
struct Stack&lt;Element&gt; {
    var items = [Element]()
    mutating func push(item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
}
</code></pre>

<p>使用占位类型<code>Element</code>，这个类型参数包裹在紧随结构体名的一对尖括号里（<code>&lt;Element&gt;</code>）,类型参数用来初始化数组,用来作为<code>push</code><code>pop</code>方法的参数</p>

<p><code>Element</code>为待提供类型定义了一个占位名。这种待提供类型可以在结构体的定义中通过<code>Element</code>来引用</p>

<ul>
<li>使用Element类型初始化items数组进行初始化</li>
<li>指定<code>push</code>方法的参数</li>
<li>指定<code>pop</code>方法的返回值类型</li>
</ul>

<p><code>Stack</code>是泛型类型,可以创建任意有效类型栈<br/>
可以通过在尖括号写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例</p>

<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push(&quot;uno&quot;)
stackOfStrings.push(&quot;dos&quot;)
let fromTheTop = stackOfStrings.pop()
</code></pre>

<h2 id="toc_4">泛型扩展</h2>

<p>当对泛型类型进行扩展时，并不需要提供类型参数列表作为定义的一部分。<br/>
可以在扩展中直接使用原始类型中声明的参数列表,并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<pre><code class="language-swift">//扩展泛型类型增加只读的计算属性
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>

<p>返回`<code>item</code>数组的最后一个元素</p>

<p>扩展中直接使用了已有的类型参数<code>Element</code></p>

<h2 id="toc_5">类型约束</h2>

<p>类型约束指定类型参数必须继承自指定类、遵循特定的协议或协议组合</p>

<p>对泛型函数或泛型类型中添加特定的类型参数，这在某些情况下是非常有用的<br/>
例如:<code>Dictionary</code>类型约束了字典中的键必须是可哈希的（符合<code>Hashable协议</code>），也就是必须有唯一的方法表示它，才能根据键进行判断</p>

<h3 id="toc_6">类型约束语法</h3>

<p>在类型参数名后放置类名或协议名用冒号隔开，来定义类型约束</p>

<pre><code class="language-swift">//类型约束的泛型函数
//T必须是SomeClass的子类，而U必须遵循SomeProtocol协议
func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
</code></pre>

<p>约束T必须是SomeClass的子类，要求U必须遵循SomeProtocol的</p>

<h3 id="toc_7">类型约束实践</h3>

<p>我们新建一个泛型函数来从实现从数组中查找特定元素的功能;</p>

<pre><code class="language-swift">//从数组中查找特定自字符串的非泛型函数
func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}


//泛型类型
func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
        return index
        }
    }
    return nil
}
</code></pre>

<p>上面的泛型函数，是无法通过编译的，因为不是任何类型都可以用<code>==</code>进行比较<br/>
Swift定义了一个<code>Equatable</code>协议,所有遵守改协议的类型都必须实现<code>==或!=</code>，从而对该类型任意值进行比较</p>

<pre><code class="language-swift">//此时泛型函数可以成功编译了
func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>

<h2 id="toc_8">关联类型</h2>

<p>定义协议时，声明一个或者多个关联类型作为协议的一部分</p>

<p><strong>关联类型</strong>为协议中的的某个类型提供占位符名称，而其实际类型在协议被采纳时才会被指定</p>

<p>用<code>associatedtype</code>关键字指定<strong>关联类型</strong></p>

<pre><code class="language-swift">protocol Container {
    associatedtype ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>

<p>在协议中声明了一个关联类型<code>ItemType</code>,来保证在不知道容器中元素的具体类型情况下行为能够正确执行</p>

<pre><code class="language-swift">//定义类型遵循Contain协议
Struct IntStack: Container {
    // IntStack 的原始实现部分
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // Container 协议的实现部分
    typealias ItemType = Int//可以省略，swift会根据协议的实现推断出类型
        mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}

</code></pre>

<p><code>IntStack</code>结构体实现了<code>Container</code>协议的三个要求，此外在实现其要求时，指定<code>Item</code>为<code>Int</code>类型，即<code>typealias ItemType = Int</code>来转换协议中的关联类型<br/>
当然，这个是可以省略的，Swift可以根据方法推断出<code>ItemType</code>类型</p>

<h3 id="toc_9">扩展存在的类型来指定关联类型</h3>

<p>对于Contain协议，Swift中的Array已经默认提供了协议中要求，因此我们只需要声明Array遵循该协议就可以扩展<code>Array</code></p>

<pre><code class="language-swift">//我们只需要扩展Array来使其遵循该协议即可
extension Array: Container {}
</code></pre>

<h3 id="toc_10">在关联类型约束里使用协议</h3>

<pre><code class="language-swift">protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -&gt; Suffix
}
</code></pre>

<p><code>Suffix</code>是一个关联类型，有两个约束: </p>

<ol>
<li>必须遵循SuffixableContainer协议</li>
<li>他的<code>Item</code>类型必须和容器里的<code>Item</code>类型相同</li>
</ol>

<h2 id="toc_11">泛型Where语句</h2>

<p>对关联类型添加约束是非常有用的。可以通过定义一个泛型<code>where</code>语句来实现。通过泛型where子句让关联类型遵循特定协议，以及某个特定的类型参数和关联参数必须相同</p>

<p>通过将<code>where</code>关键字紧跟在类型参数列表后来定义where子句，where子句后跟一个或者多个针对关联类型的约束，以及一个或者多个类型参数和关联类型间的相等关系。</p>

<p>可以在函数体或者类型的大括号之前添加<code>where</code>子句</p>

<pre><code class="language-swift">func allItemsMatch&lt;C1: Container, C2: Container&gt;
(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {
        // 检查两个容器含有相同数量的元素
        if someContainer.count != anotherContainer.count {
            return false
        }
        // 检查每一对元素是否相等
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
            return false
        }
    }
    // 所有元素都匹配，返回 true
    return true
}
</code></pre>

<p>这个函数的类型参数列表还定义对两个类型参数的要求:</p>

<ul>
<li>C1必须符合<code>Container</code>协议</li>
<li>C2必须符合<code>Containner</code>协议</li>
<li>C1的Item必须和C2的Item类型相同</li>
<li>C1的Item必须符合Equtable协议<br/>
前两个要求定义在函数的类型参数列表里，后两个要求定义在函数的泛型where分句中</li>
</ul>

<h3 id="toc_12">具有Where子句的扩展</h3>

<p>可以使用泛型where子句 作为扩展的一部分。</p>

<pre><code class="language-swift">//扩展泛型Stack结构体
extension Stack where Element: Equatable {
    func isTop(_ item: Element) -&gt; Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}

//扩展协议
extension Container where Item: Equatable {
    func startsWith(_ item: Item) -&gt; Bool {
        return count &gt;= 1 &amp;&amp; self[0] == item
    }
}

</code></pre>

<h3 id="toc_13">具有泛型Where子句的关联类型</h3>

<p>可以在关联类型后面加上具有泛型where的子句。</p>

<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -&gt; Item { get }

    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
    func makeIterator() -&gt; Iterator
}
</code></pre>

<p>迭代器<code>Iterator</code>的泛型<code>where</code>子句要求:无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。</p>

<p>当一个协议继承另外一个协议，通过在协议声明中，包含<code>where</code>子句，来添加一个约束到被继承协议的关联类型。</p>

<pre><code class="language-swift">protocol ComparableContainer: Container where Item: Comparable { }
</code></pre>

<h3 id="toc_14">泛型下标</h3>

<p>下标也可以是泛型，能够包含泛型<code>where</code>语句。<br/>
可以在 subscript 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 where 子句</p>

<pre><code class="language-swift">extension Container {
    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]
        where Indices.Iterator.Element == Int {
            var result = [Item]()
            for index in indices {
                result.append(self[index])
            }
            return result
    }
}
</code></pre>

<ul>
<li>泛型参数 Indices，必须是符合标准库中的 Sequence 协议</li>
<li>下标使用的单一的参数，indices，必须是 Indices实例</li>
<li>泛型 where 子句要求 Sequence（Indices）的迭代器，其所有的元素都是 Int 类型</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15047511695312.html">协议</a></h1>
			<p class="meta"><time datetime="2017-09-07T10:26:09+08:00" 
			pubdate data-updated="true">09/07/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>类和结构体、枚举都可以遵循协议,并为协议定义的这些要求提供实现<br/>
除了遵循协议的类型必须实现外还可以对协议进行扩展，通过扩展来实现一部分要求或者添加附加功能</p>

<h2 id="toc_0">协议语法</h2>

<p>协议的定义:</p>

<pre><code class="language-swift">protocol SomeProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<p>自定义类型遵循某个协议,定义类型时,可以在类型名称后加上协议名称,中间用<code>:</code>分割,多个协议之间用<code>,</code>分割</p>

<pre><code class="language-swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 这里是结构体的定义部分
}
</code></pre>

<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>

<pre><code class="language-swift">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 这里是类的定义部分
}
</code></pre>

<h2 id="toc_1">属性要求</h2>

<ul>
<li>协议可以指定遵循协议的类型提供特定名称和类型的实例属性或类型属性。</li>
<li>协议不指定属性是存储属性还是计算属性，只指定属性名称和类型</li>
<li>协议指定属性是可读的还是可读写的</li>
</ul>

<blockquote>
<p>注意:</p>

<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。<br/>
如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的</p>
</blockquote>

<p>协议总是用<code>var</code>关键字来声明变量属性，在类型声明后加上<code>{ set get }</code>来表示属性是可读可写的，可读属性则用<code>{ get }</code>来表示</p>

<pre><code class="language-swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>在协议中定义类型属性时，使用<code>static</code>关键字作为前缀。当类类型遵循协议时,除了<code>static</code>关键字,还可以使用<code>class</code>关键字声明类型属性:</p>

<pre><code class="language-swift">protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>

<h2 id="toc_2">方法要求</h2>

<p>遵循协议的类型实现某些指定的实例方法或类方法</p>

<ul>
<li>方法像普通方法一样放在协议的定义中,但是不需要大括号和方法体</li>
<li>与普通方法类似可以在方法中提供可变参数,但是不能为参数提供默认值</li>
<li>在协议中定义类方法时，总是使用<code>static</code>关键字为前缀.当类类型遵循协议时，除了<code>static</code>关键字，还可以使用<code>class</code>关键字作为前缀</li>
</ul>

<pre><code class="language-swift">protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<pre><code class="language-swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
</code></pre>

<h2 id="toc_3">Mutating方法要求</h2>

<p>如果在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加<code>mutating</code>关键字,使得结构体和枚举能够遵循此协议并满足方法要求</p>

<blockquote>
<p>注意</p>

<p>在实现协议的<code>mutating</code>方法时，若是类类型则不用写<code>mutating</code>关键字，而若是结构体或枚举必须写<code>mutating</code>关键字</p>
</blockquote>

<pre><code class="language-swift">protocol Togglable {
    mutating func toggle()
}

//定义在两种状态间切换的枚举
enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = .On
        case On:
            self = .Off
        }
    }
}
</code></pre>

<h2 id="toc_4">构造器要求</h2>

<p><strong>协议可以要求遵循协议的类型实现指定的构造器</strong></p>

<pre><code class="language-swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h3 id="toc_5">构造器要求在类中的实现</h3>

<p>遵循协议的类实现构造器.不论指定构造器或者便利构造器都必须在实现加上<code>required</code>修饰符</p>

<pre><code class="language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<p>使用<code>required</code>修饰符可以确保所有子类也必须提供此构造器实现，即符合协议</p>

<p>注意:</p>

<blockquote>
<p>如果类被标记为<code>final</code>，就不需要在协议构造器中使用<code>required</code>修饰符,因为<code>final</code>类不会有子类</p>
</blockquote>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求,那么重写上需要同时加上<code>required</code>和<code>override</code>修饰符</p>

<pre><code class="language-swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // 这里是构造器的实现部分
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为遵循协议，需要加上 required
    // 因为继承自父类，需要加上 override
    required override init() {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<h3 id="toc_6">可失败构造器要求</h3>

<p>协议还可以为遵循协议的类型定义可失败构造器要求</p>

<p>遵循协议的类型可以通过可失败构造器<code>（init?）</code>或非可失败构造器<code>（init）</code>来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器<code>（init</code>或隐式解包可失败构造器<code>（init!）</code>来满足</p>

<h2 id="toc_7">协议作为类型</h2>

<p>协议可以作为功能完备的类型来使用:</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>

<p>协议作为一种类型,因此与它类型的命名写法相同 应该使用驼峰写法</p>

<pre><code class="language-swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>类<code>Dice</code>中含有属性<code>generator</code>为<code>RandomNumberGenerator</code>协议类型,因此遵循了<code>RandomNumberGenerator</code>协议类型的实例都可以赋值给<code>generator</code></p>

<p>在类中有<code>roll</code>的实例方法,调用<code>generator</code>的<code>random()</code>方法来生成一个<code>[0.0,1.0)</code>区间内的随机数</p>

<h2 id="toc_8">委托（代理）模式</h2>

<hr/>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例.<br/>
委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。<br/>
委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型</p>

<hr/>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>我们可以通过扩展代码来为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中相应要求</p>

<blockquote>
<p>通过扩展使已有类型遵循并符合协议时,该类型的所有实例也会获得协议中定义的各项功能</p>
</blockquote>

<pre><code class="language-swift">protocol TextRepresentable {
    var textualDescription: String { get }
}

extension Dice: TextRepresentable {
    var textualDescription: String {
        return &quot;A \(sides)-sided dice&quot;
    }
}
</code></pre>

<p>扩展来遵循并符合协议与原始定义中效果相同</p>

<h2 id="toc_10">有条件遵循协议</h2>

<p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。</p>

<p>可以通过在扩展类型时列出限制让泛型类型有条件的遵循某协议。在你采纳协议的名字后面写泛型where分句。</p>

<pre><code class="language-swift">extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
</code></pre>

<h2 id="toc_11">通过扩展遵循协议</h2>

<p>有时一个类型已经符合了协议的要求，但是没声明采纳该协议，可以通过空的扩展使其采纳该协议:</p>

<pre><code class="language-swift">struct Hamster {
    var name: String
    var textualDescription: String {
        return &quot;A hamster named \(name)&quot;
    }
}

extension Hamster: TextRepresentable {}
</code></pre>

<h2 id="toc_12">协议类型的集合</h2>

<p>协议类型可以在数组或字典这样的集合使用</p>

<p><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></p>

<h2 id="toc_13">协议的继承</h2>

<p>协议可以继承一个或多个其他协议,可以在继承协议基础上增加新的要求.协议继承语法与类相似,多个协议用逗号分割：</p>

<pre><code class="language-swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<h2 id="toc_14">类类型专属协议</h2>

<p>通过添加<code>AnyObject</code>关键字到协议的继承列表，可以限制协议只能被类类型采纳(以及非结构体或者非枚举的类型)</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<h2 id="toc_15">协议合成</h2>

<p>有时我们需要一个类型遵循多个协议，此时可以使用协议组合来复合多个协议到一个要求中。<br/>
协议组合并不定义任何新的协议类型  </p>

<p>协议组合采用<code>SomeProtocol &amp; AnotherProtocol</code>的格式进行组合,可以泪如任意数量的协议<br/>
除了协议列表，协议组合也能包含类类型，这允许你表明一个需要的父类</p>

<pre><code class="language-swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}

func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)
}

let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
wishHappyBirthday(to: birthdayPerson)// “Happy birthday Malcolm - you&#39;re 21!”
</code></pre>

<h2 id="toc_16">检查协议一致性</h2>

<p>使用<code>is</code>和<code>as</code>检查协议的一致性,即是否符合某协议，并且可以转换到指定的协议类型,与类型检查和转换用法相同:</p>

<ul>
<li><code>is</code>用来检查实例是否符合某个协议，若符合则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>as?</code>返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回<code>nil</code></li>
<li><code>as!</code>将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误</li>
</ul>

<pre><code class="language-swift">protocol HasArea {
    var area: Double { get }
}

for object in objects {
    if let objectWithArea = object as? HasArea {
        print(&quot;Area is \(objectWithArea.area)&quot;)
    } else {
        print(&quot;Something that doesn&#39;t have an area&quot;)
    }
}
</code></pre>

<p>判断元素是否符合<code>HasArea</code>协议后将<code>as?</code>操作符通过可选绑定，绑定到<code>objectWithArea</code>常量上进行访问</p>

<blockquote>
<p>在数据中的元素类型并不会因为强转而丢失类型信息,只是在被赋值为<code>objectWithArea</code>时，被视为<code>HasArea</code>类型，因此只有<code>area</code>属性可以被访问</p>
</blockquote>

<h2 id="toc_17">可选的协议要求</h2>

<p>协议可以被定位可选要求，此时遵循协议的类型可以选择是否实现这些要求。</p>

<p>协议中使用<code>option</code>关键字作为前缀来标记可选要求，<br/>
可选要求用在需要和OC打交道的代码中<br/>
协议和可选要求都必须带上<code>@objc</code>属性<br/>
标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议</p>

<blockquote>
<p>注意:</p>

<p>当使用可选要求时，协议中的可选的方法或属性会自动变成可选的（函数的话整个函数类型是可选的而不是函数的返回值）</p>
</blockquote>

<p>可选要求 可以通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似<code>someoptionMethond?(someArgument)</code>，可以再可选方法名后加上<code>?</code>调用可选方法(因为此时其方法时可选的而不是其返回值是可选的)</p>

<pre><code class="language-swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code class="language-swift">class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
    //此处无法确定是否存在dataSource 以及 datasource是否遵循了协议 因此需要两层的可选链式调用
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>

<p>通过可选链式调用可选协议</p>

<p><code>CounterDataSource</code>的简单实现</p>

<pre><code class="language-swift">//继承自OC的NSObject
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

//@objc类
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>

<h2 id="toc_18">协议扩展</h2>

<p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的&quot;实现&quot;.<br/>
此时可以基于协议本身实现这些功能,而不需要给每个遵循协议的类型进行重复的实现或者使用全局函数</p>

<pre><code class="language-swift">//定义一个协议
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
//为协议进行协议扩展
extension RandomNumberGenerator {
    func randomBool() -&gt; Bool {
        return random() &gt; 0.5
    }
}
</code></pre>

<p>所有遵循该协议的类型 都能获得扩展所增加的方法实现</p>

<h3 id="toc_19">提供默认实现</h3>

<p>可以通过协议扩展来为协议中的的要求属性、方法、下标等提供默认实现。<br/>
如果遵循该协议的类型提供了自己的实现,那么这些自定义实现会代替扩展中的默认实现而被使用</p>

<h3 id="toc_20">为协议扩展添加限制条件</h3>

<p>我们上面有条件的遵循了某些协议，除此之外在协议扩展的时候也可以加一些限制条件,此时只有满足这些条件的时候，遵循协议的类型才能获取协议扩展提供的默认实现</p>

<p>将这些限制条件写在扩展协议名字之后,并且使用<code>where</code>字句描述</p>

<pre><code class="language-swift">/**
扩展Collection协议,适用于集合中的元素遵循Equatable协议的情况
*/
extension Collection where Element: Equatable {
    func allEqual() -&gt; Bool {
        for element in self {
            if element != self.first {
                return false
            }
        }
        return true
    }
}
//只有集合中的元素都一致   allEequal方法才返回true
</code></pre>

<blockquote>
<p>注意:</p>

<p>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多、最匹配限制的实现</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15042587690391.html">扩展</a></h1>
			<p class="meta"><time datetime="2017-09-01T17:39:29+08:00" 
			pubdate data-updated="true">09/01/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>扩展</strong>可以为一个已有的类、结构体、枚举类型或者协议类型添加新功能</p>

<p>拥有不需要访问被扩展类型源代码就能完成扩展的能力(即逆向建模)</p>

<blockquote>
<p>注意</p>

<p>Swift的扩展和OC中的分类功能很相似,但是Swift中的分类是没有名字的</p>
</blockquote>

<p><strong>Swift中的扩展可功能</strong>:</p>

<ul>
<li>添加计算型属性和计算类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>

<p>在swift中，甚至可以对协议进行扩展、提供协议其需要的实现，或者添加额外的功能给遵循的类型所使用</p>

<blockquote>
<p>注意</p>

<p>扩展只能添加新的功能不能重写已有功能</p>
</blockquote>

<h2 id="toc_0">扩展语法</h2>

<p>用关键字<code>extension</code>声明扩展:</p>

<pre><code class="language-swift">extension SomeType {
    // 为 SomeType 添加的新功能写到这里
}
</code></pre>

<p>扩展一个已有类型,使其采纳一个或多个协议</p>

<pre><code class="language-swift">extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>

<blockquote>
<p>注意:</p>

<p>对于一个现有类型，如果定义一个扩展来添加新的功能，那么这个类型的所有实例都可以使用这个新功能。包括那些在扩展定以前就存在的实例。</p>
</blockquote>

<h2 id="toc_1">计算型属性</h2>

<pre><code class="language-swift">extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print(&quot;One inch is \(oneInch) meters&quot;)
    // 打印 “One inch is 0.0254 meters”
let threeFeet = 3.ft
print(&quot;Three feet is \(threeFeet) meters&quot;)
    // 打印 “Three feet is 0.914399970739201 meters”
</code></pre>

<p>扩展<code>Double</code>类型,增加计算型属性,实现距离转换<br/>
上面的属性是只读的计算型属性,省略了<code>get</code>关键字</p>

<blockquote>
<p>注意:</p>

<p>可以增加新的计算型属性,但是不能增加存储型属性，也不能为已有属性添加属性观察器</p>
</blockquote>

<h2 id="toc_2">构造器</h2>

<p>扩展可以为已有类型添加新的构造器。</p>

<p>扩展能为<strong>类</strong>添加新的便利构造器,但是不能为类添加新的指定构造器或者析构器。指定构造器和析构器必须由类的原始实现提供</p>

<blockquote>
<p>注意:</p>

<p>如果使用扩展给<strong>值类型</strong>添加构造器只适用于给所有的存储属性提供默认值，并且没有定义任何自定义构造器，那么你将可以在该值类型扩展的构造器中使用默认构造器和逐一成员构造器。但是如果将构造器写在值类型的原始视线中，那么就属于在扩展中添加构造器</p>

<p>如果通过扩展提供一个新的构造器 那么有责任确保每个通过构造器创建的实例都是初始化完整的</p>
</blockquote>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>因为<code>Rect</code>没有指定构造器,存储属性也都有默认值,因此获得一个逐一成员构造器和默认构造器，</p>

<pre><code class="language-swift">extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        //调用结构体的逐一成员构造器
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<h2 id="toc_3">方法</h2>

<p>为已有类型添加新的实例方法和类型方法</p>

<pre><code class="language-swift">extension Int {
    func repetitions(task: () -&gt; Void) {
        for _ in 0..&lt;self {
            task()
        }
    }
}
//为Int类型添加一个名为`repetitions`的实例方法
//这个方法接受一个`()-&gt;Void`类型的单参数，没有参数也没有返回值的函数
</code></pre>

<h3 id="toc_4">可变实例方法</h3>

<p>扩展中添加的实例方法也可以修改该实例本身，对于值类型即结构体或者枚举修改<code>self</code>或其属性的方法就必须将该实例方法标注为<code>mutating</code>(类似原始实现)</p>

<pre><code class="language-swift">extension Int {
    mutating func square() {
        self = self * self
    }
}
</code></pre>

<h2 id="toc_5">下标</h2>

<p>扩展为已有类型添加下标.</p>

<pre><code class="language-swift">extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
        for _ in 0..&lt;digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// 返回 5
746381295[1]
// 返回 9
//取的下标越界时自动用0补充
746381295[9]
// 返回 0，即等同于：
0746381295[9]
</code></pre>

<p>上面的例子为<code>Int</code>增加下标方法，<code>[n]</code>返回十进制数字从右向左数的第<code>n</code>个数字</p>

<h2 id="toc_6">嵌套类型</h2>

<p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型:</p>

<pre><code class="language-swift">extension Int {
    enum Kind {
    case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
</code></pre>

<p>为<code>Int</code>添加了一个嵌套枚举,来表明特定整数的类型，即正数、负数或零</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15042543172572.html">嵌套类型</a></h1>
			<p class="meta"><time datetime="2017-09-01T16:25:17+08:00" 
			pubdate data-updated="true">09/01/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>嵌套类型:</strong>在支持的类型中定义嵌套的枚举、类和结构体</p>

<p>要在一个类型中嵌套另一个类型,将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套</p>

<h2 id="toc_0">嵌套类型实践</h2>

<pre><code class="language-swift">struct BlackjackCard {
    //嵌套的 Suit 枚举//牌的花色
    enum Suit: Character {
        case Spades = &quot;块&quot;, Hearts = &quot;心&quot;, Diamonds = &quot;*&quot;, Clubs = &quot;额&quot;
    }
    //嵌套的 Rank 枚举
    enum Rank: Int {
        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
        case Jack, Queen, King, Ace
        struct Values {//用于反应Ace有两种值，而其他只有一个
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
                case .Ace:
                    return Values(first: 1, second: 11)
                case .Jack, .Queen, .King:
                    return Values(first: 10, second: nil)
                default:
                    return Values(first: self.rawValue, second: nil)
            }
        }
    }
    // BlackjackCard 的属性和方法
    let rank: Rank, suit: Suit
    var description: String {
        var output = &quot;suit is \(suit.rawValue),&quot;
        output += &quot; value is \(rank.values.first)&quot;
        if let second = rank.values.second {
            output += &quot; or \(second)&quot;
        }
        return output
    }
}
</code></pre>

<p><code>BlackjackCard</code>结构体有默认的成员构造器,可以用默认构造器去初始化常量:</p>

<pre><code class="language-swift">/**
尽管Rank和Suit嵌套在BlackjackCard中,类型可以从上下文推断出来,
因此可以用`.Ace 和.Spades`引用枚举实例
*/
let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)
// 打印 “theAceOfSpades: suit is ?, value is 1 or 11”
</code></pre>

<h2 id="toc_1">引用嵌套类型</h2>

<p>当想要在外部引用嵌套类型时，在嵌套类型名前加外部类型的类型名作为前缀</p>

<pre><code class="language-swift">let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
//红心符号
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15037348375137.html">类型转换</a></h1>
			<p class="meta"><time datetime="2017-08-26T16:07:17+08:00" 
			pubdate data-updated="true">08/26/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在<code>Swift</code>中通过<code>is</code>和<code>as</code>操作符来实现<strong>类型转换</strong>，可以来检查值的类型或者转换类型</p>

<p>也可以用它检查一个类型是否实现了某个协议</p>

<blockquote>
<p>注意:</p>

<p>as适用于从子类向上转型，此时一定会转型成功(否则会发生编译错误)<br/>
as? 和 as!用于向下转型，此时不一定转型成功  as!包含了强制解包操作</p>
</blockquote>

<h2 id="toc_0">定义一个类层次作为例子</h2>

<p>在数组中存了一个父类的两个子类的实例</p>

<blockquote>
<p>在数组中存在两种子类类型,会推断这个数组为共同的父类类型<br/>
此时虽然数组中存的是子类类型实例,但是迭代的话取出的实例会为父类类型，此时我们需要判断和转换类型</p>
</blockquote>

<h2 id="toc_1">检查类型</h2>

<p>用类型检查操作符<code>is</code> 检查实例是否属于特定子类型，返回<code>bool</code>值</p>

<pre><code class="language-swift">for item in library {
    if item is Movie { //判断实例是否为 Movie类型
        movieCount += 1
    } else if item is Song { //判断实例是否为 Song类型
        songCount += 1
    }
}
</code></pre>

<h2 id="toc_2">向下转型</h2>

<p>当某类型的实例属于一个子类,可以用<code>as?</code>或者<code>as!</code>将其向下转换位子类类型</p>

<p>因为向下转型可能失败，因此提供<code>as?</code>和<code>as!</code>(带上强制解包操作)，当不确定是否成功时用<code>as?</code> 确定一定成功时<code>as!</code></p>

<pre><code class="language-swift">for item in library {
    if let movie = item as? Movie {
        print(&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    } else if let song = item as? Song {
        print(&quot;Song: &#39;\(song.name)&#39;, by \(song.artist)&quot;)
    }
}
</code></pre>

<p><code>if let movie = item as? Movie</code>尝试将<code>item</code>转为<code>Movie</code>类型。若成功，设置一个新的临时常量<code>movie</code>来存储返回的可选<code>Movie</code>中的值</p>

<blockquote>
<p>注意</p>

<p>转换并没有真的改变实例和它的值。根本的保持实力保持不变；只是简单的把它作为它被转换成的类型来使用</p>
</blockquote>

<h2 id="toc_3">Any和AnyObject的类型转换</h2>

<p>不确定类型的表达方式:</p>

<ol>
<li><code>Any</code>可以表示任何类型，包括函数类型。</li>
<li><code>AnyObject</code>可以表示任何<strong>类类型</strong>的实例</li>
</ol>

<p>建议只在确定需要使用时才使用<code>Any</code>和<code>AnyObject</code></p>

<pre><code class="language-swift">var things = [Any]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append(&quot;hello&quot;)
things.append((3.0, 5.0))
things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;))
things.append({ (name: String) -&gt; String in &quot;Hello, \(name)&quot; })
</code></pre>

<p>然后我们可以在<code>switch</code>表达式的</p>

<pre><code class="language-swift">for thing in things {
    switch thing {
    case 0 as Int:
        print(&quot;zero as an Int&quot;)
    case 0 as Double:
        print(&quot;zero as a Double&quot;)
    case let someInt as Int:
        print(&quot;an integer value of \(someInt)&quot;)
    case let someDouble as Double where someDouble &gt; 0:
        print(&quot;a positive double value of \(someDouble)&quot;)
    case is Double:
        print(&quot;some other double value that I don&#39;t want to print&quot;)
    case let someString as String:
        print(&quot;a string value of \&quot;\(someString)\&quot;&quot;)
    case let (x, y) as (Double, Double):
        print(&quot;an (x, y) point at \(x), \(y)&quot;)
    case let movie as Movie:
        print(&quot;a movie called &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    case let stringConverter as String -&gt; String:
        print(stringConverter(&quot;Michael&quot;))
    default:
        print(&quot;something else&quot;)
    }
}
// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of &quot;hello&quot;
// an (x, y) point at 3.0, 5.0
// a movie called &#39;Ghostbusters&#39;, dir. Ivan Reitman
// Hello, Michael
</code></pre>

<blockquote>
<p>注意</p>

<p><code>Any</code>是可以表示所有类型的值,包括可选类型,当你在用<code>Any</code>类型来表示一个可选值时,会给出警告，此时可以用<code>as</code>操作符显示转换为<code>Any</code></p>
</blockquote>

<pre><code class="language-text">let optionalNumber: Int? = 3
things.append(optionalNumber) // 会有警告
things.append(optionalNumber as Any) // 没有警告
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15034731740974.html">错误处理</a></h1>
			<p class="meta"><time datetime="2017-08-23T15:26:14+08:00" 
			pubdate data-updated="true">08/23/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><strong>错误处理</strong>就是响应错误以及从错误中回复的过程</p>

<p><code>Swift</code>提供了运行时对可恢复错误的抛出、捕获、传递和操作等的支持<br/>
通常用来区分失败情况,让程序解决并处理某些错误，把解决不了的错误报告给用户</p>

<h2 id="toc_0">表示并抛出错误</h2>

<p><code>Swift</code>中 错误用符合<code>Error</code>协议的类型值来表示，这个空协议表明该类型可以用于错误处理</p>

<p>通常用枚举类型来构建一组相关的错误状态,枚举的关联值可以提供错误状态的额外信息</p>

<p>使用关键字<code>throw</code>关键字来抛出一个错误，表示有意外发生</p>

<pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection //选择无效
    case insufficientFunds(coinsNeeded: Int) //金额不足
    case outOfStock //缺货
}

throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre>

<h2 id="toc_1">处理错误</h2>

<p><code>Swift</code>中有<code>4</code>种处理错误的方式<br/>
1.把函数抛出的错误传递给调用此函数的代码<br/>
2.用<code>do-catch</code>语句处理错误<br/>
3.将错误作为可选类型处理<br/>
4.断言此错误根本不会发生</p>

<p>当一个函数抛出错误是，程序流程发生改变，所以重要的是能迅速识别代码中抛出错误的地方。为了标识这些地方，在调用一个能跑出错误的函数、方法或者构造器之前，加上<code>try</code>关键字，或者<code>try?</code>或<code>try!</code>这种变体。</p>

<blockquote>
<p>注意:</p>

<p>Swift中的错误处理和其他语言的<code>try</code>、<code>catch</code>、<code>throw</code>进行异常处理很像。但是和其他语言(包括OC)的异常处理不同的是<code>swift</code>的错误处理不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，<code>throw</code>语句的性能特点是可以和<code>return</code>语句相媲美的</p>
</blockquote>

<h3 id="toc_2">用throwing函数传递错误</h3>

<p>在函数声明的参数列表后加上<code>throws</code>关键字，表明可以抛出错误，这个函数就称为<code>throwing</code>函数<br/>
如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面</p>

<p>throw语句执行会立即退出方法</p>

<pre><code class="language-swift">func canThrowErrors() throws -&gt; String
func cannotThrowErrors() -&gt; String
</code></pre>

<p><code>throwing</code>函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p>

<blockquote>
<p>注意:</p>

<p>对于<code>throwing</code>函数可以传递错误,非<code>throwing</code>函数抛出的错误只能在函数内部处理</p>
</blockquote>

<pre><code class="language-swift">struct Item {
    var price: Int
    var count: Int
}
class VendingMachine {
    var inventory = [
                     &quot;Candy Bar&quot;: Item(price: 12, count: 7),
                     &quot;Chips&quot;: Item(price: 10, count: 4),
                     &quot;Pretzels&quot;: Item(price: 7, count: 11)
                     ]
    var coinsDeposited = 0
    func dispenseSnack(snack: String) {
        print(&quot;Dispensing \(snack)&quot;)
    }
    //throwing函数 会抛出VendingMachineError错误
    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.InvalidSelection
        }
        guard item.count &gt; 0 else {
            throw VendingMachineError.OutOfStock
        }
        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }
        coinsDeposited -= item.price
        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem
        print(&quot;Dispensing \(name)&quot;)
    }
}
</code></pre>

<p>使用了<code>guard</code>语句来提前退出方法，因为<code>throw</code>语句会立即退出方法，保证只有在满足所有条件时才成功卖出商品</p>

<p><code>vend(itemNamed:)</code>会传递它抛出的所有错误,因此在跳用这个方法时，要么直接处理这些错误(<code>do-catch</code>语句,<code>try?</code>或<code>try!</code>)，要么类似下面函数将错误继续传递下去</p>

<pre><code class="language-swift">let favoriteSnacks = [
    &quot;Alice&quot;: &quot;Chips&quot;,
    &quot;Bob&quot;: &quot;Licorice&quot;,
    &quot;Eve&quot;: &quot;Pretzels&quot;,
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;
    try vendingMachine.vend(itemNamed: snackName)
}
//传似抛出的错误
</code></pre>

<p><code>buyFavoriteSnack</code>方法会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法尝试购买,通过在<code>vend(itemNamed:)</code>方法前加<code>try</code>关键字</p>

<p><code>throwing</code>构造器和<code>throwing</code>一样可以传递错误</p>

<pre><code class="language-swift">struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
</code></pre>

<h3 id="toc_3">用Do-Catch处理错误</h3>

<p><strong><code>do-catch</code>语句运行一段<code>闭包</code>代码来处理错误</strong></p>

<p>在<code>do</code>语句抛出一个错误,与<code>catch</code>中的字句匹配</p>

<pre><code class="language-swift">do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</code></pre>

<p><code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误.如果<code>catch</code>没有指定错误模式，那就可以匹配任何错误，并且把错误绑定到名字为<code>error</code>的局部变量</p>

<p><code>catch</code>不必处理抛出的所有错误,错误可以传递到周围,但是必须被处理，可以使外围的<code>do-catch</code>语句 或者是一个<code>throwing</code>函数进行处理</p>

<p>注意:<br/>
在<code>do</code>语句中的<code>try</code>如果有抛出错误就立刻执行<code>catch</code>语句,并判断这个错误是否要被继续传递下去,否则执行<code>do</code>子句中余下的语句</p>

<h3 id="toc_4">将错误转换成可选值</h3>

<p>通过<code>try?</code>将错误转换为一个可选值,如果表达式有错误抛出,那么表达式的值就为<code>nil</code></p>

<pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()
//等效于
let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>

<p>此时不论<code>someThrowingFunction()</code>返回值是什么类型,x，y就是该返回值类型的可选类型</p>

<h3 id="toc_5">禁用错误传递</h3>

<p>当我们确定知道某个<code>throwing</code>函数在运行时是不会抛出错误的,那么可以用<code>tr<br/>
y!</code>来禁用错误传递，它会将调用包装在一个不会有错误抛出的运行时断言中</p>

<h2 id="toc_6">指定清理操作</h2>

<p><code>defer</code>语句在即将离开当前代码块时执行一系列语句，来执行一些必要的清理工作，而不管你是由于哪种方式离开代码块</p>

<ul>
<li><code>defer</code>语句将代码执行延迟到当前作用域退出之前。</li>
<li>该语句由<code>defer</code>关键字和要延时执行的语句组成</li>
<li>延迟执行的语句不能包含任何控制转移语句例如return、break，或是抛出一个错误。</li>
<li>延时执行的操作会按照他们被指定时的顺序的相反顺序执行(第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行)</li>
</ul>

<pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // 处理文件。
        }
        // close(file) 会在这里被调用，即作用域的最后。
    }
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14896343426276.html">专用图层</a></h1>
			<p class="meta"><time datetime="2017-03-16T11:19:02+08:00" 
			pubdate data-updated="true">03/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>是Core Animation图层不仅仅能作用于图片和颜色而已。</p>

<p>补充点:<br/>
想UIView的图层上添加另外一个UIView的图层是会有两个UIVIew的（UIView的层级关系）<br/>
像一个纯Layer上添加另外一个UIView的图层,就仅仅只是添加了这个视图的图层,这个视图不会在视图的层级关系中体现.</p>

<h3 id="toc_0">CAShapeLayer</h3>

<p><code>CAShapeLayer</code> 是一个通过矢量图形而不是<code>bitmap</code>来绘制的图层子类.<br/><br/>
即<code>CAShapeLayer</code>与<code>CGPath</code>搭配来绘制图形.与用<code>Core Graphics</code>直接向原始的<code>CALyer</code>的内容中绘制一个路径相比：  </p>

<ul>
<li>渲染快速（ CAShapeLayer 使用了硬件加速）</li>
<li>高效使用内存（CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形）</li>
<li>不会被图层边界剪裁掉（CAShapeLayer 可以在边界之外绘制）</li>
<li>不会出现像素化（当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化）</li>
</ul>

<h4 id="toc_1">CGPath</h4>

<p><code>CGPath</code>来创建形状,一定要闭合,可以设置一些属性lineWith、lineCap 、lineJoin等,但是一个图层只有一次机会设置,如果想要想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。  </p>

<pre><code class="language-objectivec">//create shape layer
CAShapeLayer *shapeLayer = [CAShapeLayer layer];
shapeLayer.strokeColor = [UIColor redColor].CGColor;
shapeLayer.fillColor = [UIColor clearColor].CGColor;
shapeLayer.lineWidth = 5;
shapeLayer.lineJoin = kCALineJoinRound;
shapeLayer.lineCap = kCALineCapRound;
shapeLayer.path = path.CGPath;
</code></pre>

<h4 id="toc_2">圆角</h4>

<p>我们虽然可以用<code>CALayer</code>的<code>cornerRadius</code>可以设置圆角，但是我使用<code>CAShapeLayer</code>来单独指定每个角的形状.</p>

<pre><code class="language-objectivec">CGRect rect = CGRectMake(50, 50, 100, 100);
CGSize radii = CGSizeMake(20, 20);
UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;
//create path
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
</code></pre>

<p>然后我们可以通过这个图层路径绘制一个既有直角又有圆角的视图,如果我们想依照此图形来剪裁视图内容，我们可以把<strong><code>CAShapeLayer</code>作为视图的宿主图层</strong>，而不是添加一个子视图</p>

<h3 id="toc_3">CATextLayer</h3>

<p>如果我们想要在一个图层中显示文字,我们可以通过借助图层的代理,直接将字符串用<code>Core<br/>
Graphics</code>写入图层的内容--&gt;这就是UILabel实现  </p>

<p>如果不用上面的方式,我们还有比较简单的方式:<br/>
<code>Core Animation</code>提供了一个<code>CALayer</code>的子类<code>CATextLayer</code>，它以图层的形式包含了<code>UILabel</code>几乎所有的绘制特性，并且额外提供了一些新的特性。而且<code>CATextLayer</code>也要比 <code>UILabel</code> 渲染得快得多</p>

<pre><code class="language-objectivec">CATextLayer *textLayer = [[CATextLayer alloc] init];
    textLayer.frame = self.textLayerView.bounds;
    [self.textLayerView.layer addSublayer:textLayer];
    //用retina屏进行渲染,否则文字会像素化
    textLayer.contentsScale = [UIScreen mainScreen].scale;
    //颜色 默认黑色
    textLayer.foregroundColor = [UIColor yellowColor].CGColor;
    
    textLayer.alignmentMode = kCAAlignmentJustified;
    
    //这个属性为yes后为根据内容进行多行显示,Yes就是一行
    textLayer.wrapped = NO;
    
    UIFont *font = [UIFont systemFontOfSize:15];
    CFStringRef fontName = (__bridge CFStringRef)(font.fontName);
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    textLayer.font = fontRef;
    //字体大小是单独设置的
    textLayer.fontSize = 10;
    //设置显示字体
    textLayer.string = @&quot;zhe shi yi ge textLayer&quot;;
</code></pre>

<p><code>CATextLayer</code> 的 <code>font</code> 属性不是一个 <code>UIFont</code> 类型，而是一个 <code>CFTypeRef</code> 类型。这样可以根据你的具体需要来决定字体属性应该是用 <code>CGFontRef</code> 类型还是 <code>CTFontRef</code> 类型（<code>Core Text</code>字体）。</p>

<p>因为 <code>CTFontRef</code> 和 <code>CGFontRef</code> 并不像UIFont一样包含点大小，因此我们需要<strong>单独设置字体大小</strong>;</p>

<p>CATextLayer 的<code>string</code>属性是<code>id</code>类型的，因此我们可以用<code>NSString</code>和<code>NSAttributedString</code>来指定文本。  <strong>注意</strong>， <code>NSAttributedString</code> 并不是 <code>NSString</code> 的子类。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>

<h4 id="toc_4">富文本</h4>

<p>iOS6之后，苹果给UILabel和UIKit添加直接的属性字符串支持.从iOS3.2开始 CATextLayer 就已<br/>
经支持属性化字符串了(可以这样支持低版本 不过他吗太低了吧)。<br/><br/>
我们可以看下CATextLayer的富文本:</p>

<pre><code class="language-objectivec">//convert UIFont to a CTFont
CFStringRef fontName = (__bridge CFStringRef)font.fontName;
CGFloat fontSize = font.pointSize;
CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);

//set text attributes
NSDictionary *attribs = @{(__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor, 
(__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
[string setAttributes:attribs range:NSMakeRange(0, [text length])];

attribs = @{(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,
(__bridge id)kCTUnderlineStyleAttributeName:@(kCTUnderlineStyleSingle),(__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
[string setAttributes:attribs range:NSMakeRange(6, 5)];
//release the CTFont we created earlier
CFRelease(fontRef);
//set layer text
textLayer.string = string;

</code></pre>

<h4 id="toc_5">行距和字距</h4>

<p>由于绘制的实现机制不同（<code>Core Text</code>和<code>WebKit</code>），用 <code>CATextLayer</code> 渲染和用 <code>UILabel</code> 渲染出的文本行距和字距也不是不尽相同的。(影响不大)</p>

<h4 id="toc_6">UILabel替代品</h4>

<p>CATextLayer 比 UILabel 有着更好的性能表现,虽然UILabel很好用,但是如果我们非要找个UILabel替代品的话,有以下方法:</p>

<ol>
<li><p>继承 UILabel后添加一个子图层 CATextLayer 并重写显示文本的方法。<br/>
但是仍然会有由<code>UILabel</code>的<code>-drawRect:</code>方法创建的空寄宿图。而且由于CALayer不能自动布局,我们不能根据内容自动方法图层.</p></li>
<li><p>用 CATextLayer 作为宿主图层的 UILabel 子类<br/>
每一个 <code>UIView</code> 都是寄宿在一个 <code>CALayer</code> 的示例上。这个图层是由视图自动创建和管理的，这个图层一旦被创建就无法替代,但是我们可以继承了<code>UIView</code>，重写其<code>+layerClass</code>UIView 会在初始化的时候调用 +layerClass 方法，然后用它的返回类型来创建宿主图层。</p></li>
</ol>

<p>把 CATextLayer 作为宿主图层的另一好处就是视图自动设置了 contentsScale 属性。</p>

<p><strong>用 <code>+layerClass</code> 来创建基于不同图层的视图是一个简单可复用的方法</strong></p>

<h3 id="toc_7">CATransformLayer</h3>

<p>我们之前说过所有图层都把他的子图层平面化到一个场景中,因此没法做出3D的层级体系变换.<code>CALayer</code>中存在<code>CATransfromLayer</code>，它不同于一般图层，它不显示自己内容，只有当存在了一个能作用于子图层的变换它才真正存在。</p>

<p>我们在前面创建过一个立方体的固体对象,但是因为这次我们是向CATransformLayer上添加图层，而不是之前的<code>contaninView</code>,我们<strong>不能向一个没有寄宿图的图层上添加有寄宿图图层</strong>(就是不能向一个不是UIVIew的Layer中添加另外一个UIView的layer，否则在视图体系中显示的添加的这个不是视图而是图层),因此我们选择向<code>CATransfromLayer</code>添加立方体图层.</p>

<pre><code class="language-objectivec">//举一段代码栗子
//create cube layer
CATransformLayer *cube = [CATransformLayer layer];
//add cube face 1（添加立方体的一个面）
CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);
//[self faceWithTransform:ct] 这个方法根据Transform3D返回了一个这种变换的图层
[cube addSublayer:[self faceWithTransform:ct]];
//添加6个面后
...
//center the cube layer within the container
CGSize containerSize = self.containerView.bounds.size;
cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
/**
设置这个立方体的旋转（我们可以不用设置containerView的subTransform属性来进行立方体变换,而且可
以有几个立方体就能变换几种）
*/
cube.transform = transform;

//设置contaninView的sublayerTransform保证透视和灭点
CATransform3D pt = CATransform3DIdentity;
pt.m34 = -1.0 / 500.0;
self.containerView.layer.sublayerTransform = pt;
//将不同形状的cube添加
[self.containerView.layer addSublayer:cube1];
</code></pre>

<h3 id="toc_8">CAGradientLayer</h3>

<p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的（绘制使用了硬件加速）.<br/>
<code>CAGradientLayer</code>只适合做这种渐变没法定制,例如做环形渐变等,那样的话只能用<code>Core Graphic</code>了</p>

<h4 id="toc_9">基础渐变</h4>

<p>这是最简单的渐变,这些渐变色彩放在一个数组中，并赋给<code>colors</code>(<code>CGColorRef</code>类型)属性。</p>

<p>CAGradientLayer 也有<code>startPoint</code>和<code>endPoint</code>属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。</p>

<pre><code class="language-objectivec">CAGradientLayer *gradientLayer = [CAGradientLayer layer];
gradientLayer.frame = self.containerView.bounds;
[self.containerView.layer addSublayer:gradientLayer];
//set gradient colors
gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];
//set gradient start and end points
gradientLayer.startPoint = CGPointMake(0, 0);
gradientLayer.endPoint = CGPointMake(1, 1);
</code></pre>

<p><img src="media/14896343426276/14897191786083.jpg" alt=""/></p>

<h4 id="toc_10">多重渐变</h4>

<p><code>colors</code>属性是个数组,因此可以设置很多颜色的多重渐变.默认这些颜色在我们指定的空间是均匀渲染的,但是我们可以设置<code>location</code>属性来调整空间。<br/>
<code>location</code>属性浮点型数组(以<code>NSNumber</code>包装),是以单位坐标(针对做渐变区域的单位坐标)系进行标定。0.0代表着渐变的开始，1.0代表着结束。<br/>
<code>loaction</code>属性不一定非要设置,但是如果设置了,数组大小一定要与<code>colors</code>数组大小相同,否则会得到白色渐变.  </p>

<pre><code class="language-objectivec">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor blueColor].CGColor,(__bridge id)[UIColor greenColor].CGColor];
/**
    这个数组的意义是0.0-0.25为红色到黄色的渐变区域,0.25-0.5为黄色到绿色的渐变区域,
    0.5之后为绿色的完全区域
*/
    gradientLayer.locations = @[@(0.1),@(0.5),@(0.9)];
    gradientLayer.startPoint = CGPointMake(0.25, 0.25);
    gradientLayer.endPoint = CGPointMake(0.5, 0.5);
</code></pre>

<p><img src="media/14896343426276/14897305344880.jpg" alt=""/></p>

<h3 id="toc_11">CAReplicatorLayer</h3>

<p><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>

<h4 id="toc_12">重复图层</h4>

<p><code>instanceCount</code>属性指定了图层需要重复多少次<br/>
<code>instanceTransform</code> 指定了一个 <code>CATransform3D</code> 3D变换，复制图层在被创建时产生的和上一个制图层的位移(位移的锚点是<code>CAReplicatorlayer</code>的中心点)<br/>
<code>instanceDelay</code>在短时间内的复制延时,一般用在动画上(支持动画的延时)<br/>
 <code>preservesDepth</code>如果设置为YES,图层将保持于CATransformLayer类似的性质和相同的限制<br/>
 <code>instanceColor</code>设置这些复制图层的颜色,默认位白色(注意有可能会和要复制的图层的颜色冲突)<br/>
 变换是逐步增加的，每个实例都是相对于前一实例布局。因此这些复制体最终不会出现在同一位置上</p>

<pre><code class="language-objectivec">CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
replicator.frame = self.containerView.bounds;
[self.containerView.layer addSublayer:replicator];
//重复多少次
replicator.instanceCount = 10;

CATransform3D transform = CATransform3DIdentity;
transform = CATransform3DTranslate(transform, 0, 200, 0);
transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
transform = CATransform3DTranslate(transform, 0, -200, 0);
replicator.instanceTransform = transform;

replicator.instanceBlueOffset = -0.1;
replicator.instanceGreenOffset = -0.1;

CALayer *layer = [CALayer layer];
layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
layer.backgroundColor = [UIColor whiteColor].CGColor;
[replicator addSublayer:layer];

</code></pre>

<p>由于我们设置了<code>instanceBlueOffset</code>和 <code>instanceGreenOffset</code>属性.的颜色也在变化.除了这两个还有<code>instanceBlueOffset</code> <code>instanceAlphaOffset</code>这都是改变某个颜色通道的值</p>

<p><code>CAReplicatorLayer</code> 真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了 <code>CAEmitterLayer</code> ，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：<code>反射</code>。</p>

<h4 id="toc_13">反射</h4>

<p>创建一个指定视图的镜像照片,我们只需要使用<code>CAReplicatorLayer</code>并用一个负比例变换创建一个复制图层即可.</p>

<pre><code class="language-objectivec">+ (Class)layerClass
{
return [CAReplicatorLayer class];
}
- (void)setUp
{
//configure replicator
CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;
layer.instanceCount = 2;
//move reflection instance below original and flip vertically
//核心代码是这个动画
CATransform3D transform = CATransform3DIdentity;
CGFloat verticalOffset = self.bounds.size.height + 2;
transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
transform = CATransform3DScale(transform, 1, -1, 0);
layer.instanceTransform = transform;
//reduce alpha of reflection layer
layer.instanceAlphaOffset = -0.6;
}
- (id)initWithFrame:(CGRect)frame
{
//this is called when view is created in code
if ((self = [super initWithFrame:frame])) {
[self setUp];
}
return self;
}
- (void)awakeFromNib
{
//this is called when view is created from a nib
[self setUp];
}
</code></pre>

<p>这个镜像的是整个ReflectView视图内容(是视图层次)<br/>
因为现在这个VIew的layer已经变为<code>CAReplicatorLayer</code>所以我们对这个layer本身改变什么是不会镜像的,当然如果add的Layer内容也会被镜像</p>

<p>大神写的自适应渐变淡出效果的<a href="https://github.com/nicklockwood/ReflectionView">ReflectView</a></p>

<h3 id="toc_14">CAScrollLayer</h3>

<p>之前我们显示大图层中的一小部分是使用图层的<code>contentRect</code>属性,但是如果我们想要滑动可视区域的话这样就不是很好的办法.</p>

<p><code>CALayey</code>提供了一个子类<code>CAScrollLayer</code>.<br/>
 <code>CAScrollLayer</code> 有一个 <code>-scrollToPoint:</code>方法，它自动适应 <code>bounds</code> 的原点以便图层内容现在滑动的地方。</p>

<p>因为<code>Core Animation</code>是不处理用户输入的,所以<code>CAScrollLayer</code>并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹.</p>

<pre><code class="language-objectivec">//来用 CAScrollLayer 来常见一个基本的 UIScrollView 替代品
+ (Class)layerClass
{
    return [CAScrollLayer class];
}
//添加平移手势
//在平移手势中滚动视图
CGPoint offset = self.bounds.origin;
offset.x -= [recognizer translationInView:self].x;
offset.y -= [recognizer translationInView:self].y;
//scroll the layer
[(CAScrollLayer *)self.layer scrollToPoint:offset];
//reset the pan gesture translation
[recognizer setTranslation:CGPointZero inView:self];
//当然我们可以自己做边界检查
</code></pre>

<p>其实<strong><code>UIScrollView</code> 并没有用 <code>CAScrollLayer</code></strong>，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>

<p>那么这个<code>CAScrollLayer</code>的作用是什么呢?<br/>
在<code>CAScrollerLayer</code>的头文件中有一个<code>CALayer (CALayerScrolling)</code>的扩展分类,实现了一些：</p>

<pre><code class="language-objectivec">- (void)scrollPoint:(CGPoint)p;
- (void)scrollRectToVisible:(CGRect)r;
@property(readonly) CGRect visibleRect;
</code></pre>

<p>其实这些方法或者属性并不是给<code>CALayer</code>添加了滑动功能,事实上他们只是放置在<code>CAScrollLayer</code>中的图层的实用方法,<code>scrollPoint:</code>方法从图层树中查找并找到第一个可用的<code>CAScrollLayer</code>，然后滑动它使得指定点成为可视的。<code>scrollRectToVisible:</code>方法实现了同样的事情只不过是作用在一个矩形上的。<code>visibleRect</code> 属性决定图层（如果存在的话）的哪部分是当前的可视区域。当涉及到实现图层滑动的时候就可以用上了</p>

<h3 id="toc_15">CATiledLayer</h3>

<p>我们有可能会需要加载一张高像素图片,这时候我们不适合读取整张图片到内存中,因为载入大图会非常的慢,将会阻塞线程造成卡顿.<br/>
能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为<code>OpenGL</code>纹理，同时<code>OpenGL</code>有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为<code>Core Animation</code>强制用CPU处理图片而不是更快的GPU</p>

<p>这时候我们可以用<code>CATiledLayer</code>,它可以将大图分解成小片然后将他们单独按需载入<br/>
<strong>CATiledLayer 很好地和 UIScrollView 集成在一起。</strong></p>

<pre><code class="language-objectivec">- (void)viewDidLoad
{
    [super viewDidLoad];
    //add the tiled layer
    
    /**
    CATiledLayer 很好地和 UIScrollView 集成在一起。除了设置图层和滑动视图边界
    以适配整个图片大小，我们真正要做的就是实现 -drawLayer:inContext: 方法，当
    需要载入新的小图时， CATiledLayer 就会调用到这个方法。
    */
    
    CATiledLayer *tileLayer = [CATiledLayer layer];
    tileLayer.frame = CGRectMake(0, 0, 2048, 2048);
    tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];
    //configure the scroll view
    self.scrollView.contentSize = tileLayer.frame.size;
    //draw layer
    [tileLayer setNeedsDisplay];
}
- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //determine tile coordinate
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);
    //load tile image
    NSString *imageName = [NSString stringWithFormat: @&quot;Snowman_%02i_%02i&quot;, x, y];
    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;jpg&quot;];
    
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];
    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:bounds];
    UIGraphicsPopContext();
}
</code></pre>

<p><code>CATiledLayer</code> 的默认以淡入的方式载入小图,可以用 <code>fadeDuration</code> 属性改变淡入时长或直接禁用<br/>
掉。</p>

<p><code>CATiledLayer</code> （不同于大部分的<code>UIKit</code> 和<code>Core Animation</code>方法）支持多线程绘制，<code>-drawLayer:inContext:</code>方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。</p>

<p><strong>补充</strong><br/>
我们在使用<code>CATiledLayer *tileLayer = [CATiledLayer layer];</code>时载入图片并不是以以Retina的分辨率显示,我们可以<code>tileLayer.contentsScale = [UIScreen mainScreen].scale;</code>我们只需要设<br/>
置了<code>CATiledLayer</code>的<code>contentsScale</code>即可(因为size是以像素为单位的,所以改变了contentsScale 就自动有了默认的小图尺寸),而不需要手工更新小图的尺寸或是在<code>Retina</code>分辨率下指定一个不同的小图。</p>

<p>我们需要做的是适应小图渲染代码以对应安排 <code>scale</code>的变化</p>

<pre><code class="language-objectivec">CGRect bounds = CGContextGetClipBoundingBox(ctx);
CGFloat scale = [UIScreen mainScreen].scale;
NSInteger x = floor(bounds.origin.x / layer.tileSize.width * scale);
NSInteger y = floor(bounds.origin.y / layer.tileSize.height * scale);
</code></pre>

<h3 id="toc_16">CAEmitterLayer</h3>

<p>iOS后引入了一个新的 <code>CALayer</code> 子类叫做 <code>CAEmitterLayer</code><br/>
<code>CAEmitterLayer</code> 是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果</p>

<p><code>CAEmitterLayer</code>是很多<code>CAEmitterCell</code>的容器.这些<code>CAEmitierCell</code>定义了一个粒子效果.我们就是为不同的粒子效果定义一个或多个<code>CAEmitterCell</code>作为模版，同时<code>CAEmitterLayer</code>负责基于这些模版实例化一个粒子流。</p>

<p><code>CAEmitterCell</code>它有一个<code>contents</code>属性可以定义为一个<code>CGImage</code>，还有一些可设置属性控制着表现和行为。<br/>
举个栗子:</p>

<pre><code class="language-objectivec">- (void)viewDidLoad
{
    [super viewDidLoad];
    //create particle emitter layer
    CAEmitterLayer *emitter = [CAEmitterLayer layer];
    emitter.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:emitter];
    //configure emitter
    emitter.renderMode = kCAEmitterLayerAdditive;
    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);
    //create a particle template
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
    cell.alphaSpeed = -0.4;
    cell.velocity = 50;
    cell.velocityRange = 50;
    cell.emissionRange = M_PI * 2.0;
    //add particle template to emitter
    emitter.emitterCells = @[cell];
}
@end
</code></pre>

<p><code>CAEMitterCell</code>的属性基本上可以分为三种：</p>

<ul>
<li>这种粒子某一属性的初始值。比如，<code>color</code>属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</li>
<li>粒子某一属性的变化范围。比如<code>emissionRange</code>属性的值是2π，这意味着粒子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</li>
<li>指定值在时间线上的变化。比如，在示例中，我们将<code>alphaSpeed</code>设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐消失的效果。</li>
</ul>

<p><code>CAEmitterLayer</code>的属性它自己控制着整个例子系统的位置和形状。一些属性比如 <code>birthRate</code>， <code>lifetime</code>和<code>celocity</code>，这些属性在<code>CAEmitterCell</code>中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。</p>

<ul>
<li><code>preservesDepth</code>，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</li>
<li><code>renderMode</code>，控制着在视觉上粒子图片是如何混合的。示例中我们把它设置为<code>kCAEmitterLayerAdditive</code> ，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的<code>kCAEmitterLayerUnordered</code>，效果就没那么好看了</li>
</ul>

<p><strong>注意</strong><br/>
之前我们学习了<code>CAReplicatorLayer</code> 它的真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云,或者反射等</p>

<h3 id="toc_17">CAEAGLLayer</h3>

<p>再议</p>

<h3 id="toc_18">AVPlayerLayer</h3>

<p>它不是<code>Core Animation</code>框架的一部分，是在<code>AVFoundation</code>框架中的,但是它，提供了一个<code>CALayer</code> 子类来显示自定义的内容类型.</p>

<p><code>AVPlayerLayer</code> 是用来在iOS上播放视频的。他是高级接口例如<code>MPMoivePlayer</code>的底层实现，提供了显示视频的底层控制。</p>

<p><code>AVPlayerLayer</code>的使用相当简单：你可以用<code>+playerLayerWithPlayer:</code>方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用<code>player</code>属性绑定一个<code>AVPlayer</code>实例。</p>

<pre><code class="language-objectivec">- (void)viewDidLoad
{
    [super viewDidLoad];
    //get video URL
    NSURL *URL = [[NSBundle mainBundle] URLForResource:@&quot;Ship&quot; withExtension:@&quot;mp4&quot;];
    //create player and player layer
    AVPlayer *player = [AVPlayer playerWithURL:URL];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
    //set player layer frame and attach it to our view
    playerLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:playerLayer];
    //play the video
    [player play];
}
</code></pre>

<p><strong>注意</strong><br/>
因为Core Animation并不支持自动大小和自动布局,因此我们要考虑<code>AVPlayerLayer</code>添加到自己创建的视图View而不是直接加到控制器的View</p>

<p>因为<code>AVPlayerLayer</code>是<code>CALayer</code>的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频(我们可以对Layer进行3D，圆角，有色边框，蒙板，阴影等)。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_21.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_19.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>