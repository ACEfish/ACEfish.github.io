
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  iOS编译流程 - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15554889031358.html">otool命令</a></h1>
			<p class="meta"><time datetime="2019-04-17T16:15:03+08:00" 
			pubdate data-updated="true">04/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	

		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541067561617.html">Link Map File && dSYM</a></h1>
			<p class="meta"><time datetime="2019-04-01T16:19:16+08:00" 
			pubdate data-updated="true">04/01/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>学习自 <a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM">深入剖析iOS编译</a></p>

<h2 id="toc_0">编译后生成的二进制内容 Link Map File</h2>

<p>在<code>build Setting</code>里设置<code>Write Link Map File</code>为Yes后，每次编译都会在指定目录生成这样一个文件。文件内容包含了<code>Object files</code>，<code>Sections</code>，<code>Symbols</code></p>

<h3 id="toc_1">Object files</h3>

<p>这部分内容都是.m编译后的.o和需要link的.a文件。前面是文件编号，后面是文件路径</p>

<pre><code class="language-c">[  2] /Users/fish/Library/Developer/Xcode/DerivedData/RSSReader-dguiqpuhzqvuwbewcrithsiyuewj/Build/Intermediates.noindex/RSSReader.build/Debug-iphonesimulator/RSSReader.build/Objects-normal/x86_64/UIView+Extension.o
...
...
...
[160] /Users/fish/Library/Developer/Xcode/DerivedData/RSSReader-dguiqpuhzqvuwbewcrithsiyuewj/Build/Products/Debug-iphonesimulator/libPods-RSSReader.a(Pods-RSSReader-dummy.o)
</code></pre>

<h3 id="toc_2">Sections</h3>

<p>描述每个Section在可执行文件中的位置和大小。每个Section的Segment类型分为__TEXT代码段和__DATA数据段两种</p>

<p><img src="media/15541067561617/15541075745329.jpg" alt="" style="width:698px;"/><br/>
.data数据段里面保存的都是初始化过的全局静态变量和局部静态变量。.rodata段存放的是只读数据，一般都是const修饰的变量和字符串常量。.bss段存放的是未初始化的全局变量和局部静态变量。代码段就在.text段。</p>

<h3 id="toc_3">Symbols</h3>

<p>symbols对Sections进行了再划分。这里会描述所有的method、ivar和字符串，以及对应的地址、大小、文件编号信息等</p>

<p><img src="media/15541067561617/15541077442023.jpg" alt="" style="width:650px;"/><br/>
<img src="media/15541067561617/15541077540760.jpg" alt="" style="width:732px;"/></p>

<h2 id="toc_4">每次编译后生成的dSYM文件</h2>

<p>在每次编译后都会生成dSYM文件，程序在执行中通过地址来调用方法函数，而dSYM文件里存储了函数地址映射，这样调用栈里的地址可以通过dSYM这个映射表获取具体函数的位置。常用来处理crash时获取到的调用栈.crash文件，将其符号化</p>

<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>

<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令</p>

<pre><code class="language-objectivec">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer
symbolicatecrash appName.crash appName.app &gt; appName.log
</code></pre>

<blockquote>
<p>debug环境默认不生成dsym文件，release环境才会生成</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541064037153.html">Swift编译流</a></h1>
			<p class="meta"><time datetime="2019-04-01T16:13:23+08:00" 
			pubdate data-updated="true">04/01/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Swift编译流和Clang一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。</p>

<pre><code class="language-swift">//生成程序
swiftc toy.swift

//生成检查 AST
swiftc -dump-ast toy.swift

//可以还原之前函数名
swiftc -emit-silgen toy.swift | xcrun swift-demangle

//llvm ir 和汇编的生成
swiftc -emit-ir toy.swift
swiftc -emit-assembly toy.swift

//生成可执行的脚本
xcrun -sdk macosx swiftc toy.swift -o toy
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541023147431.html">LLVM Backend</a></h1>
			<p class="meta"><time datetime="2019-04-01T15:05:14+08:00" 
			pubdate data-updated="true">04/01/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>整个编译流程中 LLVM Backend的位置<br/>
<img src="media/15541023147431/15541023747982.jpg" alt="" style="width:707px;"/></p>

<p>LLVM Backend的流程图<br/>
<img src="media/15541023147431/15541050358473.jpg" alt="" style="width:715px;"/></p>

<h3 id="toc_0">CodeGen 阶段</h3>

<ul>
<li>Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph）</li>
<li>Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列</li>
<li>SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的</li>
<li>Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上 Prolog / Epilog 生成</li>
<li>确定所需堆栈大小：Machine Code</li>
<li>晚期优化：最后一次优化机会</li>
<li>Code Emission：输出代码，可以选择汇编或者二进制机器码。</li>
</ul>

<h3 id="toc_1">SelectionDAG</h3>

<ul>
<li>构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点</li>
<li>优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出</li>
<li>Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到</li>
<li>指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG</li>
<li>SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -&gt; linear list（SSA form） -&gt; MachineInstr -&gt; MC Layer API MCInst MCStreamr -&gt; MCCodeEmitter -&gt; Binary Instr）</li>
</ul>

<h3 id="toc_2">Register Allocation 寄存器分配</h3>

<h4 id="toc_3">寄存器在 LLVM 中的表达</h4>

<p>物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。</p>

<h4 id="toc_4">虚拟寄存器到物理寄存器的映射</h4>

<p>直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度</p>

<h4 id="toc_5">LLVM 自带的寄存器分配算法</h4>

<p><code>llc -regalloc=Greedy add.bc -o ln.s</code></p>

<ul>
<li>Fast - debug 默认，尽可能保存寄存器。</li>
<li>Basic - 增量分配</li>
<li>Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化</li>
<li>PBQP - 将寄存器分配描述成分区布尔二次规划</li>
</ul>

<h3 id="toc_6">Code Emission</h3>

<p><img src="media/15541023147431/15541063937960.jpg" alt="" style="width:706px;"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541003911598.html">Clang库&&插件</a></h1>
			<p class="meta"><time datetime="2019-04-01T14:33:11+08:00" 
			pubdate data-updated="true">04/01/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">使用 libclang 来进行语法分析</h2>

<p>使用<code>libclang</code>里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>

<h2 id="toc_1">LibTooling 对语法树完全的控制</h2>

<p>因为LibTooling能够完全控制语法树，那么就可以做很多事情了</p>

<ul>
<li>可以改变clang生成代码的方式</li>
<li>增加更强的类型检查</li>
<li>按照自己的定义进行代码的检查分析</li>
<li>对源码做任意类型分析，甚至重写程序</li>
<li>给clang添加一些自定义的分析，创建自己的重构器</li>
<li>基于现有代码做出大量的修改</li>
<li>基于工程生成相关图形或文档</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把OC转为JS或者Swift</li>
</ul>

<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>

<h2 id="toc_2">Clang Plugin</h2>

<p>通过自己写个插件，比如上面写的LibTooling的clang工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以再LLVM的目录看到一些范例<code>llvm/tools/clang/tools</code></p>

<p>动态化方案<code>DynamicCocoa</code>中就是使用了一个将<code>OC</code>源码转<code>JS</code>的插件来进行代码的转换，这里整理了些利用clang转js的库 <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个<code>slides</code>可以看看：<a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章：<a href="http://blog.cnbang.net/tech/3219/">如何动态调用 C 函数 « bang’s blog </a></p>

<ul>
<li><a href="http://blog.cnbang.net/tech/2808/">JSPatch实现原理详解 « bang’s blog</a></li>
</ul>

<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488360&amp;amp;idx=1&amp;amp;sn=94fba30a87d0f9bc0b9ff94d3fed3386&amp;source=41#wechat_redirect">《基于clang插件的一种iOS包大小瘦身方案》</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15540426044478.html">Clang Attributes</a></h1>
			<p class="meta"><time datetime="2019-03-31T22:30:04+08:00" 
			pubdate data-updated="true">03/31/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>attribute(xx)</code>是clang提供的能让开发者在编译过程中参与一些源码控制的方法</p>

<h3 id="toc_0">attribute((format(NSString,F,A)))格式化字符串</h3>

<blockquote>
<p>因为此时已经是C语言级别 String不需要加<code>@</code></p>
</blockquote>

<p>比如NSLog的用法</p>

<pre><code class="language-objectivec">FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;

#if !defined(NS_FORMAT_FUNCTION)
    #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)
    #define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))
    #else
    #define NS_FORMAT_FUNCTION(F,A)
    #endif
#endif
</code></pre>

<h3 id="toc_1">attribute((deprecated(s)))版本弃用提示</h3>

<p>在编译过程中提示开发者该方法已经被弃用</p>

<pre><code class="language-objectivec">@property (nonatomic, strong) NSString *testProperty __attribute__((deprecated(&quot;该属性已经不能用了&quot;)));

- (void)testDeprecatedMethod __attribute__((deprecated(&quot;该方法已经被弃用&quot;)));

- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏
</code></pre>

<h3 id="toc_2">attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围</h3>

<pre><code class="language-objectivec">- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”)));
</code></pre>

<h3 id="toc_3">attribute((unavailable(s))) 方法不可用提示</h3>

<pre><code class="language-objectivec">- (void)testUnvailableMethod __attribute__((unavailable(&quot;该方法已经不能使用&quot;)));
</code></pre>

<h3 id="toc_4">attribute((unused))</h3>

<p>没有被使用也不报警告</p>

<pre><code class="language-objectivec">NSString *str __attribute__((unused));
NSInteger reuslt __attribute__((unused)) = [vc testResultUnused];
</code></pre>

<h3 id="toc_5">attribute((warn_unused_result))</h3>

<p>不使用该方法的返回值就会被警告</p>

<pre><code class="language-objectivec">- (NSInteger)testResultUnused __attribute__((warn_unused_result));
</code></pre>

<h3 id="toc_6">attribute((availability(swift, unavailable, message=_msg)))</h3>

<p>OC的方法 不能在swift中使用</p>

<h3 id="toc_7">attribute((cleanup(…))) 作用域结束时自动执行一个指定方法</h3>

<p>作用于结束包括大括号结束，return，goto，break，exception等情况。这个动作是先于这个对象的dealloc调用的</p>

<pre><code class="language-objectivec">//修饰一个变量 在他的作用域结束时 自动执行该方法
}
    NSString *testCleanUp __attribute__((cleanup(testLastMethod) unused)) = @&quot;testCleanUp&quot;;
}

int testLastMethod(__strong NSString **str) {
    return 10;
}
</code></pre>

<h3 id="toc_8">attribute((overloadable)) 方法重载</h3>

<p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数</p>

<pre><code class="language-c">__attribute__((overloadable)) void printArgument(int number){
    NSLog(@“Add Int %i”, number);
}

__attribute__((overloadable)) void printArgument(NSString *number){
    NSLog(@“Add NSString %@“, number);
}

__attribute__((overloadable)) void printArgument(NSNumber *number){
    NSLog(@“Add NSNumber %@“, number);
}
</code></pre>

<h3 id="toc_9">attribute((objc_designated_initializer)) 指定内部实现的初始化方法</h3>

<p>也可以使用OC中定义的宏 <code>NS_DESIGNATED_INITIALIZER</code></p>

<p>即指定该类的指定构造器函数，使用规则</p>

<ul>
<li>该类的指定构造器函数必须调用父类的指定构造器函数</li>
<li>该类的遍历构造器函数必须最终执行该类的指定构造器函数</li>
</ul>

<h3 id="toc_10">attribute((objc_subclassing_restricted)) 指定不能有子类</h3>

<p>指定该类不能有子类，类似java中的final函数</p>

<pre><code class="language-objectivec">__attribute__((objc_subclassing_restricted))
@interface ViewController : UIViewController
@end
</code></pre>

<h3 id="toc_11">attribute((objc_requires_super)) 子类继承必须调用 super</h3>

<pre><code class="language-objectivec">//子类重写该方法如果不调用super 会有警告⚠️
- (void)testInheritanceMethod __attribute__((objc_requires_super));
</code></pre>

<h3 id="toc_12">attribute((const)) 重复调用相同数值参数优化返回</h3>

<p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次需要进行运算，后面只返回第一次的结果，这是编译器的一种优化处理</p>

<h3 id="toc_13">attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))</h3>

<p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>

<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>

<h2 id="toc_14">Clang警告处理</h2>

<pre><code class="language-objectivec">#pragma clang diagnostic push
#pragma clang diagnostic ignored “-Wdeprecated-declarations”
        sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];
#pragma clang diagnostic pop
</code></pre>

<h2 id="toc_15"><strong>attribute</strong>((constructor)) 在main函数之前调用</h2>

<h2 id="toc_16"><strong>attribute</strong>((destructor)) 在main函数执行之后 或者exit()后被自动执行</h2>

<h3 id="toc_17">文件级:在源代码文件中诊断(忽略/警告)</h3>

<p>语法:</p>

<pre><code class="language-objectivec">#pragma clang diagnostic [error|warning|ignored] &quot;-W&lt;警告选项&gt;&quot;


诊断-忽略:(关闭警告)
#pragma  clang diagnostic ignored  &quot;-Wunused&quot;
#pragma  clang diagnostic ignored  &quot;-Wunused-parameter&quot;


诊断-警告:(开启警告)
#pragma  clang diagnostic warning  &quot;-Wunused&quot;
#pragma  clang diagnostic warning  &quot;-Wunused-parameter&quot;


诊断-错误:(开启警告-升级为错误)
#pragma  clang diagnostic error  &quot;-Wunused&quot;
#pragma  clang diagnostic error  &quot;-Wunused-parameter&quot;
用法:
在文件开头处关闭警告,在文件结尾出再开启警告,这样可以忽略该文件中的指定警告.
</code></pre>

<blockquote>
<p>对于项目中的警告我们可以右键警告revela in log 查看编译时的警告<br/>
<img src="media/15540426044478/15540987741636.jpg" alt="" style="width:693px;"/><br/>
就可以根据具体警告类型进行忽略</p>
</blockquote>

<h3 id="toc_18">补充: 项目级别忽略警告</h3>

<p>在项目的<code>Build Settings</code>中也可以设置忽略某种或者多种类型的警告,忽略整个项目的警告类型</p>

<p><img src="media/15540426044478/15540998238927.jpg" alt="" style="width:706px;"/><br/>
也可以指定debug 或者 release</p>

<p>选项格式: -W[no-]&lt;警告选项&gt;<br/>
如 : -Wno-unused-parameter   # no- 表示诊断时忽略这个警告</p>

<blockquote>
<p>通过 CocoaPods 给项目导入了一些第三方库，这些库里面或多或少会有些警告，想消除这些警告，很简单，只需在 Podfile 中加上这一句 inhibit_all_warnings!，所有通过 CocoaPods 安装的第三库的警告就没有了。</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15540375355169.html">Clang CFE</a></h1>
			<p class="meta"><time datetime="2019-03-31T21:05:35+08:00" 
			pubdate data-updated="true">03/31/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>常用的Clang前端组件和库</p>

<ul>
<li>LLVM Support Library: <code>LLVM libSupport</code>库提供了许多底层库和数据结果，包括命令行option处理，各种容器和系统抽象层，用于文件系统访问</li>
<li>The Clang &quot;Basic&quot; Library: 提供了追踪和操纵<code>source buffers</code>，<code>source buffers</code>的位置，<code>diagnostics</code>，<code>token</code>，抽象目标以及编译语言自己信息的<code>low-level</code>实用程序。还部分由可以用在其他非C语言比如<code>SourceLocation</code>、<code>SourceManager</code>,<code>Diagnositics</code>，<code>FileManager</code>等。其中Diagnositics这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码那些不正确，按照严重程度产生warning或error，每个诊断会有唯一ID,sourceLocation会负责管理</li>
<li>The Driver Library : 和Driver相关的库</li>
<li>Precompiled Header： Clang支持预编译Header的两个实现</li>
<li>The Frontend Library： 这个库包含在Clang库之上构建的功能，比如输出diagnosistics的几种方法</li>
<li>The Lexer and Preprocessor Library: 词法分析和预处理的库，包含了Token、Annotation、Tokens、TokenLexer、Lexer等词法类，还有Parser library和AST语法树相关的比如Type、ASTContext、QualType、DeclarationName、DeclContext以及CFG类</li>
<li>The Sema Library： 解析器调用此库时，会对输入进行语义分析。对有效的程序，Sema为解析构造一个AST</li>
<li>The CodeGen Lirary： 用AST作为输入，生成LLVM IR代码</li>
</ul>

<h2 id="toc_0">libClang</h2>

<h2 id="toc_1">Driver</h2>

<p>Driver是Clang面向用户的接口，用来解析Option设置，判断决定调用的工具链，最终完成整个编译过程</p>

<p>Driver 的流程是按照 ArgList - Actions - Jobs 来的<br/>
<img src="media/15540375355169/15540403081825.jpg" alt="" style="width:716px;"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15540299299293.html">CodeGen IR LLVM</a></h1>
			<p class="meta"><time datetime="2019-03-31T18:58:49+08:00" 
			pubdate data-updated="true">03/31/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">CodeGen生成IR代码</h2>

<p>将语法树翻译成LLVM IR中间代码，作为LLVM Backend输入的桥接语言。方便LLVM Backend可以做到与语言无关的优化</p>

<p><strong>这个过程还会与runtime进行桥接</strong></p>

<ul>
<li>各种类、方法、成员变量等的结构体的生成，将其放到对应的Mach-O的Section中</li>
<li>Non-Fragile ABI合成OBJC_IVAR_$_偏移值常量</li>
<li>ObjCMessageExpr(AST树结构)翻译生成相应版本的objc_msgSend、super翻译生成objc_msgSendSuper</li>
<li>strong、weak、copy、atomic、nonatomic、readwrite等合成@property自动实现setter和getter</li>
<li>@synthesize 的处理</li>
<li>生成block_layout数据结构(即block对应的结构体)</li>
<li><strong>block和</strong>weak处理</li>
<li>_block_invoke</li>
<li>ARC的处理，即插入objc_storeStrong和objc_storeWeak等ARC代码;ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop;自动添加 [super dealloc];给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量</li>
</ul>

<p><strong>不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR</strong></p>

<h3 id="toc_1">LLVM IR</h3>

<p>LLVM IR有三种表示格式，第一种是bitcode这样的存储格式，以.bc做后缀；第二种是可读的.ll；第三种是用于开发是操作LLVM IR的内存格式</p>

<p>一个编译单元即一个文件在IR里就是一个<code>Module</code>，Module里有<code>Global variable</code>和<code>Function</code>，在Function里有<code>Basic Block</code>，<code>Basic Block</code>里有指令<code>Instructions</code><br/>
这样的话，如果想要开发一门新的语言只需要完成语法解析后，通过LLVM提供的丰富接口在内存中生成IR就可以直接运行在各个不同的平台</p>

<h3 id="toc_2">LLVM IR的优化</h3>

<p>选择不同的O2、O3这样的优化回调用对应的Pass进行处理，比如死代码清理、内联化、表达式重组、循环变量移动等这样的Pass，可以通过命令<code>llvm -opt</code>调用LLVM优化相关的库</p>

<h3 id="toc_3">SSA</h3>

<p>LLVM IR是SSA形式的，维护双向def-use信息，user-def是通过普通指针实现信息维护，def-user通过内存跳表和链表来实现，便于forward dataflow analysis和backward dataflow analysis。</p>

<p>llc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="iOS编译流程_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>