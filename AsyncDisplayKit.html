
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  AsyncDisplayKit - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15710288132412.html">Collections and asynchronous updates</a></h1>
			<p class="meta"><time datetime="2019-10-14T12:53:33+08:00" 
			pubdate data-updated="true">10/14/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">概述</h2>

<p>ASCollectionNode和ASTableNode使用相同的内部类(ASRangeController和ASDataController)来简化大多数的操作。</p>

<p><code>ASRangeController</code>负责确定哪些Collection cell node 是在一定范围内并且为cell node以及其子节点设置正确的 interface state</p>

<p><code>ASDataController</code>是支持UICollectionView的真实数据源。负责处理批处理更新，以线程安全的方式将其转发到bacKing View.</p>

<h2 id="toc_1">批量更新</h2>

<p><code>UICollectionView</code>允许客户端提交单个编辑而不需要包装在批处理更新中。<code>ASCollectionNode</code>虽然也允许这么做，但是在后台操作会自动捆绑到批处理更新中，因此也叫做<code>change set(更改集 _ASHierarchyChangeSet)</code>。批处理操作也可以嵌套，最后是单个的更改集<br/>
值得注意的是，在其生命周期开始，UICollectionView需要执行初始数据加载。可以简单的通过调用<code>-reladData</code>实现,这也包装在ASCollectionNode的更改集中。因此，初始数据加载只是另一个更改集，就像其它更改一样。</p>

<h2 id="toc_2">改变集 处理流程</h2>

<p><code>ASCollectionNode</code>不接受也不处理单个的编辑操作。其<code>ASDataController</code>公开的主要数据更新方法为<code>-updateWithChangeSet:（_ ASHierarchyChangeSet *）changeSet</code>，并且在通过此方法提交之前，必须将编辑操作包装在更改集中，可以将这个方法是为处理更改集的通道</p>

<p>通道在开始处理主线程的更改集之前，切换到后台线程执行昂贵的操作，最后返回到主线程将其转发到UICollectionView</p>

<h3 id="toc_3">内部队列和数据集</h3>

<p>由于通道在多个线程上运行，因此每个改变集都需要通过通道确保数据的一致性，不仅与数据源而且与backing View保持一致。在内部，<code>ASDataController</code>使用两个队列和数据集来简化通道</p>

<p>这两个队列称为<code>_editingTransactionQueue</code>和<code>_mainSerialQueue</code>。前者为串行后台dispatch_queue,后者为<code>ASMainSerialQueue</code></p>

<p>两个数据集为<code>pendingMap</code>和<code>visibleMap</code>。它们每个都是ASElementMap实例，<code>ASElementMap</code>是不可变的、主线程的<code>ASCollectionElement</code>的集合</p>

<p>每一个<code>ASCollectionElement</code>代表colletion视图中的item或者supplementary视图。它具有足够的信息帮助ASDataController来初始化和测量backing ASCellNode以及最终要的nodeblock。这个block是在进程开始时被data source返回的，并且被element引用直到该block被执行。在首次调用<code>-[ASCollectionElement node]</code>被调用时 该block被执行。一旦被执行，<code>ASCellNode</code>将会被element强应用并且block被释放。这意味着任何给定时间，element要不具有node block 要不具有node instance，不能同时拥有两者。如果caller想要获取node，只有在node已经被初始化的情况下，此时应该调用<code>-nodeIfAllocated</code></p>

<h2 id="toc_4">Data Source index space VS UIKit index space</h2>

<p>由于每个改变集都是异步处理，因此可能需要支持多个<code>UICollectionView</code>在多个主线程run loop中使用改变集。</p>

<p>在任何给定时间，ASDataController的pendingMap是从数据源获取的最新map，因此它位于数据源索引空间中。另一方面，visibleMap是UICollectionView当前显示的元素的集合。结果，它在UIKit索引空间中。</p>

<h3 id="toc_5">工作的五个步骤</h3>

<p>每个改变集都会执行这5个步骤</p>

<ol>
<li>该进程从主线程开始。此时pendingMap和visibleMap是同一个。制作一个pendingMap的mutalbe copy，然后根据改变集来进行更新。这包括，移除旧的items，向数据源查询插入新的items。在这步结束时，将会更新<code>pendingMap</code>反应data source的整体视图</li>
<li>这是一个可选的步骤，仅当layout delegate设置为data controller时执行。默认，data controller一次性的初始化和测量所有的items(步骤3)。具有layout delegate时可以使其他类自定义此行为，例如，ASCollectionLayout仅初始化和测量足够的cell填充可见口。当用户滚动时，将按需分配更多cell，为此，layout delegate可能需要构造一个上下文，该上下文必须在同一主线程runloop上发生，</li>
<li>在<code>_editingTransactionQueue</code>，分配和测量<code>pendingMap</code>的所有element，或者调用layout delegate让其决定。在此步骤结束时，element已经准备好被backing view使用</li>
<li>在block中计划执行下一步，通过<code>_mainSerialQueue</code>将其添加到主线程队列中。如果在此点之前还有其他尚未调度到队列的block被调度，执行步骤5</li>
<li>通知ASRangeController，colletionView的布局协调器，更重要的时，向collection发送有关更改集的信息。ASColelctionView调用其超类来执行批处理更新，在批处理中，pendingMap被更改为visibleMap。 UICollectionView要求将新数据集部署在-[UICollectionView performBatchUpdates：completion：]的更新块中。它还要求编辑操作必须按照特定的顺序进行，并由步骤1之前的更改集验证</li>
</ol>

<h2 id="toc_6">动画</h2>

<h2 id="toc_7">移动操作</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15710248960458.html">Layout Specs</a></h1>
			<p class="meta"><time datetime="2019-10-14T11:48:16+08:00" 
			pubdate data-updated="true">10/14/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Layout specs</h2>

<h3 id="toc_1">Layout flow</h3>

<p>Layout计算是 通过以下启动触发器来递归完成。一个layout布局完成的启动触发器就是 当父节点改变时。这触发器也在第一次node树被创建时发生。</p>

<p><code>ASDisplayNode</code>第一个重要分支是顶层的<code>[ASDisplayNode calculateLayoutThatFits]</code>，这个方法将会选择布局引擎是<code>Texture布局</code>还是<code>Yoga</code></p>

<pre><code class="language-objectivec">- (ASLayout *)calculateLayoutThatFits:(ASSizeRange)constrainedSize
{
  __ASDisplayNodeCheckForLayoutMethodOverrides;

  switch (self.layoutEngineType) {
    case ASLayoutEngineTypeLayoutSpec:
      return [self calculateLayoutLayoutSpec:constrainedSize];
#if YOGA
    case ASLayoutEngineTypeYoga:
      return [self calculateLayoutYoga:constrainedSize];
#endif
      // If YOGA is not defined but for some reason the layout type engine is Yoga
      // we explicitly fallthrough here
    default:
      break;
  }

  // If this case is reached a layout type engine was defined for a node that is currently
  // not supported.
  ASDisplayNodeAssert(NO, @&quot;No layout type determined&quot;);
  return nil;
}
</code></pre>

<p>基于UIKit系统，Texture在不同阶段遵循以下过程</p>

<ol>
<li>ASDisplayNode和ASLayout初始化。这是完全独立与UIKit存在。这是当一个布局计算创建时</li>
<li>UIView/CALayer初始化。遵循UIKit管理惯例，即在布局大小之前创建要显示的UIKit items。然而，它们是在UIKit层次，允许下列的布局触发器</li>
<li>UIView/CALayer布局。这是UIKit递归操作之后的结果。这和步骤1中的布局计算不同，这是仅仅为了使用已经准备好的布局，并且将其应用到UIView/CALayer中 进行布局调整</li>
<li>如有必要，在其中渲染CALayer的光栅化。UIKit可以将UIKit层次结构绘制到屏幕上</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15707800044047.html">Node Lifecycle</a></h1>
			<p class="meta"><time datetime="2019-10-11T15:46:44+08:00" 
			pubdate data-updated="true">10/11/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>Texture</code>使用ARC，因此对象不再有强引用时就会被dealloc。而对于ASDisplayNode和其子类来说，不同node有不同的生命周期，因此了解其生命周期以及 enter interface和loading state  是很有用的</p>

<h2 id="toc_0">node container 管理node</h2>

<p>node container负责它们管理的node的声明周期。一般来说，<code>node container</code>会在需要时尽快分配节点，并在不需要时释放它们。<code>Texture</code>假设<code>node container</code>完全管理其node，而客户端 不保留这些节点 和/或 修改其生命周期。例如，客户端不应该尝试存储由于<code>ASCollectionNode、ASPageNode或ASTableNode</code>初始化的<code>ASCellNode</code>实例</p>

<p><code>ASCollectionNode</code>和<code>ASTableNode</code>在将<code>ASCellNodes</code>添加到container node立即对其进行初始化，不论是通过reload data或者作为批处理的一部分更新。类似于<code>UICollectionView/UITableView</code>，第一次数据加载都是在没有先前数据集合的基础上重新加载数据。但是又与<code>UICollectionView/UITableView</code>不同，其cell在被显示之前会被重用和重新配置，而<code>ASCollectionNode和ASTableNode</code>不会重用<code>ASCellNode</code>。这就会导致结果，由collection和table管理的<code>ASCellNode</code>数量和截止到那时为止插入的items和rows相同</p>

<p>目前为止，ASCollectionNode和ASTableNode的当前实现会在插入所有cell后立即初始化它们。即，如果客户端执行100个items插入到collection node中的批处理更新，则该collection node将会初始化100个单元节点作为批处理更新的一部分。它还将在每个新的cell node上执行布局结算。因此，在该过程结束时，collection node将会管理100个节点，并且这些节点已经计算出可以使用的布局</p>

<p>由于上面所说的行为，ASCollection和ASTableNode可能需要一段时间才能处理插入大量items的批处理更新。在这种情况下，建议使用<code>node block</code>API，该API允许在主线程外并行初始化。如果仍然需要考虑性能，则使用批处理提取API拆分数据集，并在最终用户滚动时，逐渐向容器节点公开更多数据</p>

<h2 id="toc_1">ASCollectionLayout</h2>

<p>为了解决上面所说的处理大型数据集合的弊端，为<code>ASCollectionNode</code>引入了新的API，使其可以再用户滚动时，延迟初始化和布局cell node。但是，由于某些限制，此功能仅仅适用于知道每个cell node大小的colletion layout。例如，轮播图，分页布局等</p>

<h3 id="toc_2">ASCellNodes的 dealloction</h3>

<p>因为ASCellNode并未重用，因此与<code>UICollectionViewCell或UITableViewCell</code>相比，他们具有更长的生命周期。当不再使用ASCellNodes并将其从容器中删除时，将会释放。这可能发生在重新加载数据 或者 删除批处理数据更新之后，或者在node container不再使用而被释放。</p>

<p>对于后者node container不再被使用而被释放的情况，它们的单元节点不会立即释放。这是因为collection node和table nodes中可能持有大量的cell nodes，并且同时释放他们，这会导致明显的延迟。为了避免这种情况，使用了<code>ASDeallocQueue</code>帮助在后台线程释放。<br/>
由于<code>ASDataController</code>实例是所有单元节点的真正所有者–它对所有单元节点都有很强的引用.因此，所有这些单元节点也都从主线程中释放。因此，可以预期从释放集合或表视图开始，直到所有单元节点都完全释放并回收其内存为止的延迟。在调试内存泄漏时，请记住这一点，这一点很重要：DataController引用的对象可能需要一点时间才能被<code>Instruments</code>显示为已经dealloc。</p>

<h3 id="toc_3">ASDeallocQueue</h3>

<p><code>ASDeallocQueue</code>通过增加每个对象的引用计数（基本上保留它们并充当其唯一所有者）来帮助延迟分配给它的对象的重新分配，然后稍后在后台线程上释放它们</p>

<h2 id="toc_4">未被Container管理的Node</h2>

<p>这些节点通常由客户端代码直接创建，例如cell node的直接或间接子节点。因为node通常存在于视图结构层次中，整个node视图层次和root node有相同的生命周期。最后，如果root node由node container管理(直接被ASViewController管理，或者间接作为collection或者table的 cell node被管理)，则整个node 视图层次都由node  container管理</p>

<h3 id="toc_5">自动节点管理(ASM)下的声明周期</h3>

<p>ASM允许简单的返回包含给定时间父节点需要的子节点布局规范来操作节点的结构层次。纹理通过比较先前和当前的布局规范计算子节点的插入和删除，并更新节点层次。为了支持两个布局之间的动画，新的节点在动画之前就插入，为新来的动画做准备。新的节点在开始时就被父节点保留，而在动画结束后，删除旧的节点，如果旧节点没有被其他引用或者保留 将将被释放</p>

<h2 id="toc_6">node interface state</h2>

<p>在智能预加载的支持下，ASTableView和ASCollectionView都使用<code>ASRangeController</code>确定他们管理的每个ASCellNode的状态，并将该状态递归设置为层次结构中的每个节点</p>

<h2 id="toc_7">Node loading state</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15707737201639.html">线程</a></h1>
			<p class="meta"><time datetime="2019-10-11T14:02:00+08:00" 
			pubdate data-updated="true">10/11/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>Texture</code>是对资源的高效利用来给用户提供高帧速的体验。换言之，科学的在线程间分配工作，使默认的runLoop保持精简，实时允许用户的输入事件，并且消耗主队列上安排的工作</p>

<p>遵循以下规定：</p>

<ol>
<li>使用UIKit API必须通过<code>dispatch_get_main_queue()</code>或者使用<code>ASPerformBlockOnMainThread()</code>在主线程执行</li>
<li>一般来说 其它任何事情都应该在后台发生</li>
</ol>

<h2 id="toc_0">Run Loop、Threads and Queues</h2>

<h2 id="toc_1">ASMainSerialQueue</h2>

<p><code>ASMainSerialQueue</code>确保在不中断的情况下在主线程执行工作，其主要区别是，使用<code>dispatch_async(dispatch_get_main_queue, block)</code>会在块的执行之间中断。<br/>
因此接口将在主线程中的队列中执行所有可能操作，然后再将控制权转移给OS</p>

<p>此接口会调用<code>ASPerformBlockOnMainThread</code>。当其他线程pop block在主线程执行时，该接口就会锁定其他线程，确保其在主调度队列和runloop的其它循环之前</p>

<p>并且由于是同步机制，<code>ASMainSerialQueue</code>是串行的，因此可以确保按照顺序执行。一个示例是将以下块排队: 更改视图属性-&gt;触发布局更新-&gt;动画。 由于ASMainSerialQueue可能会较早执行，因此要比使用<code>dispatch_async（dispatch_get_main_queue（））</code>发送的块较早执行。</p>

<p>这实际上只是主调度队列的缓冲区，为计划工作提供了更多可见性。该接口确保计划的所有内容都将在主线程以同一操作顺兴进行</p>

<h3 id="toc_2">ASRunLoopQueue</h3>

<h3 id="toc_3">Locks and Safety</h3>

<h3 id="toc_4">线程竞争</h3>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15698393226216.html">Nodes</a></h1>
			<p class="meta"><time datetime="2019-09-30T18:28:42+08:00" 
			pubdate data-updated="true">09/30/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">ASDisplayNode</h2>

<p><code>ASDisplayNode</code>是UIView和CALayer的主要抽象。与UIView创建和持有<code>CALayer</code>相同，Node创建和持有UIView</p>

<pre><code class="language-objectivec">ASDisplayNode *node = [[ASDisplayNode alloc] init];
node.backgroundColor = [UIColor orangeColor];
node.bounds = CGRectMake(0, 0, 100, 100);
NSLog(@&quot;Underlying view: %@&quot;, node.view);
</code></pre>

<p>node拥有与<code>UIView</code>相同的所有属性，view和layer的所有属性都会映射到node，非常方便我们使用</p>

<pre><code class="language-objectivec">ASDisplayNode *node = [[ASDisplayNode alloc] init];
node.clipsToBounds = YES;       // not .masksToBounds
node.borderColor = [UIColor blueColor];  //layer name when there is no UIView equivalent
NSLog(@&quot;Backing layer: %@&quot;, node.layer);
</code></pre>

<p>当与node container一起使用时，node的属性将会在后台线程设置，</p>

<h3 id="toc_1">视图包装器</h3>

<p>有时，我们提供一个视图作为node的backing view。这个视图在block中提供，block中返回视图并进行保存。此时，这些node的展示会同步发生，因为只有node中的<code>_ASDisplayView</code>才会异步显示，在普通包装的UIView并不会异步显示</p>

<pre><code class="language-objectivec">ASDisplayNode *node = [ASDisplayNode alloc] initWithViewBlock:^{
    SomeView *view  = [[SomeView alloc] init];
    return view;
}];
</code></pre>

<p>我们通常使用这个方法将UIView的子类转换为<code>ASDisplayNode</code>子类，来包装现有视图</p>

<h2 id="toc_2">ASCellNode</h2>

<p>是Texture中的cell类，<code>ASCellNode</code>可以和<code>ASTableNodes</code>、<code>ASCollectionNodes</code>、<code>ASPageNodes</code>一起使用</p>

<h3 id="toc_3">使用cellNode的三种方式</h3>

<h4 id="toc_4">子类化</h4>

<p>与子类化<code>ASDisplayNode</code>几乎相同，需要使用以下方法:</p>

<ul>
<li>-init</li>
<li>-layoutSpecThatFits</li>
<li>-didLoad</li>
<li>-layout</li>
</ul>

<h4 id="toc_5">使用ASViewController初始化</h4>

<p>将视图控制器作为视图放入cell的scroll node或者page node</p>

<p>举个例子:<br/>
编写一个用于管理<code>ASTableNode</code>的视图控制器。将该表作为<code>ASPagenode</code>的页面，使用<code>initWithViewControllerBlock</code></p>

<pre><code class="language-objectivec">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index
{
    NSArray *animals = self.allAnimals[index];
    
    ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^UIViewController * _Nonnull{
        return [[AnimalTableNodeController alloc] initWithAnimals:animals];
    } didLoadBlock:nil];
    node.style.preferredSize = pagerNode.bounds.size;
    return node;
}
</code></pre>

<blockquote>
<p>注意</p>

<p>使用这个方式设置的node，需要设置其<code>.style.preferredSize</code>。</p>
</blockquote>

<h4 id="toc_6">使用UIView和CALayer初始化</h4>

<p>当如果有<code>UIView</code>或者<code>CALayer</code>子类 作为cell</p>

<pre><code class="language-objectivec">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index
{
    NSArray *animal = self.animals[index];
    
    ASCellNode *node = [[ASCellNode alloc] initWithViewBlock:^UIView * _Nonnull{
        return [[SomeAnimalView alloc] initWithAnimal:animal];
    }];

    node.style.preferredSize = pagerNode.bounds.size;
    
    return node;
}
</code></pre>

<p>虽然可以这么做 但是推荐将现有的UIView类转为ASCellNode的子类 获取异步显示的优势</p>

<h3 id="toc_7">Never Show Placeholders</h3>

<p>通常，如果cell在其到达屏幕之前仍为display完成，将会显示占位符直到绘制内容完成</p>

<p>但是，当如果我们不想要看到placeholder内容，可以将其属性<code>neverShowPlaceholders</code>设置为<code>YES</code></p>

<pre><code class="language-objectivec">node.neverShowPlaceholders = YES;
</code></pre>

<p>将其设置为yes，则cell的主线程将会被阻塞，直到cell显示完成为止。</p>

<h4 id="toc_8">UITableViewCell的特殊属性</h4>

<p>在<code>ASCellNode</code>中也存在和<code>UITableViewCell</code>中的类似<code>selectionStyle、accessoryType和seperatorInset</code>等我们偶尔可能使用的属性</p>

<h2 id="toc_9">ASButtonNode</h2>

<p>类似UIButton继承自UIControl，而ASButtonNode也继承自<code>ASControlNode</code>。</p>

<h3 id="toc_10">control state</h3>

<pre><code class="language-objectivec">[buttonNode setTitle:@&quot;Button Title Normal&quot; withFont:nil withColor:[UIColor blueColor] forState:ASControlStateNormal];

//可以通过设置Attribute  设置更多自定义属性
[self.buttonNode setAttributedTitle:attributedTitle forState:ASControlStateNormal];
</code></pre>

<h3 id="toc_11">Target-Action</h3>

<pre><code class="language-objectivec">[buttonNode addTarget:self action:@selector(buttonPressed:) forControlEvents:ASControlNodeEventTouchUpInside];
</code></pre>

<h3 id="toc_12">Content Alignment</h3>

<p><code>ASButtonNode</code>提供了<code>contentVerticalAlignment和contentHorizontalAlignment</code>属性，可以轻松设置对齐方式</p>

<pre><code class="language-objectivec">self.buttonNode.contentVerticalAlignment = ASVerticalAlignmentTop;
self.buttonNode.contentHorizontalAlignment = ASHorizontalAlignmentMiddle;
</code></pre>

<h3 id="toc_13">注意</h3>

<h2 id="toc_14">ASTextNode</h2>

<p>Texture中的主要文本节点，通常在使用UILabel的情况下使用。拥有完整的富文本支持，并且继承自ASControlNode，</p>

<h3 id="toc_15">使用</h3>

<p>ASTextNode的接口对于使用UILabel的人来说非常熟悉，第一个不同的地方在于node仅使用attribute而不能使用纯文字字符</p>

<pre><code class="language-objectivec">NSDictionary *attrs = @{ NSFontAttributeName: [UIFont fontWithName:@&quot;HelveticaNeue&quot; size:12.0f] };
NSAttributedString *string = [[NSAttributedString alloc] initWithString:@&quot;Hey, here&#39;s some text.&quot; attributes:attrs];

_node = [[ASTextNode alloc] init];
_node.attributedText = string;
</code></pre>

<h3 id="toc_16">截断字符串</h3>

<p>当显示文本的空间小于要显示的文本必须空间，将会尽可能多的显示文本，并且所有被截断字符串将会被截断字符串替换。</p>

<pre><code class="language-objectivec">_textNode = [[ASTextNode alloc] init];
_textNode.attributedText = string;
_textNode.truncationAttributedText = [[NSAttributedString alloc]
</code></pre>

<p>默认情况下，截断字符串为<code>...</code></p>

<h3 id="toc_17">Link Attributes</h3>

<p>为了将文本指定为链接，需要将<code>linkAttribute</code>数组设置为字符串数组，将该数组用作属性字符串中链接的键。在设置attribute时，将这些键指向响应的NSURL</p>

<pre><code class="language-objectivec">_textNode.linkAttributeNames = @[ kLinkAttributeName ];

NSString *blurb = @&quot;kittens courtesy placekitten.com \U0001F638&quot;;
NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:blurb];
[string addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;HelveticaNeue-Light&quot; size:16.0f] range:NSMakeRange(0, blurb.length)];
[string addAttributes:@{
                      kLinkAttributeName: [NSURL URLWithString:@&quot;http://placekitten.com/&quot;],
                      NSForegroundColorAttributeName: [UIColor grayColor],
                      NSUnderlineStyleAttributeName: @(NSUnderlineStyleSingle | NSUnderlinePatternDot),
                      }
              range:[blurb rangeOfString:@&quot;placekitten.com&quot;]];
_textNode.attributedText = string;
_textNode.userInteractionEnabled = YES;
</code></pre>

<h3 id="toc_18">ASTextNodeDelegate</h3>

<p>实现<code>ASTextNodeDelegate</code>允许类对与文本相关联的各种事件做出反应</p>

<p>例如点击事件:</p>

<pre><code class="language-objectivec">- (void)textNode:(ASTextNode *)richTextNode tappedLinkAttribute:(NSString *)attribute value:(NSURL *)URL atPoint:(CGPoint)point textRange:(NSRange)textRange
{
  // the link was tapped, open it
  [[UIApplication sharedApplication] openURL:URL];
}
</code></pre>

<p>类似的:</p>

<pre><code class="language-objectivec">– textNode:longPressedLinkAttribute:value:atPoint:textRange:

– textNode:shouldHighlightLinkAttribute:value:atPoint:

– textNode:shouldLongPressLinkAttribute:value:atPoint:
</code></pre>

<h3 id="toc_19">具有行间距的文本导致不正确的最大行数</h3>

<p>当多行文本中使用<code>NSParagraphStyle</code>修改了非默认的<code>lineSpacing</code>，那么就会导致设置的最大行数不正确</p>

<pre><code class="language-objectivec">NSString *someLongString = @&quot;...&quot;;

NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
paragraphStyle.lineSpacing = 10.0;

UIFont *font = [UIFont fontWithName:@&quot;SomeFontName&quot; size:15];

NSDictionary *attributes = @{
    NSFontAttributeName : font,
    NSParagraphStyleAttributeName: paragraphStyle
};

ASTextNode *textNode = [[ASTextNode alloc] init];
textNode.maximumNumberOfLines = 4;
textNode.attributedText = [[NSAttributedString  alloc] initWithString:someLongString
</code></pre>

<p>为了暂时解决此问题 可以通过设置<code>truncationMode</code>为<code>NSLineBreakByTruncatingTail</code></p>

<pre><code class="language-objectivec">ASTextNode *textNode = [[ASTextNode alloc] init];
textNode.maximumNumberOfLines = 4;
textNode.truncationMode = NSLineBreakByTruncatingTail;
textNode.attributedText = [[NSAttributedString  alloc] initWithString:someLongString
</code></pre>

<h2 id="toc_20">ASImageNode</h2>

<p>等效于<code>UIImageView</code>。最基本的区别在于图像默认情况下是异步解码的。并且还有其他功能，例如支持GIF和<code>imageModificationBlocks</code></p>

<h3 id="toc_21">基础使用</h3>

<p>使用方式与imageView 基本相同</p>

<pre><code class="language-objectivec">ASImageNode *imageNode = [[ASImageNode alloc] init];
imageNode.image = [UIImage imageNamed:@&quot;someImage&quot;];
imageNode.contentMode = UIViewContentModeScaleAspectFill;
</code></pre>

<h3 id="toc_22">图像变换和效果</h3>

<p>通过为imageNode设置<code>imageModificationBlock</code>,可以定义需要在imagenode上设置的任何需要图像异步发生的转换，包括圆角、添加边框、覆盖花纹等</p>

<h3 id="toc_23">图像裁剪</h3>

<p>image的默认mode为<code>UIViewContentModeScaleAspectFill</code>，图片将会放大填充内容区域，并且裁剪掉超出的内容部分。</p>

<p>我们可以通过设置<code>cropRect</code>来移动图片，其为单元矩阵，默认值为(0.5,0.5,0,0)，要显示左侧内容，可将其x设置为0，以为这图片原点从{0, 0}开始，而非默认值</p>

<h3 id="toc_24">强制放大</h3>

<p>默认情况下，图像过小而无法放入已设置的imageNode的边界时，将不会在CPU上放大图像。</p>

<p>如果您想更改此事实，可以将forceUpscaling设置为YES。这样做意味着您每次使用小于目标位置的图像时，您的应用程序都会占用更多内存</p>

<h3 id="toc_25">检测图像缩放</h3>

<p>通过使用<code>pixel scaling tool</code>可以方便的查看图片放大或者缩小了多少</p>

<h2 id="toc_26">ASNetworkImageNode</h2>

<p>当需要显示远程的图像时，可以使用<code>ASNetworkImageNode</code>,需要做的就是将.URL属性设置为合适的NSURL实例，图像将会异步加载并呈现</p>

<pre><code class="language-objectivec">ASNetworkImageNode *imageNode = [[ASNetworkImageNode alloc] init];
imageNode.URL = [NSURL URLWithString:@&quot;https://someurl.com/image_uri&quot;];
</code></pre>

<h3 id="toc_27">Network Image 布局</h3>

<p>因为<code>ASNetworkImageNode</code>并未限制内容大小，因此必须指定layout的大小</p>

<ol>
<li>style.preferredSize</li>
</ol>

<p>当我们想要使用标准尺寸时</p>

<pre><code class="language-objectivec">- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constraint
{
    imageNode.style.preferredSize = CGSizeMake(100, 200);
    ...
    return finalLayoutSpec;
}
</code></pre>

<ol>
<li>ASRatioLayoutSpec</li>
</ol>

<p>使用<code>ASRatioLayoutSpec</code>为图像分配一个比例，当图像加载完成后 将会保持该比例</p>

<pre><code class="language-objectivec">- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constraint
{
    CGFloat ratio = 3.0/1.0;
    ASRatioLayoutSpec *imageRatioSpec = [ASRatioLayoutSpec ratioLayoutSpecWithRatio:ratio child:self.imageNode];
    ...
    return finalLayoutSpec;
}
</code></pre>

<h3 id="toc_28">引擎组件</h3>

<p>如果选择没有包括<code>PINRemoteImage</code>和<code>PINCache</code>，那么将失去对<code>jpeg</code>的渐进支持，并且需要自定义实现<code>ASImageCacheProtocol</code>的缓存</p>

<h3 id="toc_29">渐进式JPEG支持</h3>

<p>由于包含了<code>PINRemoteImage</code>，NetworkImageNode现在支持加载渐进式的JPEG。意味着，如果服务器提供了这种jpeg，则图像会将以较低的质量快速显示，并且随着加载更多的数据而扩大</p>

<p>启用渐进加载只需要设置<code>shouldRenderProgressImages</code>为<code>YES</code></p>

<pre><code class="language-objectivec">networkImageNode.shouldRenderProgressImages = YES;
</code></pre>

<blockquote>
<p>注意</p>

<p>这种方式是使用一张逐渐加载的图像。如果服务器只能使用常规的JPEG，但是可以提供多个版本来提高质量，那么应该使用<code>ASMultiplexImageNode</code></p>
</blockquote>

<h3 id="toc_30">自动缓存</h3>

<p>使用<code>PINCache</code>自动缓存网络图像</p>

<h3 id="toc_31">GIF支持</h3>

<p>ASNetworkImageNode通过PINRemoteImage的beta版PINAnimatedImage提供GIF支持。注意！除非shouldCacheImage设置为NO，否则该支持将不适用于本地文件。</p>

<h2 id="toc_32">ASVideoNode</h2>

<p>方便我们在app中展示视频</p>

<blockquote>
<p>使用<code>ASVideoNode</code>就会连接<code>AVFoundation</code>，因为在内部底层中使用了<code>AVPlayerLayer</code>和<code>AVFoundataion</code></p>
</blockquote>

<h3 id="toc_33">基础使用</h3>

<p>最简单的方式就是设置一个<code>AVAsset</code>资源</p>

<pre><code class="language-objectivec">ASVideoNode *videoNode = [[ASVideoNode alloc] init];

AVAsset *asset = [AVAsset assetWithURL:[NSURL URLWithString:@&quot;http://www.w3schools.com/html/mov_bbb.mp4&quot;]];
videoNode.asset = asset;
</code></pre>

<h3 id="toc_34">自动播放、自动重复、自动静音</h3>

<p>通过一些简单的BOOL属性，设置视频播放</p>

<pre><code class="language-objectivec">//进入可见范围后自动播放
videoNode.shouldAutoplay = YES;
//视频无限循环播放
videoNode.shouldAutorepeat = NO;
//将静音设置为YES 将会关闭视频声音
videoNode.muted = YES;
</code></pre>

<h3 id="toc_35">占位图像</h3>

<p>因为video node继承自<code>ASNetworkImageNode</code>，因此可以使用<code>URL</code>属性设置其占位图像。加入决定不这么做，则视频的第一针将会自动解码并作为占位图像</p>

<h3 id="toc_36">ASVideoNode Delegate</h3>

<p>有很多delegate可以对视频事件作出响应，</p>

<p>例如,当播放状态改变时:</p>

<pre><code class="language-objectivec">- (void)videoNode:(ASVideoNode *)videoNode willChangePlayerState:(ASVideoNodePlayerState)state toState:(ASVideoNodePlayerState)toState;
</code></pre>

<h2 id="toc_37">ASMapNode</h2>

<p>帮助显示用户地离区域</p>

<h3 id="toc_38">基础使用</h3>

<p>只需要输入要显示位置的坐标即可</p>

<pre><code class="language-objectivec">ASMapNode *mapNode = [[ASMapNode alloc] init];
mapNode.style.preferredSize = CGSizeMake(300.0, 300.0);

// San Francisco
CLLocationCoordinate2D coord = CLLocationCoordinate2DMake(37.7749, -122.4194);

// show 20,000 square meters
mapNode.region = MKCoordinateRegionMakeWithDistance(coord, 20000, 20000);
</code></pre>

<h3 id="toc_39">MKMapSnapshotOptions</h3>

<p>可以通过option属性 定义<code>node</code>的主要组件部分</p>

<ul>
<li>MKMapCamera:  相机的高度和仰角</li>
<li>MKMapRect：CGRect</li>
<li>MKMapRegion：控制焦点的坐标 以及 焦点周围的大小和显示</li>
<li>MKMapType：设置为Standard、Satellite(卫星)等</li>
</ul>

<pre><code class="language-objectivec">MKMapSnapshotOptions *options = [[MKMapSnapshotOptions alloc] init];
options.mapType = MKMapTypeSatellite;
options.region = MKCoordinateRegionMakeWithDistance(coord, 20000, 20000);
mapNode.options = options;
</code></pre>

<h3 id="toc_40">标记</h3>

<p>设置标记，要做的就是为<code>ASMapNode</code>分配标记数组</p>

<pre><code class="language-objectivec">//在地图中间直接显示图钉标记
MKPointAnnotation *annotation = [[MKPointAnnotation alloc] init];
annotation.coordinate = CLLocationCoordinate2DMake(37.7749, -122.4194);

mapNode.annotations = @[annotation];
</code></pre>

<h3 id="toc_41">实时地图</h3>

<p>将map node从静态的地图转换为可交互的<br/>
<code>mapNode.liveMap = YES;</code></p>

<p>与UIKit视图一样，实时模式下的MKMapView并不是线程安全的</p>

<h3 id="toc_42">MKMapView Delegate</h3>

<pre><code class="language-text">如果启用了实时地图模式，并且您需要对与地图节点关联的任何事件做出反应，则可以设置mapDelegate属性。该代理应该实现MKMapViewDelegate协议。
</code></pre>

<h2 id="toc_43">ASControlNode</h2>

<p>ASControlNode与UIControl等效。我们不会直接创建实例，可以子类化其作为自己的控件。<code>ASTextNode、ASImageNode、ASVideoNode、ASMapNode</code>都是ASControlNode的子类</p>

<p>这意味着我们可以将任何文本或者图像作为按钮，而不必像UIKIt中依赖于手势识别器，或使用UIBUtton</p>

<h3 id="toc_44">Control state</h3>

<pre><code class="language-objectivec">typedef NS_OPTIONS(NSUInteger, ASControlState) {
    ASControlStateNormal       = 0,
    ASControlStateHighlighted  = 1 &lt;&lt; 0,  // used when isHighlighted is set
    ASControlStateDisabled     = 1 &lt;&lt; 1,
    ASControlStateSelected     = 1 &lt;&lt; 2,  // used when isSelected is set
    ...
};
</code></pre>

<h3 id="toc_45">Target-Action 机制</h3>

<p>类似UIControl  ASControlNode中也有一系列事件</p>

<pre><code class="language-objectivec">typedef NS_OPTIONS(NSUInteger, ASControlNodeEvent)
{
  /** A touch-down event in the control node. */
  ASControlNodeEventTouchDown         = 1 &lt;&lt; 0,
  /** A repeated touch-down event in the control node; for this event the value of the UITouch tapCount method is greater than one. */
  ASControlNodeEventTouchDownRepeat   = 1 &lt;&lt; 1,
  /** An event where a finger is dragged inside the bounds of the control node. */
  ASControlNodeEventTouchDragInside   = 1 &lt;&lt; 2,
  /** An event where a finger is dragged just outside the bounds of the control. */
  ASControlNodeEventTouchDragOutside  = 1 &lt;&lt; 3,
  /** A touch-up event in the control node where the finger is inside the bounds of the node. */
  ASControlNodeEventTouchUpInside     = 1 &lt;&lt; 4,
  /** A touch-up event in the control node where the finger is outside the bounds of the node. */
  ASControlNodeEventTouchUpOutside    = 1 &lt;&lt; 5,
  /** A system event canceling the current touches for the control node. */
  ASControlNodeEventTouchCancel       = 1 &lt;&lt; 6,
  /** All events, including system events. */
  ASControlNodeEventAllEvents         = 0xFFFFFFFF
};
</code></pre>

<h3 id="toc_46">Hit Test Slop</h3>

<p>尽管所有的node均有<code>hitTestSlop</code>属性，但是在control node中最常用</p>

<pre><code class="language-objectivec">CGFloat horizontalDiff = (bounds.size.width - _playButton.bounds.size.width)/2;
CGFloat verticalDiff = (bounds.size.height - _playButton.bounds.size.height)/2;

_playButton.hitTestSlop = UIEdgeInsetsMake(-verticalDiff, -horizontalDiff, -verticalDiff, -horizontalDiff);

</code></pre>

<h3 id="toc_47">Hit Test Visualization</h3>

<h2 id="toc_48">ASScrollNode</h2>

<p>ASScrollNode是一个<code>ASDisplayNode</code>,其底层是一个<code>UIScrollView</code>.其可以自动采用ASLayoutSpec的大小作为可滚动的contentSize</p>

<h3 id="toc_49">自动管理contentSize</h3>

<p>启用后，由ASSCrollNode布局规范计算的大小将定义滚动视图的<code>.contentSize</code>。在此模式下，滚动视图的边界会填充父级尺寸</p>

<p><code>AutomaticManagesContentSize</code>对于实现了<code>layoutSpecThatFits</code>的ASScrollNode子类很有用，也适用设置了<code>.layoutSpecBlock</code>基类。这两种情况下都通常适用<code>.automaticallyManagesSubnodes</code>属性，以便将layout spec中的node自动添加到可滚动区域</p>

<p>适用这种方法无需捕获布局大小，使用绝对布局规范作为包装器或在代码任何位置设置contentSize，都将会将layout布局更新。通常我们将返回<code>ASStackLayoutSpec</code>，可滚动区域将允许查看所有内容</p>

<h3 id="toc_50">滚动方向</h3>

<p>当使用<code>automaticallyManagersContentSize</code>时，特别因为默认是垂直而你想要水平方向时，这个属性是很有用的</p>

<p>这个属性控制了调整内容大小时的<code>constrainedSize</code></p>

<ul>
<li>Vertical：constrainedSize的.height是为无限制的(<code>CGFLOAT_MAX</code>)</li>
<li>Horizontal：</li>
<li>Vertical&amp;Horizontal：</li>
</ul>

<h2 id="toc_51">ASEditableTextNode</h2>

<p><code>ASEditableTextNode</code>通常在所有使用<code>UITextView</code>或者<code>UITextField</code>的地方使用。</p>

<p>在后台 使用了专门的UITextView作为其底层视图。当在主线程上操作时，你都可以直接访问和操作该视图</p>

<h3 id="toc_52">基础使用</h3>

<p>如果要默认情况下有文本，则可以将属性字符串分配给<code>attributedText</code>属性</p>

<pre><code class="language-objectivec">ASEditableTextNode *editableTextNode = [[ASEditableTextNode alloc] init];
editableTextNode.attributedText = [[NSAttributedString alloc] initWithString:@&quot;Lorem ipsum dolor sit amet.&quot;];
editableTextNode.textContainerInset = UIEdgeInsetsMake(8, 8, 8, 8);
</code></pre>

<h3 id="toc_53">Placeholder Text</h3>

<p>如果要显示占位符 只需要设置<code>attributedPlaceholderText</code>属性</p>

<pre><code class="language-objectivec">editableTextNode.attributedPlaceholderText = [[NSAttributedString alloc] initWithString:@&quot;Type something here...&quot;];
</code></pre>

<p>属性<code>isDisplayingPlaceholder</code>最初为YES，当输入文本设置为非空字符串时，又将切换为NO</p>

<h3 id="toc_54">Typing Attributes</h3>

<p>如果要修改用户将在在这text field中输入文字的style，可以设置<code>typingAttributes</code>属性</p>

<pre><code class="language-objectivec">editableTextNode.typingAttributes = @{NSForegroundColorAttributeName: [UIColor blueColor], 
                                      NSBackgroundColorAttributeName: [UIColor redColor]};
</code></pre>

<h3 id="toc_55">ASEditableTextNode Delegate</h3>

<p>可以使用一下delegate方法 来实现响应关联事件</p>

<pre><code class="language-objectivec">//
- (void)editableTextNodeDidBeginEditing:(ASEditableTextNode *)editableTextNode;

- (BOOL)editableTextNode:(ASEditableTextNode *)editableTextNode shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;

- (void)editableTextNodeDidChangeSelection:(ASEditableTextNode *)editableTextNode fromSelectedRange:(NSRange)fromSelectedRange toSelectedRange:(NSRange)toSelectedRange dueToEditing:(BOOL)dueToEditing;

- (void)editableTextNodeDidUpdateText:(ASEditableTextNode *)editableTextNode;
- 
- (void)editableTextNodeDidFinishEditing:(ASEditableTextNode *)editableTextNode;

</code></pre>

<h2 id="toc_56">ASMultiplexImageNode</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15697458035343.html">Node Containers</a></h1>
			<p class="meta"><time datetime="2019-09-29T16:30:03+08:00" 
			pubdate data-updated="true">09/29/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">ASViewController</h2>

<p><code>ASViewController</code>是<code>UIViewController</code>的子类，添加了一些有用的功能来承载<code>ASDisplayNode</code>层次结构<br/>
可以使用<code>ASViewController</code>代替任何UIViewControlller</p>

<p>使用<code>ASViewController</code>的好处:</p>

<ol>
<li>保存内存。</li>
<li>ASVisibility</li>
</ol>

<h3 id="toc_1">使用</h3>

<p><code>UIViewController</code>提供了自己的View。<code>ASViewController</code>在初始化时  通过<code>initWithNode</code>分配了要管理的节点</p>

<pre><code class="language-objectivec">//例如 修改视图控制器的视图的根node 为 table node

- (instancetype)init
{
  _tableNode = [[ASTableNode alloc] initWithStyle:UITableViewStylePlain];
  self = [super initWithNode:_tableNode];
  
  if (self) {
    _tableNode.dataSource = self;
    _tableNode.delegate = self;
  }
  
  return self;
}
</code></pre>

<h2 id="toc_2">ASTableNode</h2>

<p>相当于<code>UITableView</code> 并且可以用来代替任何<code>UITableView</code></p>

<pre><code class="language-objectivec">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath

//替换方法
- (ASCellNode *)tableNode:(ASTableNode *)tableNode nodeForRowAtIndexPath:(NSIndexPath *)indexPath
//或者
- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath
</code></pre>

<blockquote>
<p>建议使用 nodeblock版本，以便table node可以同时准备和display。这意味着所有的<code>subnode</code>初始化方法都会在后台运行，请确保线程安全。</p>
</blockquote>

<p><code>ASCellNodeBlock</code>是创建<code>ASCellNode</code>的block，能够在后台线程运行。</p>

<blockquote>
<p>注意</p>

<p><code>ASCellNodes</code>被<code>ASTableNode、ASCollectionNode、ASPagerNode</code>使用</p>

<p>这些方法均不需要重用机制(只会执行一次，与UIKIt不同，当行要显示时不会调用这些方法)</p>
</blockquote>

<h3 id="toc_3">node block的线程安全</h3>

<p>node blocks必须是线程安全的。一方面是确保在node block外访问数据模型。因此，不太需要会在block内部访问indexPath</p>

<pre><code class="language-objectivec">- (ASCellNodeBlock)tableNode:(ASTableNode *)tableNode nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoModel *photoModel = [_photoFeed objectAtIndex:indexPath.row];
    
    // this may be executed on a background thread - it is important to make sure it is thread safe
    ASCellNode *(^cellNodeBlock)() = ^ASCellNode *() {
        PhotoCellNode *cellNode = [[PhotoCellNode alloc] initWithPhoto:photoModel];
        cellNode.delegate = self;
        return cellNode;
    };
    
    return cellNodeBlock;
}
</code></pre>

<h3 id="toc_4">ASTableView的访问</h3>

<p><code>ASTableView</code>是<code>UITalbeView</code>的子类，在<code>ASTalbeNode</code>内部进行使用，可以在<code>viewDidLoad</code>或<code>didLoad</code>方法找中通过<code>.view</code>属性访问节点的<code>view</code>或者<code>layer</code>属性</p>

<p>例如，可以再<code>ViewDidLoad</code>方法中 访问呢表节点的视图完成对表格的分隔符样式设置</p>

<pre><code class="language-objectivec">- (void)viewDidLoad
{
  [super viewDidLoad];
  
  _tableNode.view.allowsSelection = NO;
  _tableNode.view.separatorStyle = UITableViewCellSeparatorStyleNone;
  _tableNode.view.leadingScreensForBatching = 3.0;  // default is 2.0
}
</code></pre>

<h3 id="toc_5">行高</h3>

<p>需要注意的是： ASTableNode不提供和<code>UITableView</code>的<code>tableView:heightForRowAtIndexPath</code>等效功能<br/>
这是因为node 会根据提供的约束确定其自身的高度，因此不再需要编写代码在视图控制器中确定此信息<br/>
node通过<code>layoutSpecThatFits</code>方法 返回的<code>layoutSpec</code>定义其高度。所有给定了限制size的node都可以计算其目标size</p>

<p>默认情况，<code>ASTableNode</code>给其cell提供的大小范围约束，其中最小宽度为tablenode的宽度，最小高度为0.最大宽度为tablenode的宽度，最大高度为<code>FLT_MAX</code>，就是说table的cell宽度是固定的为整个table的宽度，但是其高度时灵活的，可以自动调整大小</p>

<p>如果在<code>ASCellNode</code>上调用<code>-setNeddsLayout</code> 将自动执行一遍布局，如果总体所需大小已经更改，通知table 将会进行更新</p>

<blockquote>
<p>注意</p>

<p>这些规则和UIKit不同，在UIKit中必须调用reload row/item。这样就节省了大量代码</p>
</blockquote>

<h2 id="toc_6">ASCollectionNode</h2>

<p>ASCollectionNode 等效于 UICollectionView 可以在任何情况下替代<code>UICollectionView</code></p>

<pre><code class="language-objectivec">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath;
//替换为
- (ASCellNode *)collectionNode:(ASCollectionNode *)collectionNode nodeForItemAtIndexPath:(NSIndexPath *)indexPath
//或
- (ASCellNodeBlock)collectionNode:(ASCollectionNode *)collectionNode nodeBlockForItemAtIndexPath:(NSIndexPath *)indexPath
</code></pre>

<p>推荐使用node block </p>

<h3 id="toc_7">cell 大小和布局</h3>

<p>可以使用<code>ASCollectionNode</code>的<code>-constrainedSizeForItemAtIndexPath：</code>约束colletion node中使用的cell</p>

<h3 id="toc_8">UICollectionViewCell的互通性</h3>

<p><code>ASCollectionNode</code>支持<code>UICollectionViewCells</code>和<code>ASCellNodes</code>一起使用</p>

<p>注意：即使混合在统一<code>ASCollectionNode</code>中，这些<code>UIKit</code>组件也不会有<code>ASCellNode</code>的性能优势</p>

<h2 id="toc_9">ASPageNode</h2>

<p><code>ASPageNode</code>是<code>ASCollectionView</code>的子类，只是内部采用了特殊的<code>UIColelctionViewLayout</code></p>

<p><code>ASPageNode</code>可以创建出类似<code>UIPageViewController</code>创建的页面UI。支持在轮换期间停留在正确的页面。不支持循环滚动</p>

<pre><code class="language-objectivec">- (NSInteger)numberOfPagesInPagerNode:(ASPagerNode *)pagerNode
//和
- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index
//或者
- (ASCellNodeBlock)pagerNode:(ASPagerNode *)pagerNode nodeBlockAtIndex:(NSInteger)index`
</code></pre>

<h3 id="toc_10">使用ASViewController来获得最佳性能</h3>

<p>一种特别有用的模式就是 返回 使用现有<code>UIViewController</code>或者<code>ASViewController</code>初始化的ASCellNode。当然，为了获得最佳性能请使用<code>ASViewController</code></p>

<pre><code class="language-objectivec">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index
{
    NSArray *animals = self.animals[index];
    
    ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^{
        return [[AnimalTableNodeController alloc] initWithAnimals:animals];;
    } didLoadBlock:nil];
    
    node.style.preferredSize = pagerNode.bounds.size;
    
    return node;
}
</code></pre>

<p>在这个例子中，该节点使用<code>initWithViewControllerBlock：</code>方法构造。通常时必须采用这种方法，以便执行正确的布局</p>

<h3 id="toc_11">使用ASPagerNode作为ASViewController的root node</h3>

<p><a href="https://texturegroup.org/docs/containers-aspagernode.html">log message</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15697378626983.html">先进技术</a></h1>
			<p class="meta"><time datetime="2019-09-29T14:17:42+08:00" 
			pubdate data-updated="true">09/29/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">ASVisibility</h2>

<p><code>ASNavigationController</code>和<code>ASTabBarController</code>都实现了<code>ASVisibility</code>协议。即使没有<code>ASDisplayNodes</code>，也可以使用这些类，从而使他们称为继承层次结构的合适基类。对于任何作为<code>ASViewControllers</code>的子视图控制器，这些类都知道视图控制器可见所需的确切用户点击次数(如果当前可见，则为0)</p>

<p>当知道了视图控制器的可见性深度后，</p>

<ol>
<li>视图控制器可以在用户接近或离开用户时自动采取适当的措施。</li>
<li>app的非默认Tabs可能会预加载某些数据；</li>
<li>导航堆栈中深3层的控制器可能会主动释放使用的图像、文本和提取内存中的数据</li>
</ol>

<p>任何视图控制器容器类都可以实现一个简单的协议来集成。例如，<code>ASNavigationController</code>将为只需要点击一个后退按钮即可显示该可见性的视图控制器返回其自己的<code>visibleDepth+1</code>的可见性深度，</p>

<p>可以通过在<code>ASViewControllers</code>上自动启用<code>AdjustRangeModeBasedOnViewEvents</code>来自动选择某些行为。启用此功能呢后，如果视图控制器和节点符合<code>ASRangeControllerUpdateRangeProtocol</code>(ASCollectionNode和ASTableNode默认遵循)，范围会随着可见深度的增加而自动减小以节省内存</p>

<h2 id="toc_1">ASRunLoopQueue</h2>

<p>即使在主线程，Texture扔可以通过相当出色的<code>ASRunLoopQueue</code>大大减少对用户体验的影响</p>

<p><code>ASRunloopQueue</code>将必须在主线程执行的操作分解我更小的块，轻松的达到原本大小的1/10，从而可以分散例如初始化UIView甚至销毁对象的操作，使runLoop 更加频繁的运转。这种周期性的运转使设备更加频繁的检查用户是否已经已经开始触摸或动画计时器是否有新的帧需要绘制，这样即使设备非常繁忙并正在处理大量主线程，也会提供更高的响应速度</p>

<p>运行Texture时 会默认启用<code>ASRunLoopQueue</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15695667474220.html">工具</a></h1>
			<p class="meta"><time datetime="2019-09-27T14:45:47+08:00" 
			pubdate data-updated="true">09/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">点击范围可视化</h2>

<h3 id="toc_1">ASControlNode的可点击区域</h3>

<p>这个调试功能会在任何包含点击区域，<code>target：action：</code>或者手势识别器的<code>ASControlNode</code>上添加半透明的高亮覆盖。<br/>
可点击范围定义为:<code>ASControlNode</code>框架及<code>.hitTestSlop UIEdgeInsets</code></p>

<h3 id="toc_2">限制</h3>

<p>可点击区域的绿色边框，表示其点击区域是被其父视图的点击区域限制</p>

<p>可点击区域的橙色边框，表示点击区域是被被其父结构层次限制</p>

<h3 id="toc_3">使用方法</h3>

<p>在<code>AppDelegate.m</code>文件中</p>

<ul>
<li> 引入<code>AsyncDisplayKit+Debug.h</code></li>
<li> 在<code>didFinishLaunchingWithOptions</code>方法中添加<code>[ASControlNode setEnableHitTestDebug:YES]</code></li>
</ul>

<blockquote>
<p>注意</p>

<p>确保在初始化任何Node之前 初始化该方法</p>
</blockquote>

<h2 id="toc_4">图像缩放</h2>

<h3 id="toc_5">可视化ASImageNode.image 像素缩放</h3>

<p>这个调试功能，当图像大小(以像素为单位)和边界大小(以像素为单位)不匹配时，此调试功能会在<code>ASImageNode</code>的右下角添加红色文本</p>

<p>这个debug可以帮助我们快速:</p>

<ul>
<li>是否下载和渲染了过多的数据</li>
<li>是否放大了低质量图像</li>
</ul>

<h3 id="toc_6">使用方法</h3>

<p>在<code>AppDelegate.m</code>文件中</p>

<ul>
<li> 引入<code>AsyncDisplayKit+Debug.h</code></li>
<li> 在<code>didFinishLaunchingWithOptions</code>方法中添加<code>[ASImageNode setShouldShowImageScalingOverlay:YES]</code></li>
</ul>

<h2 id="toc_7">范围可视化</h2>

<h3 id="toc_8">可视化ASRangeController</h3>

<p>这个调试功能功能会在<code>shared Application的keyWindow</code>右下角添加了一个半透明的子视图，这个子视图会为屏幕上的每个<code>ASRangeController</code>实例显示<code>ASLayoutRangeType</code>的<code>ASRangeTuningParameters</code></p>

<ul>
<li>ASRangeController实例表示为条形</li>
<li>在滚动时 绿色(可见区域)、黄色(display区域)、红色(获取数据区域)，在相对于彼此进行移动</li>
<li><code>RangeController</code>的侧的白色箭头表示的滚动方向，帮助你确定头尾的<code>tuning parameters</code></li>
<li>上栏的白色标签显示了<code>RangeController</code>中的数据类名，区分嵌套式图</li>
</ul>

<blockquote>
<p>注意</p>

<p>仅展示屏幕上的<code>ASRangeControllers</code><br/>
各个比例是相对的 不同的条形图之前并无法比较大小的</p>
</blockquote>

<h3 id="toc_9">使用方法</h3>

<p>在<code>Appdelegate.h</code>文件中</p>

<ul>
<li><code>import AsyncDisplayKit+Debug.h</code></li>
<li>在顶部添加<code>[ASDisplayNode setShouldShowRangeDebugOverlay:YES]</code>方法</li>
</ul>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="AsyncDisplayKit_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B&&Runloop.html"><strong>多线程&&Runloop&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="RunLoop.html">RunLoop&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html">线程安全&&锁&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="KVC&&KVO.html">KVC&&KVO&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&&block.html"><strong>内存管理&&block&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">OC高级编程-内存管理&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="block%E5%AD%A6%E4%B9%A0.html">block学习&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">官方文档-内存管理&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%8B%BE%E9%81%97.html">内存管理-拾遗&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&&%E7%BB%84%E4%BB%B6%E5%8C%96.html"><strong>设计模式&&组件化&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html">设计模式架构谈(摘录)&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html">组件化开发学习&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BC%96%E8%AF%91&&dyld&&Mach-O.html"><strong>编译&&dyld&&Mach-O&nbsp;(19)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html">iOS编译流程&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html">dyld(程序启动)&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html">Mach-O文件了解&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86.html"><strong>模块化知识&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS-CoreAnimation.html">iOS-CoreAnimation&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="CoreGraphic.html">CoreGraphic&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="ARKit.html">ARKit&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"><strong>第三方项目学习和使用&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="AFNetworking.html">AFNetworking&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="AsyncDisplayKit.html">AsyncDisplayKit&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="ReactnativeCocoa.html">ReactnativeCocoa&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="PromiseKit.html">PromiseKit&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96.html"><strong>项目监控和优化&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html">APP体积优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html">启动优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%B0%83%E8%AF%95&&%E6%B5%8B%E8%AF%95.html"><strong>调试&&测试&nbsp;(6)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="LLDB.html">LLDB&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html">自动化测试&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="git.html">git&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>