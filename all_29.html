
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14974079542932.html">常见名词</a></h1>
			<p class="meta"><time datetime="2017-06-14T10:39:14+08:00" 
			pubdate data-updated="true">06/14/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">M2M</h3>

<p>M2M ：M2M是将数据从一台终端传送到另一台终端，也就是机器与机器（Machine to Machine）的对话</p>

<h3 id="toc_1">QoS</h3>

<p>QoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术</p>

<h3 id="toc_2">嵌套函数</h3>

<p>嵌套函数，就是指在某些情况下，您可能需要将某函数作为另一函数的参数使用。</p>

<p>C语言中函数的定义都是相互平行、相互独立的，也就是说在函数定义时，函数体内不能包含另一个函数的定义，即函数不能嵌套定义，但可以嵌套调用。</p>

<h3 id="toc_3">重载</h3>

<p>重载:指两个函数的函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同<br/>
OC不完全支持重载,即OC支持参数个数不同的函数重载,Swift是完全支持重载的</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14976096897839.html">字符串和字符</a></h1>
			<p class="meta"><time datetime="2017-06-16T18:41:29+08:00" 
			pubdate data-updated="true">06/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>字符串是字符的集合,用<code>string</code>类型表示. 一个<code>String</code>的内容可以用许多方式读取，例如作为包括作为<code>Character</code>值的集合的方式</p>

<p><code>Swift</code>的<code>String</code>和<code>Character</code>类型提供了快速和兼容<code>Unicode</code>的方式供代码使用。<br/>
String 类型是一种快速、现代化的字符串实现。 每一个字符串都是由编码无关的<code>Unicode</code>字符组成，并支持访问字符的多种<code>Unicode</code>表示形式</p>

<blockquote>
<p>注意</p>

<p>Swift的String类型 与 Foundation的NSString类型可以无缝桥接。<br/>
Foundation对String扩展，使其可以访问NSString类型中定义的方法。<br/>
这意味着可以直接调用NSString方法，而无需进行任何类型转换</p>
</blockquote>

<h2 id="toc_0">字符串字面量</h2>

<pre><code class="language-swift">//someString 常量通过字符串字面量进行初始化
let someString = &quot;Some string literal value&quot;
</code></pre>

<h3 id="toc_1">多行字符串字面量</h3>

<p>三个双引号包括这具有稳定属性的文本字符集合</p>

<pre><code class="language-swift">let quotation = &quot;&quot;&quot;
The White Rabbit put on his spectacles.  &quot;Where shall I begin,
please your Majesty?&quot; he asked.

&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on
till you come to the end; then stop.&quot;
&quot;&quot;&quot;
</code></pre>

<p>如果多行字符串中包含换行符的话，则多行字符串字面量也会包含换行符。<br/>
可以通过在行末尾添加反斜杠<code>\</code>作为续行符</p>

<h3 id="toc_2">字符串字面量的特殊字符</h3>

<p>特殊字符主要有：</p>

<ul>
<li>转义字符<code>\0</code>、反斜杠<code>\\</code>、水平制表符<code>\t</code>、换行符<code>\n</code>、回车符<code>\r</code>、双引号<code>&quot;</code>、单引号<code>\&#39;</code></li>
<li>Unicode标量，写法为<code>\u{n}</code>(u为小写)，n为任意一到八位十六进制数且可用的unicode码</li>
</ul>

<pre><code class="language-swift">let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;
// &quot;Imageination is more important than knowledge&quot; - Enistein
let dollarSign = &quot;\u{24}&quot;             // $，Unicode 标量 U+0024
let blackHeart = &quot;\u{2665}&quot;           // ♥，Unicode 标量 U+2665
let sparklingHeart = &quot;\u{1F496}&quot;      // 💖，Unicode 标量 U+1F496
</code></pre>

<p>由于多行字符串字面量使用了三个双引号，所以可以再多行字符串字面量直接使用双引号而不用加转义符。</p>

<pre><code class="language-swift">let threeDoubleQuotes = &quot;&quot;&quot;
Escaping the first quote \&quot;&quot;&quot;
Escaping all three quotes \&quot;\&quot;\&quot;
&quot;&quot;&quot;
</code></pre>

<h3 id="toc_3">扩展字符串分隔符</h3>

<p>将字符串文字放在扩展分隔符中，字符串的特殊字符会被直接包含而非转义后的效果<br/>
如果想要在扩展分隔符中的文字有特殊效果，可以在转义字符后添加与其实位置个数相匹配的<code>#</code>符<br/>
扩展分隔符也可以用于多行字符串文字</p>

<pre><code class="language-swift">＃&quot;Line 1 \nLine 2&quot;＃  //打印的为\n而非换行符

＃&quot;Line 1 \#nLine 2&quot;＃   //实现换行效果
###&quot;Line1 \###nLine2&quot;### //实现换行效果

let threeMoreDoubleQuotationMarks = #&quot;&quot;&quot;
Here are three more double quotes: &quot;&quot;&quot;
&quot;&quot;&quot;#
</code></pre>

<h2 id="toc_4">初始化空字符串</h2>

<pre><code class="language-swift">var emptyString = &quot;&quot; // 空字符串字面量
var anotherEmptyString = String() // 初始化方法


if emptyString.isEmpty {
print(&quot;Nothing to see here&quot;)
}
// 打印输出：&quot;Nothing to see here&quot;
</code></pre>

<h2 id="toc_5">字符串可变性</h2>

<pre><code class="language-swift">//通过指定为变量使其可修改
var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;
// variableString 现在为 &quot;Horse and carriage&quot;
</code></pre>

<p>与OC中的<code>NSString</code>和<code>NSMutableSting</code>确定是否可更改不同,<code>Swift</code>中类似其他值取决于其被定义为常量还是变量</p>

<h2 id="toc_6">字符串是值类型</h2>

<p><strong><code>Swift</code>的<code>String</code>类型是值类型</strong>。如果您<strong>创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作</strong>。这样保证了在函数/方法中传递的是字符串的值不会被修改，除非你自己去修改它。</p>

<blockquote>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>

<p>注意:</p>

<p><code>Swift</code>的<code>String</code>是值类型而<code>NSString</code>是引用类型,<code>NSString</code>的意思是初始化了一个指针指向了这个字符串，但Swift <code>String</code>的意思则是把字符串字面量赋值给变量</p>
</blockquote>

<h2 id="toc_7">使用字符</h2>

<p>可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code> 属性来获取每一个字符的值</p>

<pre><code class="language-swift">for character in &quot;Dog!?&quot;.characters {
    print(character)
}
// 
</code></pre>

<pre><code class="language-swift">//声明一个Character类型
let exclamationMark: Character = &quot;!&quot;

//用character类型数组初始化字符串
let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]
let catString = String(catCharacters)
print(catString)

</code></pre>

<h2 id="toc_8">连接字符串和字符</h2>

<p>字符串可以通过加法相加在一起<br/>
可以通过<code>+=</code>运算符将一个字符串添加到一个已经存在字符串变量上</p>

<pre><code class="language-swift">let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2

var instruction = &quot;look over&quot;
instruction += string2
</code></pre>

<p>可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部</p>

<pre><code class="language-swift">//初始化字符也是用双引号
let exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
// welcome 现在等于 &quot;hello there!&quot;
</code></pre>

<blockquote>
<p>注意</p>

<p>不能将一个字符串或者字符添加到字符变量上，因为字符变量只能包含一个字符</p>

<p>初始化字符也是用双引号与c中使用单引号不同</p>
</blockquote>

<h2 id="toc_9">字符串插值</h2>

<p>可以用以反斜线为前缀的圆括号将常量、变量或表达式插入字符串字面量或者多行字符串字面量之中</p>

<pre><code class="language-swift">let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
// message 是 &quot;3 times 2.5 is 7.5&quot;
</code></pre>

<blockquote>
<p>注意</p>

<p>插值字符串中写在括号内的表达式不能包含非转义反斜杠 ()，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>

<h2 id="toc_10">Unicode</h2>

<p>Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p>

<h3 id="toc_11">Unicode标量</h3>

<p><code>Unicode</code>标量是对应字符或者修饰符的唯一的21位数字</p>

<blockquote>
<p>Unicode 码位(code poing) 的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF<br/>
Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位，其码位范围是 U+D800 到 U+DFFF 。<br/>
不是所有的21位<code>Unicode</code>标量都代表一个字符，因为有一些标量是留作未来分配的。</p>
</blockquote>

<h3 id="toc_12">可扩展的字形群集</h3>

<p>每一个<code>Swift</code>的<code>Character</code>类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<pre><code class="language-swift">/*
    字母 é 可以用单一的 Unicode 标量 é (U+00E9)来表示
    一个标准的字母e(U+0065)加上一个急促重音的标量(U+0301)，这样一对标量就表示了同样的字母é 
*/
let eAcute: Character = &quot;\u{E9}&quot; // é
let combinedEAcute: Character = &quot;\u{65}\u{301}&quot; // e 后面加上 ?
// eAcute 是 é, combinedEAcute 是 é
</code></pre>

<p>因此我们可以用很多复杂的脚本字符来表示单一的Character值</p>

<p>可扩展字形集是一个将许多复杂的脚本字符表示为单个字符值的灵活方式。</p>

<p>例如</p>

<pre><code class="language-swift">/*
    可拓展的字符群集可以使包围记号的标量包围其他Unicode标量，作为一个单一的Character值
*/
let enclosedEAcute: Character = &quot;\u{20DD}&quot;//&quot;⃝&quot;
let enclosedEAcute11: Character = &quot;\u{E9}\u{20DD}&quot;//é⃝
</code></pre>

<h2 id="toc_13">计算字符数量</h2>

<p>通过字符串的<code>count</code>属性获取<code>Character</code>值的数量</p>

<p>注意:<br/>
我们在使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时不一定会改变字符数量</p>

<pre><code class="language-swift">var word = &quot;cafe&quot;//这时候字符数量是4
word += &quot;\u{301}&quot; //这时候字符数量还是4 因为e和新增的字符组合为é

let eAcute = &quot;\u{00E9}&quot; // é
eAcute.characters.count //字符数量为1
let combinedEAcute = &quot;\u{65}\u{301}&quot; //
combinedEAcute.characters.count //字符数量为1

</code></pre>

<blockquote>
<p>注意：</p>

<p>可扩展的字形群集可以由多个Unicode标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以Swift中的字符在一个字符串中并不一定占用相同的内存空间数量。因此，在没有获取字符串中的可扩展的字符群范围时，就不能计算出字符串的字符数量。如果在正在入里一个长字符串，需要注意count属性必须遍历全部的unicode标量，来确定字符串的字符数量</p>

<p>另外需要注意的时通过count属性返回的字符数量并不总是与包括相同字符的NSString的Length属性相同。NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是Unicode可扩展字符群集。作为佐证，当一个 NSString 的 length 属性被一个Swift的 String 值访问时，实际上是调用了 <code>utf16Count</code></p>
</blockquote>

<h2 id="toc_14">访问和修改字符串</h2>

<h3 id="toc_15">字符串索引</h3>

<p><code>String.Index</code>对应着字符串中的每一个<code>Character</code>的位置</p>

<p>因为字符串中每个<code>Character</code>是可扩展的字符群集,所以想要知道character的人确切位置就像从String开头遍历每一个Unicode标量直到结尾才行。因此，Swift字符串不能用整数做索引</p>

<p><code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引<br/>
<code>endIndex</code>属性可以可以获取<strong>最后一个<code>Character</code>的后一个位置的索引。</strong>因此<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的</p>

<p>可以使用<code>String</code>的<code>index(before:)</code>或<code>index(after:)</code>来获取前一个或者后一个,或者用<code>index(:_offsetBy:)</code>取得对应偏移量的索引</p>

<p>获取对应下标索引的字符:</p>

<pre><code class="language-swift">let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex]// G
greeting[greeting.index(after: greeting.endIndex)]// !
//当越界是或引发运行时的错误(可以在编译时就检测出来)
</code></pre>

<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符</p>

<pre><code class="language-swift">for index in greeting.characters.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
// 打印输出 &quot;G u t e n T a g ! &quot;
</code></pre>

<blockquote>
<p>我们在上面在<code>String</code>中获取的index的方法,可以用于在任意一个确认的并遵循<code>Collection</code>协议的类型里面(例如Array、Dictionary、Set)</p>
</blockquote>

<h3 id="toc_16">插入和删除</h3>

<p>调用<code>insert(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符，调用<code>insert(contentsOf:at:)</code>方法可以在一个字符串的指定索引插入一个段字符串。</p>

<pre><code class="language-swift">//注意必须是变量
var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, at: welcome.endIndex)
// welcome 变量现在等于 &quot;hello!&quot;
welcome.insert(contentsOf:&quot; there&quot;.characters, at: welcome.index(before: welcome.endIndex))
// welcome 变量现在等于 &quot;hello there!&quot;
</code></pre>

<p>调用<code>remove(at:)</code>方法可以在一个字符串的指定索引删除一个字符，调用<code>removeSubrange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>

<pre><code class="language-swift">welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 &quot;hello there&quot;
let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex
welcome.removeSubrange(range)
// welcome 现在等于 &quot;hello&quot;
</code></pre>

<blockquote>
<p><code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code>和<code>removeSubrange(_:)</code>方法在任意一个确认的并遵循<code>RangeReplaceableCollection</code>协议的类型里面，如上文所示是使用在 <code>String</code>中，您也可以使用在<code>Array</code>、<code>Dictionary</code>和<code>Set</code>中。</p>
</blockquote>

<h3 id="toc_17">子字符串</h3>

<pre><code class="language-swift">let greeting = &quot;Hello, world!&quot;
let index = greeting.firstIndex(of: &quot;,&quot;) ?? greeting.endIndex
let beginning = greeting[..&lt;index]
// beginning 的值为 &quot;Hello&quot;

// 把结果转化为 String 以便长期存储。
let newString = String(beginning)
</code></pre>

<p>当从String中获取一个SubString实例。Swift中的SubString绝大部分函数和String相同，可以使用相同的方式去操作。但是，与String不同的是，SubString只适合短时间操作字符串。</p>

<p>类似String，每个SubString也会在内存中保存字符集。而String和SubString的区别在性能优化上，SubString可以重用原String的内存空间或者另一个SubString的内存空间(String也有相同的优化，短时如果共享内存的话两者就会想等)。这对子字符串的优化意味着在修改String或者SubString之前都不需要去复制消耗内存。但是这也导致一个问题，因为SubString重用了原有内存的空间，原String的内存空间必须保留到SUbString不在使用为止</p>

<p><img src="media/14976096897839/15650786814829.jpg" alt="" style="width:500px;"/></p>

<h2 id="toc_18">比较字符串</h2>

<h3 id="toc_19">字符串/字符相等</h3>

<p>直接用 <code>==</code> 和 <code>!=</code>进行比较</p>

<p>判断标准等于的标准是:当有同样的语义和外观,就被认为是相等的,即使他们的可扩展字形群集可能由不同的<code>Unicode</code>标量构成</p>

<p>例如:<br/>
((U+00E9)标准等于((U+0065)(U+0301))) (都是<code>é</code>表示的有效方式)<br/>
U+0041(英语中的A)不等于U+0410(俄语中的A)尽管外观看着一样</p>

<h3 id="toc_20">前缀/后缀</h3>

<p>通过字符串的<code>hasPrefix(_:) / hasSuffix(_:)</code>方法来检查字符串是否用于特定前缀/后缀</p>

<h2 id="toc_21">字符串的Unicode表示</h2>

<p>当<code>Unicode</code>字符串写进文本文件或者其他存储时，<code>Unicode</code>会用几种<code>编码格式</code>编码(如：UTF-8 UTF-16 UTF-32) 每一个字符串中的小块编码都被称<code>代码单元</code></p>

<p>除了前面说过的用<code>for-in</code>对字符串遍历,然后访问每个<code>character</code>值的方式外:<br/>
其他三种<code>Unicode</code>兼容方式访问字符串</p>

<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的Unicode标量值集合，也就是字符串的UTF-32编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>

<p>let dogString = &quot;Dog‼🐶&quot;(其中“!!”为U+203C 🐶为U+1F436)</p>

<h4 id="toc_22">UTF-8表示</h4>

<p>通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示， 其为<code>String.UTF8View</code>类型的属性， <code>UTF8View</code>是无符号8位(UInt8)值的集合，每一个UInt8值都是一个字符的UTF-8表示</p>

<pre><code class="language-swift">for codeUnit in dogString.utf8 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)// 68 111 103 226 128 188 240 159 144 182
/*
前三个10进制 codeUnit 值 ( 68 , 111 , 103 ) 代表了字符 D 、 o 和 g ，它们的 UTF-8 表示与ASCII 表示相同。
 接下来的三个10进制 codeUnit 值 ( 226 , 128 , 188 ) 是 DOUBLE 
EXCLAMATION MARK 的3字节 UTF-8 表示。 
最后的四个 codeUnit 值 ( 240 , 159 , 144 , 182 ) 是 DOG FACE 的4字节UTF-8 表示。
*/
</code></pre>

<blockquote>
</blockquote>

<h4 id="toc_23">UTF-16表示</h4>

<p>与utf-8类似,访问其utf-16属性,是<code>String.UTF16View</code>类型(<code>UInt16</code>值集合)</p>

<pre><code class="language-swift">for codeUnit in dogString.utf16 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 55357 56374
</code></pre>

<h4 id="toc_24">Unicode标量表示</h4>

<p>通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的<code>Unicode</code>标量表示。为<code>UnicodeScalarView</code>类型的属性(<code>UnicodeScalar</code>类型的值的集合)。<br/>
<code>UnicodeScalar</code>是21位的<code>Unicode</code>代码点,拥有一个<code>value</code>属性，可以返回对应的21位数值，用 UInt32 来表示：</p>

<pre><code class="language-swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 128054
</code></pre>

<blockquote>
<p>我们平常代码中的Unicode编码就是这种21位<br/>
UTF-32也是编码一样为21位，因此swift中的有了unicodeScalars属性也就没有utf32属性</p>
</blockquote>

<p>每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值</p>

<pre><code class="language-swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar) &quot;, terminator: &quot;&quot;)
}
// D o g !! 🐶
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15537643467312.html">iOS 编译 Clang 和 LLVM</a></h1>
			<p class="meta"><time datetime="2019-03-28T17:12:26+08:00" 
			pubdate data-updated="true">03/28/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>本文学习自戴铭老师的<a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E7%BC%96%E8%AF%91-Clang---LLVM">深入剖析 iOS 编译 Clang LLVM</a></p>

<h2 id="toc_0">LLVM</h2>

<p>LLVM( Low Level Virtual Machine)是swift之父开发的一款编译器开发工具套件，可以用于常规编译器，JIT编译器（JIT是一种提高程序运行效率的方法）、汇编器、调试器、静态分析工具等。其后来又开发了clang，</p>

<p>iOS开发中的OC就是用Clang/LLVM来编译的</p>

<p>Swift是swift/LLVM,其中Swift前端会多出来SIL optimizer（SIL优化器），把.swift生成的中间代码 .sil，因为swift在编译期间就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再需要像OC那样的消息发送，这样编译器可以获得更多信息在后面的后端优化上</p>

<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang是LLVM的子集，是C、C++、Object-C的编译器，用来专门给Apple使用提供比GCC更快的编译速度。Clang提供了<code>clang static analyzer</code>即analyzer分析工具用于进行语法分析，语义分析和生成中间代码，这个过程会对代码进行检查，出错的和需要警告的会标注出来。<code>lld</code>是Clang/LLVM内置的链接器，clang必须调用链接器来产生可执行文件</p>

<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR（IR寄存器？），这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成</p>

<h2 id="toc_1">编译流程</h2>

<p>先写一个简单的例子程序来看一下程序如何运行</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#define DEFINEEight 8
int main(int argc, char * argv[]) {
    @autoreleasepool {
#pragma mark - Mark--
        int eight = DEFINEEight;
        int six = 6;
        char a = &#39;a&#39;;
        char *str = &quot;strTest&quot;;
        NSString *site = [[NSString alloc] initWithUTF8String:&quot;starming&quot;];
        int rank = eight + six;
        NSLog(@&quot;%@ rank %d&quot;, site, rank);
        printf(&quot;%s and %c&quot;, str, a);
//        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
//    return 0;
}
</code></pre>

<p>查看<code>clang</code>编译的阶段</p>

<pre><code class="language-text">//在终端输入命令
clang -ccc-print-phases main.m

//总共有7步骤，
0: input, “main.m”, objective-c //输入文件
1: preprocessor, {0}, objective-c-cpp-output //预编译
2: compiler, {1}, ir //优化编译为中间代码IR,前端的输出、后端的输入
3: backend, {2}, assembler //编译为汇编语言
4: assembler, {3}, object //汇编为目标程序
5: linker, {4}, image //链接为可执行文件
6: bind-arch, “x86_64”, {5}, image 
</code></pre>

<p>查看OC代码的C语言实现:<br/>
<code>clang -rewrite-objc main.m</code>会生成一个main.cpp的C语言文件</p>

<pre><code class="language-c">//在文件的最后可以看到我们代码的实现
int main(int argc, char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        int eight = 8;
        int six = 6;
        char a = &#39;a&#39;;
        char *str = &quot;strTest&quot;;
        NSString *site = ((NSString * _Nullable (*)(id, SEL, const char * _Nonnull))(void *)objc_msgSend)((id)((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;initWithUTF8String:&quot;), (const char *)&quot;starming&quot;);
        int rank = eight + six;
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_m7_58pb6m6x3dqbv727djzdvbvw0000gn_T_main_3cf008_mi_0, site, rank);
        printf(&quot;%s and %c&quot;, str, a);

    }

}
</code></pre>

<p>查看操作内部命令，可以使用 -### 命令<br/>
clang -### main.m -o main</p>

<ol>
<li><p>查看clang的的预编译实现:<br/>
<code>clang -E main.m</code> 查看预编译的结果</p>
<pre><code class="language-objectivec">
//在预编译文件的最后可以看到我们代码的预编译结果<br/>
# 1 &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot; 1 3<br/>
# 185 &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot; 2 3<br/>
# 12 &quot;main.m&quot; 2<br/>
int main(int argc, char * argv[]) {<br/>
    @autoreleasepool {<br/>
        UIView *view = [[UIView alloc] init];<br/>
        view.backgroundColor = [UIColor redColor];<br/>
        int eight = 8;<br/>
        int six = 6;<br/>
        char a = &#39;a&#39;;<br/>
        char *str = &quot;strTest&quot;;<br/>
        NSString *site = [[NSString alloc] initWithUTF8String:&quot;starming&quot;];<br/>
        int rank = eight + six;<br/>
        NSLog(@&quot;%@ rank %d&quot;, site, rank);<br/>
        printf(&quot;%s and %c&quot;, str, a);<br/>
    }<br/>
}
</code></pre>
<p>在预编译的过程中做的事情有:</p>
<ul>
<li><code>#define</code>宏的替换</li>
<li><code>#include</code><code>#import</code>文件的导入</li>
<li><code>#indef</code></li>
<li>注释的去除</li>
<li><code>#pragma</code>的去除</li>
</ul></li>
<li><p>在预处理完成后进行词法分析，把代码编程一个个的token，比如大小括号，等于号还有字符串等,格式化代码<br/>
<code>clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</code></p></li>
<li><p>然后语法分析，验证语法是否正确，将所有节点组成抽象语法树AST<br/>
<code>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p>
<p>下面为部分简单语句的AST结构:<br/>
//<code>int eight = 8;</code><br/>
<img src="media/15537643467312/15538400757623.jpg" alt="" style="width:880px;"/> <br/>
    //<code>char a = &#39;a&#39;;</code><br/>
<img src="media/15537643467312/15538401099554.jpg" alt="" style="width:840px;"/><br/>
    //<code>char *str = &quot;strTest&quot;;</code><br/>
<img src="media/15537643467312/15538401215169.jpg" alt="" style="width:878px;"/><br/>
    // <code>NSString *site = [[NSString alloc]  initWithUTF8String:&quot;starming&quot;];</code><br/>
<img src="media/15537643467312/15538401867042.jpg" alt="" style="width:880px;"/><br/>
//<code>NSLog(@&quot;%@ rank %d&quot;, site, rank);</code><br/>
<img src="media/15537643467312/15538403856423.jpg" alt="" style="width:830px;"/></p></li>
<li><p>完成这些步骤之后，就可以开始中间代码的生成了</p>
<p><code>CodeGen</code>会负责将语法树自上向下逐步翻译成<code>LLVM IR</code>，IR就是编译过程前端的输出、后端的输入</p>
<p>用命令行:<br/>
<code>clang -S -fobjc-arc -emit-llvm main.m -o main.ll</code><br/>
生成.ll文件即为IR中间代码<br/>
LLVM会在这一步做一些优化的事情，我们也可以在Xcode中设置优化级别<br/>
<img src="media/15537643467312/15538506827890.jpg" alt="" style="width:902px;"/><br/>
<img src="media/15537643467312/15538508218589.jpg" alt="" style="width:465px;"/></p>
<p>默认为在debug模式下为-O0.Release模式下为-Os</p>
<p>我们也可以使用命令行指定优化级别:</p>
<pre><code class="language-text">//指定优化级别为-O3
clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll<br/>
最直接的结果,就是这两个优化命令，对我们的程序产生的IR文件分别为//108行代码 和81行代码
</code></pre>
<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了<code>bitcode</code>苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</p>
<p><code>clang -emit-llvm -c main.m -o main.bc</code></p></li>
<li><p>编译生成汇编文件</p>
<pre><code class="language-text">//生成汇编文件 main.s
clang -S -fobjc-arc main.m -o main.s
</code></pre>
<p>下面是部分main.s汇编文件内容<br/>
<img src="media/15537643467312/15538515406816.jpg" alt="" style="width:638px;"/></p></li>
<li><p>汇编之后生成目标文件</p>
<pre><code class="language-text">//生成目标文件 main.o 此时内容就是一堆二进制了
clang -fmodules -c main.m -o main.o
</code></pre></li>
<li><p>链接后生成可执行文件</p>
<pre><code class="language-text">clang main.o -o main
</code></pre></li>
<li><p>执行可执行文件</p>
<pre><code class="language-text">执行
./main<br/>
输出<br/>
starming rank 14
</code></pre></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15554693626882.html">Foundation、Core Foundation框架对象</a></h1>
			<p class="meta"><time datetime="2019-04-17T10:49:22+08:00" 
			pubdate data-updated="true">04/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><code>Core Foundation</code>对象主要在用C语言编写的<code>Core Foundation</code>框架中，并使用引用计数对象。Core Foundation框架中的retain/release分别为<code>CFRetain()、CFRelease()</code>(CF对象不属于ARC内存管理)<br/>
CF对象和foundation对象很区别很小，只是生成框架不同，连着可以互相在不同框架中使用。因为两者几乎没有区别可以使用简单的C语言即可互相转换。这种转换不需要额外的CPU资源消耗，因此称之为<strong>免费桥</strong></p>

<blockquote>
<p>Core Foundation变量没有ARC，因此对其操作均为手动引用计数</p>
</blockquote>

<h2 id="toc_0">id和void *的转换</h2>

<p>在ARC无效时，可以简单的进行赋值</p>

<pre><code class="language-objectivec">id obj = [[NSObject alloc] init];
void *obj1 = obj; //简单的赋值 此时obj1不持有该对象
[obj release];
</code></pre>

<p>但是在ARC环境下，需要进行转换</p>

<pre><code class="language-objectivec">id obj = [[NSObject alloc] init];
void *obj1 = (__bridge void *)(obj);
</code></pre>

<p><code>__bridge</code>是最简单的转换 只是单纯的赋值，并不负责内存管理，导致其安全性很低，很容易访问悬空指针，因此不推荐这么使用</p>

<p><strong>除了 <code>__bridge</code>外还有<code>__bridge_retained</code>和<code>__bridge_transfer</code>转换</strong><br/>
<code>__bridge_retained</code>:使要赋值的变量也持有所赋值的变量(对象引用计数+1)</p>

<pre><code class="language-objectivec">//ARC有效时
id obj = [[NSObject alloc] init];
void *p = (__bridge_retained void *)(obj);
//等效于 ARC无效于
id obj = [[NSObject alloc] init];
void *p = obj;
[(id)p retain];
</code></pre>

<p><code>__bridge_transfer</code>: 与其相反，被转换的变量在所持有的对象在该变量被赋值给转换目标后即释放(对象引用计数-1)</p>

<pre><code class="language-objectivec">//ARC有效时
id obj1 = (__bridge_transfer id)(p);
//等效于 ARC无效于
id obj = (id)p;
[obj retain];
[(id)p release];
</code></pre>

<p><code>Core Foundation</code>中提供了<code>Toll-Free-Bridge</code>函数:</p>

<pre><code class="language-objectivec">CFTypeRef _Nullable CFBridgingRetain(id _Nullable X) {
    return (__bridge_retained CFTypeRef)X;
}

 id _Nullable CFBridgingRelease(CFTypeRef CF_CONSUMED _Nullable X) {
    return (__bridge_transfer id)X;
}
</code></pre>

<p>示例：</p>

<pre><code class="language-objectivec">CFMutableArrayRef cfObject = NULL;
{
    id obj = [[NSMutableArray alloc] init];
    cfObject = CFBridgingRetain(obj);
    CFShow(cfObject);
    printf(&quot;retain count %ld\n&quot;, (long)CFGetRetainCount(cfObject)); //2
}
printf(&quot;出了作用域范围引用计数%ld\n&quot;, (long)CFGetRetainCount(cfObject));//1
CFRelease(cfObject);
</code></pre>

<p><code>Foundation</code>框架产生的OC对象也可以作为<code>Core Foundation</code>框架对象使用</p>

<pre><code class="language-objectivec">CFMutableArrayRef cfObject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);
printf(&quot;retain count %ld\n&quot;, (long)CFGetRetainCount(cfObject)); //1
id obj = CFBridgingRelease(cfObject); 
printf(&quot;转换后的retain count %ld\n&quot;, (long)CFGetRetainCount(cfObject)); // 1
NSLog(@&quot;class = %@&quot;, obj);
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15560067896432.html">崩溃日志信息以及符号化</a></h1>
			<p class="meta"><time datetime="2019-04-23T16:06:29+08:00" 
			pubdate data-updated="true">04/23/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我们采集到的崩溃日志，主要包含以下内容:</p>

<ul>
<li>进程信息: 崩溃进程的相关信息，比如崩溃报告唯一标识符、唯一键值、设备标识</li>
<li>基本信息: 崩溃发生的日期、iOS版本</li>
<li>异常信息: 异常类型、异常编码、异常的线程</li>
<li>线程回溯: 奔溃是的方法调用栈</li>
<li>进程状态: 闪退时寄存器中的值</li>
<li>二级制映像: 闪退时已经加载的二进制文件</li>
</ul>

<p>通常我们分析日志信息先看异常信息，分析出问题的线程，然后在回溯中找到对应线程，查看符号化后的方法调用栈，分析问题</p>

<h3 id="toc_0">异常类型</h3>

<p>常用的有:</p>

<p>EXC_CRASH<br/>
EXC_BAD_ACCESS (SIGSEGV)<br/>
NSRangeException<br/>
NSZombie<br/>
等</p>

<h3 id="toc_1">异常编码</h3>

<p>在App被系统杀掉的情况 可以通过查看异常编码，可以查看完整的<a href="https://en.wikipedia.org/wiki/Hexspeak">异常编码信息</a></p>

<p>常用的就一下几种:</p>

<ul>
<li>0x8badf00d 表示app长时间无响应被watchdog杀掉</li>
<li>0xdeadfa11 表示app被用户强制退出</li>
<li>0xc00010ff 表示app因为运行设备温度过高被杀</li>
</ul>

<h2 id="toc_2">获取日志</h2>

<p>常用的获取crash日志信息方式有以下几种</p>

<h3 id="toc_3">1. 系统自带</h3>

<p>当一个app崩溃时，iOS系统自带的CrashReporter会创建一份crash日志保存在设备上。如果能拿到Crash的手机，就可以通过Xcode或symbolicatecrash符号化Crash日志。<strong>如果设备上的Crash 日志超过了一定数量，可能保存不了Crash日志</strong></p>

<h4 id="toc_4">使用Xcode导出日志</h4>

<p>在Xcode-&gt;Window菜单-&gt;Devices，弹出的设备面板，选择崩溃的设备 -&gt; 选择右侧的View Device Logs-&gt;选中导出的日志，右击，选中export log, 导出.crash后缀的崩溃日志<br/>
<img src="media/15560067896432/15560087186815.jpg" alt="" style="width:825px;"/></p>

<h4 id="toc_5">2. 第三方SDK</h4>

<p>例如友盟、bugly等</p>

<h4 id="toc_6">3. 开源框架</h4>

<p>常用的有<code>KSCrash</code></p>

<h4 id="toc_7">4. 自己收集和符号化程序</h4>

<h2 id="toc_8">解析日志</h2>

<h3 id="toc_9">DWARF简介</h3>

<p>DWARF（DebuggingWith Arbitrary Record Formats），是ELF和Mach-O等文件格式中用来存储和处理调试信息的标准格式，.dSYM中真正保存符号表数据的是DWARF文件。</p>

<p>保存在DAWARF中的信息是高度压缩的，可以通过dwarfdump命令从中提取出可读信息</p>

<h3 id="toc_10">什么是符号表</h3>

<p>iOS符号表用来将堆栈信息对应到源码信息，常用来帮助还原crash的堆栈信息，来快速定位出错的代码位置</p>

<p>符号表是debug的产物，使用archive模式打包，符号表会被裁减掉，这也增加了应用安全，提高逆向的难度。我们可以在xcode选项中配置为不裁剪，但是这会让打包的IPA变大:<br/>
<img src="media/15560067896432/15560199675296.jpg" alt="" style="width:926px;"/></p>

<p><strong>Archive时文件中虽然没有符号表，但是生成了一个dSYM符号文件</strong>，通常名称为<code>xxx.app.dSYM</code><br/>
Xcode Release编译默认会生成dSYM文件，而debug编译默认不会生成,对应的Xcode配置如下：<br/>
<code>XCode -&gt; Build Settings -&gt; Code Generation -&gt; Generate Debug Symbols -&gt; Yes</code><br/>
<code>XCode -&gt; Build Settings -&gt; Build Option -&gt; Debug Information Format -&gt; DWARF with dSYM File</code><br/>
<img src="media/15560067896432/15560166666589.jpg" alt="" style="width:557px;"/><br/>
<img src="media/15560067896432/15560215274669.jpg" alt="" style="width:719px;"/></p>

<p>每次构建都会生成不同的符号表，每个符号表都有不同的UUID<br/>
查看dSYM文件的UUID</p>

<pre><code class="language-linux">xcrun dwarfdump --uuid &lt;dSYM文件&gt;
</code></pre>

<p>因此发布的app，在crash后并不能在设备上完成符号化工作，只能返回带地址的日志信息，需要我们自己进行符号化解析</p>

<h4 id="toc_11">用Xcode解析日志</h4>

<p>当<code>crash log</code>和<code>DSYM或者App</code>携带的UUID一致时(crash log的UUID指的是镜像的UUID)，Xcode可以将日志中的地址信息符号化为代码中的符号</p>

<ul>
<li>如果该App是由自己电脑编译生成的，Xcode根据spotlight自动找到对应的符号文件</li>
<li><p>如果不是自己电脑编译生成的，只需要将.app和dSYM放入同一文件夹，然后手动生成索引。</p>
<pre><code class="language-objectivec">//mdimport命令: 导入文件到datasource,这样Xcode也能找到符号文件
mdimport pathName
</code></pre>
<p><code>Xcode</code>能根据UUID找到对应的符号文件，就能通过Xode的<code>Xcode-&gt;Devices-&gt;View Device Logs</code>自动解析解析崩溃日志</p></li>
</ul>

<h4 id="toc_12">symbolicatecrash</h4>

<p>symbolicatecrash是Xcode自带的一个分析工具，可以通过机器上的崩溃日志和应用的.dSYM文件定位发生崩溃的位置，把crash日志中的一堆地址替换成代码相应位置。</p>

<p>步骤:</p>

<ol>
<li><p>找到symbolicatecrash文件位置</p>
<pre><code class="language-linx">find /Applications/Xcode.app -name symbolicatecrash -type f
</code></pre>
<p>将找到的文件拷贝到自己创建的文件夹中</p></li>
<li><p>从Xcode的Archive中找到.dSYM文件和.app文件拷贝到自己创建的文件夹中</p></li>
<li><p>在终端执行命令</p>
<pre><code class="language-linux">./symbolicatecrash ./*.crash ./*.app.dSYM &gt; symbol.crash
</code></pre>
<blockquote>
<p>如果这一步出现<code>DEVELOPER_DIR</code>错误 就需要先执行命令</p>
<pre><code class="language-linix">export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot;
</code></pre>
</blockquote></li>
<li><p>在symbol.crash中查看符号化后崩溃信息</p></li>
</ol>

<h4 id="toc_13">atos命令</h4>

<p>这是更常用的命令</p>

<pre><code class="language-objectivec">//loadAddress：进程加载地址
//architecture： 架构常用的有arm64或者armv7
atos [-o AppName.app/AppName] [-l loadAddress] [-arch architecture]
atos -o Your.app.dSYM/Contents/Resources/DWARF/Your -arch armv7 -l 0xa2000 0x000f0846

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15668021082247.html">Blocks的实现</a></h1>
			<p class="meta"><time datetime="2019-08-26T14:48:28+08:00" 
			pubdate data-updated="true">08/26/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Block的实质</h2>

<p>通过<code>-rewrite-objc</code>将Block语法转为C++源代码</p>

<pre><code class="language-objectivec">//源代码
void(^blk)(void) = ^{
    printf(&quot;Block\n&quot;)
}
</code></pre>

<ol>
<li><p>block是&quot;带有自动变量值的匿名函数&quot;，</p>
<pre><code class="language-objectivec">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    printf(&quot;Block\n&quot;)<br/>
}
</code></pre>
<p>可以看到其执行内容会按照普通的C函数处理，并且Block会根据所属的函数名(main函数)和该block出现的顺序值(为0)进行命名。并且其函数的执行参数即为<code>__cself</code>也就是指向该block的机构体的指针</p></li>
<li><p>Block其实是<code>Object-C</code>对象</p>
<p>block转换为结构体后其结构如下:</p>
<pre><code class="language-objectivec">struct __main_block_impl_0 {
    struct __block_impl impl;<br/>
    struct __main_block_desc_0 *Desc;<br/>
    //结构体初始化函数<br/>
    __main_block_impl_0(void *fp, strct __main_block_desc_0, int flags=0) {<br/>
        impl.isa = &amp; NSConcreatStackBlock;<br/>
        impl.Flags = flags;<br/>
        impl.FuncPtr = fp;<br/>
        Desc = desc;<br/>
    }<br/>
}<br/>
struct __block_impl {<br/>
    void *isa;<br/>
    int Flags;<br/>
    int Reserved;<br/>
    void *FunctionPtr;<br/>
}<br/>
struct __main_block_desc_0 {<br/>
    unsigned long reserved; //今后版本升级所需的区域<br/>
    unsigned long Block_size; //block的大小<br/>
}
</code></pre>
<p>因此将block结构体展开的话，其初始化结构如下:</p>
<pre><code class="language-objectivec">static struct __main_block_desc_0 __main_block_desc_0_DATA = {
    0,<br/>
    sizeof(struct __main_block_impl_0) //block大小<br/>
}<br/>
//初始化<br/>
isa = &amp;_NSConcreatStackBlock;<br/>
Flags=0;<br/>
Reserved=0;<br/>
FuncPtr=__main_block_func_0;<br/>
Desc= &amp;__main_block_desc_0_DATA;
</code></pre>
<p>当执行该block时,即执行block中的FuncPtr函数，然后将block结构体指针作为参数传入：</p>
<pre><code class="language-objectivec">((void(*)(struct __block_impl *))((struct __block_impl *)blk)-&gt;FuncPtr)((struct _block_impl*)blk)
</code></pre>
<blockquote>
<p>注意</p>
<p>对于<code>isa=&amp;_NSConcreatStackBlock;</code>因为block也是一个对象，因此与其它OC对象类型，其isa指针指向其类结构体，即block的类信息就放在<code>_NSConcreatStackBlock</code>中</p>
</blockquote></li>
</ol>

<h2 id="toc_1">截获自动变量</h2>

<p>所谓的&quot;截获自动变量值&quot;其实是在执行block时，Block语法表达式所使用的自动变量被保存到Block的结构体实例中</p>

<p>截获了自动变量的结构体</p>

<pre><code class="language-objectivec">struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0 *Desc;
    const char *fmt; //自动变量值
    int val; //自动变量值
        //结构体初始化函数
     __main_block_impl_0(void *fp, strct __main_block_desc_0, const char*_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) {
        impl.isa = &amp; NSConcreatStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
}
</code></pre>

<blockquote>
<p>注意</p>

<p>block只会捕获使用到的变量，表达式中没有使用到的变量不会被自动追加</p>
</blockquote>

<h2 id="toc_2">__block说明符</h2>

<p>看到上面👆捕获变量的源码，可以看出来，block中捕获的自动变量仅捕获自动变量的值。因此在block内部重写该自动变量也不会改变原来捕获的自动变量值，因此，当我们给捕获的自动变量赋值时 就会产生编译错误</p>

<h3 id="toc_3">静态变量、静态全局变量、全局变量</h3>

<p>我们可以在block中直接访问或修改静态全局变量/全局变量 这是没有任何改变的，因此可以在block转换后的函数中直接使用，而无需在结构体中保留、变量</p>

<p>但是对于静态变量，因为block转换后的函数已经在静态变量所处的函数之外，出了访问的作用域</p>

<pre><code class="language-objectivec">//结构体中
__main_block_impl_0 {
    ...
    int * static_val; //block内部保留 静态变量的指针地址
}

//执行函数
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    (*static_val) *= 3 //
}
</code></pre>

<p>因此 block将静态变量的指针传递给<code>__main_block_impl_0</code>结构体的构造函数，并保留在结构体中，这是超出作用范围最简单的访问方法了</p>

<blockquote>
<p>注意</p>

<p>对于自动变量为什么没有采用类似静态变量的访问方式呢??<br/>
Block可以截获超过作用域被截获的对象的自动变量，变量作用域结束的，原来的自动变量被废弃，因此block中超过变量作用域的对象就如同静态变量一样，无法通过指针进行访问了</p>
</blockquote>

<h3 id="toc_4">__block修饰符</h3>

<p>在OC中存在以下几种存储域类说明符:</p>

<ul>
<li>typedef</li>
<li>extern</li>
<li>static</li>
<li>auto</li>
<li>register</li>
</ul>

<p><code>__block</code>就类似static、auto、register说明符，用于指定将变量设置到哪个存储区域中。(auto表示作为自动变量存储到栈中、static作为静态变量存储到数据区)</p>

<pre><code class="language-objectivec">//源代码
__block int val = 10
void(^blk)(void) = ^{val = 1}
</code></pre>

<p>block结构体持有了指向__block变量结构体指针</p>

<pre><code class="language-objectivec">struct __main_block_impl_0 {
    struct __block_impl impl;
    struct __main_block_desc_0 *Desc;
    __Block_byref_val_0 *val;
        //结构体初始化函数
     __main_block_impl_0(void *fp, strct __main_block_desc_0, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;_forwarding) {
        impl.isa = &amp; NSConcreatStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
}
</code></pre>

<p>__block变量<br/>
__block变量如同block一般变为<code>__Block_byref_val_0</code>结构体实例</p>

<pre><code class="language-objectivec">struct __Block_byref_val_0 {
    void *__isa;
    __Block_byref_val_0 *__forwarding;
    int __flags;
    int __size;
    int val; //相当于原自动变量
}
//其初始化
__Block_byref_val_0 val = {
    0,
    &amp;val,
    0,
    sizeof(__Block_byref_val_0),
    10
}
</code></pre>

<p>结构体持有了相当持有原自动变量的成员变量,  <code>__Block_byref_val_0</code>结构体实例的成员变量<code>__forwarding</code>持有指向该实例自身的指针。通过 <code>__forwarding</code>访问成员变量val。(成员变量val相当于原自动变量)</p>

<p>函数</p>

<pre><code class="language-objectivec">^{val=1}
    
//源代码转换为
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    __Block_byref_val_0 *val = _cself-&gt;val;
    
    (val-&gt;__forwarding-&gt;val) = 1
}
</code></pre>

<blockquote>
<p>注意：</p>

<ol>
<li>为什么将__block变量写为单独的结构体而不写在block结构体中? 因是为了可以在多个block中使用相同的__block变量</li>
<li>为了什么使用了__block变量 就可以改写值？  因为当变量添加了__block前缀，此时声明的就直接是一个结构体 我们之后访问、修改不论是在block内外 都是用的这个结构体</li>
</ol>
</blockquote>

<p>本章忽略内容：</p>

<ul>
<li>Block超出变量作用域存在原因</li>
<li><strong>block变量结构体成员</strong>forwading存在理由</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14872305472033.html">UI测试</a></h1>
			<p class="meta"><time datetime="2017-02-16T15:35:47+08:00" 
			pubdate data-updated="true">02/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>关于iOS的UI自动化测试，Xcode 7 Apple从新提供了一个新的框架UITest，使用XCTest.framework，Xcode可以自动录制UI测试的动作流，还有就是可以使用<code>XCTest UI testing API</code></p>

<h4 id="toc_0"><a href="http://www.itnose.net/detail/6507467.html">基础知识</a></h4>

<p>核心的三个类:<code>XCUIApplication</code> <code>XCUIElement</code> <code>XCUIElementQuery</code><br/>
<strong>XCUIApplication类</strong> 是Application的代理，就像我们项目工程中的AppDelegate，这个对象用来启动或者是终止UI测试程序，还可以在启动的时候设置一些启动参数，在获取程序中的UI元素的时候，就是通过这个类的实例。这个类继承自XCUIElement类<br/>
<strong>XCUIElement类</strong> 是XCTest.framework对应用中的所有UI控件的抽象，在UI测试中，没有UIKit中的UI类型，只是用这个类的实例表示所有的UI控件，以及相应的交互方法，例如：执行手势（tap，press，swipe），滑动控件交互，拾取器交互，这个类采取了XCUIElementAttributes协议（描述UI元素的属性：Identity，Value，Interaction State，Size），XCUIElementTypeQueryProvider协议(为指定类型的子代元素提供ready-made查询，子代元素查询包含button，具体实现是:@property(readonly, copy) XCUIElementQuery *buttons;等一系列对UIKit中元素的映射)<br/>
<strong>XCUIElementQuery类</strong> 是定位UI元素的查询，这个类使用类似key-value的机制得到XCUIElement的实例，使用Type(XCUIElementType枚举)，Predicate，Identifier创建query，使用elementAtIndex:, elementMatchingPredicate,elementMatchingType: identifier:方法访问匹配到的UI元素，此类采用XCUIElementTypeQueryProvider协议</p>

<p>XCTest一共提供了三种UI测试对象<br/>
    XCUIApplication 当前测试应用target<br/>
    XCUIElementQuery 定位查询当前UI中xctuielement的一个类<br/>
    XCUIElement UI测试中任何一个item项都被抽象成一个XCUIElement类型<br/>
因此:当我们获取了录制生成的代码以后，根据UITest提供的三种对象，我可以在此来对测试代码进行修改，调试,我们同样可以使用断言语句来进行测试</p>

<h4 id="toc_1">UI测试Demo</h4>

<ol>
<li><p>创建项目时勾选UITest</p></li>
<li><p>打开DemoUiTest.m,创建 - (void)testUI函数,同时将光标留在函数内<br/>
<img src="media/14872305472033/14872344264789.png" alt=""/><br/>
点击下面的红色按钮，开始recorder操作，程序运行起来后，点击APP界面进行操作,然后光标处就会生成测试代码</p></li>
<li><p>进行测试<br/>
之后我们测试只需要点击test函数前的测试按钮测试这个函数 或者command+u 来进行全部测试<br/>
此时刚才的一连串动作会一步一步连续执行下来</p></li>
<li><p>我们此时可以通过修改这段代码来进行我们想要的测试<br/>
比如：</p>
<ul>
<li>通过添加循环语句来测试一直执行是否会出现问题,判断内存问题等</li>
<li>通过添加断言来判断运行中元素或情况与我们预想是否一致</li>
</ul></li>
<li></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14872918920673.html">并发编程中的问题</a></h1>
			<p class="meta"><time datetime="2017-02-17T08:38:12+08:00" 
			pubdate data-updated="true">02/17/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>使用并发编程会带来许多陷阱<br/>
优先级反转:也就是说低优先级的线程一直阻塞着高优先级的线程</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="14872918920673.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_30.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_28.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>