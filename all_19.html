
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14862735041818.html">iOS 控制器转场</a></h1>
			<p class="meta"><time datetime="2017-02-05T13:45:04+08:00" 
			pubdate data-updated="true">02/05/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>参考知识网站:<a href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition">iOS 视图控制器转场详解</a><br/><br/>
我们平常所说的转场动画 = 转场+动画，两者互不相关。不管是简单的转场动画还是炫酷的转场动画，你想要的效果那是动画的事情，完全是另外一个话题。</p>

<h4 id="toc_0">文章前言</h4>

<p>视图控制器转换<code>View Controller Transition</code> : 在 NavigationController 里 push 或 pop 一个 View Controller，在 TabBarController 中切换到其他 View Controller，以 Modal 方式显示另外一个 View Controller，这些都是 View Controller Transition;<br/><br/>
在iOS7之前我们只能使用系统提供的转场动画，仅仅够用而已，7之后开放了相关API允许我们进行转场动画的定制。<br/>
如果对VC的结构不够了解推荐看:<a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1">View Controller Programming Guide for iOS</a><br/>
<strong>接下来进入正题</strong>.</p>

<h4 id="toc_1">Transition</h4>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14861705181412.html">小知识</a></h1>
			<p class="meta"><time datetime="2017-02-04T09:08:38+08:00" 
			pubdate data-updated="true">02/04/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">1. 判断字符character是不是英文字母 是的话返回1 否则返回0</h3>

<pre><code class="language-text">isalpha(chanracter)
</code></pre>

<h3 id="toc_1">2. 判断一个字符串是否全为空格</h3>

<pre><code class="language-object-c">[[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] length]==0
</code></pre>

<h3 id="toc_2">3. 数组排序方法</h3>

<pre><code class="language-objectivec">NSSortDescriptor *timeDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;creatTime&quot; ascending:NO];
NSArray *inviteNoticeArray = [noticeRecordModelArray sortedArrayUsingDescriptors:@[timeDescriptor]];
</code></pre>

<h3 id="toc_3">4. 自动调节字体大小</h3>

<pre><code class="language-text">`adjustsFontSizeToFitWidth`这个属性的意思是根据UILabel的宽度来自动适应字体大小，但要注意的是，这个属性不会让字体变大，只会缩小，所以开始的时候，可以设置字体fontSize大一点。
</code></pre>

<h3 id="toc_4">5. %s 为c语言字符串的输入输出控制格式</h3>

<h3 id="toc_5">6. NSString 转化为 char *</h3>

<pre><code class="language-text">```objc
NSString * str＝ @“Test”;
const char * a =[str UTF8String];
```
</code></pre>

<h3 id="toc_6">7. 按属性字段排序</h3>

<pre><code class="language-objectivec">    NSSortDescriptor *timeDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;createTime&quot; ascending:NO];
    NSArray *noticesArray = [[UserDataManager sharedInstance].userNotifyInfoArray sortedArrayUsingDescriptors:@[timeDescriptor]];
</code></pre>

<h3 id="toc_7">8. auyolayout拉伸压缩</h3>

<pre><code class="language-text">`Content Hugging Priority`(控件抗拉伸优先级) 优先级越高越不容易被拉伸，默认是250。
`Content Compression Resistance Priority`(控件抗压缩优先级) 和拉伸一样，优先级越高的越不容易和压缩，默认是750。
</code></pre>

<h3 id="toc_8">9. 从字符串中获取类名</h3>

<p>NSClassFromString(@&quot;UIView&quot;)</p>

<h3 id="toc_9">10. 视图点击拦截</h3>

<p>对于一个视图遮盖另外一个视图,如果上面视图是hidden或者alpha值为0是可以点击到后面的视图,但是如果上面的视图是clearColor 那么是点不到后面的视图的</p>

<h3 id="toc_10">11. CGRectInset、 CGRectOffset</h3>

<pre><code class="language-objectivec">    //该结构体的应用是以原rect为中心，再参考dx，dy，进行缩放或者放大。
    CGRect CGRectInset (
        CGRect rect,
        CGFloat dx,
        CGFloat dy
    );
</code></pre>

<pre><code class="language-objectivec">    // 相对于源矩形原点rect（左上角的点）沿x轴和y轴偏移, 再rect基础上沿x轴和y轴偏移
    CGRect CGRectOffset(
　 　 CGRect rect,
　　  CGFloat dx,
　 　 CGFloat dy
    );
</code></pre>

<h3 id="toc_11">12. 无限重复动画</h3>

<pre><code class="language-objectivec">//我们可以通过指定这个“options:UIViewAnimationOptionRepeat”实现无限重复动画
//注意这个‘delay’是动画开始前的延迟而不是动画重复之间的延时,动画重复之间的延时这里是没法设置的
[UIView animateWithDuration:offset/50 delay:2 options:UIViewAnimationOptionRepeat animations:^{
        self.firstLabel.transform = CGAffineTransformMakeTranslation(-offset, 0);
        self.secondLabel.transform = CGAffineTransformMakeTranslation(-offset, 0);
    } completion:^(BOOL finished) {
        self.firstLabel.transform = CGAffineTransformIdentity;
        self.secondLabel.transform = CGAffineTransformIdentity;
    }];
</code></pre>

<h3 id="toc_12">13. KVC</h3>

<p>所有的<code>NSObject</code>子类实现了KVC（键-值-编码）协议，可以用 <code>- setValue:forKey:</code>和<code>-valueForKey:</code>方法来存取属性，但是这个类需要有与之对应的属性.。但是<code>CAAnimation</code> 有一个不同的性能：它更像一个<code>NSDictionary</code>，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>

<h3 id="toc_13">14.改变push动画效果</h3>

<p>[self.navigationController.view.layer addAnimation:transition forKey:nil];</p>

<h3 id="toc_14">15. 设置cell的accessView</h3>

<p>设置cell的 accessView相当于把cell变短了<br/>
<img src="media/14861705181412/14918746728664.jpg" alt=""/></p>

<h3 id="toc_15">设置tableView分割线颜色</h3>

<p>tableView.separatorColor = ICColorOfDividingLine;</p>

<h3 id="toc_16">Json格式化option</h3>

<p>//option为0 解析出来的字符串是没有被格式化的即没有回车换行<br/>
[NSJSONSerialization dataWithJSONObject:self options:0 error:nil]</p>

<p>//option为NSJSONWritingPrettyPrinted 解析出来的字符串是被格式化的即存在回车换行方便阅读<br/>
[NSJSONSerialization dataWithJSONObject:self options:NSJSONWritingPrettyPrinted error:nil]</p>

<h3 id="toc_17">16.retain和strong</h3>

<p><img src="media/14861705181412/14949171761445.jpg" alt=""/></p>

<h3 id="toc_18">17.逆序枚举</h3>

<pre><code class="language-objectivec">//1.原始数组  
NSMutableArray *array = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,nil];  
//2.倒序的数组  
NSArray* reversedArray = [[array reverseObjectEnumerator] allObjects]; 
</code></pre>

<pre><code class="language-objectivec">NSLog(@&quot;------- 枚举器法---------&quot;);  
                                        //ObjectEnumerator        正序  
                                        //reverseObjectEnumerator 逆序  
        NSEnumerator *enumerator = [array reverseObjectEnumerator];  
        id obj = nil;  //不确定数组里面具体对象的类型，所以定义成id 类型指针  
        while (obj = [enumerator nextObject]) { //通过枚举器，取数组里面的每一个元素  
            NSLog(@&quot;%@&quot;, obj);                  //将元素赋给 obj， 直到数组结束  
                                                //取到的结果为nil，退出while  
        }  
</code></pre>

<h3 id="toc_19">18.大端小端</h3>

<p>对于iPhone采用的是小端模式</p>

<p>补充:<br/>
<code>Little endian</code>和<code>Big endian</code><br/>
上一节已经提到，<code>Unicode</code>码可以采用<code>UCS-2</code>格式直接存储。以汉字&quot;严&quot;为例，<code>Unicode</code>码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。<br/>
这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。<br/>
因此，第一个字节在前，就是&quot;大头方式&quot;（Big endian），第二个字节在前就是&quot;小头方式&quot;（Little endian）。<br/>
那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？<br/>
Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做&quot;零宽度非换行空格&quot;（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。<br/>
如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p>

<h3 id="toc_20">19.图片呈现过程</h3>

<p>1.初始化阶段：从磁盘初始化图片，生成一个未解压缩的 UIImage 对象；<br/>
2.解压缩阶段:UIImage 对象进行解压缩<br/>
3.绘制阶段:绘制到屏幕上<br/>
图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程</p>

<h3 id="toc_21">20.更改视图frame 和 设置transform 进行动画的区别</h3>

<p>对于一个视图 我们更改其frame来做动画 不论子视图是否与其有约束关系 那么子视图frame是不会改变的,即子视图是不会跟着做动画的</p>

<p>而用transform的话 不论子视图是否与其有约束关系,子视图是会随着其一起变化的</p>

<h3 id="toc_22">21.运算符重载</h3>

<p>运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p>

<h3 id="toc_23">22.unicode utf-8</h3>

<p>已知&quot;严&quot;的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此&quot;严&quot;的UTF-8编码需要三个字节，即格式是&quot;1110xxxx 10xxxxxx 10xxxxxx&quot;。然后，从&quot;严&quot;的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，&quot;严&quot;的UTF-8编码是&quot;11100100 10111000 10100101&quot;，转换成十六进制就是E4B8A5。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14861704124969.html">iOS 滤镜</a></h1>
			<p class="meta"><time datetime="2017-02-04T09:06:52+08:00" 
			pubdate data-updated="true">02/04/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<hr/>

<h3 id="toc_0">CIFilter实现滤镜效果</h3>

<p>参考网址:<a href="http://www.jianshu.com/p/98ba256b034a" title="CoreImage滤镜学习 - 简书">CoreImage滤镜学习</a> </p>

<h5 id="toc_1">CoreImage框架介绍</h5>

<p>1.是一个图片框架 基于<code>OpenGL</code>顶层创建，底层用着色器来处理图像<br/><br/>
2.利用GPU基于硬件加速来处理图像<br/><br/>
3.CoreImage中有很多滤镜<br/><br/>
4.它们能够一次给予一张图像或者视频帧多种视觉效果 -&gt; 滤镜链<br/><br/>
5.滤镜可以连接起来组成一个滤镜链 把滤镜效果叠加起来处理图像</p>

<h5 id="toc_2">CIFilter使用介绍</h5>

<ol>
<li><p><code>CIFilter</code>滤镜类中有很多的滤镜效果 这里不一一列举，可以按住command 点击CIFilter 进入接口文件 找到第128行-148行全部都是 效果分类  </p></li>
<li><p>常用效果<br/><br/>
我们使用时需要先找到需要的效果类型 比如我们使用<code>kCICategoryDistortionEffect</code>失真的效果类型，有了效果类型我们需要找到里面我们需要的效果.<br/><br/>
<code>NSLog -&gt; [CIFilter filterNamesInCategory:刚才拷贝的分类];</code><br/><br/>
比如<code>CIColorMonochrome </code>,然后就可以使用这个滤镜效果<br/><br/>
<code>CIFilter *filter = [CIFilter filterWithName:@&quot;CIColorMonochrome”];</code><br/><br/>
然后打印这个效果中包含了那些属性:<br/><br/>
<code>NSLog(@&quot;%@&quot;,filter.attributes);</code><br/><br/>
在里面我们可以看到好多属性，里面是多个字典的形式，找到我们想要修改的属性(key值) 然后在他对应的value里面查看一下他的属性类型，比如我们打印的CIColorMonochrome里面有一个inputColor，他是一个CIColor类型的，有默认值，这里我们写了一个CIColor来给他进行赋值.<br/><br/>
赋值时需要用kvc的方式:<br/><br/>
<code>[filter setValue:colorforKey:kCIInputColorKey];</code><br/><br/>
<img src="media/14861704124969/DraggedImage.png" alt="DraggedImage"/></p></li>
<li><p>实现滤镜效果代码<br/><br/>
首先我们创建一个全局变量的UIImageView，然后让他初始化出来,这个就是我们要处理的图片 一般我们从手机相册中取出来:<br/><br/>
 @interface ViewController ()&lt;UINavigationControllerDelegate,UIImagePickerControllerDelegate&gt;<br/>
    {<br/>
         UIImageView *imageView;<br/>
    }<br/>
    @end<br/>
    然后我们需要从相册中取出一张图片,保存起来:<br/>
    //跳转相册的触发方法<br/>
    - (void)doit{<br/>
    UIImagePickerController *vc = [[UIImagePickerController alloc]init];<br/>
    vc.delegate = self;<br/>
    [self presentViewController:vc animated:YES completion:nil];</p>
<pre><code class="language-text">}
//让图片显示在VC上面的方法<br/>
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info<br/>
{<br/>
NSLog(@&quot;%@&quot;,info);<br/>
//获得选中的图像<br/>
UIImage *chooseImage = info[UIImagePickerControllerOriginalImage];<br/>
//先是在试图空间上<br/>
imageView.image = chooseImage;<br/>
[self dismissViewControllerAnimated:YES completion:nil];<br/>
}
</code></pre>
<p><strong>接下来就是对图片进行滤镜处理:</strong><br/>
    - (void)addColorFilter{<br/>
    //CIImage 保存图像数据的类<br/>
    CIImage <em>inputImage = [CIImage imageWithCGImage:imageView.image.CGImage];<br/>
    //先打印NSLog(@&quot;%@&quot;,[CIFilter filterNamesInCategory:kCICategoryDistortionEffect]);进去找到需要设置的属性(查询效果分类中都有什么效果)  可以设置什么效果<br/>
    //然后通过[CIFilter filterWithName:@&quot;&quot;];找到属性   具体效果的属性<br/>
    //然后通过KVC的方式设置属性<br/>
    NSLog(@&quot;%@&quot;,[CIFilter filterNamesInCategory:kCICategoryDistortionEffect]);<br/>
    /</em><br/>
     1.查询 效果分类中 包含什么效果：filterNamesInCategory:<br/>
     2.查询 使用的效果中 可以设置什么属性（KVC） attributes</p>
<pre><code class="language-text"> 使用步骤
 1.需要添加滤镜的源图<br/>
 2.初始化一个滤镜 设置滤镜（根据查询到的属性来设置）<br/>
 3.把滤镜 输出的图像 和滤镜  合并 CIContext -&gt; 得到一个合成之后的图像<br/>
 4.展示<br/>
 */<br/>
//CIFilter 滤镜类  图片属性进行细节处理的类<br/>
CIFilter *filter = [CIFilter filterWithName:@&quot;CIColorMonochrome&quot;];<br/>
NSLog(@&quot;%@&quot;,filter.attributes);<br/>
//这个属性是必须赋值的，假如你处理的是图片的话<br/>
[filter setValue:inputImage forKey:kCIInputImageKey];<br/>
CIColor *color = [CIColor colorWithRed:1.000 green:0.759 blue:0.592 alpha:1];<br/>
[filter setValue:color forKey:kCIInputColorKey];<br/>
//CIContext 上下文是实现对图像处理的具体对象 用来把滤镜和图片合成成为一张图片 滤镜对象输出的图像并不是合成之后的图像，需要使用图片处理的上下文 合并输出图像<br/>
    CIContext *context = [CIContext contextWithOptions:nil];<br/>
CIImage *outPutImage = filter.outputImage;<br/>
//CGImageRef-&gt;图像中的数据<br/>
    CGImageRef image = [context createCGImage:outPutImage fromRect:outPutImage.extent];<br/>
    imageView.image = [UIImage imageWithCGImage:image];<br/>
 }
</code></pre>
<p>注意：<br/><br/>
对滤镜进行赋值之后图片就有了，但是我们这个时候拿出这个图片的时候发现他并没有发生变化，因为它只是单一进行了滤镜处理，还没有和原图片进行一个糅合。使用CIContext找到上下文对他进行糅合：<br/><br/>
//extent得到图像的尺寸    合并一个包含源图   滤镜效果的图片<br/>
    //1 滤镜输出的图像    2.合成之后图像的尺寸   图像.extent<br/>
    CGImageRef imageRef = [context createCGImage:outPutImage fromRect:outPutImage.extent];<br/>
注意:<br/><br/>
假如你的图片消失了，请检查一下，第一步获取图片的时候一定要获得图片的CGImage再来来获取，不要直接使用imageView.image.CGImage。</p></li>
<li><p>滤镜链:<br/><br/>
在给一张图片添加多种滤镜效果的时候，我们把它称为<code>滤镜链</code>，我们再添加滤镜链的时候，就是把图片添加一层滤镜，然后，和原图片糅合处理，然后在处理之后的图片上再添加一层滤镜，并不是直接给一张图片添加了两层路径，所以称为滤镜链。<br/><br/>
我们继续使用这个图片，在它添加第一层滤镜的时候做一些修改:  </p>
<pre><code class="language-text">//上接给效果属性赋值
//把下面注释的给注释掉，然后添加一个方法<br/>
    //CIContext<br/>
//    CIContext *context = [CIContext contextWithOptions:nil];<br/>
CIImage *outPutImage = filter.outputImage;<br/>
[self addFilterLinkerWithImage:outPutImage];<br/>
//    CGImageRef image = [context createCGImage:outPutImage fromRect:outPutImage.extent];<br/>
//    imageView.image = [UIImage imageWithCGImage:image];<br/>
//再次添加滤镜  -&gt;  形成滤镜链<br/>
- (void)addFilterLinkerWithImage:(CIImage *)image<br/>
{<br/>
CIFilter *filter = [CIFilter filterWithName:@&quot;CISepiaTone&quot;];<br/>
[filter setValue:image forKey:kCIInputImageKey];<br/>
CIContext *context = [CIContext contextWithOptions:nil];<br/>
CGImageRef resultImage = [context createCGImage:filter.outputImage fromRect:filter.outputImage.extent];<br/>
imageView.image = [UIImage imageWithCGImage:resultImage];<br/>
//把添加好滤镜效果的图片   保存到相册<br/>
//不可以直接保存 outputImage  -&gt;  这是一个没有吧滤镜效果和源图合成的图像<br/>
UIImageWriteToSavedPhotosAlbum(imageView.image, self, @selector(image:didFinishSavingWithError:contextInfo:), nil);<br/>
 }<br/>
//保存图片回调<br/>
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo<br/>
{<br/>
    NSLog(@&quot;保存成功&quot;);<br/>
}
</code></pre>
<p>这样就是一个双重的滤镜效果,同时保存到了相册.</p></li>
</ol>

<hr/>

<h3 id="toc_3">系统自带简单的滤镜效果</h3>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14861702798513.html">iOS中主要框架</a></h1>
			<p class="meta"><time datetime="2017-02-04T09:04:39+08:00" 
			pubdate data-updated="true">02/04/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h4 id="toc_0">1. 系统框架层</h4>

<p>每个框架对应IOS系统里的一层，每层建立在它下面层的上面。应该尽量使用上层的框架来代替下面的框架。更高层次的框架是对底层框架基于对象的抽象。<br/><br/>
<img src="media/14861702798513/DraggedImage.png" alt="DraggedImage"/></p>

<h4 id="toc_1">2. 两个基础框架</h4>

<p>iOS应用程序基于Foundation和UIKit框架<br/>
<strong>Foundation</strong><br/><br/>
Foundation框架为所有的应用程序提供基本系统服务你的应用程序，UIKit和其它的框架都是建立在Foundation框架上面的。Foundation框架是用Object-C对CoreFoundation框架里许多特性的封装。<br/><br/>
使用Foundation可以:</p>

<ol>
<li>创建和管理集合，比如数组和字典
<ol>
<li>访问存储在应用程序里的图片和其它资源
<ol>
<li>创建和管理字符串</li>
<li>提交和接收通</li>
<li>创建日期和时间对象</li>
<li>自动发现IP网络上的设备</li>
<li>操作URL流
<strong>UIKit</strong><br/>
所有的iOS应用程序都基于UIKit，你不能是应用程序脱离这个框架。UIKit提供了在屏幕上绘制的机制，捕获事件，和创建通用用户界面元素。UIKit也通过管理显示在屏幕上的组件来组织复杂的项目。<br/>
使用UIKit可以：</li>
</ol></li>
</ol></li>
<li>构建和管理你的用户界面
<ol>
<li>捕获触摸和基于移动的事件
<ol>
<li>呈现文字和web内容</li>
<li>优化多任务程序</li>
<li>创建定制的用户界面元素</li>
</ol></li>
</ol></li>
</ol>

<h4 id="toc_2">3. 其他重要框架</h4>

<pre><code class="language-text">Core Data , Core Graphics, CoreAnimation,和OpenGLES框架都是高级的技术
1. **CoreData框架管着理应用程序数据模型**
    Core Data提供对象的管理，使用CoreData，你可以创建模型对象，并管理这些对象。你管理这这些对象间的联系并修改数据。CoreData提供的内建SQLlite技术可以高效的管理数据。
    使用CoreData可以:
    - 在库里存储和接受对象
    - 提供基本的undo/redo
    - 自动验证属性值
    - 过滤、分组和优化内存中的数据
    - 用[NSFetchedResultsController]管理表视图中的结果
    - 支持基于文档的应用程序
2. **CoreGraphics框架帮助你创建图形

3. **CoreAnimation允许你创建高级的动画和虚拟效果
4. **OpenGL ES框架提供2D和3D绘图工具
</code></pre>

<ol>
<li><br/></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15059300219793.html">高级运算符</a></h1>
			<p class="meta"><time datetime="2017-09-21T01:53:41+08:00" 
			pubdate data-updated="true">09/21/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">位运算符</h2>

<p><code>Swift</code>支持C语言中全部位运算符</p>

<h3 id="toc_1">按位取反运算符 <code>~</code></h3>

<pre><code class="language-swift">let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits // 等于 0b11110000
</code></pre>

<h3 id="toc_2">按位与运算符 <code>&amp;</code></h3>

<h3 id="toc_3">按位或运算符 <code>|</code></h3>

<p>两个数的对应位中有任意一个为1时，返回的对应位就为1</p>

<h3 id="toc_4">按位异或运算符 <code>^</code></h3>

<p>当两个数对应位不相同时，返回1</p>

<h3 id="toc_5">按位移位运算符</h3>

<p>左移<code>&lt;&lt;</code>  右移<code>&gt;&gt;</code></p>

<p>无符号整数的移位运算是:<br/>
<strong>逻辑移位</strong>:对于移除整型存储范围的位都会被舍弃</p>

<pre><code class="language-swift">let pink: UInt32 = 0xCC6699
let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16 // redComponent 是 0xCC，即 204
let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102
let blueComponent = pink &amp; 0x0000FF // blueComponent 是 0x99，即 153
</code></pre>

<p>有符号整数的移位运算:<br/>
<strong>算术移位</strong>:当对整数进行按位右移时，对于移位产生的空白位使用符号位进行填充（逻辑移位中为0填充）,左移规则与逻辑移位相同</p>

<h2 id="toc_6">溢出运算符</h2>

<p><code>Swift</code>中的运算符默认不会溢出,溢出会被捕获并且报告为错误。</p>

<pre><code class="language-swift">var potentialOverflow = Int16.max
// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数
potentialOverflow += 1
// 这里会报错
</code></pre>

<p>我们可以选在数值溢出时采用阶段处理，而不报错：采用已出运算符(以&amp;开头)</p>

<p><code>&amp;+</code> <code>&amp;-</code> <code>&amp;*</code></p>

<blockquote>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
</blockquote>

<h2 id="toc_7">优先级和结合性</h2>

<p>注意:<br/>
<code>Swift</code>中的优先级与C语言中完全不一致</p>

<h2 id="toc_8">运算符函数</h2>

<p><em>类和结构体</em>可以为现有的运算符提供自定义实现--&gt;<strong>运算符重载</strong></p>

<pre><code class="language-swift">struct Vector2D {
    var x = 0.0, y = 0.0
}
extension Vector2D {
    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y + right.y)
    }
}
</code></pre>

<p>对于结构体<code>Vector2.0</code>，运算符函数被定义为类方法,名字与要重载的<code>+</code>一致</p>

<p>因为加法运算并不是一个向量必须的功能，因此这个类被定义在扩展而不是原结构体声明中</p>

<p>这个函数被定义为全局的,因此任意<code>Vector2D</code>示例都可以使用这个运算符:</p>

<pre><code class="language-swift">let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)
</code></pre>

<h3 id="toc_9">前缀和后缀运算符</h3>

<p>不仅加法似的中缀运算符,类和结构体也可以提供单目运算符实现</p>

<pre><code class="language-swift">extension Vector2D {
//prefix表明是前缀运算符的实现
    static prefix func - (vector: Vector2D) -&gt; Vector2D {
        return Vector2D(x: -vector.x, y: -vector.y)
    }
}

let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例
let alsoPositive = -negative
// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例
</code></pre>

<p>实现单目运算符需要用<code>prefix</code>或者<code>postfix</code>来指明前缀后后缀</p>

<h3 id="toc_10">复合赋值运算符</h3>

<p>对于复合赋值运算符例如:<code>+=</code> <code>-=</code><br/>
需要在实现时将做参数设置为<code>inout</code>类型，这样参数值可以在函数中被修改</p>

<pre><code class="language-swift">extension Vector2D {
    static func += (left: inout Vector2D, right: Vector2D) {
        left = left + right
    }
}
</code></pre>

<blockquote>
<p>不能对默认的赋值运算符<code>=</code>进行重载。只能重载组合赋值运算符，也无法对三目运算符进行重载</p>
</blockquote>

<h3 id="toc_11">等价运算符</h3>

<p>通过对自定义类或结构体进行<code>==</code>或<code>!=</code>运算符实现来判断其是否“相等”</p>

<pre><code class="language-swift">//实现方法与中缀运算符相同
extension Vector2D {
    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {
        return (left.x == right.x) &amp;&amp; (left.y == right.y)
    }
    static func != (left: Vector2D, right: Vector2D) -&gt; Bool {
        return !(left == right)
    }
}
</code></pre>

<h2 id="toc_12">自定义运算符</h2>

<p>除了实现标准运算符外还可以声明和实现<strong>自定义的运算符</strong></p>

<p>新的运算符要使用<code>operator</code>关键字在全局作用域内进行定义，同时还要指定<code>prefix</code>、<code>infix</code>或者<code>postfix</code>修饰符：</p>

<pre><code class="language-swift">prefix operator +++ {}
//定义了+++的前缀运算符  全局作用域
//这个运算符现在没有任何意义
</code></pre>

<p>我们针对<code>Vector2D</code>结构体来实现<code>+++</code>运算符</p>

<pre><code class="language-swift">extension Vector2D {
    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {
        vector += vector
        return vector
    }
}
//我们将+++实现为前面重载的运算符+=自身的值
</code></pre>

<h3 id="toc_13">自定义中缀运算符优先级</h3>

<p>每个自定义中缀运算符都属于某个优先级组。这个优先级组指定了这个运算符和其他中缀运算符的优先级和结合性</p>

<pre><code class="language-swift">//自定义中缀运算符+- 属于AdditionPrecedence优先组
infix operator +-: AdditionPrecedence

extension Vector2D {
    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y - right.y)
    }
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)
</code></pre>

<p><code>AdditionPrecedence</code>优先组为<code>+</code><code>-</code>等默认的优先级组</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15057532270985.html">访问控制</a></h1>
			<p class="meta"><time datetime="2017-09-19T00:47:07+08:00" 
			pubdate data-updated="true">09/19/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>访问控制：限定其他源文件或者模块代码对你的代码的访问级别</p>

<ul>
<li>明确的给单个类型(类,结构体,枚举)设置访问级别</li>
<li>给类型的属性、方法、构造器、下标等设置访问级别</li>
<li>限定协议在一定范围使用，包括协议中的全局变量、常亮、函数</li>
</ul>

<p><code>Swift</code>有显式提供多种访问级别，也有为场景提供了默认的访问级别</p>

<h2 id="toc_0">模块和源文件</h2>

<p><strong><code>Swift</code>中的访问控制基于模块和源文件</strong></p>

<p><mark>模块</mark>指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用<code>import</code>关键字导入另外一个模块。</p>

<p>在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。</p>

<p><mark>源文件</mark>就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>

<h2 id="toc_1">访问级别</h2>

<p><code>Swift</code>提供了5种访问级别</p>

<ul>
<li><strong>开放访问和公开访问</strong>(open、public):可以访问同一模块源文件中的任何实体，在模块外也可以导入该模块来访问源文件中的所有实体。我们通常将框架中的某个接口可以被任何使用时,设置为此级别</li>
<li><strong>内部访问</strong>(internal)：可以访问同一模块源文件的任何实体，但是不能从外部访问该模块源文件中的实体。用于某接口只在应用程序或者内部使用时</li>
<li><strong>文件私有访问限制</strong>(filepart)：限值实体只能被所定义的<em>文件</em>内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
<li><strong>私有访问限值</strong>(private)： 限值实体只能在所定义的<em>作用域</em>使用,需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
</ul>

<p>Open为最高访问级别(限制最少)  Private为最低访问级别 限制最多</p>

<p>Open和Public区别:(Open只作用于类和类的成员)</p>

<ul>
<li>Public或者其他更严访问级别的类，只能在它们定义的模块内部被继承。</li>
<li>Public或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。</li>
<li>Open的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</li>
<li>Open的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</li>
</ul>

<p>把一个类标记为Open，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</p>

<h3 id="toc_2">访问级别基本原则</h3>

<p><strong>基本原则：实体不可以在某个实体中定义访问级别更低（限制更多）的实体</strong></p>

<p>例如:函数的访问级别不能高于他的参数类型或者返回类型的访问级别。</p>

<h3 id="toc_3">默认访问级别</h3>

<p>如果不为代码中的实体指定访问级别,默认为<code>internal</code>级别。<br/>
大多数情况下我们不需要显示指定实体的访问级别</p>

<h3 id="toc_4">单target应用程序的访问级别</h3>

<p>对于单目标应用程序,应用的所有功能都为该应用进行服务而不需要提供给其他应用或者模块进行使用,因此使用默认的<code>internal</code>即可。也可以使用文件私有访问或者私有访问级别来进行一些功能的实现细节的隐藏</p>

<h3 id="toc_5">框架访问级别</h3>

<p>在开发框架时需要将对外的接口定义为Open或者Public级别，即为对外的接口API</p>

<blockquote>
<p>注意</p>

<p>框架内部实现仍使用默认的内部访问级别internal，当需要对框架内部其他部分隐藏的细节可以使用<code>private</code>或者<code>fileprivate</code>。对于框架对外api部分，需要设置为<code>open</code>或<code>public</code></p>
</blockquote>

<h3 id="toc_6">单元测试目标的访问级别</h3>

<p>当我们用单元测试目标去访问程序代码，为了访问那些非公开访问或者开发访问代码,可以在导入的应用程序模块的语句前使用<code>@testable</code>特性，然后在允许测试的编译设置<code>（Build Options -&gt; Enable Testability）</code>下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p>

<h2 id="toc_7">访问控制语法</h2>

<pre><code class="language-swift">//声明实体访问级别
public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}
public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}
//默认为内部访问级别
class SomeInternalClass {} // 隐式内部访问级别
var someInternalConstant = 0 // 隐式内部访问级别
</code></pre>

<h2 id="toc_8">自定义类型</h2>

<p>在自定义类型时指定访问的级别，然后这个类型就在访问级别限制范围内进行使用</p>

<p><mark>定义的类型访问级别会影响到类型成员(属性、方法、构造器、下标)的默认访问级别</mark>。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。</p>

<blockquote>
<p>注意：</p>

<p>必须显式指定才能将成员设置为公开访问类型，避免不消息暴露内部使用接口</p>
</blockquote>

<h3 id="toc_9">元组类型</h3>

<p>元组的访问级别 是由元组中访问级别最严格的类型来约定。</p>

<blockquote>
<p>注意</p>

<p>元组不同股类、结构体、枚举、函数那样有单独的定义。其访问级别在被使用时自动推断出，而无法明确指定</p>
</blockquote>

<h3 id="toc_10">函数类型</h3>

<p>函数的访问类型由访问级别最严格的参数类型或者返回类型的访问级别决定</p>

<p>如果访问级别不复合函数定义的环境的默认访问级别，那么就需要明确指定该函数的访问级别</p>

<pre><code class="language-swift">//定义一个函数
func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
}
/**
    这样是无法通过编译的,这个函数返回了一个元组,元组中包含了两个自定义类，根据元组访问
    级别,元组为privite的，因此函数也为private访问级别，因此并不是默认的internal级
    别，因此需要用private修饰符明确指出函数访问级别
*/

private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // 此处是函数实现部分
}
</code></pre>

<h3 id="toc_11">枚举类型</h3>

<p>枚举成员的访问级别与枚举类型相同，不能单独指定美剧成员的访问级别</p>

<h4 id="toc_12">原始值和关联值</h4>

<p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。</p>

<p>例如不能在<code>internal</code>的枚举中定义<code>private</code>的原始值类型</p>

<h3 id="toc_13">嵌套类型</h3>

<p>如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>

<h2 id="toc_14">子类</h2>

<p><strong>子类的访问级别也不能高于父类</strong></p>

<p>可以通过重写为继承来的类成员(方法、属性、下标、构造器等)提供更高的访问级别</p>

<pre><code class="language-swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {}
}
//类B继承自A，重写了类A中的方法将访问级别指定为更高的访问级别  
//将someMethod方法 由private级别重写为internal级别
</code></pre>

<p>我们甚至可以在子类中，用子成员去访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内(即，在同一源文件中访问父类<code>fileprivate</code>级别的成员，在同一模块中内访问父类<code>internal</code>级别成员)</p>

<pre><code class="language-swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
//子类中访问父类中级别更低成员（保证操作在相应访问级别的限值范围内）
</code></pre>

<h3 id="toc_15">常亮、变量、属性、下标</h3>

<p>常量、变量、属性不能有比类型（成员的定义类型）更高的访问级别，</p>

<p>下标也不能有比索引类型或返回类型更高的访问级别</p>

<h3 id="toc_16">Getter和Setter</h3>

<p>常量、变量、属性、下标的<code>Getters</code>和<code>Setters</code>的访问级别和它们所属类型的访问级别相同</p>

<p><code>Setter</code>的访问级别可以低于<code>Getter</code>的访问级别，这样就可以控制变量、属性或下标的读写权限。<br/>
在var或者subscript关键字之前，可以通过添加<code>fileprivate(set)</code>、<code>private(set)</code>、<code>internal(set)</code>来为写入指定更低权限</p>

<blockquote>
<p>注意：</p>

<p>这个规则同时适用于存储型和计算型属性。<br/>
即使你不明确指定存储型的<code>Getter</code>和<code>Seeter</code>，<code>Swift</code>也会隐式为其创建<code>Getter</code>和<code>Setter</code>，用于访问该属性的后备存储。<br/>
使用<code>fileprivate(set)</code>,<code>private(set)</code>和<code>internal(set)</code>可以改变<code>Setter</code>的访问级别，这对计算属性同样适用</p>
</blockquote>

<pre><code class="language-swift">struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = &quot;&quot; {
        didSet {
            numberOfEdits += 1
        }
    }
}
</code></pre>

<p>因为结构体的<code>numberOfEdits</code>属性采用了<code>private(set)</code>修饰符，意味着<code>numberOfEdits</code>属性只能在结构体定义中赋值。此时<code>numberOfEdits</code>属性<code>Getter</code>依然是是默认的访问级别<code>internal</code>，但是<code>Setter</code>的访问级别是<code>private</code>，这表示该属性只能在内部修改，而在结构体外部则表现为一个只读属性。</p>

<h2 id="toc_17">构造器</h2>

<p>自定义构造器的访问级别可以低于或等于其所属的的类型的访问级别</p>

<p>但是<mark>必要构造器</mark>的访问级别必须和所属的类型的访问级别相同</p>

<h3 id="toc_18">默认构造器</h3>

<p>默认构造器的访问级别和所属类型的访问级别相同，除非类型的访问级别是<code>public</code>。<br/>
当类型级别为<code>public</code>，那么默认构造器的访问级别将为<code>internal</code><br/>
如果想要在其他模块使用<code>public</code>的无参构造器，你只能自己提供一个</p>

<h3 id="toc_19">结构体默认的成员逐一构造器</h3>

<p>如果结构体中任意存储型属性的访问级别为<code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是<code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>

<p>与默认构造器类似，如果希望一个<code>public</code>级别的结构体也能在其他模块中使用默认的成员逐一构造器，你依然只能自己提供一个public级别的成员逐一构造器</p>

<h2 id="toc_20">协议</h2>

<p>在定义协议时指定协议的访问级别,限制协议只能在适当访问级别范围内被遵循</p>

<p>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别，这样才能确保该协议的所有要求对于任意遵循着都将会可用</p>

<blockquote>
<p>注意：</p>

<p>如果定义一个public级别的协议，则其协议的所有实现也会是public级别的。不同于其他类型，例如，当类型时<code>public</code>级别，其成员的访问级别却只是<code>internal</code></p>
</blockquote>

<h3 id="toc_21">协议继承</h3>

<p>如果定义一个继承自其他协议的新协议，那么该新协议的访问级别最高只能和父协议相同，而不能高于父协议</p>

<h3 id="toc_22">协议遵循</h3>

<ol>
<li><p>一个类型可以遵循级别比它更低的协议。<br/>
例如，你可以定义一个<code>public</code>级别类型，它可以在其他模块中使用，同时它也可以采纳一个<code>internal</code>级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。</p></li>
<li><p>遵循协议的上下文级别是类型和协议中级别中较小的那个。<br/>
例如：类型是public级别，但它要遵循的协议是<code>internal</code>级别，那么这个类型对该协议的遵循上下文就是internal级别</p></li>
<li><p>当编写或者扩展一个类型让它遵循一个协议时，必须保证该类型对协议中每个要求的实现，至少与遵循协议的上下文级别一致。<br/>
例如：一个public类型遵循一个internal协议，这个类型对协议的所有实现至少都已应该是internal级别的</p></li>
</ol>

<h2 id="toc_23">Extension</h2>

<ol>
<li>可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别</li>
<li>可以明确指定扩展的访问级别(例如：<code>private extension</code>)，从而给扩展中成员一个新的访问级别,但是新的默认访问级别仍会被单独指定的级别覆盖</li>
</ol>

<h3 id="toc_24">通过扩展添加协议一致性</h3>

<p>通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>

<h3 id="toc_25">Extension的私有成员</h3>

<p>扩展同一文件内的类、结构体或者枚举，extension里的代码会表现的和声明在元类型里一模一样。</p>

<ul>
<li>在类型的声明里声明一个私有成员，在同一文件的extension里访问</li>
<li>在extension里声明一个私有成员，在同一文件的另一个extension里访问</li>
<li>在extension里声明一个私有成员，在同一文件的类型声明里访问</li>
</ul>

<h2 id="toc_26">泛型</h2>

<p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>

<h2 id="toc_27">类型别名</h2>

<p>定义的任何类型别名都会被当做不同的类型，以便进行访问控制。<br/>
类型别名的访问级别不可高于其表示的类型的访问级别。</p>

<p>例如： private 级别的类型别名可以作为 private、file-private、internal、public 或者 open 类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal、file-private 或 private 类型的别名。</p>

<blockquote>
<p>注意：</p>

<p>这条规则 也适用于为满足协议遵循而将类型别名用于关联类型的情况</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15660380397380.html">内存安全</a></h1>
			<p class="meta"><time datetime="2019-08-17T18:33:59+08:00" 
			pubdate data-updated="true">08/17/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>默认情况下，<code>Swift</code>会阻止代码里的不安全行为。例如，变量在使用前完成初始化，在内存回收后无法被访问，并且数组的索引会做越界检查。</p>

<p>因为<code>Swift</code>管理内存，大部分时间 并不需要考虑内存访问的事情。然而，理解潜在冲突也是很重要的，可以避免写出访问冲突的代码。如果代码确实存在冲突，那在编译时或者运行时会得到错误。</p>

<h2 id="toc_0">理解内存访问冲突</h2>

<p>内存的访问，会发生在你给变量赋值，或者传递参数给函数时。<br/>
而内存的访问冲突发生在代码多个访问同时访问同一个内存地址，造成的不可预计或者不一致的行为。</p>

<h2 id="toc_1">内存访问性质</h2>

<p>内存访问冲突会发生在以下两个访问符合情况时:</p>

<ul>
<li>至少有一个是写访问</li>
<li>访问的是统一存储地址</li>
<li>访问在时间线上部分重叠</li>
</ul>

<p>内存的访问时长，要么是瞬时的，要么是长期的。主要区别在于，别的代码有没有可能在访问期间同时访问，也就是时间线上的重叠。一个长期访问可以被别的长期或者瞬时访问重叠</p>

<p>重叠访问主要出现在使用<code>in-out</code>参数的函数或方法  或者结构体的<code>mutating</code>方法里。</p>

<h2 id="toc_2">In-Out参数的访问冲突</h2>

<p>一个函数会对它所有的in-out参数进行长期写访问。in-out参数的写访问会在所有非in-out参数处理完成后开始，直到函数执行完毕位置。如果有多个in-out参数，则写访问开始的顺序和参数顺序一致。</p>

<ol>
<li><p>不能在访问以in-out形式传入后的原变量，即使作用域原则和访问权限允许--任何访问原变量的行为都会造成冲突<br/>
<img src="media/15660380397380/15661846253994.jpg" alt="" style="width:600px;"/></p>
<p>解决方案是 显示的拷贝一份<code>stepSize</code>：</p>
<pre><code class="language-swift">// 显式拷贝
var copyOfStepSize = stepSize<br/>
increment(&amp;copyOfStepSize)<br/>
// 更新原来的值<br/>
stepSize = copyOfStepSize<br/>
// stepSize 现在的值是 2
</code></pre></li>
<li><p>当向同一函数的多个in-out参数里传入同一个变量也会产生冲突，</p>
<pre><code class="language-swift">func balance(_ x: inout Int, _ y: inout Int) {
let sum = x + y<br/>
x = sum / 2<br/>
y = sum - x<br/>
}<br/>
var playerOneScore = 42<br/>
var playerTwoScore = 30<br/>
balance(&amp;playerOneScore, &amp;playerTwoScore)  // 正常<br/>
balance(&amp;playerOneScore, &amp;playerOneScore)<br/>
// 错误：playerOneScore 访问冲突
</code></pre>
<p>将 playerOneScore 作为参数同时传入就会产生冲突，因为它会发起两个写访问，同时访 问同一个的存储地址</p></li>
</ol>

<blockquote>
<p>注意:</p>

<p>因为操作符也是函数，它们也会对in-out参数进行长期访问</p>
</blockquote>

<h3 id="toc_3">方法里self的访问冲突</h3>

<p>一个结构体的<code>mutating</code>方法会在调用期间对<code>self</code>进行写访问</p>

<pre><code class="language-swift">extension Player {
    mutating func shareHealth(with teammate: inout Player) {
        balance(&amp;teammate.health, &amp;health)
    }
}

var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)
var maria = Player(name: &quot;Maria&quot;, health: 5, energy: 10)
oscar.shareHealth(with: &amp;maria)  // 正常
</code></pre>

<p><img src="media/15660380397380/15661951218602.jpg" alt="" style="width:600px;"/></p>

<p>但是当如果</p>

<pre><code class="language-swift">oscar.shareHealth(with: &amp;oscar)
// 错误：oscar 访问冲突
</code></pre>

<p>因为 mutating方法在调用期间需要对self发起访问，而同时in-out参数也需要写访问。在方法里，<code>self</code>和<code>teammate</code>指向统一存储地址。对同一块内存进行访问，并且重叠，就会产生冲突。</p>

<h2 id="toc_4">属性的访问冲突</h2>

<p>结构体、元组和枚举都是值类型，由多个独立的值构成，所以修改值的一部分都是对于整个值的修改，意味着其中一个属性的读和写访问都需要访问整一个值。</p>

<ol>
<li><p>对元组元素的写访问重写会产生冲突</p>
<pre><code class="language-swift">var playerInformation = (health: 10, energy: 20)
balance(&amp;playerInformation.health, &amp;playerInformation.energy)<br/>
// 错误：playerInformation 的属性访问冲突
</code></pre>
<p>所以，在任何情况下，对于元组元素的写访问都需要对整个元组发起写访问。</p></li>
<li><p>对存储在全局变量的结构体属性写访问重叠</p>
<pre><code class="language-swift">var holly = Player(name: &quot;Holly&quot;, health: 10, energy: 10)
balance(&amp;holly.health, &amp;holly.energy)  // 错误
</code></pre>
<p>大多数对于结构体属性的访问都会安全的重叠。例如，将上面例子的变量改为本地变量而非全局变量，编译器即可保证其是安全的</p>
<pre><code class="language-swift">func someFunction() {
    var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)<br/>
    balance(&amp;oscar.health, &amp;oscar.energy)  // 正常<br/>
}
</code></pre>
<p>此时编译器可以保证内存安全，因为两个存储尚需经任何情况下都不会互相影响。</p></li>
</ol>

<p>限制结构体属性的重叠访问对于保证内存安全不是必要的。保证内存安全是必要的，但因为访问独占权的要求比内存安全还要更严格——意味着即使有些代码违反了访问独占权的原则，也是内存安全的，所以如果编译器可以保证这种非专属的访问是安全的，那 Swift 就会允许这种行为的代码运行。特别是当你遵循下面的原则时，它可以保证结构体属性的重叠访问是安全的：</p>

<ul>
<li>你访问的是实例的存储属性，而不是计算属性或类的属性</li>
<li>结构体是本地变量的值，而非全局变量</li>
<li>结构体要么没有被闭包捕获，要么只被非逃逸闭包捕获了</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15028525854956.html">自动引用计数</a></h1>
			<p class="meta"><time datetime="2017-08-16T11:03:05+08:00" 
			pubdate data-updated="true">08/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>与<code>OC</code>相同 <code>Swift</code>使用自动引用计数(ARC)来跟踪和管理应用程序内存</p>

<blockquote>
<p>注意</p>

<p>引用计数仅仅应用于类的实例。结构体和枚举是值类型，不是引用类型，也不是通过引用的方式存储和传递的</p>
</blockquote>

<h2 id="toc_0">工作机制</h2>

<p>创建类的实例时,<code>ARC</code>会分配一块内存来存储实例信息.不再使用该实例,ARC将其释放.当是实例被释放后，其方法或属性均不能被访问或调用。<br/>
因此，为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>

<h2 id="toc_1">循环强引用</h2>

<p>如果两个类实例互相引用,那么类实例的强引用数永远不能变为0，这就是<strong>循环强引用</strong></p>

<h2 id="toc_2">解决循环强引用方法</h2>

<p>解决办法: <strong>弱引用</strong> <strong>无主引用</strong></p>

<p>将循环引用中一个实例对另外的实例不保持强引用</p>

<p>当其他的实例有更短的生命周期时,使用弱引用，即其 实例 析构在先时; 当其他实例有相同或者更长的声明周期时,请使用无主引用</p>

<h3 id="toc_3">弱引用</h3>

<p>弱引用不会对其引用的实例保持强引用，因而不会阻止<code>ARC</code>销毁被引用的实例。</p>

<p>声明属性或变量时,在前面加上<code>weak</code>关键字表明是个弱引用</p>

<p><code>ARC</code>会在引用的实例被销毁后自动将其赋值为<code>nil</code>.并且弱引用可以允许它们的值运行时赋值为<code>nil</code>，所以会被定义为可选类型变量而不是常量</p>

<p>弱引用为可选类型变量,可以通过检查是否为nil,防止访问已经销毁的实例的引用</p>

<blockquote>
<p>注意</p>

<p>在<code>ARC</code>设置弱引用为<code>nil</code>时,属性观察不会被触发</p>
</blockquote>

<pre><code class="language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}

var john: Person?
var unit4A: Apartment?
john = Person(name: &quot;John Appleseed&quot;)
unit4A = Apartment(unit: &quot;4A&quot;)
john!.apartment = unit4A
unit4A!.tenant = john
//因为Apartment 中 的 tenant 属性为弱引用,因此即使这样也不会产生循环引用

john = nil
// 打印 “John Appleseed is being deinitialized”

unit4A = nil
// 打印 “Apartment 4A is being deinitialized”

</code></pre>

<p>变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息</p>

<blockquote>
<p>注意:</p>

<p>在使用垃圾收集的系统里</p>
</blockquote>

<h3 id="toc_4">无主引用</h3>

<p>在属性前加<code>unowned</code>关键字进行声明无主引用</p>

<p>与弱引用类似,无主引用不会保持住引用的实例<br/>
与弱引用不同,<strong>无主引用用在与其他实例有相同或者更长声明周期时使用</strong></p>

<p>无主引用为非可选类型,因此<code>ARC</code>无法在实例被销毁后将无主引用设置为<code>nil</code></p>

<blockquote>
<p>注意:</p>

<p>使用无主引用，必须<strong>保证引用始终指向一个未销毁的实例</strong><br/>
试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误</p>
</blockquote>

<p>举个栗子:<br/>
<code>Customer</code>客户和<code>CreditCard</code>银行卡之间的关系,两个类都将另外一个类的实例作为自身属性,关系是客户可能没有银行卡,但是银行卡一定有客户,因此将银行卡的<code>customer</code>设置为无主引用</p>

<pre><code class="language-swift">
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64 //确保在32、64位机器上均可以保存16位的卡号
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}


var john: Customer?
john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)

john = nil
// 打印 “John Appleseed is being deinitialized”
// 打印 ”Card #1234567890123456 is being deinitialized”

</code></pre>

<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对 <code>Customer</code>实例的无主引用</p>

<blockquote>
<p>注意:</p>

<p>上面是展示如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况(例如：处于次年功能方面原因)，Swift还提供了不安全的无主引用。与所有的不安全操作类似，需要负责检查代码确保其安全性。可以通过<code>unowned(unsafe)</code>声明不安全的无主引用。如果视图在实力被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作</p>
</blockquote>

<h3 id="toc_5">无主引用以及隐式解析可选属性</h3>

<pre><code class="language-swift">class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>

<p>我们在<code>Country</code>的<code>capitalCity</code>属性声明为<code>City!</code>隐式解析可选类型的属性,表明像其他可选类型一样，默认值为<code>nil</code>，但是不需要展开他的值就能访问</p>

<p>因为<code>capitalCity</code>的默认值为默认为<code>nil</code>，因此在构造country时,当name赋值以后,初始化就完成了,此时我们就能把这个初始化的<code>country</code>实例传递给<code>City</code>来构造City实例</p>

<h2 id="toc_6">闭包引起的循环强引用</h2>

<p>闭包和类 类似,都是引用类型,因此,将闭包赋值为某属性时,是将这个闭包的引用赋值给属性,因此当闭包体中访问实例的某个属性时,就会造成循环引用</p>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<blockquote>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为<code>HTML</code>输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>

<p><strong>闭包捕获列表</strong>解决闭包引起的循环引用</p>

<p>对于一个类的闭包属性,想要改变这个属性的行为,可以通过给这个属性再赋值一个闭包</p>

<p><code>HTMLElement</code>有类和作为<code>asHTML</code>默认值的闭包之间的循环强引用</p>

<p>此时<code>HTMLElement</code>实例和它的闭包是不会被销毁和释放的</p>

<blockquote>
<p>注意:</p>

<p>虽然闭包中多次使用<code>self</code>，但是它只捕获<code>HTMLElement</code>实例的一个强引用</p>
</blockquote>

<h2 id="toc_7">解决闭包引起的循环强引用</h2>

<p>在定义闭包时同时定义<strong>捕获列表</strong>作为闭包的一部分，捕获列表定义了闭包体内捕获一个或多个引用类型的规则.声明捕获的引用为弱引用或者无主引用,而不是强引用</p>

<blockquote>
<p>注意:</p>

<p><code>Swift</code>规定:在闭包中使用<code>self</code>的成员，要使用<code>self.someProperty</code>或者<code>self.someMethod()</code>，而不是使用<code>someProperty</code>或<code>someMethod()</code><br/>
这是为了提醒你 一不小心就捕获了self</p>
</blockquote>

<h3 id="toc_8">定义捕获列表</h3>

<p>捕获列表由一对元素组成,一个是<code>weak</code>或<code>unowned</code>关键字,另一个是类实例的引用如<code>self</code>或初始化的变量.</p>

<p>在方括号中用逗号隔开</p>

<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面:</p>

<pre><code class="language-swift">lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // 这里是闭包的函数体
}
</code></pre>

<pre><code class="language-swift">
/**
如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，
那么可以把捕获列表和关键字 in 放在闭包最开始的地方
*/

lazy var someClosure: Void -&gt; String = {
    [unowned self, weak delegate = self.delegate!] in
    // 这里是闭包的函数体
}

</code></pre>

<h3 id="toc_9">弱引用和无主引用</h3>

<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为<code>无主引用</code>。(即被捕获的引用不会变为nil使用无主引用)<br/>
在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>，弱引用总是可选类型,在引用的实例被销毁后自动置为<code>nil</code></p>

<blockquote>
<p>注意</p>

<p>如果被捕获的引用绝对不会变成nil,应该用无主引用，而不是弱引用</p>
</blockquote>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<p>在<code>asHTML</code>闭包中多了一个捕获列表，<code>[unowned self]</code>将self声明为无主引用<br/>
这时候没有了循环引用,我们就可以销毁<code>HTMLElement</code>实例了</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_20.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_18.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>