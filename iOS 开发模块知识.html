<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  iOS 开发模块知识 - 栗豫塬的博客
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="栗豫塬的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:acefish.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 栗豫塬的博客</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="iOS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9D%97%E7%9F%A5%E8%AF%86.html">iOS 开发模块知识</a></li>
        
            <li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B.html">计算机编程</a></li>
        
            <li><a href="iOSDevelop.html">iOSDevelop</a></li>
        
            <li><a href="supplement.html">补充</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14978615246204.html">
                
                  <h1>集合类型</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>Swift</code>语言提供<code>Arrays</code>(有序数据集)、<code>Sets</code>(无序不重复数据集)和<code>Dictionaries</code>(无序键值对)三种基本的集合类型用来存储集合数据</p>

<p><code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确<br/>
Swift 的Arrays、Sets和Dictionaries类型被实现为<code>泛型集合</code>。</p>

<blockquote>
<p>数组类型<code>Array&lt;Int&gt;</code> 简化形式 <code>[Int]</code><br/>
集合类型<code>Set&lt;Int&gt;</code> 无简化形式<br/>
字典类型<code>Dictionary&lt;Int, String&gt;</code> 简化 <code>[Int: String]</code><br/>
Array继承<code>RangeReplaceableCollection</code>协议 因此可以使用我们前面说的<code>index索引</code>和<code>insert方法</code></p>
</blockquote>

<h2 id="toc_0">集合可变性</h2>

<p>当集合为变量，集合是可变的,当不需要集合改变时建议创建为不可变的,有利于优化</p>

<h2 id="toc_1">数组Array</h2>

<p>存储同一类型值,可以重复</p>

<h3 id="toc_2">创建空数组</h3>

<pre><code class="language-swift">var someInts = [Int]()//创建空数组
通过构造函数的类型，数组可以推断为[Int]
//创建特定数据类型的空数组
var someInt1 = [[Int]]()//创建类型为整形数组的空数组
</code></pre>

<blockquote>
<p>数组的类型表达为 [Int]  表示一个类型为[Int]的数组</p>
</blockquote>

<pre><code class="language-swift">someInts.append(3)
//可以从上面推断出数组为Int类型数组,因此可以直接创建空数组
someInts = []
//直接创建空数组
</code></pre>

<h3 id="toc_3">带有默认值的数组</h3>

<p>创建特定大小并且所有数据都被默认构造数组方法</p>

<pre><code class="language-swift">var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]
</code></pre>

<h3 id="toc_4">通过两个数组相加创建一个数组</h3>

<p>可以用<code>+</code>将两种相同数据类型数组组合为一个新的数组,新的数组类型与这两个数组类型相同</p>

<h3 id="toc_5">用数组字面量构造数组</h3>

<p>用数组字面量来进行数组构造,这是用一个或者多个数值构造数组</p>

<pre><code class="language-swift">[value 1, value 2, value 3]
// shoppingList 已经被构造并且拥有两个初始项。
var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]
var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] //可以不用声明类型 可以推断为String类型
</code></pre>

<h3 id="toc_6">访问和修改数组</h3>

<p>1.使用数组的只读<code>count</code>属性来获取数组中数据项数量<br/>
2.用布尔<code>isEmpty</code>检查数组是否为空 即<code>count</code>属性是否为<code>0</code><br/>
3.使用<code>append(_:)</code>方法在数组后添加一个新的数组项</p>

<pre><code class="language-swift">shoppingList.append(&quot;Flour&quot;) //只能添加一项
</code></pre>

<p>4.用加法赋值运算符<code>+=</code>在数组后添加一个或多个相同类型数据项<br/>
<code>shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]</code><br/>
5.用下标来获取数组中数据项</p>

<pre><code class="language-Swift">var firstItem = shoppingList[0]//获取数组中第一项
</code></pre>

<p>6.用下标改变一个或多个下标索引对应色数据值</p>

<pre><code class="language-Swift">shoppingList[0] = &quot;Six eggs&quot;//

shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]//改变一系列值 即使新数据和原有数据的数量不一致
</code></pre>

<blockquote>
<p>不能用下标访问的形式在数组尾部添加新项</p>
</blockquote>

<p>7.用<code>insert(_:at:)</code>方法在某个索引之前添加新的数据项</p>

<p>8.移除<br/>
使用<code>remove(at:)</code>方法来移除数组中的某一项</p>

<pre><code class="language-swift">//移除下标索引为0的数据项
let mapleSyrup = remove(at: 0)
//返回值 mapleSyrup 等于被移除的数据项值&quot;Maple Syrup&quot;
</code></pre>

<p><code>removeLast()</code>移除数组最后一项(使用这个方法可以避免我们去用count属性获取数组最后一个下标)</p>

<blockquote>
<p>运行期可以自动检查是否发生数组越界</p>
</blockquote>

<h3 id="toc_7">遍历数组</h3>

<p>用<code>for-in</code>进行遍历</p>

<pre><code class="language-swift">for item in shoppingList {
    print(item)//单独的变量或常量可以直接print
}
</code></pre>

<p>如果想要在遍历时获取每个数据项的索引和值,可以用数组的<code>enumerated()</code>，它会返回由索引和数组值组成的元组</p>

<pre><code class="language-swift">for (index, value) in shoppingList.enumerated() {
    print(&quot;Item \(String(index + 1)): \(value)&quot;)
}
/*
    shoppingList.enumerated()返回就是一个sorted后 以元组形式返回
*/
</code></pre>

<blockquote>
<p>数组也继承了<code>collection</code>协议</p>
</blockquote>

<h2 id="toc_8">集合Set</h2>

<p>存储相同类型并且没有确定顺序的值</p>

<h3 id="toc_9">集合类型的哈希值</h3>

<p>一个类型为了存储在集合中，该类型必须是可哈希化的,即该类型必须提供一个方法来计算它的哈希值(哈希值是<code>Int</code>类型的)，相等对象的哈希值必须相同(<code>a==b因此a.hashValue == b.hashValue</code>).</p>

<p>Swift 的所有基本类型(比如<code>String , Int , Double 和 Bool</code>)默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值默认也是可哈希化的。</p>

<blockquote>
<p>为了使我们的自定义类型作为集合或者字典键的类型,需要使你的自定义类型符合<code>Hashable</code>协议.这个协议需要我们提供一个类型为<code>Int</code>的可读属性<code>hashValue</code>.<code>hashValue</code>属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。</p>

<p>因为<code>Hashable</code>协议符合<code>Equatable</code>协议，所以遵循该协议的类型也必须提供一个&quot;是否相等&quot;运算符(<code>==</code>)的实现。<br/>
<code>==</code>的实现必须满足以下三种情况:<br/>
* a == a (自反性)<br/>
* a == b 意味着 b == a (对称性)<br/>
* a == b &amp;&amp; b == c 意味着 a == c (传递性)</p>
</blockquote>

<h3 id="toc_10">集合类型写法/表达</h3>

<p>Swift 中的<code>Set</code>类型被写为 <code>Set&lt;Element&gt;</code>(<code>Element</code>表示<code>Set</code>中允许存储的类型)，它并没有类似数组的简化形式</p>

<h3 id="toc_11">空的集合</h3>

<pre><code class="language-swift">var letters = Set&lt;Character&gt;()
</code></pre>

<pre><code class="language-swift">letters.insert(&quot;a&quot;)//通过这 我们可以推断出为一个Set&lt;Character&gt;类型集合
letters = []//我们可以直接设置其为空的Set  其类型还是Set&lt;Character&gt; 
</code></pre>

<h3 id="toc_12">用数组字面量创建集合</h3>

<pre><code class="language-swift">//有三个初始值
var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>

<p>我们用数组字面量的形式初始化这个<code>Set</code>.我们从数组字面量没有办法推断出为<code>Set</code>类型,因此必须显示声明,但是可以推断出Set中元素类型,因此我们可以简化为</p>

<pre><code class="language-swift">var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>

<h3 id="toc_13">访问和修改一个集合</h3>

<p>1.只读属性<code>count</code>获取集合中个数</p>

<p>2.布尔属性<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为 0</p>

<p>3.<code>insert(_:)</code>方法来添加一个新元素</p>

<pre><code class="language-swift">favoriteGenres.insert(&quot;Jazz&quot;)
/**
    返回一个元组(inserted: Bool, memberAfterInserted: String)
*/
</code></pre>

<p>4.<code>remove(_:)</code>方法去删除一个元素 <code>removeAll()</code>删除所有元素</p>

<p>5.<code>contains(_:)</code>方法去检查<code>Set</code>中是否包含一个特定的值</p>

<pre><code class="language-swift">    if favoriteGenres.contains(&quot;Funk&quot;) {
        print(&quot;I get up on the good foot.&quot;)
    } else {
        print(&quot;It&#39;s too funky in here.&quot;)
    }
</code></pre>

<p>6.用<code>for-in</code>遍历</p>

<pre><code class="language-swift">    for genre in favoriteGenres {
        print(&quot;\(genre)&quot;)
    }
</code></pre>

<p><code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个<code>Set</code>中的值可以使用<code>sorted()</code>方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符<code>&#39;&lt;&#39;</code>对元素进行比较的结果来确定</p>

<pre><code class="language-swift">    for genre in favoriteGenres.sorted() {
        print(&quot;(genre)&quot;)
    }
</code></pre>

<blockquote>
<p>sorted()后返回的是数组<br/>
sorted()返回排序后数组 数据源不变 sort()不返回数组将数据源变为排序后的数组(Set没有这方法,Array有)</p>
</blockquote>

<h2 id="toc_14">集合操作</h2>

<h3 id="toc_15">基本集合操作</h3>

<p>用<code>intersection(_:)</code>计算两个集合相交部分<br/>
用<code>symmetricDifference(_:)</code>计算两个集合中不同部分<br/>
用<code>union(_:)</code>方法合并两个集合<br/>
用<code>subtracting(_:)</code>方法根据在本集合不在另外集合中的部分</p>

<pre><code class="language-swift">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
oddDigits.union(evenDigits).sort()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre>

<h3 id="toc_16">集合成员关系以及相等</h3>

<p>用<code>==</code>判断两个集合是否包含完全相同的值<br/>
用<code>isSubset(of:)</code>判断是不是两外一个集合的子集<br/>
用<code>isSuperset(of:)</code>判断另外一个集合是不是本集合的子集<br/>
用<code>isStrictSubset(of:)</code>或<code>isStrictSuperset(of:)</code>判断一个集合是否是另外一个集合的子集合或<br/>
者父集合并且两个集合并不相等<br/>
用<code>isDisjoint(with:)</code>判断两个集合是否没有交集（没有相同的值）</p>

<pre><code class="language-swift">let houseAnimals: Set = [&quot;?&quot;, &quot;?&quot;]
let farmAnimals: Set = [&quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;]
let cityAnimals: Set = [&quot;?&quot;, &quot;?&quot;]
houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre>

<h2 id="toc_17">字典</h2>

<p>存储多个相同类型的值的容器</p>

<h3 id="toc_18">字典类型表达语法</h3>

<p><code>Swift</code>的字典使用<code>Dictionary&lt;Key, Value&gt;</code>定义，<code>Key</code>是键的类型,<code>Value</code>是值所对应的数据类型<br/>
<code>[Key: Value]</code>通常我们使用这种简化形式</p>

<blockquote>
<p>一个字典的 Key 类型必须遵循<code>Hashable</code>协议，就像<code>Set</code>的值类型,因为在字典中键也是唯一的,需要利用哈希值进行判断相等</p>
</blockquote>

<h3 id="toc_19">创建一个空字典</h3>

<pre><code class="language-swift">var namesOfIntegers = [Int: String]()//创建一个[Int: String] 类型的空字典
</code></pre>

<p>如果上下文已经知道类型信息</p>

<pre><code class="language-swift">namesOfIntegers = [:]//创建一个[Int: String] 类型的空字典
</code></pre>

<h3 id="toc_20">用字典字面量创建字典</h3>

<pre><code class="language-swift">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
//因为swift可以推断出为[String : String]类型 因此可以不同显示声明
var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
</code></pre>

<h3 id="toc_21">访问和修改字典</h3>

<p>1.只读属性<code>count</code>来获取字典的数据项数量</p>

<pre><code class="language-swift">print(&quot;The dictionary of airports contains (airports.count) items.&quot;)
// 打印 &quot;The dictionary of airports contains 2 items.&quot;（这个字典有两个数据项）
</code></pre>

<p>2.<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为 0 </p>

<p>3.可以在字典中使用下标语法来添加新的数据项<br/>
4.在字典中使用下标语法来改变特定键对应的值<br/>
<code>swift<br/>
airports[&quot;LHR&quot;] = &quot;London&quot;<br/>
//若不存在键&quot;LHR&quot; 即为添加新的数据项 否则为改变键对应值<br/>
</code><br/>
5.<code>updateValue(_:forKey:)</code>方法可以设置或者更新特定键对应的值(当存在键时即为更新值 否则为设置值)<br/>
<code>updateValue(_:forKey:)</code>方法会返回对应值的类型的可选值(因为可能没有oldvalue因此为可选类型)</p>

<pre><code class="language-swift">if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {
    print(&quot;The old value for DUB was (oldValue).&quot;)
}
// 输出 &quot;The old value for DUB was Dublin.&quot;
</code></pre>

<p>6.下标语法来在字典中检索特定键对应的值,因为可能不存在这个键，因此返回的为可选类型</p>

<pre><code class="language-swift">if let airportName = airports[&quot;DUB&quot;] {
    print(&quot;The name of the airport is (airportName).&quot;)
} else {
    print(&quot;That airport is not in the airports dictionary.&quot;)
}
</code></pre>

<p>7.通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对</p>

<pre><code class="language-swift">airports[&quot;APL&quot;] = &quot;Apple Internation&quot;
// &quot;Apple Internation&quot; 不是真的 APL 机场, 删除它
airports[&quot;APL&quot;] = nil
// APL 现在被移除了
</code></pre>

<p>8.<code>removeValue(forKey:)</code>也可以用来在字典中移除键值对<br/>
在键值对存在的情况下会移除该键值对并且返回被移除的值 或者在没有值的情况下返回<code>nil</code></p>

<pre><code class="language-swift">if let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) {
    print(&quot;The removed airport&#39;s name is (removedValue).&quot;)
} else {
    print(&quot;The airports dictionary does not contain a value for DUB.&quot;)
}
</code></pre>

<h3 id="toc_22">字典遍历</h3>

<p><code>for-in</code>遍历字典中的键值对，字典中的数据项都以<code>(key, value)</code>元组形式返回</p>

<pre><code class="language-swift">for (airportCode, airportName) in airports {
    print(&quot;\(airportCode): \(airportName)&quot;)
}
</code></pre>

<p>通过访问<code>keys</code>或者<code>values</code>属性，我们也可以遍历字典的键或者值</p>

<pre><code class="language-swift">for airportCode in airports.keys {
    print(&quot;Airport code: (airportCode)&quot;)
}
for airportName in airports.values {
print(&quot;Airport name: (airportName)&quot;)
}
</code></pre>

<p>我们可以直接使用<code>keys</code>或者<code>values</code>属性构造一个新数组</p>

<pre><code class="language-swift">let airportCodes: [String] = airports.keys
// airportCodes 是 [&quot;YYZ&quot;, &quot;LHR&quot;]
let airportNames: [String] = airports.values
// airportNames 是 [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]
let airportCodes = airports.keys.sorted()

//创建键或者值的新数组
</code></pre>

<blockquote>
<p><code>Swift</code>的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的<code>keys</code>或<code>values</code>属性使用<code>sorted()</code>方法</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Swift-BaseLearning.html'>Swift基础知识</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="iOS 开发模块知识_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>栗豫塬的博客</h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="iOS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9D%97%E7%9F%A5%E8%AF%86.html"><strong>iOS 开发模块知识</strong></a>
        
            <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B.html"><strong>计算机编程</strong></a>
        
            <a href="iOSDevelop.html"><strong>iOSDevelop</strong></a>
        
            <a href="supplement.html"><strong>补充</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14978615246204.html">集合类型</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14976139025239.html">编码</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14976096897839.html">字符串和字符</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974389141976.html">Swift 基本运算符</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974079542932.html">常见名词</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
