
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15469354561176.html">变量声明</a></h1>
			<p class="meta"><time datetime="2019-01-08T16:17:36+08:00" 
			pubdate data-updated="true">01/08/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>使用建议：</p>

<ol>
<li>默认使用const</li>
<li>当需要修改时改为let</li>
<li>尽量不在使用var</li>
</ol>

<h2 id="toc_0">let var const</h2>

<ol>
<li><p>var 是函数级别作用域，可以再同一作用域重复声明同一变量</p>
<p>var的问题:</p>
<ul>
<li>函数级作用域,表示在block外（例如if语句、for语句等）外访问内部声明的变量，会经常声明出全局变量</li>
<li>var声明的变量可重复声明 会导致难以定位的bug</li>
</ul>
<p>因此推荐使用<code>let</code></p></li>
<li><p>let 是block级别函数作用域</p></li>
<li><p>const 声明常量 不能修改值类型 但是可以修改引用类型</p></li>
</ol>

<h3 id="toc_1">代替立即执行函数</h3>

<pre><code class="language-javascript">//用var声明私有变量时 只能用立即执行函数
(function () {
    var name = &quot;fk&quot;
})()

//用let或者const时 只需要一个块即可
{
    let name = &quot;lyy&quot;
}

</code></pre>

<h3 id="toc_2">变量提示</h3>

<p>var存在变量提升 可以在变量为声明之前访问和使用变量</p>

<p>let虽然也存在变量提升 但是在变量在声明之前是处于临时性死区 在声明之前使用会报错</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15469181321574.html">正则表达式</a></h1>
			<p class="meta"><time datetime="2019-01-08T11:28:52+08:00" 
			pubdate data-updated="true">01/08/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">正则写法</h2>

<p>有两种写法</p>

<pre><code class="language-javascript">//js风格写法
// i ignore 忽略大小写
// g global 全局匹配找到所有符合条件
var re = new RegExp(&#39;a&#39;, &quot;i&quot;)
//perl风格写法
var re1 = /a/
</code></pre>

<h2 id="toc_1">常用字符串操作</h2>

<p>以下语法可以用字符串操作 也可以用正则表达式增加作用</p>

<ol>
<li><p>search<br/>
获取字符出现的位置，存在返回字符串出现位置,否则返回-1</p>
<pre><code class="language-javascript">var str = &quot;abcde&quot;
var index = str.search(&quot;a&quot;)
</code></pre></li>
<li><p>substring<br/>
获取字符串的子串</p>
<pre><code class="language-javascript">var str = &quot;abcde&quot;
//开始位置和结束位置 左闭右开<br/>
var subStr = str.substring(1, 2) //b<br/>
//只传入开始位置 从开始位置一直到结束<br/>
var subStr1 = str.substring(1) 
</code></pre></li>
<li><p>charAt()<br/>
获取该位置的字符</p>
<pre><code class="language-javascript">var str = &quot;abcde&quot;
var char = str.charAt(3) //d
</code></pre></li>
<li><p>split() <br/>
将字符串按特定字符切分为数组</p>
<pre><code class="language-javascript">var str = &quot;ab-cd-e&quot;
var arr = str.split(&quot;-&quot;) //[ab, cd, e]
</code></pre></li>
<li><p>match</p>
<p>获取符合条件的结果</p>
<pre><code class="language-javascript">var re = new RegExp(&quot;\\d+&quot;, &quot;g&quot;)
// var re = /\d+/g<br/>
var str = &quot;1AbBc33Cd3DeE2rRtT&quot;<br/>
str.match(re) //[1, 33, 3, 2]
</code></pre></li>
<li><p>replace </p>
<p>替换所有符合条件的字符</p>
<pre><code class="language-javascript">var re = new RegExp(&quot;\\d+&quot;, &quot;g&quot;)
// var re = /\d+/g<br/>
var str = &quot;1AbBc33Cd3DeE2rRtT&quot;<br/>
str.replace(re, &quot;dog&quot;) //dogAbBcdogCddogDeEdogrRtT
</code></pre></li>
<li><p>test<br/>
检测字符串中是否有符合规则的部分 返回boolean</p></li>
</ol>

<h2 id="toc_2">正则写法</h2>

<h3 id="toc_3">匹配</h3>

<pre><code class="language-javascript">\d  数字 [0-9]
\D  除了数字[^0-9]

\w  英文、数字、下划线 [a-z0-9_]
\W  非英文、数字、下划线 [^a-z0-9_]

\s  空白字符
\S  非空白字符 

.   表示为任意字符
</code></pre>

<h3 id="toc_4">元字符</h3>

<p>由<code>[]</code>括起来</p>

<pre><code class="language-javascript">//表示范围
[0-9] 表示0-9中任意字符
//表示任意字符
[abc] 表示出现的a、b、c出现哪个都行
//用来排除
[^0-9] 表示出现非数字
</code></pre>

<h3 id="toc_5">量词</h3>

<p>表示出现的个数<br/>
由<code>{}</code>括起来</p>

<pre><code class="language-javascript">{n} 表示出现n次
{n,m} 表示最少n次 最多m次
{n,}    最少n次 最多不限
+  等效于 {1,} 最少1次 做多不限
? 等效于 {0,1} 最少0次 最多1次  可有可无
* 等效于 {0,}  表示可以没有 也可以有无数次
</code></pre>

<h3 id="toc_6">行首 行尾</h3>

<pre><code class="language-javascript">^  当此字符不在元字符中时 表示行首
$   表示行尾
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15468536285872.html">Cookie</a></h1>
			<p class="meta"><time datetime="2019-01-07T17:33:48+08:00" 
			pubdate data-updated="true">01/07/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">特性</h2>

<ol>
<li><p>同一网站(域名)的所有页面共享一套cookie</p></li>
<li><p>cookie的数量和大小是有限的</p></li>
<li><p>cookie是有过期时间的<br/>
如果不主动设置过期时间,cookie会在浏览器关闭就清除</p></li>
</ol>

<h2 id="toc_1">使用</h2>

<p><code>document.cookie</code><br/>
通过赋值和取值来实现cookie操作</p>

<ol>
<li><p>设置cookie</p>
<pre><code class="language-javascript">//此时cookie中会有两天记录 而不会被覆盖
document.cookie = &quot;username=lyy&quot;<br/>
document.cookie = &quot;password=123456&quot;<br/>
//设置有效期限的cookie<br/>
var currentDate = new Date()<br/>
var expiresDate =  currentDate.setDate(currentDate.getDate+100)<br/>
//使用这种格式设置时间 <br/>
document.cookie = &quot;name=fk;expires=&quot;+expiresDate
</code></pre></li>
<li><p>读取cookie<br/>
cookie是用分号空格进行分离的</p></li>
<li><p>删除cookie<br/>
当cookie过期时 删除cookie<br/>
我们通过将cookie的过期时间设置为-1天 即将其设置为已过期 来删除cookie</p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15468326596010.html">BOM</a></h1>
			<p class="meta"><time datetime="2019-01-07T11:44:19+08:00" 
			pubdate data-updated="true">01/07/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">常用windows</h2>

<ul>
<li><p>window.open<br/>
打开新的窗口</p>
<pre><code class="language-javascript">var newWindow = window.open(&#39;about:blank&#39;, &#39;_blank&#39;)
newWindow.document.write(textarea1.value)
</code></pre></li>
<li><p>window.close</p>
<pre><code class="language-javascript">////关闭当前窗口，但是在不同浏览器有一些不同
window.close() 
</code></pre></li>
<li><p>window.navigator<br/>
获取一些浏览器的属性</p>
<pre><code class="language-javascript">//获取浏览器的属性
window.navigator.userAgent
</code></pre></li>
<li><p>window.location</p>
<pre><code class="language-javscript">//获取网页网址 可以通过赋值这个属性来打开新的网页
window.location
</code></pre></li>
<li><p>window.onload</p></li>
<li><p>window.onscroll</p></li>
<li><p>window.onresize <br/>
当窗口尺寸发生变化时</p></li>
</ul>

<h3 id="toc_1">尺寸</h3>

<ol>
<li><p>可视区尺寸<br/>
可视区域尺寸 会随着窗口大小变化而变化</p>
<pre><code class="language-javascript">//高
document.documentElement.clientHeight<br/>
//宽<br/>
document.documentElement.clientWidth
</code></pre></li>
<li><p>滚动高度</p>
<pre><code class="language-javascript">//只支持IE
document.documentElement.scrollTop<br/>
//火狐等浏览器<br/>
document.body.scrollTop<br/>
//兼容版本<br/>
document.documentElement.scrollTop || document.body.scrollTop
</code></pre></li>
<li><p>当前对象尺寸</p>
<pre><code class="language-javascript">//当前对象高度
offsetHeight<br/>
//当前对象宽度<br/>
offsetWidth
</code></pre></li>
</ol>

<h2 id="toc_2">弹框</h2>

<pre><code class="language-javascript">//警告弹框
alert(&quot;&quot;)
//确认弹框 返回boolean
confirm(&quot;&quot;)
//输入框 返回字符串或者null
prompt(&quot;提示&quot;, &quot;默认填充内容&quot;)
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15468310700235.html">JS中系统对象</a></h1>
			<p class="meta"><time datetime="2019-01-07T11:17:50+08:00" 
			pubdate data-updated="true">01/07/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li><p>本地对象<br/>
本地对象常指那些我们平常 常用对象<br/>
<code>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error</code>等</p></li>
<li><p>内置对象<br/>
内置对象指那些系统中内置的对象，即一些概念中的对象例如:<code>Global</code><br/><br/>
内置库中不需要我们实例化对象可以直接使用的:<code>Math</code>等</p></li>
<li><p>宿主对象<br/>
指JS运行环境(常指浏览器)中提供的对象: DOM BOM </p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15459662586152.html">ReactiveObjC</a></h1>
			<p class="meta"><time datetime="2018-12-28T11:04:18+08:00" 
			pubdate data-updated="true">12/28/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">基础知识</h2>

<p>常用的 <code>RACSignal</code>为冷信号  <code>RACSubject</code>为热信号<br/>
冷信号 即为订阅之后才开始执行的消息，订阅几次 就执行几次<br/>
热信号 为创建信号就开始执行的消息 无需订阅</p>

<h2 id="toc_1">常用类</h2>

<h3 id="toc_2">RCASignal信号</h3>

<pre><code class="language-objectivec">//1.创建信号 

//可以在创建信号中立即发送信号 但是不能在block结束返回前销毁该信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [subscriber sendNext:@&quot;发送的消息内容&quot;];
        return nil;
}];
//立即发送给定的错误信息
NSError *error = [[NSError alloc] init];
[RACSignal error:error];
//返回一个信号 该信号立即发送给定值 然后 complete
[RACSignal return:@&quot;value&quot;];
//返回信号 该信号直接 complete
[RACSignal empty];

//2.信号处理

//2.1 concat 返回一个信号signal3 当signal1 complete时订阅信号就signal2信号变化 我们可以通过订阅 signal3 来收到信号两个信号的值变化
RACSignal *signal3 = [signal1 concat:signal2]

//2.2  flattenMap 串联信号 当收到第一个消息的值变化时 开始执行第二个信号 此时我们订阅信号2  只会收到信号2值改变信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [subscriber sendNext:@&quot;发送的消息内容&quot;];
        });
        return nil;
    }];
RACSignal *signal2 = [signal flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) {
    return  [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [subscriber sendNext:@&quot;signal2 发送的消息内容&quot;];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [subscriber sendNext:@&quot;signal2 3秒后发送的消息内容&quot;];
        });
        return nil;
    }];
}];

//2.2 map 对信号1中收到的值进行处理返回信号2 
RACSignal *signal2 = [signal map:^id _Nullable(NSString *  _Nullable value) {
    return [value substringFromIndex:2];
}];

//2.3 filter 过滤信号值
RACSignal *signal2 = [signal filter:^BOOL(NSString *  _Nullable value) {
    return YES;
}];

//2.4 ignore 忽略特定值的信号
RACSignal *signal2 = [signal ignore:@&quot;发送的消&quot;];

//2.5 startwith: 将这个值 拼接到信号值开头 返回新的信号 
RACSignal *signal2 = [signal startWith:@&quot;start with发送的消息内容&quot;];

//2.6 skip: 忽略开始的count个信号值改变
RACSignal *signal2 = [signal skip:1];

//2.7 take: 返回一个只接收前count个信号的信号值改变  其后发送的信号会失败
RACSignal *signal2 = [signal take:2];

//2.8  scanWithStart: reduce: 遍历信号1值变化 block中next即为信号1的信号值  
//      running为累计值 初始为start值 
RACSignal *signal2 = [signal scanWithStart:@&quot;1&quot; reduce:^NSString * _Nullable(NSString *  _Nullable running, NSString *  _Nullable next) {
    running = [[NSMutableString stringWithFormat:@&quot;%@%@&quot;, running, next] copy];
    return running;
}];

//2.9 takeUntilBlock: 忽略这符合条件的信号以及之后的信号
//     takeWhileBlock: 返回符合条件的信号值
//      skipUntilBlock: 只返回符合条件以及之后的信号
//      skipWhileBlock: 忽略符合条件的信号
RACSignal *signal2 = [signal takeUntilBlock:^BOOL(NSString *  _Nullable x) {
    return [x hasPrefix:@&quot;3秒&quot;];
}];

//2.10 distinctUntilChanged 只返回值不一样的信号
RACSignal *signal2 = [signal distinctUntilChanged];


//3. 订阅

//subscribeNext： 订阅信号值改变  error 订阅错误信号 completed 订阅完成信号 
RACDisposable *disposable = [signal3 subscribeNext:^(NSString *  _Nullable x) {
    NSLog(@&quot;signal3收到订阅值:%@&quot;, x);
} error:^(NSError * _Nullable error) {
    NSLog(@&quot;signal3收到错误订阅:%@,&quot; error);
} completed:^{
    NSLog(@&quot;signal3收到成功订阅;&quot;);
}];

//取消订阅
[disposable dispose];


</code></pre>

<h3 id="toc_3">RACSubject信号</h3>

<pre><code class="language-objectivec">//RACSubject 继承于 RACSignal 使用这个对象 可以直接发送和接收信号值改变  而不需要关心 创建信号和注销订阅问题
RACSubject *subject = [RACSubject subject];

[subject subscribeNext:^(NSString *x) {
    NSLog(@&quot;接受新值%@&quot;, x);
} completed:^{
    NSLog(@&quot;接受完成情况&quot;);
}];

[subject sendNext:@&quot;新的值1&quot;];

</code></pre>

<h3 id="toc_4">RACTuple 元组</h3>

<p>元组功能</p>

<h3 id="toc_5">NSArray NSDictionary 集合操作</h3>

<p>RAC扩展了NSArray 和  NSDictionary 拥有 <code>rac_sequence</code>(<code>RACSequence</code>类)属性</p>

<h3 id="toc_6">RACSequence</h3>

<pre><code class="language-objectivec">    //1. 获取一个 发送集合中值改变的信号
    arr.rac_sequence.signal
    //2. 用信号来遍历集合
    [arr.rac_sequence.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;%@&quot;, x);
    }];
    //3. head
    NSLog(@&quot;第一个元素%@&quot;, arr.rac_sequence.head);
    //4. tail
    NSLog(@&quot;除了第一个元素外的所有元素集合%@&quot;, arr.rac_sequence.tail);
    
    //5. 从左侧开始遍历 start: 累计的初始值 accumulator: 累计值 value:当前值 count: 最终值
    NSNumber *count = [intArr.rac_sequence foldLeftWithStart:@(10) reduce:^NSNumber* (NSNumber *accumulator, NSNumber *value) {
        NSLog(@&quot;%@--- %@&quot;, accumulator, value);

        return @(accumulator.integerValue + value.integerValue);
    }];
    NSLog(@&quot;%@&quot;, count);
    
    //6. 同样可以从右边开始遍历
    
    //7. 遍历集合 判断是否存在符合条件 当遇到block返回YES 返回YES不再执行
    BOOL exist = [intArr.rac_sequence any:^BOOL(NSNumber *value) {
        return value.integerValue == 2;
    }];
    NSLog(@&quot;%@&quot;, exist ? @&quot;存在&quot; : @&quot;不存在&quot;); //存在
    //8. 遍历集合 判断是否所有元素都满足条件
    BOOL pass = [intArr.rac_sequence all:^BOOL(id  _Nullable value) {
        return [value isKindOfClass:[NSNumber class]];
    }];
    NSLog(@&quot;%@&quot;, pass ? @&quot;通过&quot; : @&quot;不通过&quot;); //存在
    //9. 遍历集合找到第一个符合条件的元素
    id obj = [intArr.rac_sequence objectPassingTest:^BOOL(id  _Nullable value) {
        if ([value isKindOfClass:[NSNumber class]]) {
            NSNumber *value1 = (NSNumber *)value;
            if (value1.integerValue % 3 == 0) {
                return YES;
            }
        }
        return NO;
    }];
    NSLog(@&quot;第一个通过测试的是%@&quot;, obj); //9
    
    //10. 用户动态生成sequenceh headblock和tailblock只会执行一次
    //是惰性加载生成的
    //必须保证headblock和tailblock是线程安全的
    RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @(11);
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence sequenceWithHeadBlock:^id _Nullable{
            return @(11);
        } tailBlock:^RACSequence * _Nonnull{
            return [RACSequence sequenceWithHeadBlock:^id _Nullable{
                return @(22);
            } tailBlock:^RACSequence * _Nonnull{
                return @[@(33)].rac_sequence;
            }];
        }];
    }];
    
    [sequence.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;%@&quot;, x);
    }];
</code></pre>

<h3 id="toc_7">UI操作</h3>

<h4 id="toc_8">UIControl</h4>

<pre><code class="language-objectivec"> RACSignal *signal = [self.btn rac_signalForControlEvents:UIControlEventTouchUpInside];
[signal subscribeNext:^(UIButton *  _Nullable x) {
    NSLog(@&quot;&quot;);
}];
</code></pre>

<h4 id="toc_9">UIButton</h4>

<pre><code class="language-objectivec">//当 按钮被点击时 执行 command中的block
self.btn.rac_command 
</code></pre>

<h4 id="toc_10">RACCommand</h4>

<pre><code class="language-objectivec">//初始化command 用一个信号
self.btn.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {
        return [RACSignal empty];
    }];
    
//executionSignals  属性为 command执行时的信号
[self.btn.rac_command.executionSignals subscribeNext:^(RACSignal&lt;id&gt; * _Nullable x) {
    NSLog(@&quot;信号值执行了&quot;);
}];
    
</code></pre>

<h4 id="toc_11">UITextfield</h4>

<pre><code class="language-objectivec">//rac_textSignal 获取textfield内容改变信号
[self.textfield.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
    NSLog(@&quot;输出内容%@&quot;, x);
}];
</code></pre>

<h3 id="toc_12">NSNotification</h3>

<pre><code class="language-objectivec">//通知事件 无需主动移除通知
[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;&quot; object:nil] subscribeNext:^(NSNotification * _Nullable x) {
    
}];
</code></pre>

<h3 id="toc_13">Delegate</h3>

<pre><code class="language-objectivec">[[self.view rac_signalForSelector:@selector(nameBtnDidClick:)] subscribeNext:^(RACTuple * _Nullable x) {
    
}];
</code></pre>

<h3 id="toc_14">KVO</h3>

<pre><code class="language-objectivec">//这样设置KVO 无需主动移除
//监听btn frame变化 
[[self.btn rac_valuesForKeyPath:@&quot;frame&quot; observer:self] subscribeNext:^(id  _Nullable x) {
        
}];

//使用宏定义快捷设置KVO （推荐）
[RACObserve(self.btn, frame) subscribeNext:^(id  _Nullable x) {
    
}];

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15450317285396.html">ReactiveObjC</a></h1>
			<p class="meta"><time datetime="2018-12-17T15:28:48+08:00" 
			pubdate data-updated="true">12/17/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>本文内容来自github <a href="https://github.com/ReactiveCocoa/ReactiveObjC">ReactiveObjC的官方文档</a></p>
</blockquote>

<h2 id="toc_0">介绍</h2>

<p>ReactiveObjC 是一个函数相应式编程的OC框架，为我们提供了组合、转换流的api</p>

<p>RAC没有使用可修改或可替换的变量，而是提供了信号(<code>RACSignal</code>)来捕获当前或者未来的信号，我们通过串联、绑定、响应信号，就可以无需持续的观察和更新值来检测变化</p>

<p>例如: 为了检测一个textField的text的最新内容,我们不需要每秒钟就去获取其值的变化,使用RAC更像KVO可以实时获取到其内容变化,与KVO不同的时 我们使用<code>block</code>而不是使用<code>-observeValueForKeyPath:ofObject:change:context:</code></p>

<p>信号也可以帮助我们进行异步操作,就像对未来结果的许诺,极大的帮助我们简化网络请求等异步操作代码</p>

<p><strong>RAC主要提供了一个统一的方法 来处理异步行为，包括delegate、kvo、target-action、notification、block</strong></p>

<ol>
<li><p>监测属性值变化</p>
<pre><code class="language-objectivec">类似kvo
//检测self.username属性变化<br/>
//RACObserve(TARGET, KEYPATH)是一个创建检测值变化的信号<br/>
//subscribeNext 当检测的信号变化时 就会执行这个信号<br/>
[RACObserve(self, username) subscribeNext:^(NSString *newName) {<br/>
       NSLog(@&quot;%@&quot;, newName);<br/>
}];
</code></pre></li>
<li><p>监测过滤出来的部分信号值<br/>
与kvo不同的是，我们可以串联、操作这些信号</p>
<pre><code class="language-objectivec">//过滤 信号中以&quot;j&quot;开头的信号值的变化
[[RACObserve(self, username)<br/>
filter:^(NSString *newName) {<br/>
    return [newName hasPrefix:@&quot;j&quot;];<br/>
}]<br/>
subscribeNext:^(NSString *newName) {<br/>
    NSLog(@&quot;%@&quot;, newName);<br/>
}];
</code></pre></li>
<li><p>通过RAC我们可以很方便的通过信号监测变化,而不需要通过观察和设置其它属性</p>
<pre><code class="language-objectivec">//combineLatest: reduce:方法 合并一组信号,当其中任意一个信号的最新值变化时,会执行该block 并返回新的值
RAC(self, createEnabled) = [RACSignal<br/>
combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ]<br/>
reduce:^(NSString *password, NSString *passwordConfirm) {<br/>
    return @([passwordConfirm isEqualToString:password]);<br/>
}];
</code></pre></li>
<li><p>信号不止类似kvo可以监测属性，还可以监测其它任何随时间变化的值或者流</p>
<pre><code class="language-objectivec">//RACCommand 创建一个与UI有关的信号 此处是按钮点击信号,当按钮被点击时执行该block
//rac_command是按钮类别的属性，当按钮被点击自动发送<br/>
self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {<br/>
NSLog(@&quot;button was pressed!&quot;);<br/>
return [RACSignal empty];<br/>
}];
</code></pre></li>
<li><p>RAC表示网络操作</p>
<pre><code class="language-objectivec">//创建一个信号 当self.loginCommand执行其block
self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {<br/>
    return [client logIn];<br/>
}];<br/>
//executionSignals 返回上面RACComond中block返回的信号的信号,即当上面block返回时 会触发该信号 并可以监测block返回的信号的变化<br/>
[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {<br/>
    // Log a message whenever we log in successfully.<br/>
    [loginSignal subscribeCompleted:^{<br/>
        NSLog(@&quot;Logged in successfully!&quot;);<br/>
    }];<br/>
}];<br/>
//当按钮点击时 执行该self.loginCommand<br/>
self.loginButton.rac_command = self.loginCommand;
</code></pre></li>
<li><p>表示异步操作的信号间可以链接来表示更加复杂的行为(在一组操作完成后开始另外一个操作)</p>
<pre><code class="language-objectivec">//merge: 合并两个信号 返回一个新的信号
//subscribeCompleted: 订阅返回完成的信号<br/>
[[RACSignal merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]<br/>
subscribeCompleted:^{<br/>
    NSLog(@&quot;They&#39;re both done!&quot;);<br/>
}];
</code></pre></li>
<li><p>信号可以串联起来 避免使用block嵌套来表示依赖</p>
<pre><code class="language-objectivec">//
[[[[client<br/>
    logInUser]<br/>
    flattenMap:^(User *user) {<br/>
        // Return a signal that loads cached messages for the user.<br/>
        return [client loadCachedMessagesForUser:user];<br/>
    }]<br/>
    flattenMap:^(NSArray *messages) {<br/>
        // Return a signal that fetches any remaining messages.<br/>
        return [client fetchMessagesAfterMessage:messages.lastObject];<br/>
    }]<br/>
    subscribeNext:^(NSArray *newMessages) {<br/>
        NSLog(@&quot;New messages: %@&quot;, newMessages);<br/>
    } completed:^{<br/>
        NSLog(@&quot;Fetched all messages.&quot;);<br/>
    }];
</code></pre></li>
<li><p>获取异步操作的结果 </p>
<pre><code class="language-objectivec">//当异步图片下载完成后赋值到图片上
//deliverOn: 创建信号并执行在其他队列线程  [RACScheduler scheduler] background线程  RACScheduler.mainThreadScheduler]主线程<br/>
RAC(self.imageView, image) = [[[[client<br/>
fetchUserWithUsername:@&quot;joshaber&quot;]<br/>
deliverOn:[RACScheduler scheduler]]<br/>
map:^(User *user) {<br/>
    // Download the avatar (this is done on a background queue).<br/>
    return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];<br/>
}]<br/>
// Now the assignment will be done on the main thread.<br/>
deliverOn:RACScheduler.mainThreadScheduler];
</code></pre></li>
</ol>

<h2 id="toc_1">示例</h2>

<h3 id="toc_2">1. 处理多来源的异步操作或事件状态</h3>

<p>不使用RAC的情况</p>

<p>页面中的登录按钮 只有在<code>usernameTextField</code> <code>passwordTextField</code> 不为空 并且当前不在登录状态 才可以点击</p>

<pre><code class="language-objectivec">static void *ObservationContext = &amp;ObservationContext;

- (void)viewDidLoad {
    [super viewDidLoad];

    [LoginManager.sharedManager addObserver:self forKeyPath:@&quot;loggingIn&quot; options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext];
    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];

    [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];
}

- (void)dealloc {
    [LoginManager.sharedManager removeObserver:self forKeyPath:@&quot;loggingIn&quot; context:ObservationContext];
    [NSNotificationCenter.defaultCenter removeObserver:self];
}

- (void)updateLogInButton {
    BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0;
    BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn;
    self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;
}

- (IBAction)logInPressed:(UIButton *)sender {
    [[LoginManager sharedManager]
        logInWithUsername:self.usernameTextField.text
        p**assword:self.passwordTextField.text
        success:^{
            self.loggedIn = YES;
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
}

- (void)loggedOut:(NSNotification *)notification {
    self.loggedIn = NO;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if (context == ObservationContext) {
        [self updateLogInButton];
    } else {
        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
    }
}
</code></pre>

<p>使用RAC来写的话</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    @weakify(self);

    RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue);
        }];

    [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {
        @strongify(self);

        RACSignal *loginSignal = [LoginManager.sharedManager
            logInWithUsername:self.usernameTextField.text
            password:self.passwordTextField.text];

            [loginSignal subscribeError:^(NSError *error) {
                @strongify(self);
                [self presentError:error];
            } completed:^{
                @strongify(self);
                self.loggedIn = YES;
            }];
    }];

    RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter
        rac_addObserverForName:UserDidLogOutNotification object:nil]
        mapReplace:@NO];
}
</code></pre>

<h3 id="toc_3">2.串联异步操作的依赖</h3>

<pre><code class="language-objectivec">//logInWithSuccess 登录成功 -&gt; loadCachedMessagesWithSuccess 加载本地数据   -&gt;  fetchMessagesAfterMessage 请求本地为缓存的最新的数据

//不使用色RAC 使用block嵌套
[client logInWithSuccess:^{
    [client loadCachedMessagesWithSuccess:^(NSArray *messages) {
        [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {
            NSLog(@&quot;Fetched all messages.&quot;);
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
    } failure:^(NSError *error) {
        [self presentError:error];
    }];
} failure:^(NSError *error) {
    [self presentError:error];
}];

//RAC版本
[[[[client logIn]
    then:^{
        return [client loadCachedMessages];
    }]
    flattenMap:^(NSArray *messages) {
        return [client fetchMessagesAfterMessage:messages.lastObject];
    }]
    subscribeError:^(NSError *error) {
        [self presentError:error];
    } completed:^{
        NSLog(@&quot;Fetched all messages.&quot;);
    }];
</code></pre>

<h3 id="toc_4">3.用RAC实现 OC中 集合没有的 map、filter、fold/reduce等方法</h3>

<pre><code class="language-objectivec">//获取数组中字符串长度大于2并且拼接字符串`foobar`
NSMutableArray *results = [NSMutableArray array];
for (NSString *str in strings) {
    if (str.length &lt; 2) {
        continue;
    }

    NSString *newString = [str stringByAppendingString:@&quot;foobar&quot;];
    [results addObject:newString];
}


RACSequence *results = [[strings.rac_sequence
    filter:^ BOOL (NSString *str) {
        return str.length &gt;= 2;
    }]
    map:^(NSString *str) {
        return [str stringByAppendingString:@&quot;foobar&quot;];
    }];
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15446921413334.html">ReactiveCocoa 版本</a></h1>
			<p class="meta"><time datetime="2018-12-13T17:09:01+08:00" 
			pubdate data-updated="true">12/13/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>reactiveCocoa 分为两个版本 </p>

<ol>
<li>OC版本的 <strong>ReactiveObjC</strong></li>
<li>swift版本的 <strong>ReactiveSwift</strong></li>
</ol>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_12.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_10.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>