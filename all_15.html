
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15317258769792.html">Python基础</a></h1>
			<p class="meta"><time datetime="2018-07-16T15:24:36+08:00" 
			pubdate data-updated="true">07/16/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">数据类型</h2>

<h3 id="toc_1">字符串</h3>

<p><strong>字符串是不可变的</strong></p>

<ol>
<li>用<code>&#39;</code>或者<code>&quot;</code>括起来的文本</li>
<li>可以通过 <code>\</code>转义字符来在文本中转义,进行<code>\n</code>换行 <code>\t</code>制表</li>
<li>可以通过在文本前加<code>r</code>表示文本不转义</li>
<li>用三个单引号<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的文本可以在内部直接换行而不需要<code>\n</code></li>
</ol>

<pre><code class="language-python">print(&quot;hello, world&quot;)
print(&quot;I\&#39;m OK!&quot;)
print(&quot;\t文本&quot;)
print(r&#39;&#39;&#39;\\line1
line2
line3aaaa&#39;&#39;&#39;)
</code></pre>

<blockquote>
<p>python中的单引号和双引号的用法都是一样的，只是如果字符串中有相同字符时需要转义</p>
</blockquote>

<h3 id="toc_2">布尔</h3>

<p><code>True</code>  真<br/>
<code>False</code> 假</p>

<p>布尔运算<br/>
<code>and</code>  与<br/>
<code>or</code>   或<br/>
<code>not</code>  非</p>

<h3 id="toc_3">空值</h3>

<p><code>None</code>表示空值</p>

<h2 id="toc_4">变量</h2>

<p>定义变量<br/>
<code>a=1</code></p>

<blockquote>
<p>python是动态语言 因此可以将不同类型的变量赋值给同一变量</p>
</blockquote>

<pre><code class="language-python">a=False
a=&quot;aa&quot;
print(a)
</code></pre>

<h2 id="toc_5">常量</h2>

<p>在python中常用全大写的变量名来表示常量</p>

<blockquote>
<p>python中除法<code>/</code>的结果为浮点数(即使整除),  <code>//</code>为地板除，两个除法的结果仍为整数</p>
</blockquote>

<pre><code class="language-python">print(10/3)   3.3333333333333335
print(10//3)   3
print(9/3)    3.0
print(9//3)   3
print(12.7//5.1)   2.0
print(1.2/3)    0.39999999999999997
</code></pre>

<h2 id="toc_6">编码</h2>

<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000</a></p>

<p>在python3中字符串以Unicode编码，</p>

<p>可以通过<code>ord()</code>函数获取字符的整数表示<br/>
可以通过<code>chr()</code>函数将编码转为对应字符</p>

<pre><code class="language-python">print(ord(&quot;😱&quot;)) //128561
print(chr(128561)) //😱
//当知道字符的整数编码,可以用16进制来写str
print(&#39;\u4e2d\u6587&#39;) //中文
</code></pre>

<p>Python对bytes类型的数据用带<code>b</code>前缀的单引号或双引号表示:</p>

<pre><code class="language-python">x = b&#39;ABC&#39;
</code></pre>

<blockquote>
<p>python的字符串<code>str</code>在内存中以Unicode表示,当在网上传输或者保存磁盘时,需要将其转为以字节为单位的<code>bytes</code>使用<code>encode()</code>,而当从网络或磁盘读取数据读到的是<code>bytes</code>,将butes转为str，使用<code>decode()</code>方法</p>
</blockquote>

<p>可以通过<code>encode()</code>方法将<code>str</code>编码为指定的<code>bytes</code></p>

<pre><code class="language-python">print(&quot;中文&quot;.encode(&quot;utf-8&quot;))  # b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
print(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;))  #中文

#如果bytes中存在一小部分无效字节,可以添加errors=&#39;ignore&#39;来忽略错误的字节
b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)  #中
</code></pre>

<p><code>len()</code>函数用来计算<code>str</code>字符串的字符数,对于<code>bytes</code>则计算其字节数:</p>

<pre><code class="language-python">&gt;&gt;&gt; len(b&#39;ABC&#39;)
3
&gt;&gt;&gt; len(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
6
&gt;&gt;&gt; len(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
</code></pre>

<blockquote>
<p>为避免乱码,请坚持使用UTF-8编码进行转换,因此对于python的源码文件,指定其为UTF-8编码保存,并通过<code># -*- coding: utf-8 -*-</code>告诉编译器按照UTF-8读取源码</p>
</blockquote>

<p><strong><code># -*- coding: utf-8 -*-</code></strong></p>

<h2 id="toc_7">格式化</h2>

<pre><code class="language-python"># 格式化
print(&quot;这是字符串的%s格式化&quot; % (&quot;栗豫塬&quot;))
print(&quot;my name is %s age is %d height %.2f&quot; % (&quot;栗豫塬&quot;, 24, 17.0))
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15312926184354.html">Stack Navigation</a></h1>
			<p class="meta"><time datetime="2018-07-11T15:03:38+08:00" 
			pubdate data-updated="true">07/11/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">navigationOptions</h3>

<p>title: 导航栏的标题</p>

<p>header: 导航栏设置对象</p>

<p>headerTitle: 导航栏的标题, 可以是字符串也可以是个组件<br/>
headerBackTitle: 左上角的返回键文字, 默认是上一个页面的title，设置这个属性会覆盖掉title的值<br/>
headerRight: 导航栏右按钮<br/>
headerLeft: 导航栏左按钮<br/>
headerStyle: 导航栏的style<br/>
headerTitleStyle: 导航栏的title的style<br/>
headerTintColor: 返回按钮的颜色<br/>
headerPressColorAndroid ：按压返回按钮显示的颜色 安卓系统 &gt;= 5.0才有效。<br/>
gesturesEnabled ：是否允许右滑返回，在iOS上默认为true，在Android上默认为false</p>

<h3 id="toc_1">StackNavigatorConfig</h3>

<ul>
<li>initialRouteName: 设置默认的页面组件，必须是上面已注册的页面组件</li>
<li>initialRouteParams: 初始路由的参数</li>
<li>navigationOptions: 屏幕导航的默认选项</li>
<li>paths: RouteConfigs里面路径设置的映射</li>
<li>mode: 页面切换模式:
<ul>
<li>card: 普通app常用的左右切换</li>
<li>modal: 上下切换</li>
</ul></li>
<li>headerMode: 导航栏的显示模式:
<ul>
<li>float: 无透明效果, 默认</li>
<li>screen: 有渐变透明效果, 如微信QQ的一样</li>
<li>none: 隐藏导航栏</li>
</ul></li>
<li>cardStyle: 样式</li>
<li>onTransitionStart: 页面切换开始时的回调函数</li>
<li>onTransitionEnd: 页面切换结束时的回调函数</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15304988629042.html">混合开发(OC)</a></h1>
			<p class="meta"><time datetime="2018-07-02T10:34:22+08:00" 
			pubdate data-updated="true">07/02/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">声明类 实现协议</h2>

<p>需要实现了<code>RCTBridgeModule</code>协议类,<br/>
导入<code>#import &lt;React/RCTBridgeModule.h&gt;</code></p>

<p>实现协议需要包含这个宏，可以添加参数作为访问此模块的名字 通常不指定默认使用类名<br/>
<code>RCT_EXPORT_MODULE();</code></p>

<h2 id="toc_1">声明原生方法给js调用</h2>

<p>声明需要提供给<code>React Native</code>组件调用的方法，即导出的方法<br/>
<code>RCT_EXPORT_METHOD()</code></p>

<pre><code class="language-javascript">//在OC中
RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
{
  RCTLogInfo(@&quot;Pretending to create an event %@ at %@&quot;, name, location);
}
//在js中这样调用
import { NativeModules } from &#39;react-native&#39;;
var CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent(&#39;Birthday Party&#39;, &#39;4 Privet Drive, Surrey&#39;);
</code></pre>

<p>通常我们将多个参数使用一个字典进行存放</p>

<pre><code class="language-javascript">#import &lt;React/RCTConvert.h&gt;

RCT_EXPORT_METHOD(addEvent:(NSString *)name details:(NSDictionary *)details)
{
  NSString *location = [RCTConvert NSString:details[@&quot;location&quot;]];
  NSDate *time = [RCTConvert NSDate:details[@&quot;time&quot;]];
  ...
}

CalendarManager.addEvent(&#39;Birthday Party&#39;, {
  location: &#39;4 Privet Drive, Surrey&#39;,
  time: date.toTime(),
  description: &#39;...&#39;
})
</code></pre>

<h3 id="toc_2">声明回调函数</h3>

<pre><code class="language-javascript">
//原生
//原生模块通常只应调用回调函数一次。但是，它可以保存callback并在将来调用
RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
{
  NSArray *events = ...
  callback(@[[NSNull null], events]);
}

//js调用
CalendarManager.findEvents((error, events) =&gt; {
  if (error) {
    console.error(error);
  } else {
    this.setState({events: events});
  }
})

//采用promise

//原生
RCT_REMAP_METHOD(findEvents,
                 resolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject)
{
  NSArray *events = ...
  if (events) {
    resolve(events);
  } else {
    reject(error);
  }
}
//js调用
async function updateEvents() {
  try {
    var events = await CalendarManager.findEvents();
    this.setState({ events });
  } catch (e) {
    console.error(e);
  }
}

updateEvents();

</code></pre>

<h2 id="toc_3">多线程</h2>

<p>生模块不应对自己被调用时所处的线程做任何假设。React Native在一个独立的串行GCD队列中调用原生模块的方法，但这属于实现的细节，并且可能会在将来的版本中改变。通过实现方法<code>- (dispatch_queue_t)methodQueue</code>，原生模块可以指定自己想在哪个队列中被执行。</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code></pre>

<p>如果一个操作需要花费很长时间，原生模块不应该阻塞住，而是应当声明一个用于执行操作的独立队列</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_queue_create(&quot;com.facebook.React.AsyncLocalStorageQueue&quot;, DISPATCH_QUEUE_SERIAL);
}
</code></pre>

<blockquote>
<p>在模块之间共享分发队列<br/>
methodQueue方法会在模块被初始化的时候被执行一次，然后会被React Native的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p>
</blockquote>

<h2 id="toc_4">导出常量</h2>

<pre><code class="language-objectivec">- (NSDictionary *)constantsToExport
{
  return @{ @&quot;firstDayOfTheWeek&quot;: @&quot;Monday&quot; };
}
</code></pre>

<h2 id="toc_5">给JS发送事件</h2>

<p>继承<code>RCTEventEmitter</code>，实现<code>suppportEvents</code>方法并调用<code>self sendEventWithName:</code></p>

<pre><code class="language-objectivec">#import &lt;React/RCTEventEmitter.h&gt;

- (NSArray&lt;NSString *&gt; *)supportedEvents
{
  return @[@&quot;EventReminder&quot;];
}

- (void)calendarEventReminderReceived:(NSNotification *)notification
{
  NSString *eventName = notification.userInfo[@&quot;name&quot;];
  [self sendEventWithName:@&quot;EventReminder&quot; body:@{@&quot;name&quot;: eventName}];
}

</code></pre>

<p>JavaScript代码可以创建一个包含你的模块的NativeEventEmitter实例来订阅这些事件。</p>

<pre><code class="language-javascript">import { NativeEventEmitter, NativeModules } from &#39;react-native&#39;;
const { CalendarManager } = NativeModules;

const calendarManagerEmitter = new NativeEventEmitter(CalendarManager);

const subscription = calendarManagerEmitter.addListener(
  &#39;EventReminder&#39;,
  (reminder) =&gt; console.log(reminder.name)
);
...
// 别忘了取消订阅，通常在componentWillUnmount生命周期方法中实现。
subscription.remove();
</code></pre>

<h2 id="toc_6">原生UI</h2>

<p>原生视图需要被一个RCTViewManager来管理和创建。本质上都是单例 - React Native只会为每个管理器创建一个实例。它们创建原生的视图并提供给<code>RCTUIManager</code>，<code>RCTUIManager</code>则会反过来委托它们在需要的时候去设置和更新视图的属性。RCTViewManager还会代理视图的所有委托，并给JavaScript发回对应的事件</p>

<ol>
<li>创建<code>RCTViewManager</code>的子类</li>
<li>添加<code>RCT_EXPORT_MODULE()</code>标记宏</li>
<li><p>实现<code>-(UIView *)view</code>方法</p></li>
<li><p>在js代码中将视图变为可用的React组件</p></li>
</ol>

<pre><code class="language-javascript">// MapView.js
var { requireNativeComponent } = require(&#39;react-native&#39;);

// requireNativeComponent 自动把这个组件提供给 &quot;RNTMapManager&quot;
module.exports = requireNativeComponent(&#39;RNTMap&#39;, null);
</code></pre>

<h3 id="toc_7">声明属性</h3>

<pre><code class="language-objectivec">//声明属性
RCT_EXPORT_VIEW_PROPERTY(pitchEnabled, BOOL)

//设置属性之后，在js中可以直接设置
&lt;MapView pitchEnabled={false} /&gt;

//比较复杂的属性
RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RNTMap)
{
  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15293961047296.html">组件属性一</a></h1>
			<p class="meta"><time datetime="2018-06-19T16:15:04+08:00" 
			pubdate data-updated="true">06/19/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">View</h2>

<h3 id="toc_1">颜色与边框</h3>

<ol>
<li>backgroundColor: 背景颜色</li>
<li>opacity: 0~1透明度</li>
<li><p>borderStyle: 边框风格</p>
<ul>
<li>solid: default 实线边框</li>
<li>dotted: 点状边框</li>
<li>dashed: 虚线边框</li>
</ul></li>
<li><p>borderColor: 边框颜色,可以单独定义上下左右</p></li>
<li><p>borderRadius: 定义圆角边框,可单独定义四个角</p></li>
</ol>

<blockquote>
<p>大部分组件继承了View的属性</p>
</blockquote>

<h3 id="toc_2">视觉效果</h3>

<h4 id="toc_3">阴影</h4>

<ol>
<li>shadowColor</li>
<li>shadowOffset</li>
<li>shadowOpacity</li>
<li>shadowRadius</li>
</ol>

<h4 id="toc_4">overflow</h4>

<p>取值为 visible和hidden(默认),定义子组件产出父组件部分的是否显示，当设置为visible时，仅对ios平台有效,显示超出父组件部分</p>

<h4 id="toc_5">elevation</h4>

<p>Android平台特有效果,在组件周围渲染阴影</p>

<h3 id="toc_6">变形</h3>

<p>利用<code>transform</code>设置组件的变形,包括<code>translate</code>平移,<code>scale</code>缩放,<code>rotate</code>旋转,<code>skew</code>倾斜</p>

<pre><code class="language-javascript">const styles = StyleSheet.create({
    view1Style: {
        ....
        transform: [{scale:2}, {rotateZ:&quot;45deg&quot;}]
    }
})
//Xdeg 表示角度 取值0-360
</code></pre>

<h3 id="toc_7">回调函数</h3>

<p>回调函数命名 onB 即B事件发生的回调函数</p>

<h4 id="toc_8">onLayOut</h4>

<p>当View组件被加载或者改变布局时</p>

<h4 id="toc_9">onTouchStart、onTouchMove、onTouchEnd</h4>

<p>开始触摸事件、触摸点移动事件、触摸结束事件<br/>
三个回调函数带一个event参数,</p>

<pre><code class="language-javascript">//Event结构有用对象
{
 timeStamp: aNumber, //时间戳
 nativeEvent: {
    locationX: aNumber,
    locationY: aNumber,
 }
}
</code></pre>

<pre><code class="language-javascript">//示例 demo
constructor(props) {
        super(props)
        this._onTouchStart = this._onTouchStart.bind(this)
    }

    _onTouchStart(event) {
        console.log( event.nativeEvent.locationX)
    }

    render() {
        return(
            &lt;View style={styles.containStyle}&gt;
                &lt;View style={styles.view1Style} onTouchStart={this._onTouchStart}&gt;

                &lt;/View&gt;
            &lt;/View&gt;
        )
    }
</code></pre>

<h4 id="toc_10">removeClippedSubviews</h4>

<p>布尔属性，与性能有关的，属性为true将允许释放不在显示范围内的子组件，需要将overflow设置为hidden才会生效</p>

<h3 id="toc_11">onLayOut</h3>

<p>应用通过<code>Dimension</code>获取屏幕宽高，Dimensions.get(&#39;window&#39;).width/height,获取到的宽和高是实时屏幕的宽和高,当横置时宽大于高</p>

<h3 id="toc_12">pointEvents</h3>

<p>在RN中 触摸事件总是传递给最上层的组件，当被遮盖的组件需要向银行触摸事件，就需要从View继承的<code>pointEvents</code></p>

<p>可以取值为<code>none</code> <code>box-none</code> <code>box-only</code> <code>auto</code></p>

<p><strong>none:</strong> 发生在本组件和子组件的触摸事件交给本组件的父组件处理<br/>
<strong>box-none:</strong> 本组件显示范围内，非子组件显示范围内的时间交给本组件父组件处理,子组件显示范围交给子组件处理<br/>
<strong>box-only:</strong> 本组件显示范围内的所有触摸事件都交给本组件处理<br/>
<strong>auto:</strong> 视组件不同而不同 不是所有组件都支持box-none和box-only</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15290351401483.html">补充</a></h1>
			<p class="meta"><time datetime="2018-06-15T11:59:00+08:00" 
			pubdate data-updated="true">06/15/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">当安装了第三方库之后 需要重新yarn安装依赖</h3>

<p><code>yarn install</code></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15289781671435.html">对象</a></h1>
			<p class="meta"><time datetime="2018-06-14T20:09:27+08:00" 
			pubdate data-updated="true">06/14/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">JS创建对象以及对象属性的几种方式</h2>

<h3 id="toc_1">1.创建直接的对象</h3>

<pre><code class="language-javascript">person=new Object();
person.firstname=&quot;Bill&quot;;
person.lastname=&quot;Gates&quot;;
person.age=56;
person.eyecolor=&quot;blue&quot;;
</code></pre>

<h3 id="toc_2">2.替代语法(使用对象 literals)</h3>

<pre><code class="language-javascript">person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,age:50,eyecolor:&quot;blue&quot;};

</code></pre>

<h3 id="toc_3">3.函数对象构造器</h3>

<pre><code class="language-javascript">function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}
</code></pre>

<h3 id="toc_4">4.使用class</h3>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15289587744708.html">导航页面</a></h1>
			<p class="meta"><time datetime="2018-06-14T14:46:14+08:00" 
			pubdate data-updated="true">06/14/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">适配不同平台</h3>

<ol>
<li><p>文件适配</p>
<p>通过命名文件后缀为 <code>.android.js</code> 和 <code>.ios.js</code>文件 RN会根据不同平台加载不同文件</p></li>
<li><p>平台检测</p></li>
</ol>

<pre><code class="language-javascript">import {
    Platform

} from &#39;react-native&#39;
if(Platform.OS === &quot;android&quot;) {
//安卓代码
} else  {
//iOS代码
}
</code></pre>

<h3 id="toc_1">监测android物理后退按钮时间</h3>

<pre><code class="language-javascript">//对于android 点击后退按钮 如果当前有后退视图就后退 并返回true 否则返回false标识后退事件没被处理 传递给操作系统 就退出应用
    handleBackAndroid() {
        if (this.navigator.getCurrentRoutes().length &gt; 1) {
            this.navigator.pop()
            return true
        } else  {
            return false
        }
    }
    //组件挂接到当前页面
    componentDidMount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.addListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }
    //组件挂接到当前页面
    componentWillUnmount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.removeListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }

</code></pre>

<p>可以使用<code>BackAndroid</code>的<code>addEventListener</code>函数挂接多个监听器,当返回键按下，最后的的最先执行 如果返回false会接下来执行倒数第二个 所有的都执行完 才会交给安卓操作系统</p>

<p><code>BackAndroid.exitApp();</code>可以 直接退出应用</p>

<h3 id="toc_2">颜色</h3>

<ol>
<li><code>rgba(52, 52, 52, 0.5)</code></li>
<li><code>0xF5FCFF01</code></li>
<li><code>#F5FCFF</code></li>
<li><code>rgb(245, 255, 255)</code></li>
<li><code>hsl(360, 100%, 100%)</code></li>
<li><code>hsla(360, 100%, l00%, 1.0)</code></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15288713693530.html">状态机</a></h1>
			<p class="meta"><time datetime="2018-06-13T14:29:29+08:00" 
			pubdate data-updated="true">06/13/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>ReactNative 将UI视作一个状态机,每个UI场景就是状态机的一个状态</p>

<blockquote>
<p>不要在状态机变量中存放于显示无关的变量,会导致务必要渲染UI</p>
</blockquote>

<h2 id="toc_0">State</h2>

<blockquote>
<p>尽可能让自定义的组件成为无状态组件<br/>
好的reactnative设计思路:创建多个只负责渲染数据的无状态组件，将他们封装在一个有状态的reactnative组件中,有状态的组件封装了UI交互的逻辑，而无状态的组件负责渲染UI界面。</p>
</blockquote>

<pre><code class="language-javascrip">constructor(props) {
        super(props)
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    updateNum(newText) {
        this.setState((state) =&gt; {
            return {input: newText}
        });
    }

    updatePWD(newText) {
        this.setState(() =&gt; {
            return {
                inputPWD : newText
            }
        })
    }
</code></pre>

<p>通过this.state.状态机变量名 访问状态机变量</p>

<p>我们需要将状态机变量看做 <strong>不可变常量</strong>，不能直接改变状态机变量，只能通过<strong>setState</strong>函数</p>

<h2 id="toc_1">渲染</h2>

<p>setState函数原型：<code>setState(oldState, callback)</code> 第二个参数为回调函数,会在setState完成并且重新渲染完成(如果需要的话)后被调用</p>

<p>如果setState函数将传入函数的返回值与当前状态机相比没有任何修改或增加,将不会进行渲染</p>

<p>改变状态机变量后 所有与状态机变量值有关系的组件都会被刷新。</p>

<blockquote>
<p>当修改组件的状态机变量值后，ReactNative会在考虑清楚如何高效的渲染UI后,执行SetState的箭头函数来渲染组件,因此setState是异步执行的函数</p>

<p>当子组件需要渲染时,那么该子组件的各个生命周期的函数都会按声明周期调用 这就是渲染高效的原因</p>
</blockquote>

<h3 id="toc_2">判断是否渲染</h3>

<pre><code class="language-javascript">//判断是否渲染，实现这个函数后,会在重新渲染组件前，调用这个函数，返回false就放弃渲染组件
shouldComponentUpdate() {
        if (this.state.input.length &lt; 3) {
            return true;
        }
        return false;
    }
</code></pre>

<h3 id="toc_3">强制渲染</h3>

<p><code>forceUpdate(callback)</code> <br/>
当UI的可变数据来源为属性和状态之外获取时,可以使用这个函数要求重新渲染，这会导致所有级别的UI都重新读取、计算、渲染。</p>

<blockquote>
<p>这个渲染过程不会调用<code>shouldComponentUpdate</code><br/>
可以通过回调函数,在执行结束后调用<br/>
尽量避免使用</p>
</blockquote>

<h3 id="toc_4">render渲染过程</h3>

<p>RN通过<code>render</code>实现重新渲染。原型为<code>ReactComponent render()</code><br/>
任何组件都必须有这个函数 也必须只能返回一个可渲染组件<br/>
通过修改属性或者状态机变量来触发render的重新渲染，而不是直接调用这个函数</p>

<h3 id="toc_5">简洁写法</h3>

<pre><code class="language-javascript">    //简洁写法1（通过指定参数名称与状态机变量名称相同 省略）
    updateNum(input) {
        this.setState(() =&gt; {
            return {input}
        })
    }
    
    //简洁写法2（省略箭头函数）
    updateNum(input) {
        this.setState( {input})
    }
 ```

## 成员变量

```javascript
    constructor(props) {
        super(props)
        this.myProperty1 = &quot;test&quot;
        this.myProperty2 = true
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    //就可以在组件中使用myProperty1  myProperty2 这两个成员变量
</code></pre>

<p>组件可以有静态变量、静态成员函数，直接用<code>类名.</code>调用</p>

<h3 id="toc_6">回调函数绑定</h3>

<pre><code class="language-javascript">//在constuctor函数中
this.updateNum = this.updateNum.bind(this)
</code></pre>

<p>绑定操作是为了让回调函数能正确解析出this，否则this.updateNum函数被执行时,指向另外对象而不是该组建类的实例</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_16.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_14.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B&&Runloop.html"><strong>多线程&&Runloop&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="RunLoop.html">RunLoop&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html">线程安全&&锁&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="KVC&&KVO.html">KVC&&KVO&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&&block.html"><strong>内存管理&&block&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">OC高级编程-内存管理&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="block%E5%AD%A6%E4%B9%A0.html">block学习&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">官方文档-内存管理&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%8B%BE%E9%81%97.html">内存管理-拾遗&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&&%E7%BB%84%E4%BB%B6%E5%8C%96.html"><strong>设计模式&&组件化&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html">设计模式架构谈(摘录)&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html">组件化开发学习&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BC%96%E8%AF%91&&dyld&&Mach-O.html"><strong>编译&&dyld&&Mach-O&nbsp;(19)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html">iOS编译流程&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html">dyld(程序启动)&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html">Mach-O文件了解&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86.html"><strong>模块化知识&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS-CoreAnimation.html">iOS-CoreAnimation&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="CoreGraphic.html">CoreGraphic&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="ARKit.html">ARKit&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"><strong>第三方项目学习和使用&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="AFNetworking.html">AFNetworking&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="AsyncDisplayKit.html">AsyncDisplayKit&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="ReactnativeCocoa.html">ReactnativeCocoa&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="PromiseKit.html">PromiseKit&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96.html"><strong>项目监控和优化&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html">APP体积优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html">启动优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%B0%83%E8%AF%95&&%E6%B5%8B%E8%AF%95.html"><strong>调试&&测试&nbsp;(6)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="LLDB.html">LLDB&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html">自动化测试&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="git.html">git&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>