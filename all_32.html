
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14879278087290.html">协议与分类</a></h1>
			<p class="meta"><time datetime="2017-02-24T17:16:48+08:00" 
			pubdate data-updated="true">02/24/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Objective-C中的分类允许我们通过给一个类添加方法来扩充它（但是通过<code>category</code>不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>

<p>@protocol声明了可以呗其他任何方法类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="14879278087290.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14925128921601.html">常用动画示例</a></h1>
			<p class="meta"><time datetime="2017-04-18T18:54:52+08:00" 
			pubdate data-updated="true">04/18/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">1.地震动画</h3>

<p>适合一整个大视图的突然晃动</p>

<pre><code class="language-objectivec">- (void)earthquake:(UIView*)itemView {
    CGFloat t = 2.0;
    CGAffineTransform leftQuake  = CGAffineTransformTranslate(CGAffineTransformIdentity, t, 0);
    CGAffineTransform rightQuake = CGAffineTransformTranslate(CGAffineTransformIdentity, -t, 0); //水平晃动

    itemView.transform = leftQuake;  // starting point

    [UIView beginAnimations:@&quot;earthquake&quot; context:(__bridge void *)(itemView)];
    [UIView setAnimationRepeatAutoreverses:YES]; // 如果不加这一句 整个动画感觉不连贯
    [UIView setAnimationRepeatCount:5];
    [UIView setAnimationDuration:0.07];
    [UIView setAnimationDelegate:self];
    [UIView setAnimationDidStopSelector:@selector(earthquakeEnded:finished:context:)];

    itemView.transform = rightQuake; // end here &amp; auto-reverse

    [UIView commitAnimations];
}

- (void)earthquakeEnded:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context {
    if ([finished boolValue]) {
        UIView* item = (__bridge UIView *)context;
        item.transform = CGAffineTransformIdentity;
    }
}
</code></pre>

<h3 id="toc_1">2.图标的抖动效果</h3>

<pre><code class="language-objectivec">//开始抖动
-(void)BeginWobble
{

    srand([[NSDate date] timeIntervalSince1970]);
    float rand=(float)random();
    CFTimeInterval t=rand*0.0000000001;

    [UIView animateWithDuration:0.1 delay:t options:0  animations:^
     {
         要抖动的视图.transform=CGAffineTransformMakeRotation(-0.05);
     } completion:^(BOOL finished)
     {
         [UIView animateWithDuration:0.1 delay:0 options:UIViewAnimationOptionRepeat|UIViewAnimationOptionAutoreverse|UIViewAnimationOptionAllowUserInteraction  animations:^
          {
              要抖动的视图.transform=CGAffineTransformMakeRotation(0.05);
          } completion:^(BOOL finished) {}];
     }];
}
//停止抖动
-(void)EndWobble
{

    [UIView animateWithDuration:0.1 delay:0 options:UIViewAnimationOptionAllowUserInteraction|UIViewAnimationOptionBeginFromCurrentState animations:^
     {
         要抖动的视图.transform=CGAffineTransformIdentity;
     } completion:^(BOOL finished) {}];
}

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14968373667230.html">Swift 基础部分</a></h1>
			<p class="meta"><time datetime="2017-06-07T20:09:26+08:00" 
			pubdate data-updated="true">06/07/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Swift 包含了C和Objective-C上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。 Swift 还提供了三个基本的集合类型<code>Array</code> ，<code>Set</code> 和<code>Dictionary</code><br/>
除了我们熟悉的类型，<code>Swift</code>还增加了<code>Objective-C</code>中没有的高阶数据类型比如元组（<code>Tuple</code>）。<br/>
<code>Swift</code>还增加了可选（Optional）类型，用于处理值缺失的情况。</p>

<p><code>Swift</code>是一门类型安全的语言，这意味着<code>Swift</code>可以让你清楚地知道值的类型。</p>

<h2 id="toc_0">常量和变量</h2>

<p>常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>

<h3 id="toc_1">声明常量和变量</h3>

<p>用<code>let</code>来声明常量，用<code>var</code>来声明变量</p>

<pre><code class="language-swift">//一行中声明多个
var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<p>注意:<strong>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。</strong></p>

<h3 id="toc_2">类型标注</h3>

<p>声明常量或者变量的时候可以加上类型标注，在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。(声明时如果有初始值，Swift可以推断出这个常量或者变量的类型)</p>

<pre><code class="language-swift">//可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：
var red, green, blue: Double
</code></pre>

<h3 id="toc_3">常量和变量的命名</h3>

<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>

<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。（不推荐）</p>

<h3 id="toc_4">输出常量和变量</h3>

<p>用 <code>print(someValue, separator:, terminator:)</code> 函数来输出当前常量或变量的值:<br/>
<code>separator</code>用来设置各个值间的拼接字符串<br/>
<code>terminator</code>用来设置输出结果结束后的结束字符，默认为“\n”换行</p>

<pre><code class="language-swift">print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
//输出结果(并没有换行)
//111--222结束符 111--222结束符
</code></pre>

<p><code>Swift</code>用<strong>字符串插值</strong>（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，<code>Swift</code>会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>

<pre><code class="language-swift">/*
    若只是要print一个变量或者常量可以直接print，但是如果要将这个拼接到字符串中需要这
    样做
*/
print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)
// 输出 &quot;The current value of friendlyWelcome is Bonjour!
</code></pre>

<blockquote>
<p><code>print(_:separator:terminator:)</code>这个函数第一个参数为<code>_</code>即并没有设置标签,其他参数设置了标签并且有默认值因此是可选的</p>
</blockquote>

<h2 id="toc_5">注释</h2>

<p>单行注释用双正斜杠<code>（ // ）</code>作为起始标记:<br/>
多行注释用：</p>

<pre><code class="language-swift">/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>

<p>多行注释可以去嵌套注释，我们可以方便的注释掉大段代码 即使代码中已经包含注释(oc中是没有多行注释的)</p>

<h2 id="toc_6">分号</h2>

<p><code>Swift</code>并不需要在末尾添加分号,但是如果单行内写多条语句时,必须用分号分开;</p>

<h2 id="toc_7">整数</h2>

<p><code>Swift</code> 提供了8，16，32和64位的有符号和无符号整数类型(即分别为1、2、4、8字节)。<br/>
命名:比如8位无符号整数类型是 UInt8 ，32位有符号整数类型是 Int32 。</p>

<h3 id="toc_8">范围</h3>

<p>我们可以用不同整数类型的<code>min</code>和<code>max</code>属性获取对应类型的最小值和最大值：</p>

<pre><code class="language-swift">//返回的类型正是其对应类型
let minValue = UInt8.min // minValue 为 0，是 UInt8 类型
let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型
</code></pre>

<p>Swift提供了整数类型<code>Int</code>和<code>UInt</code>其长度和当前平台<code>原生字长</code>相同</p>

<p>补充:<br/>
尽量不要使用<code>UInt</code> ，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断</p>

<h2 id="toc_9">浮点数</h2>

<p><code>Swift</code>提供了两种有符号浮点数类型：</p>

<ul>
<li>Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float 表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>

<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择<code>Double</code>。</p>

<h2 id="toc_10">类型安全和类型推断</h2>

<p><code>Swift</code>是一个类型安全（type safe）的语言。因此它会在编译时进行类型检查,将不匹配的类型标记为错误。但是也不需要每个都显示的指定类型,编译器可以在编译代码的时候自动推断出表达式的类型。</p>

<pre><code class="language-swift">//当推断浮点数的类型时，Swift 总是会选择 Double 而不是 Float 
let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>

<p>如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型</p>

<pre><code class="language-swift">let anotherPi = 3 + 0.14159
// anotherPi 会被推测为 Double 类型
</code></pre>

<h2 id="toc_11">数值型字面量</h2>

<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是 <code>0b</code></li>
<li>一个八进制数，前缀是 <code>0o</code></li>
<li>一个十六进制数，前缀是 <code>0x</code></li>
</ul>

<p>对于浮点数用10进制或者16进制表示，可以用指数来表示，10进制的指数为<code>e</code>(可为大写或小写)，16进制使用大写或者小写的<code>p</code></p>

<pre><code class="language-swift">1.25e2 表示 1.25 × 10^2，等于 125.0 
1.25e-2 表示 1.25 × 10^-2，等于 0.0125
0xFp2 表示 15 × 2^2，等于 60.0
0xFp-2 表示 15 × 2^-2，等于 3.75
</code></pre>

<p>补充:<br/>
为了可读性：整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>

<pre><code class="language-swift">let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>

<h2 id="toc_12">数值型类型转换</h2>

<p>前面说过,即使知道整数常量或者变量为非负也推荐使用<code>Int</code>类型，这样可以保证我们的的变量或常量可以直接被复用并且可以匹配整数类字面量的类型推断</p>

<p>我们通常使用其他整数类型是为了处理外部明确长度的数据或者优化性能、内存。这样直接使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>

<h3 id="toc_13">整数转换</h3>

<p><code>Swift</code>任何时候都不会隐式进行类型转换，所以我们应该根据情况进行显式的进行类型装换，这样代码的转换意图也更清晰</p>

<pre><code class="language-swift">let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>

<p><code>SomeType(ofInitialValue)</code> 是调用<code>Swift</code>构造器并传入一个初始值的默认方法(但是也不能接受任意类型的值,只能传入<code>SomeType</code>内部有对应构造器的值)</p>

<h3 id="toc_14">整数和浮点数转换</h3>

<p>整数和浮点数之间可以互相转换</p>

<pre><code class="language-swift">let pi = Double(3);
let integerPi = Int(3.1415)
//这样转换的话会向下取整
//即浮点值会被截断
</code></pre>

<h2 id="toc_15">类型别名</h2>

<p>给现有类型定义另外一个名字,使用<code>typealias</code>关键字来定义类型别名<br/>
<code>typealias AudioSample = UInt16</code><br/>
<strong>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名</strong>：</p>

<h2 id="toc_16">布尔值</h2>

<p><code>Swift</code>提供基本布尔类型<code>Bool</code>，有两个布尔常量:<code>ture</code>和<code>false</code><br/>
Swift中的Bool是非常严格的必须为ture或者false，而不是OC中的非0为真</p>

<h2 id="toc_17">元组</h2>

<p>元组将多个值组合为一个复合值，其中可以为任意类型</p>

<p>元组只适用于我们临时组织数据,不适合创建复杂的数据结构，如果不是临时使用请使用类或者结构体</p>

<pre><code class="language-swift">//定义元组
let http404Error = (404, &quot;Not Found&quot;)
//元组解析 也可以将 (statusCode, statusMessage) 看为定义的元组名称
let (statusCode, statusMessage) = (404, &quot;Not Found&quot;)
//元组解析 利用 _ 忽略其他的部分
let (justTheStatusCode, _) = http404Error
print((statusCode, statusMessage).0, (statusMessage), http404Error.1)


let (status200Code, status200Message) = (statusCode: 200, description: &quot;OK&quot;)
status200Code
(status200Code, status200Message).1
//这种方式报错,因为用(status200Code, status200Message) 已经将元组内容部分解析,定义的名称已经被覆盖了
//(status200Code, status200Message).status200Code 
let status400 : (statusCode: Int, description: String) = (404, &quot;Not Found&quot;)
status400.statusCode
</code></pre>

<h2 id="toc_18">可选类型</h2>

<p>可选类型用来处理值可能缺失的情况</p>

<p><code>OC</code>中并没有这个类型,在oc中为了表达这个意思我们通常让方法返回一个特殊值(比如 <code>NSNotFound</code>)，来让我们对特殊值进行判断，<code>Swift</code>提供了一个可选类型可以按时任意类型值得缺失很方便.</p>

<p>可选类型的值: 要不有值为X 要不为没有值</p>

<pre><code class="language-swift">//我们将String强转为Int 因为并不是所有字符串都能转为整数,因此返回可选类型
let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;
</code></pre>

<p>问号表示是可选类型Int，就是有可能包含<code>Int</code>也有可能不包含值</p>

<h3 id="toc_19">nil</h3>

<p>在<code>Swift</code>中的<code>nil</code>和OC中并不同。 在OC中<code>nil</code>是一个指向不存在的对象的指针。而<code>Swift</code>中nil不是一个指针,是一个确定的值来表示值得缺失,任何可选状态都可被置为<code>nil</code>，不仅是对象类型。<strong><code>nil</code>只能设置可选类型的值,如果想设置一个常量或者变量,需要先将其设置为可选类型</strong></p>

<pre><code class="language-swift">var serverResponseCode: Int? = 404
serverResponseCode = nil
//对于未赋值的可选类型 默认值为 nil
var surveyAnswer: String?
</code></pre>

<h3 id="toc_20">if语句以及强行解析</h3>

<p>对于一个可选类型值,可以通过 在其后加上<code>!</code>强制解析来获取其值,但是对于不存在的值加！会导致错误,因此在强制解析前需要判断非空</p>

<pre><code class="language-swift">if convertedNumber != nil {
print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)
}
</code></pre>

<h3 id="toc_21">可选绑定</h3>

<p>上面强行解析后这个值还是可选类型,为了避免这种情况我们可以使用<strong>可选绑定</strong>,用着<code>if</code>或<code>while</code>语句中,通过判断可选类型是否有值,有值得话将其赋值给一个确定类型的变量或者常量,这样就可以使用这个变量或者常量来避免使用可选类型的值避免使用强行解析</p>

<blockquote>
<p>缺点是这样创建的常量或者变量只能在这个if语句中使用</p>
</blockquote>

<pre><code class="language-swift">if let actualNumber = Int(possibleNumber) {
print(&quot;\&#39;\(possibleNumber)\&#39; has an integer value of \(actualNumber)&quot;)
} else {
print(&quot;\&#39;\(possibleNumber)\&#39; could not be converted to an integer&quot;)
}
//如果 Int(possibleNumber)不是nil就可创建一个常量actualNumber指向这个值

</code></pre>

<h3 id="toc_22">隐式解析可选类型</h3>

<p>有时在可选类型第一次被赋值后,就可以确定其总是有值,这时候我们可以声明其为隐式解析可选类型来避免每次都判断解析<br/>
通过将可选类型后的 <code>?</code> 替换为<code>!</code>来声明隐式解析可选类型</p>

<blockquote>
<p>可以将隐式解析可选类型当做一个可以自动解析的可选类型<br/>
使用隐式解析必须确保这个值不会为空 否则和对空值进行强行解析一样会出错</p>
</blockquote>

<pre><code class="language-swift">let possibleString: String? = &quot;An optional string.&quot;
let forcedString: String = possibleString! // 需要感叹号来获取值

let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString // 不需要感叹号
</code></pre>

<h3 id="toc_23">错误处理</h3>

<p><code>Swift</code>允许我们在函数声明中通过添加 <code>throw</code>类型来判处错误消息<br/>
当我们调用一个可能抛出错误消息的函数时,应该在表达式前置<code>try</code>关键字</p>

<blockquote>
<p>这里只是简单了解</p>
</blockquote>

<pre><code class="language-swift">func makeASandwich() throws {
// ...
}
do {
    try makeASandwich()
    eatASandwich()//没有错误抛出会执行这个函数
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)//匹配的错误抛出 函数被调用并且会
}
</code></pre>

<h2 id="toc_24">断言</h2>

<p>有时我们需要在代码中判断某些条件是否满足条件来决定是否继续执行,这时候我们需要断言</p>

<h3 id="toc_25">使用断言进行调试</h3>

<p>断言会在运行时判断一个逻辑条件是否为<code>ture</code>。如果条件判断为<code>true</code>，代码运行会继续进<br/>
行；如果条件判断为<code>false</code> ，代码执行结束，你的应用被终止。</p>

<p>我们在调试环境中触发一个断言，可以检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>

<p>你可以使用全局<code>assert(_:_:file:line:)</code>函数来写一个断言.<br/>
向这个函数传入一个结果为 <code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>

<pre><code class="language-swift">let age = -3
assert(age &gt;= 0, &quot;A person&#39;s age cannot be less than zero&quot;)
// 因为 age &lt; 0，所以断言会触发
</code></pre>

<blockquote>
<p>当代码使用优化编译的时候，断言将会被禁用，例如在<code>Xcode</code>中，使用默认的<code>target Release</code>配置选项来<code>build</code>时，断言会被禁用。</p>
</blockquote>

<h3 id="toc_26">何时使用断言</h3>

<p>当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。</p>

<blockquote>
<p>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

<p>断言的适用情景:</p>

<ul>
<li>整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是 nil ，但是后面的代码运行需要一个非 nil 值。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15536843996723.html">View层的架构</a></h1>
			<p class="meta"><time datetime="2019-03-27T18:59:59+08:00" 
			pubdate data-updated="true">03/27/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>文章看自<a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">这里</a></p>

<h2 id="toc_0">View层组织注意事项</h2>

<ol>
<li><p><code>ViewController</code>中的书写规范</p>
<ul>
<li>在<code>viewDidLoad</code>中做<code>addSubViews</code>和布局</li>
<li>getter和setter放到最后避免影响业务逻辑阅读</li>
<li>将代理都写到一个delegate区域中，并且加上对应protocol名字</li>
<li>为按钮点击事件等，单独开一个<code>event response</code>的区域</li>
</ul></li>
<li><p>建议使用全代码 不使用xib或者storyboard</p></li>
<li><p>不建议统一派生<code>ViewController</code>，可以使用<code>AOP</code>或者使用NSObject的load函数(在应用启动时自动监听)，实现要实现的功能 --- 尽量不要使用继承</p></li>
<li><p>能不放在Controller中做的事情就尽量不要放在Controller中做</p></li>
</ol>

<h2 id="toc_1">View层应避免</h2>

<ol>
<li>代码不规范导致混乱</li>
<li>过多继承导致复杂的依赖关系</li>
<li>横向依赖</li>
<li>架构设计失去传承</li>
</ol>

<h2 id="toc_2">制作好的View架构</h2>

<p>要做一个View层架构，主要就是从以下三方面入手：</p>

<p>制定良好的规范<br/>
选择好合适的模式（MVC、MVCS、MVVM、VIPER）<br/>
根据业务情况针对ViewController做好拆分，提供一些小工具方便开发</p>

<h2 id="toc_3">MVC MVVM等设计模式</h2>

<p>这些设计模式其实是 规定了架构中的3个角色:数据管理者，数据加工者，数据展示者,之间的数据如何交换</p>

<h3 id="toc_4">对mvc的一些总结</h3>

<p>M应该做的事：</p>

<ul>
<li>给ViewController提供数据</li>
<li>给ViewController存储数据提供接口</li>
<li>响应数据请求一般来时C的</li>
<li>提供经过抽象的业务基本组件，供Controller调度</li>
</ul>

<blockquote>
<p>M不应该这是dataModel 而是整个Model层</p>
</blockquote>

<p>C应该做的事：</p>

<ul>
<li>管理View Container的生命周期</li>
<li>负责生成所有的View实例，并放入View Container</li>
<li>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。</li>
</ul>

<p>V应该做的事：</p>

<ul>
<li>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。</li>
<li>界面元素表达</li>
</ul>

<h2 id="toc_5">MVVM</h2>

<p>MVVM把数据加工的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。</p>

<p>MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel。</p>

<p>MVVM<br/>
viewmodel需要做的就是将json等数据转换为能给view用的model<br/>
Model层 这里的model层包括数据model层、网络请求层、数据存储层、</p>

<p>C负责View和ViewModel数据的绑定</p>

<p>MVVM就是讲MVC的C中的数据处理逻辑抽出来了</p>

<blockquote>
<p>对于API的调用应该放在VM还是C中，看情况而定，如果你的请求独立于C，请求时不需要再联系ViewController就可以放在VM中，否则的话在VM中调用逻辑混乱，最好放在C中</p>

<p>RAC的目的1：View并不适合直接持有ViewModel。第二个目的就在于，ViewModel有可能并不是只服务于特定的一个View，使用更加松散的绑定关系能够降低ViewModel和View之间的耦合度</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541132912435.html">Mach-O文件</a></h1>
			<p class="meta"><time datetime="2019-04-01T18:08:11+08:00" 
			pubdate data-updated="true">04/01/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>记录编译后的可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式<br/>
是二进制数据文件，里面有不同的包含元信息的数据块，比如字节顺序，cpu类型，块大小等。文件内容不可修改，因为在.app目录中有<code>_CodeSignature</code>目录，里面包含了程序代码的签名，这个签名的作用就是保证.app里的文件，包括资源文件，Mach-O文件都不能更改</p>

<p>Mach-O文件包含三个区域</p>

<ul>
<li><code>Mach-O Header</code>：包含字节顺序，magic，cpu类型，加载指令的数量等</li>
<li><code>Load Commands</code>：包含很多内容的表，包括区域的位置，符号表，动态符号表。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置</li>
<li><code>data</code>: 文件中最大的部分，包含了代码，数据，比如符号表、动态符号表</li>
</ul>

<p><img src="media/15541132912435/15541134009742.jpg" alt="" style="width:415px;"/></p>

<p><img src="media/15541132912435/15541204613989.jpg" alt="" style="width:636px;"/></p>

<h2 id="toc_0">Mach-O 文件的解析</h2>

<p>自己创建一个test.c文件</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    printf(&quot;hi there!\n&quot;);
    return 0;
}
</code></pre>

<pre><code class="language-c">//将test.c 编译汇编链接成一个可执行文件 未指定输出文件 即默认为a.out
xcrun clang test.c 
</code></pre>

<hr/>

<p>使用size工具查看a.out中的section</p>

<pre><code class="language-c">xcrun size -x -l -m a.out
</code></pre>

<pre><code class="language-c">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)
Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)
    Section __text: 0x34 (addr 0x100000f50 offset 3920)
    Section __stubs: 0x6 (addr 0x100000f84 offset 3972)
    Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)
    Section __cstring: 0xa (addr 0x100000fa6 offset 4006)
    Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)
    total 0xa6
Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)
    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)
    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)
    total 0x18
Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)
total 0x100003000
</code></pre>

<p>有4个segment和多个section<br/>
当运行时，虚拟内存会把segment映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存</p>

<p><code>__PAGEZERO sement</code>的大小是4GB，不是文件真实大小，是规定进程地址空间前4GB被映射为不可执行文件，不可读、不可写</p>

<p><code>__TEXT segment</code>包含被执行的代码以只读和可执行的方式映射</p>

<ul>
<li>__text section 包含编译后的机器码</li>
<li><strong>stubs和</strong>stub_hepler是给动态链接器dyld使用，可以允许延迟链接</li>
<li>__csstring 可执行文件中的字符串</li>
<li>__const不可变的常量</li>
</ul>

<p><code>__DATA segment</code>以可读写和不可执行的方式映射,里面是会被更改的数据</p>

<ul>
<li>__nl_symbol_ptr 非延迟指针.可执行文件加载同时加载</li>
<li>__la_symbol_ptr延迟符号指针.延迟用于可执行文件汇总调用未定义的函数，可执行文件里没有包含的函数会延迟加载</li>
<li>__const 需要重定向的常量  例如 char * const c = “foo”; c指针指向可变的数据</li>
<li>__bbs不用初始化的静态变量</li>
<li>__common包含外部全局变量。例如在函数外定义 int i；</li>
<li>__dyld是section占位符，用于动态链接器</li>
</ul>

<hr/>

<p>查看<strong>section中的内容</strong></p>

<pre><code class="language-text">xcrun otool -s __TEXT __text a.out
</code></pre>

<p>显示的为二进制数据，我们可以反汇编,查看汇编信息 -s __TEXT __text 有个缩写 -t</p>

<pre><code class="language-text">xcrun otool -v -t a.out
</code></pre>

<pre><code class="language-c">a.out:
(__TEXT,__text) section
_main:
0000000100000f50    pushq    %rbp
0000000100000f51    movq    %rsp, %rbp
0000000100000f54    subq    $0x20, %rsp
0000000100000f58    leaq    0x47(%rip), %rax
0000000100000f5f    movl    $0x0, -0x4(%rbp)
0000000100000f66    movl    %edi, -0x8(%rbp)
0000000100000f69    movq    %rsi, -0x10(%rbp)
0000000100000f6d    movq    %rax, %rdi
0000000100000f70    movb    $0x0, %al
0000000100000f72    callq    0x100000f84
0000000100000f77    xorl    %ecx, %ecx
0000000100000f79    movl    %eax, -0x14(%rbp)
0000000100000f7c    movl    %ecx, %eax
0000000100000f7e    addq    $0x20, %rsp
0000000100000f82    popq    %rbp
0000000100000f83    retq
</code></pre>

<hr/>

<p>使用otool查看可执行文件的头部,即header</p>

<pre><code class="language-c">otool -v -h a.out
</code></pre>

<p>得到 <strong>头部信息</strong></p>

<pre><code class="language-text">Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE
</code></pre>

<p>mach_header 结构体</p>

<pre><code class="language-text">struct mach_header {
  uint32_t      magic; 
  cpu_type_t    cputype; 
  cpu_subtype_t cpusubtype;
  uint32_t      filetype;
  uint32_t      ncmds;
  uint32_t      sizeofcmds;
  uint32_t      flags;
};
</code></pre>

<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令<code>LoadCommand</code></p>

<hr/>

<p><strong>查看LoadCommands</strong>使用命令 <code>otool -v -l a.out</code></p>

<pre><code class="language-c">...
...
Load command 1
      cmd LC_SEGMENT_64
  cmdsize 472
  segname __TEXT
   vmaddr 0x0000000100000000
   vmsize 0x0000000000001000
  fileoff 0
 filesize 4096
  maxprot rwx
 initprot r-x
   nsects 5
    flags (none)
Section
  Section
  sectname __text
   segname __TEXT
      addr 0x0000000100000f50 //代码的位置地址 和上面反汇编的地址是一样的
      size 0x0000000000000034 
    offset 3920 //在文件中的偏移量
     align 2^4 (16)
    reloff 0
    nreloc 0
      type S_REGULAR
attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS
 reserved1 0
 reserved2 0
Section
  sectname __stubs
   segname __TEXT
      addr 0x0000000100000f88
      size 0x0000000000000006
    offset 3976
     align 2^1 (2)
    reloff 0
    nreloc 0
      type S_SYMBOL_STUBS
attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS
 reserved1 0 (index into indirect symbol table)
 reserved2 6 (size of stubs)
 ...
 ...
</code></pre>

<p>加载命令的结构体</p>

<pre><code class="language-text">struct segment_command {
  uint32_t  cmd;
  uint32_t  cmdsize;
  char      segname[16];
  uint32_t  vmaddr;
  uint32_t  vmsize;
  uint32_t  fileoff;
  uint32_t  filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot; //权限 例如r-x
  uint32_t  nsects;
  uint32_t  flags;
};
</code></pre>

<hr/>

<h2 id="toc_1">逆向Mach-O文件</h2>

<p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>

<p>Mobilesubstrate 提供了三个模块来方便开发。</p>

<p>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。<br/>
MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook 放在这里就可以了。<br/>
Safe mode：类似安全模式，会禁用的改动。<br/>
先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>

<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>

<ul>
<li>入门文章可以看看这篇: <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C"> MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li><a href="http://blog.imjun.net/posts/convert-iOS-app-to-dynamic-library/">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>  <a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/"> iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15541213204265.html">dyld动态链接</a></h1>
			<p class="meta"><time datetime="2019-04-01T20:22:00+08:00" 
			pubdate data-updated="true">04/01/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>生成可执行文件后，就是在启动时进行动态链接了,进行符号和地址的绑定。首先会加载所依赖的<code>dylibs</code>，修正地址偏移，因为iOS会用 ASLR 来做地址偏移避免攻击，确定<code>Non-Lazy Pointer</code>地址进行符号地址绑定，加载所有类，最后执行<code>load</code>方法和<code>clang attribute</code> 的<code>constructor</code>修饰函数。</p>

<p>每个函数、全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接为一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理</p>

<p>查看一个可链接文件的符号表<br/>
<code>xcrun nm -nm SayHi.o</code></p>

<pre><code class="language-c">                 (undefined) external _OBJC_CLASS_$_Foo
                 (undefined) external _objc_autoreleasePoolPop
                 (undefined) external _objc_autoreleasePoolPush
                 (undefined) external _objc_msgSend
0000000000000000 (__TEXT,__text) external _main
</code></pre>

<ul>
<li><code>OBJC_CLASS$_Foo</code>表示<code>Foo</code>的<code>OC</code>符号</li>
<li><code>(undefined) external</code>表示未实现非私有，如果是私有就是<code>non-external</code></li>
<li><code>external _main</code> 表示<code>main()</code>函数，处理<code>0</code>地址，将要到 <strong>TEXT,</strong>text section</li>
</ul>

<pre><code class="language-text">xcrun nm -nm Foo.o
</code></pre>

<pre><code class="language-c">                 (undefined) external _NSLog
                 (undefined) external _OBJC_CLASS_$_NSObject
                 (undefined) external _OBJC_METACLASS_$_NSObject
                 (undefined) external ___CFConstantStringClassReference
                 (undefined) external __objc_empty_cache
0000000000000000 (__TEXT,__text) non-external -[Foo say]
0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo
00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo
00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo
0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
</code></pre>

<p>undefine符号表示该文件类未实现的，所以在目标文件和<code>Function framework</code>动态库做链接处理时，链接器尝试解析所有的undefined符号</p>

<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下a.out符号表，看看可执行文件是怎么解析符号的</p>

<pre><code class="language-text">xcrun nm -nm a.out
</code></pre>

<pre><code class="language-c">                 (undefined) external _NSLog (from Foundation)
                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)
                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)
                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)
                 (undefined) external __objc_empty_cache (from libobjc)
                 (undefined) external _objc_autoreleasePoolPop (from libobjc)
                 (undefined) external _objc_autoreleasePoolPush (from libobjc)
                 (undefined) external _objc_msgSend (from libobjc)
                 (undefined) external dyld_stub_binder (from libSystem)
0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header
0000000100000e90 (__TEXT,__text) external _main
0000000100000f10 (__TEXT,__text) non-external -[Foo say]
0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
</code></pre>

<p>undefined 符号 有了更多信息，可以知道在哪个库能够找到<br/>
通过otool可以找到所需要的库在哪</p>

<pre><code class="language-text">xcrun otool -L a.out
</code></pre>

<pre><code class="language-text">a.out:
    /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
    /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
</code></pre>

<p>dylib这种格式表示是动态链接的，即动态库，编译时不会被编译到执行文件中，在程序执行时才link，这样就不用算到包的大小中,而且也能够不更新执行程序就能更新库</p>

<p>打印什么库被加载了</p>

<pre><code class="language-text">(export DYLD_PRINT_LIBRARIES=; ./a.out )
</code></pre>

<pre><code class="language-text">dyld: loaded: /Users/didi/Downloads/./a.out
dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
dyld: loaded: /usr/lib/libSystem.B.dylib
dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
…
</code></pre>

<p>因为Fundation库依赖一些其他库,其他库还会依赖更多，因此为了减少处理的时间,系统上的动态链接器会共享缓存,共享的缓存在<code>/var/db/dyld/</code>，这样，当加载Mach-O文件时动态链接器会先检查共享内存是否有。每个进程都会有自己地址空间映射这些共享缓存，可以优化启动速度</p>

<h3 id="toc_0">dyld做了什么事情</h3>

<ul>
<li>kernel做启动程序初始准备,开始由dyld负责</li>
<li>基于非常简单的原始栈为kernel设置进程来启动自身</li>
<li>使用共享缓存来处理递归依赖带来的性能问题,ImageLoader会读取二进制文件,其中包含了我们的类,方法等各种符号</li>
<li>立即绑定non-lazy的符号并设置用于lazy bind的必要表，将这些库link到执行文件里</li>
<li>为可执行文件运行静态初始化</li>
<li>设置参数到可执行文件的 main 函数并调用它</li>
<li>在执行期间，<strong>通过绑定符号处理对<code>lazily-bound</code>符号存根的调用提供runtime动态加载服务(通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime会调用map_images做解析和处理,load_images来调用call_load_methods方法遍历所有加载了的Class，按照继承层级依次调用+load方法；</strong></li>
<li>在main函数返回后运行 static terminator</li>
<li>在某些情况下,一旦main函数返回就需要调用<code>libSystem</code>的_exit</li>
</ul>

<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime<a href="https://github.com/RetVal/objc-runtime">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的runtime方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>

<pre><code class="language-objectivec">0 +[someclass load]
1  call_class_loads()
2  ::call_load_methods
3  ::load_images(const char *path __unused, const struct mach_header *mh)
4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)
11 _dyld_start
</code></pre>

<p>在<code>load_images</code>方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的<code>hasLoadMethods</code>用于快速判断是否有<code>+load</code>方法。</p>

<p><code>prepare_load_methods</code>这个方法会获取所有类的列表然后收集其中的<code>+load</code>方法，在代码里可以发现<code>Class</code>的<code>+load</code>是先执行的，然后执行<code>Category</code>的<code>+load</code>方法。为什么这样做，原因可以通过<code>prepare_load_methods</code>这个方法看出，在遍历<code>Class</code>的<code>+load</code>方法时会执行<code>schedule_class_load</code>这个方法，这个方法会递归到根节点来满足<code>Class</code>收集完整关系树的需求。<br/>
最后<code>call_load_methods</code>会创建一个<code>autoreleasePool</code>使用函数指针来动态调用类和<code>Category</code>的<code>+load</code>方法</p>

<p>如果想了解<code>Cocoa</code>的<code>Fundation</code>库可以通过<a href="https://github.com/AaronYi/gnustep-base">GNUStep</a>源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的</p>

<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld**">GitHub - opensource-apple/dyld</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15543839316178.html">线程安全与非线程安全</a></h1>
			<p class="meta"><time datetime="2019-04-04T21:18:51+08:00" 
			pubdate data-updated="true">04/04/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就存在<strong>竞态条件</strong>，而导致竞态条件发生的代码称为<strong>临界区</strong>。在临界区使用适当的同步可以避免竞态条件</p>

<p>允许被多个线程同时执行的代码称为<strong>线程安全的代码</strong>。其不包含竞态条件。</p>

<ol>
<li>共享资源：<br/>
当多个线程同时更新共享资源会引发竞态条件，多个线程对同一资源文件执行了写操作才会发生竞态条件，同时读取统一资源文件不会产生竞态条件</li>
<li>局部变量<br/>
局部变量是存在线程自己的栈中。局部变量永远不会被多个线程共享</li>
<li><p>局部对象引用<br/>
当局部变量是一个对象类型，对象的局部引用虽然没有被引用，但是引用的对象没有在栈中，所有的对象都在共享堆中，所以对对象的局部引用可能是不安全的；但是如果这个对象没有被其他方法或者全局变量获得，因此创建的对象没有逃逸，就是线程安全的</p></li>
<li><p>对象本身是线程安全的，但如果对象包含了其它其他资源(文件、数据库),也许就不再是线程安全的了</p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15547780131307.html">停止RunLoop</a></h1>
			<p class="meta"><time datetime="2019-04-09T10:46:53+08:00" 
			pubdate data-updated="true">04/09/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>启动一个runloop有以下三种方法</p>

<pre><code class="language-objectivec">- (void)run;  
- (void)runUntilDate:(NSDate *)limitDate；
- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;
</code></pre>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="15547780131307.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_33.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_31.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>