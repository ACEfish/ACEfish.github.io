<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  ACEfish的博客
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="ACEfish的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:acefish.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; ACEfish的博客</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="iOSDevelop.html">iOSDevelop</a></li>
        
            <li><a href="2017%E5%B9%B4%E3%80%82%E3%80%82%E3%80%82.html">2017年。。。</a></li>
        
            <li><a href="English.html">English</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14873831706932.html">
                
                  <h1>OCMock</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3 id="toc_0">Mock介绍</h3>

<p>对于一些不容易构造或不容易获取的对象，此时你可以创建一个虚拟的对象（mock object）来完成测试。</p>

<h3 id="toc_1">OCMock介绍</h3>

<p><a href="http://ocmock.org/features/">官方网站</a><br/>
根据要mock的对象的class来创建一个对应的对象，并且设置好该对象的属性和调用预定方法后的动作（例如返回一个值，调用代码块，发送消息等等），然后将其记录到一个数组中，接下来开发者主动调用该方法，最后做一个verify（验证），从而判断该方法是否被调用，或者调用过程中是否抛出异常等。</p>

<h4 id="toc_2">1.OCMock中简单使用</h4>

<ol>
<li><p>class mock一个对象</p>

<pre><code class="language-Object-c">id mockClass = OCMClassMock([SomeClass class]);
//创建mock object当做类的实例
</code></pre></li>
<li><p>Stubbing methods that return objects<br/>
<code>Object-c<br/>
/**<br/>
意的就是有参数的方法，参数是可以具体指定的，也就是说只有满足你指定的具体参数的调用才会被mock指定的返回值。例子中的[OCMArg any]是指任意参数。<br/>
*/<br/>
//没有参数的方法<br/>
OCMStub([mockClass someMethod]).andReturn(anObject);<br/>
//有参数的方法<br/>
OCMStub([mockClass someMethod:[OCMArg any]]).andReturn(anObject);<br/>
</code><br/>
注意:<br/>
<strong>OCMock会在mock实例上没有找到相同名字的实例方法的时候去找同名的类方法。</strong></p></li>
<li><p>Verify-after-running<br/>
有些时候需要验证我们执行的代码流程是否调用了某个外部的方法，这个时候用OCMock就比较简单来实现。如果没有调用过这个方法的话，会立即抛一个异常出来。</p>

<pre><code class="language-Object-c">id mockClass = OCMClassMock([SomeClass class]);
//...
//some code
//...
OCMVerify([mockClass someMethod]);
</code></pre></li>
<li><p>验证mock方法没有被调用<br/>
验证代码没有调用某个方法<br/>
如果方法被调用了，就将isCalled设置为YES，这样最后assert的时候就会报错。<br/>
<code>Object-c<br/>
static BOOL isCalled = false;<br/>
id mockClass = OCMClassMock([SomeClass class]);<br/>
OCMStub([mockClass someMethod]).andDo(^(NSInvocation *invocation){<br/>
isCalled = YES;<br/>
});<br/>
//...<br/>
//some code<br/>
//...<br/>
XCTAssertFalse(isCalled);<br/>
</code></p></li>
<li><p>验证mock方法传入的参数<br/>
验证传递给外部调用的参数是否符合预期</p>

<pre><code class="language-Objec-c">id mockClass = OCMClassMock([SomeClass class]);
OCMStub([mockClass someMethod:[OCMArg checkWithBlock:^BOOL(id obj) {
//...
//some code
//...
return YES;
]]);
</code></pre></li>
<li><p>mock单例</p>

<p>如果我们mock的类是个单例的话，那么使用之前的方法进行mock是不会生效的。不过OCMock提供了一个很简单的解决方法，那就是调用单例返回mock</p>

<pre><code class="language-Object-c">id mockClass = OCMClassMock([SomeClass class]);
OCMStub([mockClass instanceMethod]).andReturn(mockClass);
</code></pre></li>
<li><p>The any constraint</p>

<pre><code class="language-Object-c">OCMStub([mock someMethodWithAnArgument:[OCMArg any]])
OCMStub([mock someMethodWithPointerArgument:[OCMArg anyPointer]])
OCMStub([mock someMethodWithSelectorArgument:[OCMArg anySelector]])

</code></pre></li>
<li><p>处理block参数<br/>
OCMock也可以处理block回调参数。block回调通常用于网络代码，数据库代码，或者在任何异步操作中。在这个例子中，思考下下面的方法：<br/>
<code>- (void)downloadWeatherDataForZip:(NSString *)zip callback:(void (^)(NSDictionary *response))callback;</code></p></li>
</ol>

<p>在这个例子中，我们有一个下载天气压缩数据的方法，并且把下载下来的dictionary代理到一个block的回调中。在测试中，我们通过预定义的天气数据来测试回调处理。这也是明智的测试失败场景。你永远不会知道网络上会返回你什么东西！</p>

<pre><code class="language-Object">OCMStub([groupModelMock downloadWeatherDataForZip:@&quot;80304&quot; callback:[OCMArg any]]]).andDo(^(NSInvocation *invocation){
        //2. declare a block with same signature
        void (^weatherStubResponse)(NSDictionary *dict);
        //3. link argument 3 with with our block callback
        [invoke getArgument:&amp;weatherStubResponse atIndex:3];
        //4. invoke block with pre-defined input
        NSDictionary *testResponse = @{@&quot;high&quot;: 43 , @&quot;low&quot;: 12};
        weatherStubResponse(groupMemberMock);
    });
    /**
        1.这个mock对象使用带NSInvocation参数的“andDo”方法。一个NSInvocation对象代表一
        个‘objectivetified’（实在不知道这个什么鬼）表现的方法调用。通过这个NSinvocation对
        象，使得拦截传递给我们的方法的block参数变得可能。
        2.用与我们测试的方法中相同的方法签名声明一个block参数。
        3.NSInvocation实例方法&quot;getArgument:atIndex:&quot;将赋值后的块函数传递都原始函数中定义
        的块函数中。注意：在Objective-C中，传递给任意方法的前两个参数都是“self”和“_cmd”.这是
        一个运行时的小功能以及用下标来获取NSInvocation参数时我们需要考虑的东西。
        4.最后，传递这个回调的预定义字典。
    */
</code></pre>

<h4 id="toc_3">2.OCMock简单示例</h4>

<p><img src="media/14873831706932/14873839517952.png" alt=""/></p>

<p>示例2：</p>

<pre><code class="language-Object-c">- (void)testStrictMock3{

    id classMock = OCMClassMock([TweetView class]);

    //设置期望或预设，这个classMock需要执行addTweet方法且参数不为nil。  不然的话会抛出异常
    //OCMExpect([classMock addTweet:[OCMArg isNotNil]]);
    //OCMStub([classMock addTweet:[OCMArg isNotNil]]);

    /* 如果不执行以下代码的话会抛出异常 */
    Tweet *testTweet = [[Tweet alloc] init];
    testTweet.userName = @&quot;齐滇大圣&quot;;
    [classMock addTweet:testTweet];

    OCMVerifyAll(classMock);
}
</code></pre>

<p>这表示一种友好的mock，不会在没有OCMExpect或OCMStub设置类的所有方法时抛出异常。以上代码把OCMExpect和OCMStub注释掉时不会报错。</p>

<p>还有一种表示严格的mock：OCMStrictClassMock，如果把OCMExpect和OCMStub注释掉时会报错，它要求你执行类中的所有方法，所以比较适合用来测试必须实现的方法，代码如下：</p>

<pre><code class="language-Object-c">- (void)testStrictMock3{
    id classMock = OCMStrictClassMock([TweetView class]);
    //OCMExpect([classMock addTweet:[OCMArg isNotNil]]);
    //OCMStub([classMock addTweet:[OCMArg isNotNil]]);

    Tweet *testTweet = [[Tweet alloc] init];
    testTweet.userName = @&quot;齐滇大圣&quot;;
    [classMock addTweet:testTweet]; 

    OCMVerifyAll(classMock);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%B5%8B%E8%AF%95.html'>测试</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14873195104181.html">
                
                  <h1>NSRunLoop</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在<code>主 dispatch/operation</code>队列中， <code>run loop</code> 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p>

<p><strong>一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的</strong><br/>
在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置<code>计时器</code>、使用<code>NSURLConnection</code>或者调用 <code>performSelector:withObject:afterDelay:</code>，其实背后都是 run loop 在处理这些异步任务。</p>

<p>run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行的一种聪明的做法。<br/>
* NSDefalutRunLoopMode : 默认Mode, 通常主线程在这个模式下运行<br/>
* UITrackingRunLoopMode : 滑动ScrollView是会切换到这个模式<br/>
* NSRunLoopCommonModes: 包括上面两个模式</p>

<p>例1:滑动ScrollView后系统把RunLoop切换为UITrackingRunLoopMode,因此加载默认模式中的定时器并不会执行,只有滚动停止回到默认模式才会继续执行。我们可以把定时器设为 <code>NSRunLoopCommonModes</code>的模式，并添加到 run loop 中；<br/>
<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>

<p>例2:当tableview的cell从网络异步加载图片, 加载完成后在主线程刷新显示图片, 这时滑动tableview会造成卡顿. 通常的思路是tableview滑动的时候延迟加载图片, 等停止滑动时再显示图片. 这里我们可以通过RunLoop来实现.<br/>
<code>[self.cellImageView performSelector:@sector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]];</code></p>

<p>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于<a href="https://objccn.io/issue-2-2/">常见的后台实践</a>的文章里阐述了一些关于这种模式的很好的例子。</p>

<p>如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14873150230777.html">
                
                  <h1>并发编程基础知识</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>基础容易混淆知识:</p>

<ol>
<li><p>串行(Serial) VS. 并行(Concurrent)<br/>
串行和并行描述的是任务和任务之间的执行方式. 串行是任务A执行完了任务B才能执行, 它们俩只能顺序   执行. 并行则是任务A和任务B可以同时执行.</p></li>
<li><p>同步(Synchronous) VS. 异步(Asynchronous)<br/>
同步和异步描述的其实就是函数什么时候返回. 比如用来下载图片的函数A: {download image}, 同步函数只有在image下载结束之后才返回, 下载的这段时间函数A只能搬个小板凳在那儿坐等... 而异步函数, 立即返回. 图片会去下载, 但函数A不会去等它完成. So, 异步函数不会堵塞当前线程去执行下一个函数!</p></li>
<li><p>并发(Concurrency) VS. 并行(Parallelism)</p>

<blockquote>
<p>并发是程序的属性(property of the program), 而并行是计算机的属性(property of the machine).<br/>
<img src="media/14873150230777/14873157020644.png" alt=""/></p>
</blockquote>

<p>并行和并发都是用来让不同的任务可以&quot;同时执行&quot;, 只是并发是伪同时, 而并行是真同时. 假设你有任务T1和任务T2(这里的任务可以是进程也可以是线程):</p>

<blockquote>
<p>其实我们平常说的并发编程包括狭义上的&quot;并行&quot;和&quot;并发&quot;, 你不能保证你的代码会被并行执行, 但你可以以并发的方式设计你的代码. 系统会判断在某一个时刻是否有可用的core(多核CPU核心), 如果有就并行(parallelism)执行, 否则就用context switch来分时并发(concurrency)执行. 最后再以Ray大神的话结尾: Parallelism requires Concurrency, but Concurrency does not guarantee Parallelism!</p>
</blockquote></li>
</ol>

<h1 id="toc_0">iOS多线程</h1>

<h2 id="toc_1">1.Pthrea</h2>

<p>可以自己了解</p>

<h2 id="toc_2">2.NSThread</h2>

<p>经过苹果封装后直接面对对象的，可以直接操控线程对象，但是生命周期需要我们自己管理，偶尔使用。例如<strong>NSThrea mainthread</strong>可以获取当前线程类，知道当前线程的各种属性用于调试  </p>

<h3 id="toc_3">创建线程并启动</h3>

<ul>
<li>先创建再启动<br/>
<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];
[thread start];</code></li>
<li><p>创建并启动<br/><br/>
<code>[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];</code>  </p>

<ul>
<li>用oc方法创建启动（不安全）<br/>
<code>[self performSelectorInBackground:@selector(run:) withObject:nil];</code><br/></li>
<li><p>其他方法  </p>

<p>//取消线程</p>

<ul>
<li>(void)cancel;</li>
</ul>

<p>//启动线程<br/>
- (void)start;</p>

<p>//判断某个线程的状态的属性<br/>
@property (readonly, getter=isExecuting) BOOL executing;<br/>
@property (readonly, getter=isFinished) BOOL finished;<br/>
@property (readonly, getter=isCancelled) BOOL cancelled;</p>

<p>//设置和获取线程名字<br/>
-(void)setName:(NSString *)n;<br/>
-(NSString *)name;</p>

<p>//获取当前线程信息<br/>
+ (NSThread *)currentThread;</p>

<p>//获取主线程信息<br/>
+ (NSThread *)mainThread;</p>

<p>//使当前线程暂停一段时间，或者暂停到某个时刻<br/>
+ (void)sleepForTimeInterval:(NSTimeInterval)time;<br/>
+ (void)sleepUntilDate:(NSDate *)date; </p></li>
</ul></li>
</ul>

<h2 id="toc_4">3.GCD</h2>

<p>Grand Central Dispatch,是苹果为多核并行运算提出的解决办法，或自动管理线程生命周期</p>

<h3 id="toc_5">任务和队列</h3>

<p>这是在GCD中此案有的重要概念：<strong>任务</strong>和<strong>队列</strong><br/>
* 任务：即即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： <strong>同步执行</strong> 和 <strong>异步执行</strong>，他们之间的区别是<strong><em>是否会创建新的线程</em></strong>。     </p>

<pre><code>    同步（sync）和异步（async）的主要区别是在于会不会阻塞当前线程，直到block中任务执行完毕；  
    同步就是阻塞当前线程并等待block中的任务执行完毕，然后线程会继续向下执行，异步操作当前线程会继续向下执行
</code></pre>

<ul>
<li>队列：用于存放任务。一共有两种队列，串行和并行队列
<strong>串行队列</strong>：放在串行队列中的任务，GCD会FIFO的取出来，执行，然后取出下一个<br/></li>
</ul>

<p><strong>并行队列</strong>：在并行队列中的任务，GCD也会FIFO的取出来，但不同的是，取出来一个后就会放到别的线程，然后取出来再放到另一个线程，取的动作很快，看起来所有是同时执行。注意：GCD会根据系统资源控制并行数量，所以如果任务很多，并不会让人物同时执行  </p>

<h3 id="toc_6">创建队列</h3>

<ul>
<li><h5 id="toc_7">主队列</h5>

<p>特殊的 串行队列。它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。</p>

<pre><code>     //OBJECTIVE-C
    dispatch_queue_t queue = ispatch_get_main_queue();

      //SWIFT
      let queue = ispatch_get_main_queue()  
</code></pre></li>
<li><h5 id="toc_8">自己创建的队列</h5>

<p>自己可以创建 串行队列, 也可以创建 并行队列。看下面的代码（代码已更新），它有两个参数，第一个上面已经说了，第二个才是最重要的。第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>

<p>queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, NULL);<br/>
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL);<br/>
  //并行队列<br/>
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</p>

<p>//SWIFT<br/>
  //串行队列<br/>
  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, nil);<br/>
  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL)<br/>
  //并行队列<br/>
  let queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT)</p></li>
<li><h4 id="toc_9">全局并行队列</h4>

<p>一般只要是并行任务都加到这个队列<br/>
  //OBJECTIVE-C<br/>
  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>//SWIFT<br/>
  let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</p></li>
</ul>

<h3 id="toc_10">创建任务</h3>

<ul>
<li><h5 id="toc_11">同步任务：会阻塞当前线程</h5>

<pre><code>dispatch_sync(&lt;#queue#&gt;, ^{
</code></pre>

<p>//code here<br/>
  NSLog(@&quot;%@&quot;, [NSThread currentThread]);<br/>
    });</p></li>
<li><h5 id="toc_12">异步任务：不会阻塞当前线程</h5>

<pre><code>dispatch_async(&lt;#queue#&gt;, ^{
    //code here
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
});
</code></pre></li>
</ul>

<h3 id="toc_13">更好的理解同步异步以及各种队列的使用</h3>

<pre><code>同步任务会阻塞当前线程，然后把block块中的任务放到指定队列中执行，等到block任务完成后会让当前线程继续往下执行  
同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回.
</code></pre>

<h3 id="toc_14">队列组的使用</h3>

<p>可以将很多丢列添加到一个组中，这样的话，当这个组中所有任务都执行完了，队列会通过一个方法通知我们  </p>

<pre><code>//1.创建队列组
dispatch_group_t group = dispatch_group_create();
//2.创建队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue, ^{
    for (NSInteger i = 0; i &lt; 3; i++) {
        NSLog(@&quot;group-01 - %@&quot;, [NSThread currentThread]);
    }
});

//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue(), ^{
    for (NSInteger i = 0; i &lt; 8; i++) {
        NSLog(@&quot;group-02 - %@&quot;, [NSThread currentThread]);
    }
});

//3.3.执行5次循环
dispatch_group_async(group, queue, ^{
    for (NSInteger i = 0; i &lt; 5; i++) {
        NSLog(@&quot;group-03 - %@&quot;, [NSThread currentThread]);
    }
});

//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@&quot;完成 - %@&quot;, [NSThread currentThread]);
});
SWIFT
//1.创建队列组
let group = dispatch_group_create()
//2.创建队列
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue) { () -&gt; Void in
    for _ in 0..&lt;3 {
        NSLog(&quot;group-01 - %@&quot;, NSThread.currentThread())
    }
}

//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue()) { () -&gt; Void in
    for _ in 0..&lt;8 {
        NSLog(&quot;group-02 - %@&quot;, NSThread.currentThread())
    }
}

//3.3.执行5次循环
dispatch_group_async(group, queue) { () -&gt; Void in
    for _ in 0..&lt;5 {
        NSLog(&quot;group-03 - %@&quot;, NSThread.currentThread())
    }
}

//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue()) { () -&gt; Void in
    NSLog(&quot;完成 - %@&quot;, NSThread.currentThread())
}
</code></pre>

<p><strong>关于GCD还有两点要说的</strong><br/><br/>
* <code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</code><br/><br/>
这个方法重点是传入的queue，当你传入的queue是通过<code>DISPATCH_QUEUE_CONCURRENT</code>参数自己创建的queue时，这个方法会阻塞这个queue（注意是阻塞queue，而不是阻塞当前线程），一直等到这个queue中排在他前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，是这个queue中排在他后面的任务继续执行。但是如果你传入的是其他queue，那他和dispatch_async一样了<br/><br/>
* <code>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</code><br/><br/>
这个方法的使用和上一个一样，传入自定义的并发队列（<strong>DISPATCH_QUEUE_CONCURRENT</strong>），会阻塞queue，不同的是这个方法还会阻塞当前线程，，但是如果你传入其他queue就和dispatch_sync一样了  </p>

<h3 id="toc_15">线程同步</h3>

<ul>
<li><h5 id="toc_16">互斥锁：</h5>

<p>给需要同步的代码加一个互斥锁保证每次只有一个线程访问此代码块</p>

<pre><code>    //OBJECTIVE-C
    @synchronized(self) {
        //需要执行的代码块
    }
    //SWIFT
    objc_sync_enter(self)
    //需要执行的代码块
    objc_sync_exit(self)
</code></pre></li>
<li><h5 id="toc_17">同步执行：</h5>

<p>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 <code>GCD</code> 和 <code>NSOperation</code> 两种方案，我都写出来。</p>

<pre><code>//OBJECTIVE-C
      //GCD
      //需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中
      dispatch_sync(queue, ^{
          NSInteger ticket = lastTicket;
          [NSThread sleepForTimeInterval:0.1];
          NSLog(@&quot;%ld - %@&quot;,ticket, [NSThread currentThread]);
          ticket -= 1;
          lastTicket = ticket;
      });

      //NSOperation &amp; NSOperationQueue
      //重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中
      //       2. 设置 queue 的 maxConcurrentOperationCount 为 1
      //       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！

      NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
          NSInteger ticket = lastTicket;
          [NSThread sleepForTimeInterval:1];
          NSLog(@&quot;%ld - %@&quot;,ticket, [NSThread currentThread]);
          ticket -= 1;
          lastTicket = ticket;
      }];

      [queue addOperation:operation];

      [operation waitUntilFinished];

      //后续要做的事
</code></pre></li>
<li><h5 id="toc_18">延迟执行：</h5>

<pre><code>//OBJECTIVE-C（这个方法在swift中去掉了）
    // 3秒后自动调用self的run:方法，并且传递参数：@&quot;abc&quot;
    [self performSelector:@selector(run:) withObject:@&quot;abc&quot; afterDelay:3];
    //GCD
    // 创建队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 设置延时，单位秒
    double delay = 3; 

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
        // 3秒后需要执行的任务
    });
</code></pre></li>
<li><h5 id="toc_19">单例模式：</h5>

<pre><code>OBJECTIVE-C
    @interface Tool : NSObject &lt;NSCopying&gt;

    + (instancetype)sharedTool;

    @end

    @implementation Tool

    static id _instance;

    + (instancetype)sharedTool {
        static dispatch_once_t onceToken;
        dispatch_once(&amp;onceToken, ^{
            _instance = [[Tool alloc] init];
        });

        return _instance;
    }

    @end
    swift
        class Tool: NSObject {
        static let sharedTool = Tool()

        // 私有化构造方法，阻止其他对象使用这个类的默认的&#39;()&#39;构造方法
        private override init() {}
        }
</code></pre></li>
</ul>

<h3 id="toc_20">从其他线程回到主线程的方法</h3>

<ul>
<li><h5 id="toc_21">NSThread</h5>

<pre><code>//Objective-C
[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];

//Swift
//swift 取消了 performSelector 方法。
</code></pre></li>
<li><h5 id="toc_22">GCD</h5>

<pre><code>//Objective-C
dispatch_async(dispatch_get_main_queue(), ^{

});

//Swift
dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in

})
</code></pre></li>
<li><h5 id="toc_23">NSOperationQueue</h5>

<pre><code>//Objective-C
[[NSOperationQueue mainQueue] addOperationWithBlock:^{

}];

//Swift
NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in

}
</code></pre></li>
</ul>

<h2 id="toc_24">评论补充</h2>

<pre><code>同步派发(sync)会尽可能地在当前线程派发任务.但如果在其他队列往主队列同步派发,任务会在主线程执行.
异步派发(async)也不绝对会另开线程.例如在主线程异步派发到主线程,派发依旧是异步的,任务也会在主线程执行.
我感觉同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回.

无论串行还是并发队列,任务启动顺序都是按照 FIFO 的,只是并发队列允许同一时间有多个任务执行都在执行.

创建队列

也可以自己创建并发队列.
dispatch_queue_create(&quot;我是私有串行队列&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_queue_create(&quot;我是私有并发队列&quot;, DISPATCH_QUEUE_CONCURRENT);

dispatch_async(dispatch_get_main_queue()) {
// Swift 中用尾闭包写法感觉更美观.
}

关于同步,还有这么个东西:
dispatch_barrier_async(privateConcurrentQueue, ^{
// 写入操作会确保队列前面的操作执行完毕才开始,并会阻塞队列中后来的操作.
});

dispatch_sync(privateConcurrentQueue, ^{
// 只要没有写入操作,多个读取操作是相对并行的.
});
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%A4%9A%E7%BA%BF%E7%A8%8B.html'>多线程</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_7.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_9.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>ACEfish的博客</h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="iOSDevelop.html"><strong>iOSDevelop</strong></a>
        
            <a href="2017%E5%B9%B4%E3%80%82%E3%80%82%E3%80%82.html"><strong>2017年。。。</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14913623029277.html">基于定时器的动画</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14906168166224.html">缓冲</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14905958336865.html">图层时间</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14903444013647.html">CAAnimation</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14903384285214.html">显式动画</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
