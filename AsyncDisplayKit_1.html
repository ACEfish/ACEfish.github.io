
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  AsyncDisplayKit - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15694018519470.html">优化</a></h1>
			<p class="meta"><time datetime="2019-09-25T16:57:31+08:00" 
			pubdate data-updated="true">09/25/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Layer 支持</h2>

<p>在某些情况下 使用<code>Layer</code>代替<code>View</code>能显著提高app的性能。建议在不需要任何触摸处理的自定义节点中启用<code>layer-backing</code></p>

<p>在UIKit中，因为API的不同， 手动将基于View的视图转换为layer是非常费力的。并且如果将来需要启用触摸处理，就只能将所有内容都转换回去</p>

<p>在<code>Texture</code>中，可以很简单的将整个view树转换为layer树，如果想要改回用view，直接删掉这行代码即可</p>

<pre><code class="language-objectivec">rootNode.isLayerBacked = YES;
</code></pre>

<h2 id="toc_1">子树光栅化</h2>

<p>将整个视图层次结构展平为一个图层，可以提高性能。但是，当使用UIKit时，可维护性和层次结构受到冲击</p>

<pre><code class="language-objectivec">[rootNode enableSubtreeRasterization];
</code></pre>

<p>这行代码将会造成该节点的整个节点层次结构呈现为一层。</p>

<h2 id="toc_2">同步并发</h2>

<p><code>ASViewController</code>和<code>ASCellNode</code>中都有<code>neverShowPlaceholders</code>属性</p>

<p>设置该属性为YES后，主线程将会被阻塞只到<code>cell</code>或者<code>VC的view</code>被展示完成</p>

<p>虽然使用这个选项会类似UIKit阻塞主线程直到绘制完成，但是并没有减少Texture带来的优化。因为预加载的存在，一个node当到达屏幕显示范围时，已经几乎加载完成，因此阻塞主线程的时间也会很短。即使<code>rangeTuningParameters</code>属性被设置为0，其表现效果也好于<code>UIKit</code>。而且，因为主线程处于阻塞等待状态，所有的子节点都会并发的的diaplay。因此叫做<mark>同步并发</mark></p>

<pre><code class="language-objectivec">node.neverShowPlaceholders = YES;
</code></pre>

<p>通常，当cell在到达屏幕展示范围还没有完成展示渲染时，将会展示占位图直到内容被绘制完成。设置该属性为YES后，node或者<code>ASViewController</code>滚动起来更像UIKit.(事实上，除了Texture更快之外，并没有其他什么区别)</p>

<h2 id="toc_3">圆角</h2>

<p>我们经常会使用<code>CALayer</code>的<code>.cornerRadius</code>属性在实现圆角。不幸的是，这个方便的属性会造成严重的性能损失，因此只在别无选择时才会选择使用。</p>

<h3 id="toc_4">为什么.cornerRadius如此昂贵</h3>

<p>使用<code>CALayer</code>的<code>.cornerRadius</code>属性会触发离屏渲染，即每帧(当滚动时为60FPS)都执行剪切操作，即使此时该内容区域的内容并没有变化。这意味着GPU必须在每帧之间切换上下文，在合成整个帧与使用.cornerRadius的附加遍历之间</p>

<p>重要的是，这些消耗并不会显示在<code>Time Profile</code>中，因为它影响的是CoreAnimation Render Server在App自身的工作完成。这会影响许多设备的性能。</p>

<h3 id="toc_5">使用圆角策略需要考虑的情况</h3>

<ol>
<li>在圆角之下是否存在背景移动: 指的是拐角位置之后的任何运动</li>
<li>是否存在穿过圆角区域的移动:</li>
<li>是否4个角处于相同的node，并且拐角区域没有和其它节点相交</li>
</ol>

<blockquote>
<p>注意</p>

<p>可以再圆角内部有移动 而无需穿过拐角区域。例如，当移动插入时，其边距大小为角半径大小，因此当内容滚动时，也不会在拐角移动。我们也可以利用这种策略消除拐角的移动，</p>
</blockquote>

<h3 id="toc_6">圆角预合成</h3>

<p>圆角预合成是指使用贝塞尔曲线绘制角点，然后在<code>CGContet/UIGraphicsContext</code>中剪切内容(<code>[path clip]</code>)。此时圆角就成为了图像的一部分并且被渲染到单个CALayer中。有两种类型的预合成圆角:</p>

<ol>
<li>最好的预合成圆角是使用预合成的不透明角，这是最有效的方法，可以实现零alpha混合。可惜这种方法并不灵活，如果圆角图像需要在其顶部移动，则其圆角后的背景需要为纯色。</li>
<li>第二种方法涉及使用带有预合成Alpha角的贝塞尔曲线路径。这个方法就很灵活了，是最常用的方法之一，但是增加了整个内容上Alpha混合的成本，虽然比不透明的预合成增加25%的内存，但是在现代设备上这些影响很小</li>
</ol>

<p>这些预合成圆角的关键是，圆角只能接触一个节点，而且能与其他圆角相交。如果上面所说的存在任何一种情况，则必须使用夹角</p>

<blockquote>
<p>注意</p>

<p>Texture node对<code>.corenerRaduis</code>具有特殊的优化，仅仅当启用<code>shouldRasterizeDescendants</code>时(启用光栅化)，自动实现预合成</p>

<p>Texture提供了方便的方法来创建简单、纯色的圆角矩形或圆形。<br/>
可以看<code>UIImage + ASConveniences.h</code>类，了解使用预合成的角(包括alpha和不透明)创建纯色、圆角可调整的图像。这对于使用image node作为<code>placeholders</code>或者ASButtonNode作为背景</p>
</blockquote>

<h3 id="toc_7">夹角</h3>

<p>(即用4个角将四周覆盖)<br/>
这个解决策略包含了将4个单独的不透明角图层放置在四角。这个方法非常灵活，并且性能很好。它具有4个单独层的CPU开销</p>

<p>这种夹角策略适合两种主要类型的圆角情况:</p>

<ul>
<li>圆角接触了多个节点或者与任何节点相交的情况下的圆角</li>
<li>在固定的Texture或者照片背景上增加圆角。虽然夹角方法很复杂，但是很有用哦</li>
</ul>

<h3 id="toc_8">使用CALayer的.cornerRadius属性</h3>

<p>在一些极少数情况下，很适合使用<code>.cornerRaduis</code>属性，包括当动态内容同时在内部和圆角移动。对于某些动画，这是不可避免的。但是在很多情况下，可以通过调整设计消除运动源。</p>

<p>对于没有任何移动的屏幕，使用<code>.cornerRadius</code>危害也会小很多，也可以作为快捷方式。然而当屏幕上有任何移动，甚至不涉及角的移动，都将会造成<code>.cornerRadius</code>的性能折扣。例如：在导航栏中存在一个圆形元素，在其下方存在滚动视图，即使它们不重叠 也会造成影响。即使用户不与其进行互动，也会对屏幕中的所有内容进行动画处理。此外，任何屏幕上刷新都会造成圆角成本消耗</p>

<h3 id="toc_9">光栅化和图层支持</h3>

<p>并不能随便使用<code>.shouldRasterize</code>来提高<code>.cornerRaduis</code>属性性能。只要没有造成重新的光栅化的操作(例如，移动、点击更改颜色、不在移动的table之上等)，就是可以使用的。通常，不鼓励这么做，很容易导致性能下降。</p>

<p><code>CALayer</code>的<code>.shouldRasterize</code>和<code>Texture</code>的<code>node.shouldRasterizeDescendents.</code>无关。启用时，<code>.shouldRasterizeDescendents</code>将会阻止创建子节点子级的实际图层和层。</p>

<h3 id="toc_10">圆角策略选取</h3>

<p><img src="media/15694018519470/15695659459083.png" alt=""/></p>

<h3 id="toc_11">Texture对圆角的支持</h3>

<ol>
<li><p>使用<code>.cornerRadius</code></p>
<pre><code class="language-objectivec">CGFloat cornerRadius = 20.0;
_photoImageNode.cornerRoundingType = ASCornerRoundingTypeDefaultSlowCALayer;<br/>
_photoImageNode.cornerRadius = cornerRadius;
</code></pre></li>
<li><p>使用预合成的圆角</p>
<pre><code class="language-objectivec">CGFloat cornerRadius = 20.0;
_photoImageNode.cornerRoundingType = ASCornerRoundingTypePrecomposited;<br/>
_photoImageNode.cornerRadius = cornerRadius;
</code></pre></li>
<li><p>使用夹角 圆角</p>
<pre><code class="language-objectivec">CGFloat cornerRadius = 20.0;
_photoImageNode.cornerRoundingType = ASCornerRoundingTypeClipping;<br/>
_photoImageNode.backgroundColor = [UIColor whiteColor];<br/>
_photoImageNode.cornerRadius = cornerRadius;
</code></pre></li>
<li><p>使用<code>willDisplayNodeContentWithRenderingContext</code>设置内容的剪切路径和圆角</p>
<pre><code class="language-objectivec">CGFloat cornerRadius = 20.0;
// Use the screen scale for corner radius to respect content scale<br/>
CGFloat screenScale = UIScreen.mainScreen.scale;<br/>
_photoImageNode.willDisplayNodeContentWithRenderingContext = ^(CGContextRef context, id drawParameters) {<br/>
    CGRect bounds = CGContextGetClipBoundingBox(context);<br/>
    CGFloat radius = cornerRadius * screenScale; <br/>
    UIImage *overlay = [UIImage as_resizableRoundedImageWithCornerRadius:radius<br/>
                                                             cornerColor:[UIColor clearColor]<br/>
                                                               fillColor:[UIColor clearColor]];<br/>
    [overlay drawInRect:bounds];<br/>
    [[UIBezierPath bezierPathWithRoundedRect:bounds cornerRadius:radius] addClip];<br/>
};
</code></pre></li>
<li><p>使用<code>ASImageNode</code> 使图像变圆 并添加边框<br/>
    这非常适合头像图片的圆角</p>
<pre><code class="language-objectivec">CGFloat cornerRadius = 20.0;
_photoImageNode.imageModificationBlock = ASImageNodeRoundBorderModificationBlock(5.0, [UIColor orangeColor])
</code></pre></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15693141187091.html">Teture的便捷性</a></h1>
			<p class="meta"><time datetime="2019-09-24T16:35:18+08:00" 
			pubdate data-updated="true">09/24/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Hit Test Slop</h2>

<p><code>ASDisplayNode</code>提供了<code>UIEdgeInset</code>类型的属性，当设置为非0的inset时，提高点击命中范围，使其更容易点击或执行手势</p>

<p>因为<code>ASDisplayNode</code>是所有node的基类，因此所有的<code>texture</code>node都有这个属性</p>

<blockquote>
<p>注意</p>

<p>这个属性影响了<code>-hitTest</code>和<code>-pointInside</code>，所以在重写这个方法时 建议调用<code>super</code></p>
</blockquote>

<p>节点捕获触摸事件的能力受到父节点的边界和父级<code>hitTestSlop</code>属性的限制。如果你想让子项的<code>hitTestSlop</code>扩展到父项的边界之外，只需要扩展父节点的<code>hitTestSlop</code>即可</p>

<p>示例：<br/>
当有一个文本节点作为按钮时，通常，文本节点高度通常不会达到要求的最低44的点击高度，此时，可以计算出区域差，并对标签应用inset来增加点击区域</p>

<pre><code class="language-objectivec">ASTextNode *textNode = [[ASTextNode alloc] init];
CGFloat padding = (44.0 - button.bounds.size.height)/2.0;
textNode.hitTestSlop = UIEdgeInsetsMake(-padding, 0, -padding, 0);
</code></pre>

<h2 id="toc_1">批量获取API</h2>

<p>Texture的批量获取API，用于批量获取数据块。这个通常在会写在<code>-scrollViewDidScroll:</code>方法中，但是<code>Texture</code>提供了更结构化的机制</p>

<p>默认，当用户滑动table或者collection，当那里距离屏幕底部2个屏幕远时，会试着获取更多的数据。我们可以通过调整<code>ASTableView</code>或者<code>ASCollectionView</code>的<code>leadingScreensForBatching</code>属性</p>

<pre><code class="language-objectivec">tableNode.view.leadingScreensForBatching = 3.0;  // overriding default of 2.0
</code></pre>

<h3 id="toc_2">代理方法</h3>

<p>实现该代理方法  决定是否需要加载新内容数据</p>

<pre><code class="language-objectivec">- (BOOL)shouldBatchFetchForTableNode:(ASTableNode *)tableNode
{
  if (_weNeedMoreContent) {
    return YES;
  }

  return NO;
}
</code></pre>

<p>当用户滚动到批量获取范围时，会调用该方法，我们通常根据是否还有数据需要获取来决定是否需要会进行批量获取请求，当返回YES时 就会进行接下来的步骤:</p>

<pre><code class="language-objectivec">-tableNode:willBeginBatchFetchWithContext:
-collectionNode:willBeginBatchFetchWithContext:
</code></pre>

<p>我们在这个方法中 执行数据获取(从网络或者本地数据库获取数据)</p>

<blockquote>
<p>注意</p>

<p>这个方法总是在后台线程中调用，意味着如果需要工作在主线程中，就需要dispatch其到主线程</p>
</blockquote>

<pre><code class="language-objectivec">- (void)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context 
{
  // Fetch data most of the time asynchronously from an API or local database
  NSArray *newPhotos = [SomeSource getNewPhotos];

  // Insert data into table or collection node
  [self insertNewRowsInTableNode:newPhotos];

  // Decide if it&#39;s still necessary to trigger more batch fetches in the future
  _stillDataToFetch = ...;

  // Properly finish the batch fetch
  [context completeBatchFetching:YES];
}
</code></pre>

<p>当完成数据获取时，需要调用<code>-completeBatchFetching:</code>方法传递参数YES来通知已经结束数据获取。这确保了批量获取机制可以同步进行，并且下次批量获取可以发生了。只有传递YES，context才知道可以尝试另外一批更新。</p>

<h2 id="toc_3">自动节点管理</h2>

<p><a href="https://texturegroup.org/docs/automatic-subnode-mgmt.html">自动节点管理</a></p>

<p>当我们需要使用<code>Layout Transition api</code>时，就需要启用自动节点管理功能。然而，不需要动画的功能，也会从代码量的减小中受益</p>

<p>启用了自动节点管理功能，说明我们不再需要再调用<code>addNode</code>或者<code>removeNode</code>方法。节点的存在与否完全由<code>layoutSpecThatFits:</code>方法决定</p>

<h3 id="toc_4">更新ASLayoutSpec</h3>

<p>当需要更改<code>ASLayoutSepec</code>时，我们需要手动调用<code>setNeedLayout</code>。这个等效于<code>Transition Layout API</code>中的<code>transitionLayout: duration:0</code>。</p>

<p>正确构造的<code>ASLayoutSpec</code>知道需要添加、删除或设置动画的子节点。</p>

<blockquote>
<p>注意</p>

<p>在启用的自动节点管理后，就不能再调用<code>addSubnode:</code>和<code>removeFromSupernode</code>方法</p>
</blockquote>

<h2 id="toc_5">反转</h2>

<p><code>ASTableNide</code>和<code>ASCollectionNide</code>具有BOOL类型的反转属性，当设置为YES时，将自动反转内容可以自下向上布局(即indexPath为(0,0)的位于底部)，这对于聊天应用是十分方便的，而且仅需要一个属性</p>

<pre><code class="language-objectivec"> CGFloat inset = [self topBarsHeight];
 self.tableNode.view.contentInset = UIEdgeInsetsMake(0, 0, inset, 0);
 self.tableNode.view.scrollIndicatorInsets = UIEdgeInsetsMake(0, 0, inset, 0);
  
</code></pre>

<h2 id="toc_6">图像修改block</h2>

<p>大多数时候，我们在主线程进行大量修改图像外观的操作，我们当然希望将其移动到后台</p>

<p>通过给<code>imageNode</code>设置<code>imageModificationBlock</code>,定义一系列的转换，这些转换与imageNode上设置的图像异步发生</p>

<pre><code class="language-objectivec">//举例
_backgroundImageNode.imageModificationBlock = ^(UIImage *image) {
    UIImage *newImage = [image applyBlurWithRadius:30
        tintColor:[UIColor colorWithWhite:0.5 alpha:0.3]
        saturationDeltaFactor:1.8
        maskImage:nil];
    return newImage ?: image;
};

//some time later...

_backgroundImageNode.image = someImage;
</code></pre>

<p>此时，每当把照片分配给imageNode前，都需要进行异步处理</p>

<h3 id="toc_7">添加图像效果</h3>

<p>利用<code>imageModificationBlock</code>给图像添加效果是很有效的，当提供了block时，可以再显示阶段对图像执行绘制操作。由于显示是在后台执行的，因此不会阻塞主线程</p>

<p><code>imageModificationBlock</code>可以非常方便的用于添加各种图像效果</p>

<p>举个例子：<br/>
我们有一个图像节点，并且<code>imageNode</code>需要被切圆角。我们可以提供一个<code>imageModificationBlock</code>，可以方便的将传入的图像切圆并且返回</p>

<pre><code class="language-objectivec">- (instancetype)init
{
// ...
  _userAvatarImageNode.imageModificationBlock = ^UIImage *(UIImage *image) {
    CGSize profileImageSize = CGSizeMake(USER_IMAGE_HEIGHT, USER_IMAGE_HEIGHT);
    return [image makeCircularImageWithSize:profileImageSize];
  };
  // ...
}

//绘图代码抽象为UIImage的匪类中
@implementation UIImage (Additions)
- (UIImage *)makeCircularImageWithSize:(CGSize)size
{
  // make a CGRect with the image&#39;s size
  CGRect circleRect = (CGRect) {CGPointZero, size};

  // begin the image context since we&#39;re not in a drawRect:
  UIGraphicsBeginImageContextWithOptions(circleRect.size, NO, 0);

  // create a UIBezierPath circle
  UIBezierPath *circle = [UIBezierPath bezierPathWithRoundedRect:circleRect cornerRadius:circleRect.size.width/2];

  // clip to the circle
  [circle addClip];

  // draw the image in the circleRect *AFTER* the context is clipped
  [self drawInRect:circleRect];

  // get an image from the image context
  UIImage *roundedImage = UIGraphicsGetImageFromCurrentImageContext();

  // end the image context since we&#39;re not in a drawRect:
  UIGraphicsEndImageContext();

  return roundedImage;
}
@end
</code></pre>

<h2 id="toc_8">Placeholders</h2>

<p>任何<code>ASDisplayNode</code>的子类都实现了<code>-placeholderImage</code>方法，提供了一个覆盖内容的的占位图，直到node内容显示。<br/>
通过设置<code>.placeholderEnabled = YES</code>以及可选属性<code>.placeholderFadeDuration</code><br/>
对于image drawing，使用node的<code>.calculateSize</code>属性</p>

<blockquote>
<p>注意</p>

<p>因为<code>placeholderImage</code>函数有可能在后台调用，因此我们需要保证其线程安全。注意，利用 <code>-[UIImage imageNamed:]</code>使用image asset不是线程安全,可以代替的使用<code>-[UIImage imageWithContentsOfFile:]</code></p>
</blockquote>

<p><code>Texture</code>中的<code>UIImage + ASConvenience</code>类别方法是创建占位符图像的理想资源，包括圆形，矩形，单色或简单的方角图像。</p>

<h3 id="toc_9">.neverShowPlaceholders</h3>

<h3 id="toc_10">ASNetworkImageNode also have Default Images</h3>

<p>对于<code>ASNetworkImageNode</code>除了展位图像还有 <code>.defaultImage</code>属性。虽然占位符是暂时的，但如果图像节点.URL属性是nil或者URL加载失败，则默认图像将保留。建议使用默认图像</p>

<h2 id="toc_11">Accessibility</h2>

<h2 id="toc_12">UICollectionViewCell的互通性</h2>

<p><code>Texture</code>提供了<code>UICollectionViewCell</code>和<code>ASCellNodes</code>的互通性</p>

<blockquote>
<p>注意</p>

<p>UIKit中的cell即使混杂在<code>ASCollectionNode</code>中，也并不会有类似<code>ASCellNodes</code>的便捷收益(类似，预加载，异步布局，异步绘图等)</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15688983880412.html">Layout</a></h1>
			<p class="meta"><time datetime="2019-09-19T21:06:28+08:00" 
			pubdate data-updated="true">09/19/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>学习自<a href="https://texturegroup.org/docs/layout2-quickstart.html">Texture-Quickstart</a></p>

<p>因为UIKit的<code>Auto Layout</code>框架 在视图层次变得复杂的时候，布局成本会成倍增加。(已经在iOS12中修复)</p>

<p><code>Texture</code>提供的layout的api相比有很多优点</p>

<ol>
<li>与手动使用layout布局一样快速</li>
<li>布局可以在后台计算，因此不会影响用户交互</li>
<li>布局采用了 不可变数据结构声明。</li>
<li>布局结果是不可变的数据结构，就可以提前预计算并缓存，提高用户体验</li>
<li>可扩展</li>
</ol>

<h4 id="toc_0">Layout Specs</h4>

<p><code>layout specs</code>并没有物理呈现。它通过了解这些子布局元素如何相互关联来充当其他布局元素的容器，完成对布局元素的位置排列。</p>

<p><code>Texture</code>提供了一些<code>ASLayoutSpec</code>的子类，包括从插入一个简单的布局规范到在不同堆栈中布置元素的的复杂规范</p>

<h4 id="toc_1">Layout Elements</h4>

<p><code>Layout spec</code>包含<code>Layout Elements</code>，并且对<code>LayoutElements</code>进行整理</p>

<p>所有的<code>ASDisplayNode</code>和<code>ASLayoutSec</code>遵循<code>&lt;ASLayoutElement&gt;</code>协议。意味着我们可以通过不同的node或者layout Specs来组成其它布局规范</p>

<p><code>&lt;ASLayoutElement&gt;</code>协议有一些属性用于创建非常复杂的布局。</p>

<h3 id="toc_2">组合Layout Specs和Layout Elements 进行布局</h3>

<h2 id="toc_3">Layout Specs</h2>

<h3 id="toc_4">ASWrapperLayoutSpec</h3>

<p><code>ASLayoutSpec</code>的一个简单的子类，可以封装一个<code>ASLayoutElement</code>元素并且根据Element上设置的大小计算元素的布局</p>

<p>通常用于在<code>layyoutSpecThatFits:</code>方法中返回一个单一的元素。这个元素可以设置大小布局信息。但是，如果你想设置postion而不仅仅只是大小，可以使用<code>ASAbsoluteLayoutSpec</code></p>

<h3 id="toc_5">ASStackLayoutSpec</h3>

<p>这个<code>spec</code>是最有用的。<code>ASStackLayoutSpec</code>使用flexbox布局算法 决定子元素的位置和大小。</p>

<p><code>ASStackLayoutSpec</code>有7个属性</p>

<ul>
<li>direction： 指定stack方向。当指定<code>horizontalAligment/verticalAligment</code>属性时，会被重新解析，而造成<code>justifyContent</code>和<code>alignItems</code>相应更新</li>
<li>spacing：每个子元素的间距</li>
<li>horizontalAligment：指定子元素如何水平对齐，根据堆栈方向，设置对齐方式会导致<code>justifyContent</code>和<code>alignItems</code>更新。即使direction更改，此属性将会仍然有效。</li>
<li>verticalAligment</li>
<li>justifyContent： 指定在主轴上的对齐方式</li>
<li>aligItems： 横轴上的对齐方式</li>
<li>flexWrap： 是否子元素被堆栈为单行或者多行。默认为单行</li>
<li>aligContent：</li>
</ul>

<blockquote>
<p>注意</p>

<p>与CSS中的flex 默认方向不同 而且并没有<code>flex</code>参数</p>
</blockquote>

<h3 id="toc_6">ASInsetLayoutSpec</h3>

<p><code>ASInsetLayoutSpec</code>将其<code>constrainedSize.max</code>减去insets之后得到的<code>CGSize</code>传递给子节点，一旦子节点去定了它的size，<code>insetSpec</code>将最终size作为子节点的<code>size</code>和<code>margin</code></p>

<p>如果将<code>UIEdgeInsets</code>中的一个值设置为INFINITY，则将只使用子节点的固有大小</p>

<h3 id="toc_7">ASOverlayLayoutSpec</h3>

<p><code>ASOverlayLayoutSpec</code>则会将上面子节点延伸，覆盖一个子节点</p>

<p><code>OverlayLayoutSpec</code>的size根据字节点size计算，子节点是被覆盖的底层，然后将子节点的size作为<code>constrainedSize</code>传递给叠加的子节点。因此，被覆盖的子节点必须有固定大小或者明确设置的大小</p>

<h3 id="toc_8">ASBackgroundLayoutSpec</h3>

<p>与<code>ASOverlayLayoutSpec</code>刚好相反，其设置一个子节点内容，并将另外一个子节点拉伸为背景</p>

<p><code>ASBackgroundLayoutSpec</code>的size根据子节点的size确定，子节点size作为<code>constrainedSize</code>传递给背景子节点。因此 自己子节点也必须有固定大小或者明确设置的size</p>

<h3 id="toc_9">ASCenterLayoutSpec</h3>

<p><code>ASCenterLayoutSpec</code>将其子节点的中心设置为最大<code>constrainedSize</code>的中心</p>

<p>如果<code>ASCenterLayoutSpec</code>的宽度和高度没有约定，则会缩放到和子节点高度和宽度一致</p>

<p>属性：</p>

<ul>
<li>centeringOptions：决定如何在<code>ASCenterLayoutSpec</code>中居中，可选值包括<code>NONE  X  Y  XY</code></li>
<li>sizingOptions: 决定<code>ASCenterLayoutSpec</code>占用 多少空间，可选值为<code>Default,  minimun X, minimun Y, minimun XY</code></li>
</ul>

<h3 id="toc_10">ASRatioLayoutSpec</h3>

<p>以固定的宽高比来缩放子节点。这个规则必须传一个高度或者宽度给他作为<code>constrainedSize</code>，进行计算</p>

<p>使用<code>ASRatioLayoutSpec</code>为<code>ASNetworkImageNode</code>和<code>ASVideoNode</code>提供固有大小是非常常见的，因为两者在内容从服务器返回之前没有固定大小</p>

<h3 id="toc_11">ASRelativeLayoutSpec</h3>

<h3 id="toc_12">ASAbsoluteLayoutSpec</h3>

<p>通过设置他们的<code>layoutPosition</code>属性来指定其子节点的横纵坐标。</p>

<p>属性：</p>

<ul>
<li>sizing： 确定<code>ASAbsoluteLayoutSpec</code>将占用多少空间，可选值<code>Default, Size to Fit</code> </li>
</ul>

<h3 id="toc_13">ASLayoutSpec</h3>

<p>所有布局规则的父类，负责处理和管理所有的子类，也可以用来创建自定义布局规则。不建议自定义子类，如果有这方面需求可以将提供的布局规则进行组合来实现</p>

<p><code>ASLayoutSpec</code>中应用了<code>.flexShrink</code>和<code>.flexGrow</code>，在<code>ASStackLayoutSpec</code>作为一个<code>spacer</code>和其它节点一起使用</p>

<h2 id="toc_14">Layout Element 属性</h2>

<h3 id="toc_15">ASStackLayoutElement 属性</h3>

<p>只有在<code>ASStackLayout</code>的<code>subnode</code>上生效</p>

<ul>
<li><p><code>.style.spacingBefore</code> </p>
<p>CGFloat类型，direction与前一个node的间隔</p></li>
<li><p><code>.style.spacingAfter</code></p>
<p><code>CGFloat</code>类型，direction与后一个node的间隔</p></li>
<li><p><code>.style.flexGrow</code></p>
<p><code>Bool</code>类型，子节点尺寸总和小于minimum 即存在剩余空间时，是否放大</p></li>
<li><p><code>style.flexShrink</code></p>
<p><code>Bool</code>类型，子节点综合大于maximum，即空间不足时，是否缩小</p></li>
<li><p><code>.style.flexBasis</code><br/>
<code>ASDimension</code>类型，在应用<code>flexGrow/flexShrink</code>属性 并且分配剩余空间之前，以堆栈水平或垂直尺寸指定此对象的初始大小</p></li>
<li><p><code>.style.alignSelf</code><br/>
<code>ASStackLayoutAlignSelf</code>类型， 指定对象在次轴方向上的布局，会覆盖<code>alignItems</code>。可选值有<code>ASStackLayoutAlignSelfAuto, ASStackLayoutAlignSelfStart, ASStackLayoutAlignSelfEnd, ASStackLayoutAlignSelfCenter, ASStackLayoutAlignSelfStretch</code></p></li>
<li><p><code>.style.ascender</code><br/>
<code>CGFloat</code>类型，用于基线对齐，描述对象从顶部到其基线的距离</p></li>
<li><p><code>.style.descender</code><br/>
<code>CGFloat</code>类型，英语基线对齐，描述对象从基线到底部距离</p></li>
</ul>

<h3 id="toc_16">ASAbsoluteLayoutElement Properties</h3>

<p>只在<code>ASAbsolute</code>的subnode中才能生效</p>

<p><code>.style.layoutPosition</code></p>

<p><code>CGFloat</code>类型，描述该对象在<code>ASAbsoluteLayoutSpec</code>父规则中的位置</p>

<h3 id="toc_17">ASLayoutElement Properties</h3>

<p>适用于所有布局元素</p>

<ul>
<li><p><code>.style.width</code><br/>
<code>ASDimension</code>类型，width描述内容区域的宽度。默认值为<code>ASDimensionAuto</code><br/>
<code>minWidth</code>和<code>maxWidth</code>属性会覆盖<code>width</code></p></li>
<li><p><code>.style.height</code><br/>
<code>ASDImension</code>类型，height描述内容区域的高度。默认值为<code>ASDimensionAuto</code>。<br/>
<code>minHeight</code>和<code>maxHeight</code>属性会覆盖<code>height</code></p></li>
<li><p><code>style.minWidth</code><br/>
<code>ASDImension</code>类型，用于设置一个特定布局元素的最小宽度。默认值为<code>ASDimensionAuto</code>。</p></li>
<li><p><code>style.maxWidth</code><br/>
<code>ASDImension</code>类型，用于设置一个特定布局元素的最大宽度。默认值为<code>ASDimensionAuto</code>。</p></li>
<li><p><code>.style.minHeight</code><br/>
<code>ASDImension</code>类型，用于设置一个特定布局元素的最小高度。默认值为<code>ASDimensionAuto</code>。</p></li>
<li><p><code>.style.maxHeight</code><br/>
<code>ASDImension</code>类型，用于设置一个特定布局元素的最大高度。默认值为<code>ASDimensionAuto</code>。</p></li>
<li><p><code>.style.preferredSize</code><br/>
<code>CGSize</code>类型， 建议布局元素的size。minSize和maxSize会限制和覆盖该属性。如果未提供，默认会使用<code>calculateSizeThatFits:</code>方法提供的固有大小</p>
<p>该属性是可选的，但是对于没有固定大小或需要用于固有大小不同的size进行布局的节点，则必须指定<code>preferredSize</code>或<code>preferredLayoutSize</code>中一个，比如这个属性可以在<code>ASImageNode</code>上设置，使这个节点的size和图片的size不同</p>
<blockquote>
<p>注意</p>
<p>当size的宽度和高度时相对值时  调用getter进行断言</p>
</blockquote></li>
<li><p><code>.style.minSize</code><br/>
<code>CGSize</code>类型，可选属性，为布局元素提供最小尺寸，</p></li>
<li><p><code>.style.maxSize</code><br/>
<code>CGSize</code>类型，可选属性，为布局元素提供最大尺寸</p></li>
<li><p><code>.style.preferredLayoutSize</code><br/>
<code>ASLayoutSize</code>类型，为布局提供建议的size。<br/>
使用百分比而不是点来指定布局。</p></li>
<li><p><code>.style.minLayoutSize</code><br/>
<code>ASLayoutSize</code>类型，可选属性，为布局提供最小相对尺寸</p></li>
<li><p><code>.style.maxLayoutSize</code><br/>
<code>ASLayoutSize</code>类型，可选属性，为布局提供最大相对尺寸</p></li>
</ul>

<h2 id="toc_18">Layout API Sizing</h2>

<h3 id="toc_19">ASDimension</h3>

<p>为一个<code>CGFloat</code>表示一个pt值、一个百分比或者一个自动值,这个单位允许一个API同时使用固定值或者相对值</p>

<pre><code class="language-objectivec">// 返回一个相对值
ASDimensionMake(&quot;50%&quot;)
ASDimensionMakeWithFraction(0.5)

// 返回一个 pt 值
ASDimensionMake(&quot;70pt&quot;)
ASDimensionMake(70)
ASDimensionMakeWithPoints(70)
</code></pre>

<h3 id="toc_20">CGSize、ASLayoutSize</h3>

<p><code>ASLayoutSize</code>类似于<code>CGSize</code>，只是其高度和宽度可以同时使用pt值或百分比，宽度和高度是独立的，它们的值类型可以不同。</p>

<p>允许同一个的API采用绝对值和相对值</p>

<pre><code class="language-objectivec">ASLayoutSizeMake(ASDimension width, ASDimension height);

//例如
ASDimension width = ASDimensionMake(ASDimensionUnitAuto, 0);  
ASDimension height = ASDimensionMake(@&quot;50%&quot;);
layoutElement.style.preferredLayoutSize = ASLayoutSizeMake(width, height);
</code></pre>

<p>也可以使用<code>preferredSize、minSize、maxSize</code>属性</p>

<pre><code class="language-objectivec">layoutElement.style.preferredSize = CGSize(width: 30, height: 60)
</code></pre>

<p>但是大多数情况下，不需要限制宽度和高度。如果需要，可以使用<code>ASDimension</code>值单独设置布局的size属性</p>

<pre><code class="language-objectivec">layoutElement.style.width     = ASDimensionMake(&quot;50%&quot;)
layoutElement.style.minWidth  = ASDimensionMake(&quot;50%&quot;)
layoutElement.style.maxWidth  = ASDimensionMake(&quot;50%&quot;)

layoutElement.style.height    = ASDimensionMake(&quot;50%&quot;)
layoutElement.style.minHeight = ASDimensionMake(&quot;50%&quot;)
layoutElement.style.maxHeight = ASDimensionMake(&quot;50%&quot;)
</code></pre>

<h3 id="toc_21">ASSizeRange</h3>

<p>因为在UIKit并没有提供机制 绑定最大和最小的Size，因此，为了支持，创建了<code>ASSizeRange</code></p>

<p><code>ASSizeRange</code>通常用于layout的API内部，作为输入传递给layoutSpecThatFits：的constrainedSize值是ASSizeRange</p>

<pre><code class="language-objectivec">- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize;
</code></pre>

<p>传递的<code>constrainedSize</code>是node最合适的最大和最小尺寸，constrainedSize中包含的最小和最大CGSize可用于调整节点的布局元素的大小</p>

<h2 id="toc_22">Layout Transition API</h2>

<p><a href="https://texturegroup.org/docs/layout-transition-api.html">参考Layout Transition API</a></p>

<p>帮助我们使所有动画 变得简单，甚至将一个试图集转为另外一个完全不同的视图集</p>

<blockquote>
<p>注意</p>

<p>使用<code>Layout Transition API</code>必须使用<code>自动节点管理功能</code></p>
</blockquote>

<h3 id="toc_23">Layout 之间的动画</h3>

<p>在这个过程中没有使用<code>addSubnode:</code>或<code>removeFromSupernode:</code>。 Layout Transition API 会分析旧布局和新布局之间节点层次结构的差异，通过自动子节点管理隐式的执行节点插入和删除。</p>

<p>通过更新属性，来让展示不同的lauout specs。并且，调用<code>transitionLayoutWithAnimation：</code>调用动画方法。默认实现的API中，布局会重新计算布局，并且调整子节点的大小和位置，而不设置动画。此时我们需要自定义动画block，当通过<code>transitionLayoutWithAnimation</code>计算出新的布局后，会调用<code>- (void)animateLayoutTransition:(id&lt;ASContextTransitioning&gt;)context</code>我们在其中自定义动画</p>

<pre><code class="language-objectivec">- (void)animateLayoutTransition:(id&lt;ASContextTransitioning&gt;)context
{
  if (self.fieldState == SignupNodeName) {
    CGRect initialNameFrame = [context initialFrameForNode:self.ageField];
    initialNameFrame.origin.x += initialNameFrame.size.width;
    self.nameField.frame = initialNameFrame;
    self.nameField.alpha = 0.0;
    CGRect finalAgeFrame = [context finalFrameForNode:self.nameField];
    finalAgeFrame.origin.x -= finalAgeFrame.size.width;
    [UIView animateWithDuration:0.4 animations:^{
      self.nameField.frame = [context finalFrameForNode:self.nameField];
      self.nameField.alpha = 1.0;
      self.ageField.frame = finalAgeFrame;
      self.ageField.alpha = 0.0;
    } completion:^(BOOL finished) {
      [context completeTransition:finished];
    }];
  } else {
    CGRect initialAgeFrame = [context initialFrameForNode:self.nameField];
    initialAgeFrame.origin.x += initialAgeFrame.size.width;
    self.ageField.frame = initialAgeFrame;
    self.ageField.alpha = 0.0;
    CGRect finalNameFrame = [context finalFrameForNode:self.ageField];
    finalNameFrame.origin.x -= finalNameFrame.size.width;
    [UIView animateWithDuration:0.4 animations:^{
      self.ageField.frame = [context finalFrameForNode:self.ageField];
      self.ageField.alpha = 1.0;
      self.nameField.frame = finalNameFrame;
      self.nameField.alpha = 0.0;
    } completion:^(BOOL finished) {
      [context completeTransition:finished];
    }];
  }
}
</code></pre>

<p><code>ASContextTransitioning</code>中包含了过渡前和过度后的node状态信息。<br/>
动画完成后必须调用<code>[context completeTransition:finished];</code>,这会使其内部执行必要步骤，将计算的布局变为当前布局</p>

<p>在实现animateLayoutTransition：之前插入了节点，这是在开始动画之前手动管理层次结构的好地方。在context对象上调用completeTransition：之后，将在didCompleteLayoutTransition：中执行删除。如果您需要手动执行删除，请覆盖didCompleteLayoutTransition：并执行自定义操作。请注意，这将覆盖默认行为，建议调用super或遍历上下文对象中的RemovedSubnodes getter以执行清理。</p>

<p>将NO传递给<code>transitionLayoutWithAnimation：</code>仍将通过<code>[context isAnimated]</code>属性设置为NO的<code>animateLayoutTransition：</code>和<code>didCompleteLayoutTransition：</code>实现运行。您可以选择如何处理此案件（如果有的话）。提供默认实现的一种简单方法是调用super</p>

<pre><code class="language-objectivec">- (void)animateLayoutTransition:(id&lt;ASContextTransitioning&gt;)context
{
  if ([context isAnimated]) {
    // perform animation
  } else {
    [super animateLayoutTransition:context];
  }
}
</code></pre>

<h3 id="toc_24">限制大小更改动画</h3>

<p>当只是想对node的边界更改作出相应，并为其重新计算layout 动画效果。此时可以在节点上调用<code>transitionLayoutWithSizeRange:animated:</code></p>

<p>与<code>transitionLayoutWithAnimation:</code>类似，但是如果传递的ASSizeRange和当前的相同，则不会触发动画，这对旋转视图好更改控制器大小非常有效果：</p>

<pre><code class="language-objectivec">- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator
{
  [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];
  [coordinator animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt;  _Nonnull context) {
    [self.node transitionLayoutWithSizeRange:ASSizeRangeMake(size, size) animated:YES];
  } completion:nil];
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15686206334500.html">子类</a></h1>
			<p class="meta"><time datetime="2019-09-16T15:57:13+08:00" 
			pubdate data-updated="true">09/16/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">ASDisplayNode</h2>

<p>虽然使用类似于<code>UIView</code> 但是我们需要遵循一些使用规则 帮助更好的使用并按照预期运行</p>

<h4 id="toc_1">-init</h4>

<p>当使用<code>nodeBlocks</code>时，此方法在后台线程调用。在init方法完成之前没有其他方法可以运行，因此我们无需在此方法中锁定</p>

<p>需要注意，<code>-init</code>方法能在任何对队列调用。所以我们不应该在初始化过程中初始化任何UIKit对象，调用任何node的view或layer等有关的操作，或者添加任何手势识别器。这些过程可以在<code>-didLoad</code>方法中</p>

<h4 id="toc_2">-didLoad</h4>

<p>这个方法当视图在后台加载完成后执行一次。保证在主线程被调用，因此<mark>是我们运行任何UIKit事务的适当位置</mark>(例如添加手势识别器，触摸视图/图层，初始化UIKit对象)</p>

<h4 id="toc_3">-layoutSpecThatFits:</h4>

<p>这个方法在后台执行繁重的定义布局的计算。这是我们声明、创建和修改<code>ASLayoutSepec</code>布局描述对象的地方，该对象描述节点的size以及子节点的position和size。<mark>这是我们放置大部分布局代码的地方</mark></p>

<p>ASLayoutSpec 对象直到在此方法中返回前是可变的。 在这之后，这个对象将不可改变，需要注意的是你不需要缓存 ASLayoutSpec 对象以备后用，我们建议你在必要时重新创建布局描述。</p>

<p>因为此方法在后台运行，因此不应该在此方法中设置<code>node.view</code>或者<code>node.layer</code>属性。此外，除非您知道自己在做什么，否则不应该再次方法中创建任何节点。与其它方法重写不同，不必在方法开始时调用super方法</p>

<h4 id="toc_4">-layout</h4>

<p>在此方法中调用<code>super</code>，将会使用<code>layoutSpec</code>对象计算布局，所有子节点都将计算其size和position。</p>

<p><code>layout</code>在概念上类似<code>UIViewController</code>的<code>-viewWillLayoutSubviews</code>。可以在这个方法中，更改<code>hidden</code>属性、修改View属性(不是布局属性)、或者背景颜色。假如正好使用UIView，可以再这个方法中修改其<code>frame</code>。然而，我们可以用<code>initWithViewBlock：</code>然后在后台线程的任何地方，调整其大小。</p>

<p>这个方法在主线程上调用。但是最后不要过多使用这个方法，我们更应该在主线程以外做布局</p>

<p>使用<code>-layout</code>的一个重要用途是你需要子节点的<code>size</code>是精确的。例如：当你想要一个<code>collectionNode</code>占满屏幕时，这种情况是不被布局规范所允许的，我们通常手动在方法中添加<code>subnode.frame = self.bounds;</code></p>

<h2 id="toc_5">ASViewController</h2>

<p><code>ASViewController</code>是<code>UIViewController</code>的子类，用来管理nodes。因为是一个<code>UIViewController</code>，所以所有方法都在主线程调用(<code>ASViewController</code>也应该在主线程创建)。</p>

<h4 id="toc_6">-init</h4>

<p>在生命周期的最开始调用一次。与<code>UIViewController</code>相同不要再次方法中访问<code>self.view</code>或者<code>self.node.view</code>，因而为它会强制视图提前创建。可以在<code>viewDidLoad</code>方法中执行任何视图访问</p>

<p>ASViewController 指定的构造器是<code>initWithNode:</code>方法，在调用super方法前初始化node。</p>

<pre><code class="language-objectivec">- (instancetype)init
{
  _pagerNode = [[ASPagerNode alloc] init];
  self = [super initWithNode:_pagerNode];
  
  // setup any instance variables or properties here
  if (self) {
    _pagerNode.dataSource = self;
    _pagerNode.delegate = self;
  }
  
  return self;
}
</code></pre>

<h4 id="toc_7">-loadView</h4>

<p>不推荐使用此方法，因此相比较<code>viewDidLoad</code>只有缺点没有优点。然而，只要我们在此方法中不将<code>self.view</code>设置为其他值 也可以安全使用的。其super方法会将其<code>UIViewController</code>的view换为<code>ASViewController</code>的<code>node.view</code></p>

<h4 id="toc_8">-viewDidLoad</h4>

<p>这方法在ASViewController的生命周期中，只会在loadView方法后，立即执行一次。此时最方便访问<code>node.view</code>。也可以执行需要访问<code>view/layer</code>的只执行一次的方法(例如添加手势)。</p>

<p>不适合在方法中放置布局视图的代码。因为界面重绘时，该方法也不会被再次调用。</p>

<h4 id="toc_9">-viewWillLayoutSubviews</h4>

<p>与节点node的<code>layout</code>方法同时调用，在ASVC的生命周期中有可能会多次调用。当<code>ASViewController</code>的node边界发生变化(包括旋转、分屏、键盘)以及层次结构发生变化（包括node增加、删除、改变大小）时，都会调用</p>

<p>因为它不经常调用，但是调用及代表页面需要重绘，因此所有布局代码最好放到这个方法中，即使不直接依赖size的UI代码。<br/>
<mark>为保持一致性，通常将所有布局代码放置在此处。</mark></p>

<h4 id="toc_10">-viewWillAppear: / -viewDidDisappear:</h4>

<p>方法在<code>ASViewController</code>的node出现在屏幕之前 和 从视图层次中删除之后调用。通常在方法中开始或者停止动画，或者记录用户操作。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15686140907064.html">Node</a></h1>
			<p class="meta"><time datetime="2019-09-16T14:08:10+08:00" 
			pubdate data-updated="true">09/16/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Node Containers</h2>

<ul>
<li><code>ASCollectionNode</code>  类似UIKit中的<code>UICollectionView</code></li>
<li><code>ASPagerNode</code>  类似UIKit中的<code>UIPageViewController</code></li>
<li><code>ASTableNode</code> 类似UIKit中的<code>UITableView</code></li>
<li><code>ASViewController</code> 类似UIKit中的<code>UIViewController</code></li>
<li><code>ASNavigationController</code> 类似UIKit中的<code>UINavigationController</code>，遵循了<code>ASVisibility</code>协议</li>
<li><code>ASTabBarController</code> 类似UIKit中<code>UITabBarController</code> 遵循了<code>ASVisibility</code>协议</li>
</ul>

<p>节点容器作用：</p>

<p>节点容器自动福安里其子节点实现智能预加载，这意味着节点所有布局计算、数据读取，解码和渲染都将会异步完成，这也是为什么建议将节点放到节点容器中使用的原因。<br/>
而容器外的node只会在屏幕出现时才开始渲染，类似UIKit的做法，这会导致性能下降和内容闪烁。</p>

<h2 id="toc_1">Node Subclasses</h2>

<p>使用node代替UIKit组件的一个关键优势就是  所有的节点都在主线程之外布局和显示，以便主线程可以立即响应用户事件</p>

<p><code>ASDisplayNode</code>   替代<code>UIView</code> ，其为根node，其它node均继承自其</p>

<p><code>ASCellNode</code> 替代 <code>UITalbeViewCell</code>和<code>UICollectionCell</code>。其被用于<code>ASTableNode、ASCollectionNode、ASPageNode</code></p>

<p><code>ASScrollNode</code> 替代 <code>UIScrollView</code>   此node用于创建包含其他节点的自定义可滚动区域</p>

<p><code>ASEditableTextNode</code> 替代 <code>UITextView</code></p>

<p><code>ASTextNode</code> 替代 <code>UILabel</code></p>

<p><code>ASImageNode、 ASNetworkImageNode、 ASMultiplexImageNode</code> 替代 <code>UIImageView</code></p>

<p><code>ASVideoNode</code> 替代 <code>AVPlayerLayer</code><br/>
<code>ASVideoPlayerNode</code> 替代 <code>UIMoviePlayer</code></p>

<p><code>ASControlNode</code> 替代 <code>UIControl</code> </p>

<p><code>ASButtonNode</code> 替代 <code>UIButton</code></p>

<p><code>ASMapNode</code>  替代 <code>MKMapView</code></p>

<p>Texture的node相比UIKit的组件通常提供了更加便利的功能。例如，ASNetworkImageNode执行自动加载和缓存管理，甚至支持渐进式jpeg和GIF动画</p>

<h3 id="toc_2">Node继承关系</h3>

<p><img src="media/15686140907064/15686201072605.png" alt=""/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15682782807154.html">智能预加载</a></h1>
			<p class="meta"><time datetime="2019-09-12T16:51:20+08:00" 
			pubdate data-updated="true">09/12/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>学习自<a href="https://texturegroup.org/docs/intelligent-preloading.html">Texture官方文档</a></p>

<p>虽然异步并发渲染和FlexBox布局已经足够强大，但是Texture还做了另外的智能预加载的思想</p>

<p>我们通常不在<code>node container</code>外使用node，因为所有的node都有当前的<code>interface state</code>概念。<br/>
<code>interface state</code>属性由<code>ASRangeController</code>更新和维护，ASRangeController又由所有的<code>node container</code>在内部创建和维护。<br/>
当我们在contain外部使用node时，就不会有<code>ASRangeController</code>更新其状态，这个有时会导致渲染时node闪烁，这是因为这些容器外的节点因为状态的错误，在节点被渲染到屏幕上后又进行了一次渲染。</p>

<h1 id="toc_0">接口状态范围</h1>

<p><img src="media/15682782807154/15682794649845.jpg" alt="" style="width:497px;"/><br/>
当nodes<mark>添加到滚动或者分页界面时</mark>，会处在上面所处的几个状态之一。意味着当视图滚动时，他们的状态将会更新</p>

<p>Preload： 预加载，离可见区域最远的内容，在这个地方收集其他的输入源信息<br/>
Display： 在这个地方展示例如文字光栅化、图片解码等任务<br/>
Visible： 在屏幕上展示至少一个像素</p>

<h3 id="toc_1">ASRangeTuningParameters</h3>

<p>这些状态范围的大小是可调整的。默认大小适合于大多数情况，我们也可以设置滚动范围参数调整其大小</p>

<p>在下面图片中我们可以看到，当用户向下滚动时，滚动方向的范围比尾部方向内容大得多。当用户改变滚动方向时，则首尾将会动态交换，以保持内存最佳使用率。这使得我们只需要关系首尾方向的range size大小，而不需担心用户更改滚动方向<br/>
<img src="media/15682782807154/15682825633985.jpg" alt="" style="width:500px;"/></p>

<h2 id="toc_2">接口状态回调</h2>

<p>当用户滚动时 node会在这三个状态范围中切换 并且通过加载数据或者渲染做出反应。自己的node子类可以通过实现相应的回调方法来利用这种机制</p>

<pre><code class="language-objectivec">-didEnterVisibleState
-didExitVisibleState

-didEnterDisplayState
-didExitDisplayState

-didEnterPreloadState
-didExitPreloadState
//记得都要调用super
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15681914341057.html">Texture</a></h1>
			<p class="meta"><time datetime="2019-09-11T16:43:54+08:00" 
			pubdate data-updated="true">09/11/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>学习自<a href="https://texturegroup.org/docs/getting-started.html">Texture官方文档</a></p>

<p><a href="https://juejin.im/post/5a16acf56fb9a04509092ce5#heading-39">掘金[译] AsyncDisplayKit/Texture 官方文档</a></p>

<p><code>Texure</code>的基本单元是node。<code>ASDisplayNode</code>是一个对<code>UIView</code>的抽象，而<code>UIView</code>还是<code>CALayer</code>的的上层抽象。</p>

<p>不同之处在于：<br/>
View只能在主线程使用，但是node是线程安全的: <code>Node</code>可以亦不会只，并且线程安全的。可以在异步线程中实例化和配置层级结构</p>

<p>一般程序以每秒60帧进行呈现是iOS的黄金标准.意味着主线程执行所有布局和绘图代码只有16毫秒,并且由于系统开销,如果布局绘图代码执行超过10ms就会引起掉帧</p>

<p><code>Texture</code>允许我们将图像解码、文字调整和绘制等其它昂贵的UI操作，移到主线程外，保证主线程可以一直响应用户操作，等。</p>

<h2 id="toc_0">Node</h2>

<p><code>UIView</code>中的绝大多数方法，node都有其对应的映射。当UIViw和CALayer的方法名有冲突时，默认使用<code>UIView</code>的命名。(唯一例外的是 node使用position代替center)</p>

<p>可以再确保在主线程执行的基础上，调用<code>node.view</code>或者<code>node.layer</code>方法</p>

<h2 id="toc_1">Node Containers</h2>

<p>当将Texture集成到项目中时，不能将<code>Node</code>直接添加到已有视图中，这样会导致节点在渲染时闪烁。</p>

<p>应该把节点添加到<code>Node</code>容器中，由Node容器负责管理这节点，可以将Node容器理解为UIKit和Texture之间的桥梁</p>

<h2 id="toc_2">Layout Engine</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15645543599204.html">AsyncDisplayKit</a></h1>
			<p class="meta"><time datetime="2019-07-31T14:25:59+08:00" 
			pubdate data-updated="true">07/31/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>即刻团队的 <a href="https://medium.com/jike-engineering/asyncdisplaykit%E4%BB%8B%E7%BB%8D-%E4%B8%80-6b871d29e005">AsyncDisplayKit介绍</a></p>

<p><a href="https://texturegroup.org/docs/getting-started.html">AsyncDisplayKit-TextTrue</a></p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="AsyncDisplayKit.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>