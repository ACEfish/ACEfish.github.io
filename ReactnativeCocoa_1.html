
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ReactnativeCocoa - ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15529084547270.html">ReactObjc常用</a></h1>
			<p class="meta"><time datetime="2019-03-18T19:27:34+08:00" 
			pubdate data-updated="true">03/18/2019</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">常用信号</h2>

<pre><code class="language-objectivec">//按钮点击事件信号
RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside];

//监测textField改变信号
RACSignal *textChange = [myTextField rac_textSignal];

//alertView UIActionSheet UIImagePickerControl 监测信号
//例如对alertView  UIActionSheet 等监测返回的就是点击的按钮index
RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal];

//监测对象某个事件的执行
RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)];

</code></pre>

<h2 id="toc_1">UI控件展示与对象属性的绑定</h2>

<pre><code class="language-objectivec">//将label内容与model属性绑定  之后当model属性改变即会改变label内容，
//RACObserve 是采用了KVO方式，因此改变userFullName属性方法需要出发setter方法 
RAC(self.userNameLabel, text) = RACObserve(self.viewModel, userFullName);

//当要赋值的属性类型不一致时，可以使用map将属性调整一致
RAC(self.countLabel, text) = [RACObserve(cellVM, count) map:^id _Nullable(NSNumber *  _Nullable value) {
    return value.stringValue;
}];

//将UI控件内容绑定到对象属性
//将Textfield内容绑定到self.viewModel的userName属性 
//rac_textSignal默认检测textEditingEvent 因此代码级别改变Textfield内容不会触发此信号
RAC(self.viewModel, username) = [myTextfield rac_textSignal];
</code></pre>

<h2 id="toc_2">UI事件与对象数据绑定</h2>

<pre><code class="language-objectivec">//订阅数据改变的信号 当数据信号改变时刷新tableView 这样之后我们只需要改变数据即可 无需手动调用tableView刷新事件
//因为这里tableView的刷新绑定两个属性 因此我们需要对这两个信号执行merge
//因为多个信号 同时改变的话可能会导致多次刷新 因此`bufferWithTime`
//设置在指定时间内只执行一次 当设置为0时 在下次屏幕刷新之前(即一个runloop中) 只执行一次 而不会多次刷新
@weakify(self);
[[[RACSignal merge:@[RACObserve(self.viewModel, tweets),
                    RACObserve(self.viewModel, allTweetsLoaded)]]
bufferWithTime:0 onScheduler:[RACScheduler mainThreadScheduler]]
subscribeNext:^(id value) {
    @strongify(self);
    [self.tableView reloadData];
}];


//按钮点击事件
[[self.goButton rac_signalForControlEvents:UIControlEventTouchUpInside]
subscribeNext: ^(id value) {
    @strongify(self);
    [self.viewModel getTweetsForCurrentUsername];
}];
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15459662586152.html">ReactiveObjC</a></h1>
			<p class="meta"><time datetime="2018-12-28T11:04:18+08:00" 
			pubdate data-updated="true">12/28/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">基础知识</h2>

<p>常用的 <code>RACSignal</code>为冷信号  <code>RACSubject</code>为热信号<br/>
冷信号 即为订阅之后才开始执行的消息，订阅几次 就执行几次<br/>
热信号 为创建信号就开始执行的消息 无需订阅</p>

<h2 id="toc_1">常用类</h2>

<h3 id="toc_2">RCASignal信号</h3>

<pre><code class="language-objectivec">//1.创建信号 

//可以在创建信号中立即发送信号 但是不能在block结束返回前销毁该信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [subscriber sendNext:@&quot;发送的消息内容&quot;];
        return nil;
}];
//立即发送给定的错误信息
NSError *error = [[NSError alloc] init];
[RACSignal error:error];
//返回一个信号 该信号立即发送给定值 然后 complete
[RACSignal return:@&quot;value&quot;];
//返回信号 该信号直接 complete
[RACSignal empty];

//2.信号处理

//2.1 concat 返回一个信号signal3 当signal1 complete时订阅信号就signal2信号变化 我们可以通过订阅 signal3 来收到信号两个信号的值变化
RACSignal *signal3 = [signal1 concat:signal2]

//2.2  flattenMap 串联信号 当收到第一个消息的值变化时 开始执行第二个信号 此时我们订阅信号2  只会收到信号2值改变信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [subscriber sendNext:@&quot;发送的消息内容&quot;];
        });
        return nil;
    }];
RACSignal *signal2 = [signal flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) {
    return  [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [subscriber sendNext:@&quot;signal2 发送的消息内容&quot;];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [subscriber sendNext:@&quot;signal2 3秒后发送的消息内容&quot;];
        });
        return nil;
    }];
}];

//2.2 map 对信号1中收到的值进行处理返回信号2 
RACSignal *signal2 = [signal map:^id _Nullable(NSString *  _Nullable value) {
    return [value substringFromIndex:2];
}];

//2.3 filter 过滤信号值
RACSignal *signal2 = [signal filter:^BOOL(NSString *  _Nullable value) {
    return YES;
}];

//2.4 ignore 忽略特定值的信号
RACSignal *signal2 = [signal ignore:@&quot;发送的消&quot;];

//2.5 startwith: 将这个值 拼接到信号值开头 返回新的信号 
RACSignal *signal2 = [signal startWith:@&quot;start with发送的消息内容&quot;];

//2.6 skip: 忽略开始的count个信号值改变
RACSignal *signal2 = [signal skip:1];

//2.7 take: 返回一个只接收前count个信号的信号值改变  其后发送的信号会失败
RACSignal *signal2 = [signal take:2];

//2.8  scanWithStart: reduce: 遍历信号1值变化 block中next即为信号1的信号值  
//      running为累计值 初始为start值 
RACSignal *signal2 = [signal scanWithStart:@&quot;1&quot; reduce:^NSString * _Nullable(NSString *  _Nullable running, NSString *  _Nullable next) {
    running = [[NSMutableString stringWithFormat:@&quot;%@%@&quot;, running, next] copy];
    return running;
}];

//2.9 takeUntilBlock: 忽略这符合条件的信号以及之后的信号
//     takeWhileBlock: 返回符合条件的信号值
//      skipUntilBlock: 只返回符合条件以及之后的信号
//      skipWhileBlock: 忽略符合条件的信号
RACSignal *signal2 = [signal takeUntilBlock:^BOOL(NSString *  _Nullable x) {
    return [x hasPrefix:@&quot;3秒&quot;];
}];

//2.10 distinctUntilChanged 只返回值不一样的信号
RACSignal *signal2 = [signal distinctUntilChanged];


//3. 订阅

//subscribeNext： 订阅信号值改变  error 订阅错误信号 completed 订阅完成信号 
RACDisposable *disposable = [signal3 subscribeNext:^(NSString *  _Nullable x) {
    NSLog(@&quot;signal3收到订阅值:%@&quot;, x);
} error:^(NSError * _Nullable error) {
    NSLog(@&quot;signal3收到错误订阅:%@,&quot; error);
} completed:^{
    NSLog(@&quot;signal3收到成功订阅;&quot;);
}];

//取消订阅
[disposable dispose];


</code></pre>

<h3 id="toc_3">RACSubject信号</h3>

<pre><code class="language-objectivec">//RACSubject 继承于 RACSignal 使用这个对象 可以直接发送和接收信号值改变  而不需要关心 创建信号和注销订阅问题
RACSubject *subject = [RACSubject subject];

[subject subscribeNext:^(NSString *x) {
    NSLog(@&quot;接受新值%@&quot;, x);
} completed:^{
    NSLog(@&quot;接受完成情况&quot;);
}];

[subject sendNext:@&quot;新的值1&quot;];

</code></pre>

<h3 id="toc_4">RACTuple 元组</h3>

<p>元组功能</p>

<h3 id="toc_5">NSArray NSDictionary 集合操作</h3>

<p>RAC扩展了NSArray 和  NSDictionary 拥有 <code>rac_sequence</code>(<code>RACSequence</code>类)属性</p>

<h3 id="toc_6">RACSequence</h3>

<pre><code class="language-objectivec">    //1. 获取一个 发送集合中值改变的信号
    arr.rac_sequence.signal
    //2. 用信号来遍历集合
    [arr.rac_sequence.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;%@&quot;, x);
    }];
    //3. head
    NSLog(@&quot;第一个元素%@&quot;, arr.rac_sequence.head);
    //4. tail
    NSLog(@&quot;除了第一个元素外的所有元素集合%@&quot;, arr.rac_sequence.tail);
    
    //5. 从左侧开始遍历 start: 累计的初始值 accumulator: 累计值 value:当前值 count: 最终值
    NSNumber *count = [intArr.rac_sequence foldLeftWithStart:@(10) reduce:^NSNumber* (NSNumber *accumulator, NSNumber *value) {
        NSLog(@&quot;%@--- %@&quot;, accumulator, value);

        return @(accumulator.integerValue + value.integerValue);
    }];
    NSLog(@&quot;%@&quot;, count);
    
    //6. 同样可以从右边开始遍历
    
    //7. 遍历集合 判断是否存在符合条件 当遇到block返回YES 返回YES不再执行
    BOOL exist = [intArr.rac_sequence any:^BOOL(NSNumber *value) {
        return value.integerValue == 2;
    }];
    NSLog(@&quot;%@&quot;, exist ? @&quot;存在&quot; : @&quot;不存在&quot;); //存在
    //8. 遍历集合 判断是否所有元素都满足条件
    BOOL pass = [intArr.rac_sequence all:^BOOL(id  _Nullable value) {
        return [value isKindOfClass:[NSNumber class]];
    }];
    NSLog(@&quot;%@&quot;, pass ? @&quot;通过&quot; : @&quot;不通过&quot;); //存在
    //9. 遍历集合找到第一个符合条件的元素
    id obj = [intArr.rac_sequence objectPassingTest:^BOOL(id  _Nullable value) {
        if ([value isKindOfClass:[NSNumber class]]) {
            NSNumber *value1 = (NSNumber *)value;
            if (value1.integerValue % 3 == 0) {
                return YES;
            }
        }
        return NO;
    }];
    NSLog(@&quot;第一个通过测试的是%@&quot;, obj); //9
    
    //10. 用户动态生成sequenceh headblock和tailblock只会执行一次
    //是惰性加载生成的
    //必须保证headblock和tailblock是线程安全的
    RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @(11);
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence sequenceWithHeadBlock:^id _Nullable{
            return @(11);
        } tailBlock:^RACSequence * _Nonnull{
            return [RACSequence sequenceWithHeadBlock:^id _Nullable{
                return @(22);
            } tailBlock:^RACSequence * _Nonnull{
                return @[@(33)].rac_sequence;
            }];
        }];
    }];
    
    [sequence.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;%@&quot;, x);
    }];
</code></pre>

<h3 id="toc_7">UI操作</h3>

<h4 id="toc_8">UIControl</h4>

<pre><code class="language-objectivec"> RACSignal *signal = [self.btn rac_signalForControlEvents:UIControlEventTouchUpInside];
[signal subscribeNext:^(UIButton *  _Nullable x) {
    NSLog(@&quot;&quot;);
}];
</code></pre>

<h4 id="toc_9">UIButton</h4>

<pre><code class="language-objectivec">//当 按钮被点击时 执行 command中的block
self.btn.rac_command 
</code></pre>

<h4 id="toc_10">RACCommand</h4>

<pre><code class="language-objectivec">//初始化command 用一个信号
self.btn.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {
        return [RACSignal empty];
    }];
    
//executionSignals  属性为 command执行时的信号
[self.btn.rac_command.executionSignals subscribeNext:^(RACSignal&lt;id&gt; * _Nullable x) {
    NSLog(@&quot;信号值执行了&quot;);
}];
    
</code></pre>

<h4 id="toc_11">UITextfield</h4>

<pre><code class="language-objectivec">//rac_textSignal 获取textfield内容改变信号
[self.textfield.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
    NSLog(@&quot;输出内容%@&quot;, x);
}];
</code></pre>

<h3 id="toc_12">NSNotification</h3>

<pre><code class="language-objectivec">//通知事件 无需主动移除通知
[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;&quot; object:nil] subscribeNext:^(NSNotification * _Nullable x) {
    
}];
</code></pre>

<h3 id="toc_13">Delegate</h3>

<pre><code class="language-objectivec">[[self.view rac_signalForSelector:@selector(nameBtnDidClick:)] subscribeNext:^(RACTuple * _Nullable x) {
    
}];
</code></pre>

<h3 id="toc_14">KVO</h3>

<pre><code class="language-objectivec">//这样设置KVO 无需主动移除
//监听btn frame变化 
[[self.btn rac_valuesForKeyPath:@&quot;frame&quot; observer:self] subscribeNext:^(id  _Nullable x) {
        
}];

//使用宏定义快捷设置KVO （推荐）
[RACObserve(self.btn, frame) subscribeNext:^(id  _Nullable x) {
    
}];

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15450317285396.html">ReactiveObjC</a></h1>
			<p class="meta"><time datetime="2018-12-17T15:28:48+08:00" 
			pubdate data-updated="true">12/17/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>本文内容来自github <a href="https://github.com/ReactiveCocoa/ReactiveObjC">ReactiveObjC的官方文档</a></p>
</blockquote>

<h2 id="toc_0">介绍</h2>

<p>ReactiveObjC 是一个函数相应式编程的OC框架，为我们提供了组合、转换流的api</p>

<p>RAC没有使用可修改或可替换的变量，而是提供了信号(<code>RACSignal</code>)来捕获当前或者未来的信号，我们通过串联、绑定、响应信号，就可以无需持续的观察和更新值来检测变化</p>

<p>例如: 为了检测一个textField的text的最新内容,我们不需要每秒钟就去获取其值的变化,使用RAC更像KVO可以实时获取到其内容变化,与KVO不同的时 我们使用<code>block</code>而不是使用<code>-observeValueForKeyPath:ofObject:change:context:</code></p>

<p>信号也可以帮助我们进行异步操作,就像对未来结果的许诺,极大的帮助我们简化网络请求等异步操作代码</p>

<p><strong>RAC主要提供了一个统一的方法 来处理异步行为，包括delegate、kvo、target-action、notification、block</strong></p>

<ol>
<li><p>监测属性值变化</p>
<pre><code class="language-objectivec">类似kvo
//检测self.username属性变化<br/>
//RACObserve(TARGET, KEYPATH)是一个创建检测值变化的信号<br/>
//subscribeNext 当检测的信号变化时 就会执行这个信号<br/>
[RACObserve(self, username) subscribeNext:^(NSString *newName) {<br/>
       NSLog(@&quot;%@&quot;, newName);<br/>
}];
</code></pre></li>
<li><p>监测过滤出来的部分信号值<br/>
与kvo不同的是，我们可以串联、操作这些信号</p>
<pre><code class="language-objectivec">//过滤 信号中以&quot;j&quot;开头的信号值的变化
[[RACObserve(self, username)<br/>
filter:^(NSString *newName) {<br/>
    return [newName hasPrefix:@&quot;j&quot;];<br/>
}]<br/>
subscribeNext:^(NSString *newName) {<br/>
    NSLog(@&quot;%@&quot;, newName);<br/>
}];
</code></pre></li>
<li><p>通过RAC我们可以很方便的通过信号监测变化,而不需要通过观察和设置其它属性</p>
<pre><code class="language-objectivec">//combineLatest: reduce:方法 合并一组信号,当其中任意一个信号的最新值变化时,会执行该block 并返回新的值
RAC(self, createEnabled) = [RACSignal<br/>
combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ]<br/>
reduce:^(NSString *password, NSString *passwordConfirm) {<br/>
    return @([passwordConfirm isEqualToString:password]);<br/>
}];
</code></pre></li>
<li><p>信号不止类似kvo可以监测属性，还可以监测其它任何随时间变化的值或者流</p>
<pre><code class="language-objectivec">//RACCommand 创建一个与UI有关的信号 此处是按钮点击信号,当按钮被点击时执行该block
//rac_command是按钮类别的属性，当按钮被点击自动发送<br/>
self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {<br/>
NSLog(@&quot;button was pressed!&quot;);<br/>
return [RACSignal empty];<br/>
}];
</code></pre></li>
<li><p>RAC表示网络操作</p>
<pre><code class="language-objectivec">//创建一个信号 当self.loginCommand执行其block
self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {<br/>
    return [client logIn];<br/>
}];<br/>
//executionSignals 返回上面RACComond中block返回的信号的信号,即当上面block返回时 会触发该信号 并可以监测block返回的信号的变化<br/>
[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {<br/>
    // Log a message whenever we log in successfully.<br/>
    [loginSignal subscribeCompleted:^{<br/>
        NSLog(@&quot;Logged in successfully!&quot;);<br/>
    }];<br/>
}];<br/>
//当按钮点击时 执行该self.loginCommand<br/>
self.loginButton.rac_command = self.loginCommand;
</code></pre></li>
<li><p>表示异步操作的信号间可以链接来表示更加复杂的行为(在一组操作完成后开始另外一个操作)</p>
<pre><code class="language-objectivec">//merge: 合并两个信号 返回一个新的信号
//subscribeCompleted: 订阅返回完成的信号<br/>
[[RACSignal merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]<br/>
subscribeCompleted:^{<br/>
    NSLog(@&quot;They&#39;re both done!&quot;);<br/>
}];
</code></pre></li>
<li><p>信号可以串联起来 避免使用block嵌套来表示依赖</p>
<pre><code class="language-objectivec">//
[[[[client<br/>
    logInUser]<br/>
    flattenMap:^(User *user) {<br/>
        // Return a signal that loads cached messages for the user.<br/>
        return [client loadCachedMessagesForUser:user];<br/>
    }]<br/>
    flattenMap:^(NSArray *messages) {<br/>
        // Return a signal that fetches any remaining messages.<br/>
        return [client fetchMessagesAfterMessage:messages.lastObject];<br/>
    }]<br/>
    subscribeNext:^(NSArray *newMessages) {<br/>
        NSLog(@&quot;New messages: %@&quot;, newMessages);<br/>
    } completed:^{<br/>
        NSLog(@&quot;Fetched all messages.&quot;);<br/>
    }];
</code></pre></li>
<li><p>获取异步操作的结果 </p>
<pre><code class="language-objectivec">//当异步图片下载完成后赋值到图片上
//deliverOn: 创建信号并执行在其他队列线程  [RACScheduler scheduler] background线程  RACScheduler.mainThreadScheduler]主线程<br/>
RAC(self.imageView, image) = [[[[client<br/>
fetchUserWithUsername:@&quot;joshaber&quot;]<br/>
deliverOn:[RACScheduler scheduler]]<br/>
map:^(User *user) {<br/>
    // Download the avatar (this is done on a background queue).<br/>
    return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];<br/>
}]<br/>
// Now the assignment will be done on the main thread.<br/>
deliverOn:RACScheduler.mainThreadScheduler];
</code></pre></li>
</ol>

<h2 id="toc_1">示例</h2>

<h3 id="toc_2">1. 处理多来源的异步操作或事件状态</h3>

<p>不使用RAC的情况</p>

<p>页面中的登录按钮 只有在<code>usernameTextField</code> <code>passwordTextField</code> 不为空 并且当前不在登录状态 才可以点击</p>

<pre><code class="language-objectivec">static void *ObservationContext = &amp;ObservationContext;

- (void)viewDidLoad {
    [super viewDidLoad];

    [LoginManager.sharedManager addObserver:self forKeyPath:@&quot;loggingIn&quot; options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext];
    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];

    [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];
}

- (void)dealloc {
    [LoginManager.sharedManager removeObserver:self forKeyPath:@&quot;loggingIn&quot; context:ObservationContext];
    [NSNotificationCenter.defaultCenter removeObserver:self];
}

- (void)updateLogInButton {
    BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0;
    BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn;
    self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;
}

- (IBAction)logInPressed:(UIButton *)sender {
    [[LoginManager sharedManager]
        logInWithUsername:self.usernameTextField.text
        p**assword:self.passwordTextField.text
        success:^{
            self.loggedIn = YES;
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
}

- (void)loggedOut:(NSNotification *)notification {
    self.loggedIn = NO;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if (context == ObservationContext) {
        [self updateLogInButton];
    } else {
        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
    }
}
</code></pre>

<p>使用RAC来写的话</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    @weakify(self);

    RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue);
        }];

    [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {
        @strongify(self);

        RACSignal *loginSignal = [LoginManager.sharedManager
            logInWithUsername:self.usernameTextField.text
            password:self.passwordTextField.text];

            [loginSignal subscribeError:^(NSError *error) {
                @strongify(self);
                [self presentError:error];
            } completed:^{
                @strongify(self);
                self.loggedIn = YES;
            }];
    }];

    RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter
        rac_addObserverForName:UserDidLogOutNotification object:nil]
        mapReplace:@NO];
}
</code></pre>

<h3 id="toc_3">2.串联异步操作的依赖</h3>

<pre><code class="language-objectivec">//logInWithSuccess 登录成功 -&gt; loadCachedMessagesWithSuccess 加载本地数据   -&gt;  fetchMessagesAfterMessage 请求本地为缓存的最新的数据

//不使用色RAC 使用block嵌套
[client logInWithSuccess:^{
    [client loadCachedMessagesWithSuccess:^(NSArray *messages) {
        [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {
            NSLog(@&quot;Fetched all messages.&quot;);
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
    } failure:^(NSError *error) {
        [self presentError:error];
    }];
} failure:^(NSError *error) {
    [self presentError:error];
}];

//RAC版本
[[[[client logIn]
    then:^{
        return [client loadCachedMessages];
    }]
    flattenMap:^(NSArray *messages) {
        return [client fetchMessagesAfterMessage:messages.lastObject];
    }]
    subscribeError:^(NSError *error) {
        [self presentError:error];
    } completed:^{
        NSLog(@&quot;Fetched all messages.&quot;);
    }];
</code></pre>

<h3 id="toc_4">3.用RAC实现 OC中 集合没有的 map、filter、fold/reduce等方法</h3>

<pre><code class="language-objectivec">//获取数组中字符串长度大于2并且拼接字符串`foobar`
NSMutableArray *results = [NSMutableArray array];
for (NSString *str in strings) {
    if (str.length &lt; 2) {
        continue;
    }

    NSString *newString = [str stringByAppendingString:@&quot;foobar&quot;];
    [results addObject:newString];
}


RACSequence *results = [[strings.rac_sequence
    filter:^ BOOL (NSString *str) {
        return str.length &gt;= 2;
    }]
    map:^(NSString *str) {
        return [str stringByAppendingString:@&quot;foobar&quot;];
    }];
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15446921413334.html">ReactiveCocoa 版本</a></h1>
			<p class="meta"><time datetime="2018-12-13T17:09:01+08:00" 
			pubdate data-updated="true">12/13/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>reactiveCocoa 分为两个版本 </p>

<ol>
<li>OC版本的 <strong>ReactiveObjC</strong></li>
<li>swift版本的 <strong>ReactiveSwift</strong></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15446723749030.html">基础</a></h1>
			<p class="meta"><time datetime="2018-12-13T11:39:34+08:00" 
			pubdate data-updated="true">12/13/2018</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">常见编程风格</h2>

<p>目前已知常用的编程风格:</p>

<ol>
<li><p>面向过程</p></li>
<li><p>面向对象</p></li>
<li><p>链式编程<br/>
将多个操作通过 . 连接起来 增加代码的可读性<br/>
例如: masonry框架</p></li>
<li><p>响应式编程<br/>
不考虑事件发生顺序 只考虑结果 发生的事件像流一样传播出去，我们关注数据流和变化传播<br/>
例如: KVO运用</p></li>
<li><p>函数式编程<br/>
将操作写成一系列嵌套的函数或者方法调用，将其他函数作为参数</p>
<p>其在OC中实质即:向方法中传入block，方法中嵌套block调用，对代码进行聚合管理</p></li>
</ol>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="ReactnativeCocoa.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B&&Runloop.html"><strong>多线程&&Runloop&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="RunLoop.html">RunLoop&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html">多线程&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html">线程安全&&锁&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="KVC&&KVO.html">KVC&&KVO&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&&block.html"><strong>内存管理&&block&nbsp;(18)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">OC高级编程-内存管理&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="block%E5%AD%A6%E4%B9%A0.html">block学习&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html">官方文档-内存管理&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E6%8B%BE%E9%81%97.html">内存管理-拾遗&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&&%E7%BB%84%E4%BB%B6%E5%8C%96.html"><strong>设计模式&&组件化&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html">设计模式架构谈(摘录)&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html">组件化开发学习&nbsp;(3)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BC%96%E8%AF%91&&dyld&&Mach-O.html"><strong>编译&&dyld&&Mach-O&nbsp;(19)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html">iOS编译流程&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html">dyld(程序启动)&nbsp;(4)</a>&nbsp;&nbsp;
	        
	        	<a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html">Mach-O文件了解&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9F%A5%E8%AF%86.html"><strong>模块化知识&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="iOS-CoreAnimation.html">iOS-CoreAnimation&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="CoreGraphic.html">CoreGraphic&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="ARKit.html">ARKit&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8.html"><strong>第三方项目学习和使用&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="AFNetworking.html">AFNetworking&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="AsyncDisplayKit.html">AsyncDisplayKit&nbsp;(16)</a>&nbsp;&nbsp;
	        
	        	<a href="ReactnativeCocoa.html">ReactnativeCocoa&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="PromiseKit.html">PromiseKit&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96.html"><strong>项目监控和优化&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html">项目监控&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html">APP体积优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html">启动优化&nbsp;(1)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%B0%83%E8%AF%95&&%E6%B5%8B%E8%AF%95.html"><strong>调试&&测试&nbsp;(6)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="Instrument%E5%AD%A6%E4%B9%A0.html">Instrument学习&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="LLDB.html">LLDB&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html">自动化测试&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="git.html">git&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Cocoapods.html">Cocoapods&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(35)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(5)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>