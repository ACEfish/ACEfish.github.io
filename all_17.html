
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  ACEfish-Blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="学习记录">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ACEfish-Blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ACEfish-Blog</a></h1>
  
    <h2>学习记录</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:acefish.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">首页</a></li>

  <li id=""><a target="_self" href="archives.html">归档</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15082316038998.html">ARSCNView</a></h1>
			<p class="meta"><time datetime="2017-10-17T17:13:23+08:00" 
			pubdate data-updated="true">10/17/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>用于3DAR场景的视图</p>

<ul>
<li>在视图中渲染设备摄像头的实时视频流，并就其设置为 3D 场景的背景</li>
<li>ARKit 的 3D 坐标系会匹配 SceneKit 的 3D 坐标系，所以此视图渲染的对象会自动匹配增强后的 ARKit 世界视图</li>
<li>自动移动虚拟 SceneKit 3D 摄像头来匹配 ARKit 追踪到的 3D 位置，所以不需要再写代码连接 ARKit 移动事件与 SceneKit 3D 渲染</li>
</ul>

<pre><code class="language-objectivec">/**
代理
 */
@property (nonatomic, weak, nullable) id&lt;ARSCNViewDelegate&gt; delegate;

/**
AR会话
 */
@property (nonatomic, strong) ARSession *session;

/**
场景
 */
@property(nonatomic, strong) SCNScene *scene;

/**
是否自动适应灯光
 */
@property(nonatomic) BOOL automaticallyUpdatesLighting;

/**
返回对应节点的锚点，节点是一个3D虚拟物体，它的坐标是虚拟场景中的坐标，而锚点ARAnchor是ARKit中现实世界的坐标。
 */
- (nullable ARAnchor *)anchorForNode:(SCNNode *)node;

/**
返回对应锚点的物体
 */
- (nullable SCNNode *)nodeForAnchor:(ARAnchor *)anchor;

/**
根据2D坐标点搜索3D模型，这个方法通常用于，当我们在手机屏幕点击某一个点的时候，可以捕捉到这一个点所在的3D模型的位置，至于为什么是一个数组非常好理解。手机屏幕一个是长方形，这是一个二维空间。而相机捕捉到的是一个由这个二维空间射出去的长方体，我们点击屏幕一个点可以理解为在这个长方体的边缘射出一条线，这一条线上可能会有多个3D物体模型
point：2D坐标点（手机屏幕某一点）
ARHitTestResultType：捕捉类型  点还是面
(NSArray&lt;ARHitTestResult *&gt; *)：追踪结果数组  详情见本章节ARHitTestResult类介绍
数组的结果排序是由近到远
 */
- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;

@end

//代理
#pragma mark - ARSCNViewDelegate


//代理的内部实现了SCNSceneRendererDelegate：scenekit代理 和ARSessionObserver：ARSession监听（KVO机制）
@protocol ARSCNViewDelegate &lt;SCNSceneRendererDelegate, ARSessionObserver&gt;
@optional

/**
自定义节点的锚点
 */
- (nullable SCNNode *)renderer:(id &lt;SCNSceneRenderer&gt;)renderer nodeForAnchor:(ARAnchor *)anchor;

/**
当添加节点是会调用，我们可以通过这个代理方法得知我们添加一个虚拟物体到AR场景下的锚点（AR现实世界中的坐标）
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

/**
将要刷新节点
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer willUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

/**
 已经刷新节点
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

/**
 移除节点
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didRemoveNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15082286345415.html">ARKit框架API简介</a></h1>
			<p class="meta"><time datetime="2017-10-17T16:23:54+08:00" 
			pubdate data-updated="true">10/17/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">ARAnchor</h2>

<p>物体的3D锚点,表示物体在3D空间的位置和方向</p>

<pre><code class="language-objectivec">/**
 标识符
 */
@property (nonatomic, readonly) NSUUID *identifier;

/**
 锚点的旋转变换矩阵，定义了锚点的旋转、位置、缩放。是一个4x4的矩阵（读者可以自行科普什么叫4x4矩阵）
 */
@property (nonatomic, readonly) matrix_float4x4 transform;

/**
 构造方法,一般我们无需构造。因为添加一个3D物体时ARKit会有代理告知我们物体的锚点
 */
- (instancetype)initWithTransform:(matrix_float4x4)transform;
</code></pre>

<h2 id="toc_1">ARFrame</h2>

<p>主要用于追踪相机的当前状态,包括位置、图像帧以及时间等参数</p>

<pre><code class="language-objectivec">/**
时间戳.
 */
@property (nonatomic, readonly) NSTimeInterval timestamp;

/**
 缓冲区图像帧
 */
@property (nonatomic, readonly) CVPixelBufferRef capturedImage;

/**
相机（表示这个ARFrame是哪一个相机的，iPhone7plus有两个摄像机）
 */
@property (nonatomic, copy, readonly) ARCamera *camera;

/**
 返回当前相机捕捉到的锚点数据（当一个3D虚拟模型加入到ARKit中时，锚点值得就是这个模型在AR中的位置）
 */
@property (nonatomic, copy, readonly) NSArray&lt;ARAnchor *&gt; *anchors;

/**
灯光（指的是灯光强度 一般是0-2000，系统默认1000）
 */
@property (nonatomic, copy, nullable, readonly) ARLightEstimate *lightEstimate;

/**
特征点（捕捉平地或者人脸的，比较苹果有自带的人脸识别功能）
 */
@property (nonatomic, nullable, readonly) ARPointCloud *rawFeaturePoints;

/**
根据2D坐标点搜索3D模型，这个方法通常用于，当我们在手机屏幕点击某一个点的时候，可以捕捉到这一个点所在的3D模型的位置，至于为什么是一个数组非常好理解。手机屏幕一个是长方形，这是一个二维空间。而相机捕捉到的是一个由这个二维空间射出去的长方体，我们点击屏幕一个点可以理解为在这个长方体的边缘射出一条线，这一条线上可能会有多个3D物体模型
point：2D坐标点（手机屏幕某一点）
ARHitTestResultType：捕捉类型  点还是面
(NSArray&lt;ARHitTestResult *&gt; *)：追踪结果数组  详情见本章节ARHitTestResult类介绍

 */
- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;

/**
相机窗口的的坐标变换（可用于相机横竖屏的旋转适配）
 */
- (CGAffineTransform)displayTransformWithViewportSize:(CGSize)viewportSize orientation:(UIInterfaceOrientation)orientation;
</code></pre>

<h2 id="toc_2">ARHitTestResult</h2>

<p>点击的回调结果,通常用于获取ARKit的捕捉结果，获取物体到相机的距离/位置、方向等</p>

<pre><code class="language-swift">//捕捉类型枚举
typedef NS_OPTIONS(NSUInteger, ARHitTestResultType) {
    /** 点. */
    ARHitTestResultTypeFeaturePoint              = (1 &lt;&lt; 0),

    /** 水平面 y为0. */
    ARHitTestResultTypeEstimatedHorizontalPlane  = (1 &lt;&lt; 1),

    /** 已结存在的平面. */
    ARHitTestResultTypeExistingPlane             = (1 &lt;&lt; 3),

    /** 已结存在的锚点和平面. */
    ARHitTestResultTypeExistingPlaneUsingExtent  = (1 &lt;&lt; 4),
} NS_SWIFT_NAME(ARHitTestResult.ResultType);

/**
捕捉类型
 */
@property (nonatomic, readonly) ARHitTestResultType type;

/**
 3D虚拟物体与相机的距离（单位：米）
 */
@property (nonatomic, readonly) CGFloat distance;

/**
本地坐标矩阵（世界坐标指的是相机为场景原点的坐标，而每一个3D物体自身有一个场景，本地坐标就是相对于这个场景的坐标）类似于frame和bounds的区别
 */
@property (nonatomic, readonly) matrix_float4x4 localTransform;

/**
世界坐标矩阵
 */
@property (nonatomic, readonly) matrix_float4x4 worldTransform;

/**
 锚点（3D虚拟物体，在虚拟世界有一个位置，这个位置参数是SceneKit中的SCNVector3：三维矢量），而锚点anchor是这个物体在AR现实场景中的位置，是一个4x4的矩阵
 */
@property (nonatomic, strong, nullable, readonly) ARAnchor *anchor;

</code></pre>

<h2 id="toc_3">ARLightEstimate</h2>

<p>灯光效果</p>

<pre><code class="language-swift">/**
灯光强度  范围0-2000 默认1000
 */
@property (nonatomic, readonly) CGFloat ambientIntensity;

</code></pre>

<h2 id="toc_4">ARPlaneAnchor</h2>

<p>平面锚点,是<code>ARAnchor</code>的子类,<code>ARKit</code>可以自动识别平面并且添加一个锚点到场景中</p>

<p>所有被检测到的表面都会关联到一个<code>ARPlaneAnchor</code>对象，并可进一步使用提供物体到镜头的距离、位置和方向的<code>ARHitTestResult</code>进行描述。<code>ARPlaneAnchor</code>是<code>ARAnchor</code>的一个子类实例，可添加到AR场景中，实现在场景中放置虚拟物体。</p>

<pre><code class="language-swift">/**
平面类型，目前只有一个，就是水平面
 */
@property (nonatomic, readonly) ARPlaneAnchorAlignment alignment;

/**
3轴矢量结构体，表示平地的中心点  x/y/z
 */
@property (nonatomic, readonly) vector_float3 center;

/**
3轴矢量结构体，表示平地的大小（宽度和高度）  x/y/z
 */
@property (nonatomic, readonly) vector_float3 extent;
</code></pre>

<h2 id="toc_5">ARPointCloud</h2>

<p>点状渲染云 主要用于渲染场景</p>

<pre><code class="language-objectivec">/**
 点的数量
 */
@property (nonatomic, readonly) NSUInteger count;

/**
每一个点的位置的集合（结构体带*表示的是结构体数组）
 */
@property (nonatomic, readonly) const vector_float3 *points;
</code></pre>

<h2 id="toc_6">ARConfiguration</h2>

<p>会话追踪配置，主要就是追踪相机的位置</p>

<blockquote>
<p>子类ARWorldTrackingConfiguration</p>
</blockquote>

<pre><code class="language-objectivec">/**
当前设备是否支持，一般A9芯片以下设备不支持
 */
@property(class, nonatomic, readonly) BOOL isSupported;

/**
会话的对齐方式，这里的对其指的是3D世界的坐标。枚举值见下方
 */
@property (nonatomic, readwrite) ARWorldAlignment worldAlignment;

typedef NS_ENUM(NSInteger, ARWorldAlignment) {
    ARWorldAlignmentGravity,//相机位置
    ARWorldAlignmentGravityAndHeading,//相机位置及方向
    ARWorldAlignmentCamera//相机方向
} 

/**
是否需要自适应灯光效果，默认是YES
 */
@property (nonatomic, readwrite, getter=isLightEstimationEnabled) BOOL lightEstimationEnabled;

@end


//世界会话追踪配置，苹果建议我们使用这个类，这个子类只有一个属性，也就是可以帮助我们追踪相机捕捉到的平地
@interface ARWorldTrackingSessionConfiguration : ARSessionConfiguration

/**
侦查类型。枚举值见下方（默认侦查平地）
 */
@property (nonatomic, readwrite) ARPlaneDetection planeDetection;
</code></pre>

<h2 id="toc_7">ARError</h2>

<p>描述ARKit中的错误信息</p>

<pre><code class="language-swift">//作用域，一般会表示是哪一个类出现问题
NSString *const ARErrorDomain;
typedef NS_ERROR_ENUM(ARErrorDomain, ARErrorCode) {
    /** Unsupported session configuration. */
    ARErrorCodeUnsupportedConfiguration   = 100,//不支持会话追踪配置，由于A9芯片以下的机型会报错

    /** A sensor required to run the session is not available. */
    ARErrorCodeSensorUnavailable          = 101,//失活状态

    /** A sensor failed to provide the required input. */
    ARErrorCodeSensorFailed               = 102,//传感器故障

    /** World tracking has encountered a fatal error. */
    ARErrorCodeWorldTrackingFailed        = 200,//追踪失败
};

</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15077240642559.html">SceneKit</a></h1>
			<p class="meta"><time datetime="2017-10-11T20:14:24+08:00" 
			pubdate data-updated="true">10/11/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我们通过<code>ARKit</code>的相机(<code>ARCamera</code>)捕获现实世界图像,利用<code>SceneKit</code>来在图像中展示3D模型</p>

<h2 id="toc_0">SceneKit中常用类及作用</h2>

<ul>
<li><strong>ARCamera</strong>:用于捕获摄像头画面</li>
<li><strong>ARSCNView</strong>:视图类用于展示由摄像头捕捉到的现实世界3D场景,继承自<code>SceneKit</code>中的<code>SCNView</code>用于展示3D场景,<code>SCNView</code>继承自<code>UIView</code>视图</li>
<li><strong>ARSession</strong>: 会话,搭建3D场景</li>
<li><strong>ARKit</strong>:用于将现实世界转为3D场景</li>
<li><strong>SceneKit</strong>:用于将虚拟物体构建在3D场景中</li>
<li><strong>SCNNode</strong>:每个虚拟物体都是一个节点,其作为主节点构成了<code>SCNScene</code>场景,无数个场景构成3D世界</li>
</ul>

<h3 id="toc_1">ARSession</h3>

<p>通过<code>ARSession</code>来沟通<code>ARSCNView</code>和<code>ARCamera</code></p>

<p>我们需要给ARSession会话指定一个<code>会话追踪设置</code>(<code>ARConfiguration</code>),用其来追踪相机在3D世界的位置特征和场景</p>

<p>苹果建议使用<code>ARWorldTrackingConfiguration</code>，该类只支持A9之后芯片</p>

<h4 id="toc_2">ARWorldTrackingConfiguration与ARFrame</h4>

<p><code>ARWorldTrackingConfiguration</code>得到手机在世界中的位置数据交给<code>ARSession</code>，而相机在的位置数据即<strong>ARFrame</strong></p>

<blockquote>
<p>用ARSession的currentFrame属性来获取当前位置信息</p>
</blockquote>

<p><img src="media/15077240642559/15078865839013.png" alt=""/></p>

<p><code>ARConfiguration</code>捕捉相机3D位置的意义就在于能够在添加3D物体模型的时候计算出3D物体模型相对于相机的真实的矩阵位置</p>

<p><code>ARKit API</code>支持两种主配置，即只追踪设备定位的<code>ARConfiguration</code>，以及进一步追踪设备位置并检测真实世界表面<code>ARWorldTrackingConfiguration</code>。</p>

<h2 id="toc_3">ARKit实战</h2>

<p>完整的ARKit环境必须需要:<br/>
ARSCNView、ARSession、ARSessionConfiguration</p>

<p>1.初始化 搭建AR环境</p>

<p>2.开启AR扫描</p>

<blockquote>
<p>苹果推荐将开启的代码写到<code>viewWillAppear</code>而不是<code>viewDidLoad</code></p>
</blockquote>

<p>3.进行自定制操作</p>

<blockquote>
<p>默认情况下，节点<code>SCNNode</code>的x/y/z位置是(0,0,0),也就是摄像头所在的位置，每一个<code>ARSession</code>在启动时，摄像头的位置就是3D世界的原点，而且这个原点不再随着摄像头的移动而改变，是第一次就永久固定的</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15077234771115.html">ARKit</a></h1>
			<p class="meta"><time datetime="2017-10-11T20:04:37+08:00" 
			pubdate data-updated="true">10/11/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>AR即虚拟现实增强技术</p>

<p><code>ARKit</code>是基于苹果的游戏引擎3D(SceneKit)和2D的(SpriktKit)</p>

<p>注意:需要A9处理器的的iOS11以上的系统</p>

<p>增强现实的目标是往真实世界中的特定点插入虚拟内容，并且在真实世界中移动时还能对此虚拟内容保持追踪。ARKit 的基本流程包括从 iOS 设备摄像头中读取视频帧，对每一帧的图片进行处理并获得特征点。特征有很多很多，但我们需要从图片中找出能在多个帧中都被追踪到的特征。特征可能是物体的某个角，或是有纹理的织物的某条边等等。有很多种方式可以生成这些特征，可以在网上了解更多（例如搜索 SIFT）但目前我们只需知道，每张图片里会产生多个唯一标识的特征就足够了。</p>

<p>获得某张图片的特征后，就可以从多个帧中追踪这些特征，随着用户在世界中移动，就可以利用相应的特征点来估算 3D 世界信息，例如当前摄像头的位置和特征的位置。用户移动地越多，就会获得越多的特征，并优化这些估算的 3D 世界信息。</p>

<p>至于平面检测，就是在获得一定数量的 3D 特征点后，尝试在这些点中安装一些平面，然后根据尺度、方向和位置找出最匹配的那个。ARKit 会不断分析 3D 特征点并在代码中报告找到的平面。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14988080333726.html">NSNotification</a></h1>
			<p class="meta"><time datetime="2017-06-30T15:33:53+08:00" 
			pubdate data-updated="true">06/30/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">notification的使用</h2>

<h3 id="toc_1">注册观察者</h3>

<p><code>- (void)addObserver:(id)notificationObserver selector:(SEL)notificationSelector name:(NSString *)notificationName object:(id)notificationSender<br/>
</code><br/>
注意:</p>

<ol>
<li><code>notificationObserver</code>不能为nil</li>
<li><code>notification Selector</code>回调方法有且只有一个参数(<code>NSNotification</code>对象)</li>
<li>如果<code>notificationName</code>为<code>nil</code>，则会接收所有的通知(如果<code>notificationSender</code>不为空，则接收所有来自于<code>notificationSender</code>的所有通知)</li>
<li>如果<code>notificationSender</code>为<code>nil</code>，则会接收所有<code>notificationName</code>定义的通知；否则，接收由<code>notificationSender</code>发送的通知</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的</li>
</ol>

<h3 id="toc_2">post通知</h3>

<pre><code class="language-objectivec">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;First&quot; object:@&quot;博客园-Fly_Elephant&quot;];
-(void)notificationFirst:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
}
//名称:First----对象:博客园-Fly_Elephant

[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;Second&quot; object:@&quot;http://www.cnblogs.com/xiaofeixiang&quot; userInfo:dict];
-(void)notificationSecond:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSDictionary  *dict=[notification userInfo];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
    NSLog(@&quot;获取的值:%@&quot;,[dict objectForKey:@&quot;key&quot;]);
}
//名称:Second----对象:http://www.cnblogs.com/xiaofeixiang
//获取的值:keso
</code></pre>

<h2 id="toc_3">通知原理</h2>

<p>单例的方式创建一个<code>NSNotificationCenter</code>对象<br/>
对象注册观察者时 将注册的<code>name</code> <code>selector</code> <code>object</code> 作为一个模型 添加到一个数组中</p>

<p>post时根据名字和object 找到数组中注册的对象 执行通知的方法</p>

<h2 id="toc_4">多线程</h2>

<p>在多线程应用中，<code>Notification</code>在哪个线程中<code>post</code>，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。<br/>
也就是说，<code>Notification</code>的发送与接收处理都是在同一个线程中.</p>

<h2 id="toc_5">通告队列 NSNotificationQueue</h2>

<p><code>NSNotificationQueue</code> 作用是充当通告中心(<code>NSNotificationCenter</code>)的缓冲区,以FIFO的顺序进行维护。当一个通告上升到队列最前时，就将他发送给通告中心，通告中心随后将它派发给所有注册为观察者的对象</p>

<p>参考<a href="http://www.jianshu.com/p/b4835026e8e9">NSNotification&amp;NSNotificationCenter(实现原理,多线程,内存管理角度)</a><br/>
参考<a href="http://www.cnblogs.com/heyonggang/p/3681689.html">iOS NSNotification的使用</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14982190720101.html">网络通信</a></h1>
			<p class="meta"><time datetime="2017-06-23T19:57:52+08:00" 
			pubdate data-updated="true">06/23/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">TCP/IP五层模型</h2>

<p><img src="media/14982190720101/14982758829850.jpg" alt=""/><br/>
<code>TCP/IP协议五层模型</code>中的应用层对应<code>网络七层模型</code>中的第五层、第六层和第七层的功能</p>

<ul>
<li>应用层:对应应用程序的通信服务  如HTTP,FTP,NFS,SMTP</li>
<li>传输层:是否选择差错恢复协议还是无差错恢复协议，在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。 如TCP UDP</li>
<li>网络层:主要为数据包寻找路由(路由寻址),为了适应最大传输单元长度(MTU)小于包长度的传输介质，网络层还定义了如何分包 ,路由器</li>
<li>数据链路层:传输有地址的帧 ，以太网交换机等 数据成帧后通过差错控制提供数据帧在信道上无差错的传输</li>
<li>物理层:数据传输的物理媒介</li>
</ul>

<p>应用层用于识别数据内容,通过遵循应用层协议(HTTP、FTP或者我们自己定义的协议等)可以识别数据,使数据有意义</p>

<p>TCP/IP协议还提供一项名为UDP（用户数据报协议)<br/>
TCP：面向连接、传输可靠、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br/>
UDP：面向非连接(是指在正式通信前不必与对方先建立连接，不管对方状态就直接发送)、传输不可靠、用于传输少量数据(数据包模式)、速度快。</p>

<p>//UDP传输层传输的示意图<br/>
<img src="media/14982190720101/14982727461179.png" alt=""/></p>

<p>UDP端口对于基于UDP的通信作为单一消息队列和网络端点来操作，而所有TCP通信的终点都是唯一的连接。每个TCP连接由两个端点唯一识别。由于所有TCP连接由两对 IP 地址和TCP端口唯一识别（每个所连主机都有一个地址/端口对），因此每个TCP服务器端口都能提供对多个连接的共享访问</p>

<h2 id="toc_1">TCP的长连接和短连接</h2>

<p>在利用TCP协议开始通讯前,需要客户端和服务端进行<code>三次握手</code>来建立连接,而在结束通信后需要由<code>四次握手</code>来释放连接</p>

<h3 id="toc_2">TCP短连接&amp;&amp;长连接</h3>

<p>短连接即建立连接后,<code>client</code>向<code>server</code>发送消息,<code>server</code>收到消息回应<code>client</code> 然后完成了一次读写通信后,这时候双方都可以进行<code>close</code>操作,一般由客户端进行断开连接的操作,因此短连接只进行一次传递读写的操作</p>

<p>长连接是在建立连接,进行读写之后并不会主动关闭连接,后续仍然使用这个连接来进行读写</p>

<h3 id="toc_3">维护长连接</h3>

<p>我们在应用中创建一个长连接，这个长连接并没有确切时间限制,而是说这条连接需要时间较长<br/>
通常我们在应用中对网络通信的实时性要求较高,需要及时知道已经断开的连接进行及时处理,因此我们需要手工来进行不断探测</p>

<h4 id="toc_4">1.应用层使用心跳包</h4>

<p>一般在一个心跳间隔,客户端发送一个特定<code>ping</code>消息到服务器,服务器返回消息完成一次心跳交互,等待下一轮.如果客户端没有收到心跳反馈就会关闭掉<code>TCP</code>连接,心跳周期一般设置为几分钟,比如微信为300S</p>

<p>心跳机制可以由客户端和服务器两端都可以发送心跳包，两端也都可以监测, 一般为客户端发送心跳包服务器监测,如果在一个心跳周期没有收到心跳反馈可以断开连接(或者没有收到反馈后再发送几次ping包确定没有收到反馈后即断开连接)  而服务器一般在心跳间隔的1.5周期没有收到客户端的心跳包可以选择断开连接，当然具体情况视应用具体需求而定</p>

<h4 id="toc_5">2.TCP/IP协议层面的心跳机制</h4>

<p><strong>TCP保活功能:</strong><br/>
保活功能<code>主要为服务器</code>应用提供，用来检测客户端主机是否已经崩溃,如果客户端主机已经消失,那么服务器上这个连接就成为了半开放连接,而保活功能就是用来检测这种半开放连接的:<br/>
如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机处于以下4个状态之一：</p>

<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ol>

<p>TCP的心跳机制即为利用上面说的保活功能使两小时后发现TCP连接是否存在,如果想要使时间减少就需要修改内核方面参数,这种方式是很不合适的</p>

<h2 id="toc_6">socket编程</h2>

<p><code>socket</code>也称为<strong>套接字</strong>,用于描述IP地址和端口,实现不同主机间通信,IP地址和端口确定一个socket</p>

<blockquote>
<p>端口:用于区分不同应用服务,比如<code>HTTP</code>或者<code>FTP</code>等,然后可以根据应用协议来解析数据</p>
</blockquote>

<p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层，对<code>TCP/IP</code>进行了封装，这就是<code>Socket编程接口</code>,程序员通过其进行网络开发.</p>

<blockquote>
<p>HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力</p>
</blockquote>

<p><img src="media/14982190720101/14984586168116.jpg" alt=""/></p>

<p>在<code>Internet</code>上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个<code>Socket</code>，并绑定到一个端口上，不同的端口对应于不同的服务。</p>

<p><img src="media/14982190720101/14982205873836.jpg" alt=""/></p>

<h2 id="toc_7">常用应用层协议</h2>

<p><strong>应用层协议 :规定了客户端和服务器之间的数据传输格式</strong></p>

<h3 id="toc_8">1.HTTP</h3>

<h4 id="toc_9">长连接&amp;&amp;短连接</h4>

<p>HTTP为应用层协议,在传输层使用TCP协议，在网络使用IP协议<br/>
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br/>
HTTP的长连接和短连接本质就是TCP的长连接和短连接,http通过tcp三次握手建立连接<br/>
在HTTP/1.0中默认使用短连接，每进行一次HTTP操作就建立一次连接,结束就中断<br/>
从HTTP/1.1开始，默认使用长连接来保持连接特性,使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code>,可以在一次连接中处理多个请求，可以重叠进行<br/>
<code>Keep-Alive</code>并不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如<code>Apache</code>）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<blockquote>
<p>注意:这个alive 和 tcp的alive是不同的</p>
</blockquote>

<h4 id="toc_10">轮询</h4>

<p>分为短轮询和长轮询</p>

<p>短轮询:向服务器发送数据，服务器返回结果,不断的操作就是轮询,缺点是浪费了大量资源<br/>
优点：后端程序编写比较容易。 <br/>
缺点：请求中有大半是无用，浪费带宽和服务器资源。 <br/>
实例：适于小型应用。</p>

<p>长轮询：解决了短轮询的问题,长轮询的操作是:前段发送请求给后端，后台收到请求后并不及时返回,加入后台数据没有更新,就将请求挂起来直到有消息返回才返回响应信息并关闭连接,这样就不会频繁请求堵塞服务器<br/>
优点：在无消息的情况下不会频繁的请求，耗费资源小。 <br/>
缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 <br/>
实例：WebQQ、Hi网页版 <br/>
<img src="media/14982190720101/14985257353004.png" alt=""/></p>

<h3 id="toc_11">2.WebSocket</h3>

<p>在上面介绍的HTTP的轮询方式是非常浪费资源的,因为HTTP的header非常长,我们频繁发送一个很小的数据却占用了大量带宽,因此我们可以用<code>webSocket</code>代替</p>

<p><code>WebSocket</code>是应用层协议，是<code>html5</code>一种新的协议。它<strong>实现了浏览器与服务器全双工通信</strong></p>

<p>WebSocket建立连接过程:</p>

<ol>
<li>浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行</li>
<li>TCP连接成功后，浏览器通过<code>HTTP协议</code>向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</li>
<li>服务器收到客户端的握手请求后，同样采用<code>HTTP协议</code>回馈数据。</li>
<li>当收到了连接成功的消息后，通过TCP通道进行传输通信</li>
</ol>

<blockquote>
<p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的<br/>
<code>WebSocket</code>是一种双向通信协议，在建立连接后，<code>WebSocket</code>服务器和<code>Browser/Client Agent</code>都能主动的向对方发送或接收数据，就像<code>Socket</code>一样;</p>
</blockquote>

<p>存在问题:<br/>
<code>webSockets</code>虽然是实现了长连接，但是如果客户端与服务端长时间没有发送数据，那么网络链路就会认为这个连接已经失效，会自作主张的将其断开，因此需要发送心跳包</p>

<p>iOS端使用webSocket：<br/>
<a href="http://www.cocoachina.com/ios/20161031/17886.html">接入WebSocket记录</a></p>

<h2 id="toc_12">iOS中网络编程</h2>

<h3 id="toc_13">iOS网络层次</h3>

<p>iOS网络编程层次结构分为三层:<br/>
Cocoa层：NSURL，Bonjour，Game Kit，WebKit<br/>
Core Foundation层：基于C的CFNetwork 和 CFNetServices<br/>
OS层:基于C的 BSD socket</p>

<p><code>Bonjour</code>封装了<code>CFNetwork</code>,Bonjour中的<code>NSNetService</code>也有对应底层实现<code>CFNetService</code>，<code>NSInputStream</code>有对应的底层实现<code>CFInputStream</code></p>

<p><code>Bonjour</code>是一种能够自动查询接入网络中的设备或应用程序的协议，抽象ip和port为<code>service</code>，一个应用程序<code>publish</code>一个网络服务<code>service</code>然后网络中的其他程序就能自动发现这个<code>service</code>，从而可以向这个<code>service</code>查询其<code>ip</code>和<code>port</code>，然后通过获得的<code>ip</code>和<code>port</code>建立 <code>socket</code>链接进行通信。通常我们是通过<code>NSNetService</code>和<code>NSNetServiceBrowser</code>来使用 <code>Bonjour</code>的，前者用于建立与发布<code>service</code>，后者用于监听查询网络上的<code>service</code>。<br/>
不多做介绍,深入学习可以参考<a href="http://www.cnblogs.com/kesalin/archive/2011/09/15/cocoa_bonjour.html">深入浅出Cocoa之Bonjour网络编程</a></p>

<h3 id="toc_14">iOS中应用限制</h3>

<p>Apple为了让设备尽量省电，减少不必要的开销，保持系统流畅除了特殊的官方程序外是不会让程序在后台无限执行的,开发者开发的程序收到以下限制:</p>

<p>按下<code>home</code>将应用转为后台运行后,app后台运行时间有限（可以通过<code>backgroundTimeRemaining</code>属性来获取这个可用时间）(<code>拥有180s运行时间可以处理后台操作</code>), 时间结束后我们的程序在程序会进入挂起状态，这种状态下应用不会执行任何代码、关闭定时器、系统会收回给程序分配的<code>socket</code>资源</p>

<p>我们只能通过苹果提供的几种特殊后台方式来进行程序的“后台”工作</p>

<ol>
<li><p>进入后台后前若应用还有未完成任务,可以申请有限时间(最多不超过10分钟)来完成重要任务<br/>
当10分钟到了后会，无论怎么向系统申请继续后台，系统会强制挂起App，挂起所有后台操作、线程，直到用户再次点击App之后才会继续运行。</p>
<pre><code class="language-objectivec">- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void (^)(void))handler
//返回一个新的后台任务的唯一的标示符，你必须将这个值传给endBackgroundTask:方法来标记任务的结束。如果无法在后台运行这个方法将返回UIBackgroundTaskInvalid。<br/>
//handle回调是在时间快到了执行,防申请到的时间片段内，还是没能完成任务的话，做最后的清理和标注工作,如果不传的话，那么结果就是iOS直接kill掉你的APP
</code></pre>
<p>必须在任务执行结束时，调用<code>endBackgroundTask</code>并传递这个标示符，来结束后台任务。</p></li>
<li><p>iOS为特殊任务设计的后台模式</p></li>
</ol>

<p>后台下载任务：<br/>
<code>Background Downloading</code> <strong>后台下载</strong>,必须使用 iOS 指定的机制才可以，那就是 <code>NSURLSession</code></p>

<p>后台运行的特定服务类型<br/>
    <img src="media/14982190720101/14990618979269.jpg" alt=""/></p>

<pre><code class="language-text">1. 应用在后台播放或者录制音频
2. APP更新GPS信息，通知给用户
3. `voip` 网络电话功能
4. 杂志应用,在后台下载杂志并处理(用通知触发后台下载任务)
5. 一些控制外设的app，需要不停与外设沟通.系统就不会主动关闭 APP 与 外设之间的连接，而是替
    APP 监视这个连接，但有数据过来时，会唤醒 APP 进行处理，每次唤醒 APP 只有 10S 时间
    进行数据处理(不够的话还使用上面的方法申请更多时间)
6. iPhone作为蓝牙中心设备，需要不停更新蓝牙设备
7. iphone作为蓝牙外围设备，需要不停访问其他蓝牙设备数据
8. 需要在后台频繁有规律获取数据,统在你的 APP 进入后台后，会间隔性的给机会将你的 APP 唤醒，
   并回调你的 委托方法`application:performFetchWithCompletionHandler:`
9. App后台关注推送,推送到达时，后台启动app：服务端推送加上键值对content-available = 1的
   话, 手机收到这个通知后，会自动启动 APP 到后台，或 唤醒（依旧保持后台执行），并回调 委托
   方法 application:didReceiveRemoteNotification:fetchCompletionHandler:
</code></pre>

<p>详细设计可参考<a href="http://dxjia.cn/2016/05/26/ios-background-executions/?utm_source=tuicool&amp;utm_medium=referral">iOS 后台任务设计指导</a></p>

<h2 id="toc_15">补充：</h2>

<p>*### WebService<br/>
*<code>Web Service</code>是一种可以接收从<code>Internet</code>或者<code>Intranet</code>上的其它系统中传递过来的请求，轻量级的独立的通讯技术。<br/>
WebService是一种跨编程语言和跨操作系统平台的远程调用技术</p>

<p>远程调用就是:一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法。 例如百度等把自己的系统服务以<code>webservice</code>服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能</p>

<p>可以从多个角度来理解<code>WebService</code>，从表面上看，<code>WebService</code>就是一个应用程序向外界暴露出一个能通过<code>Web</code>进行调用的<code>API</code>,能用编程的方法通过Web来调用这个应用程序,那么提供这个<code>WebService</code>的应用程序就是服务端。从深层次看，<code>WebService</code>是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在<code>Web</code>上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写<code>WebService</code>，只要我们可以通过<code>WebService</code>标准对这些服务进行查询和访问。</p>

<p>为了分布式应用程序的创建,必须要有一套标准的类型系统,需要标准的描述语言来描述webService让开发者可以获取信息，最后还需要有一个方法对这个<code>WebService</code>进行远程调用即远程调用协议(RPC)，为了达到跨语言跨平台目的这个RPC还需要和平台语言无关</p>

<ol>
<li>XML+XSD<br/>
WebService采用HTTP协议传输数据，采用XML格式封装数据，
<code>XSD</code>即 <code>XML Schema</code> 是定义了XML的标准数据类型.WebService平台就是用XSD来作为其数据类型系统的。</li>
<li>SOAP（简单对象访问协议）<br/>
WebService采用HTTP协议传输数据，采用XML格式封装数据，并且增加了一些特定的HTTP消息头来说明消息的内容格式，这些特定的HTTP消息头和XML内容格式就是<code>SOAP协议</code>。SOAP提供了标准的RPC方法来调用Web Service。
<code>SOAP协议 = HTTP协议 + XML数据格式</code>
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。</li>
<li>WSDL（Web服务描述语言）<br/>
WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么。<code>WSDL</code>文件是一个<code>XML</code>文档，用于描述Web Service及其函数、参数和返回值。</li>
</ol>

<p><code>WebService</code>服务提供商可以通过两种方式来暴露它的<code>WSDL</code>文件地址：1.注册到<code>UDDI</code>服务器，以便被人查找；2.直接告诉给客户端调用者。</p>

<p><code>WebService</code>的调用有3种方式：<br/>
1)httpget <br/>
2)httppost<br/>
3)httpsoap<br/>
<code>soap</code>的优点是 可以传递结构化的数据，而前两种不行</p>

<p>将数据直接用XML格式封装 因此不用担心编码，大小写等问题,传递数据可以是数组，对象等</p>

<p>但是由于要进行XML解析 因此会导致效率有所降低</p>

<h2 id="toc_16">参考连接:</h2>

<p><a href="http://blog.csdn.net/wwd0501/article/details/54582912">WebSocket介绍，与Socket的区别</a><br/>
<a href="http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html">Web 通信 之 长连接、长轮询</a><br/>
<a href="http://blog.csdn.net/prl18353364833/article/details/51593643">网络七层协议 五层模型</a><br/>
<a href="http://www.jianshu.com/p/49d7997ad3b7">Web Service到底是什么</a><br/>
<a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理</a><br/>
<a href="http://www.jianshu.com/p/121fc5b7f2d3">iOS Background Modes</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14976139025239.html">编码</a></h1>
			<p class="meta"><time datetime="2017-06-16T19:51:42+08:00" 
			pubdate data-updated="true">06/16/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>参考：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">ASCII,Unicode、UTF-8</a></p>

<p><a href="https://objccn.io/issue-9-1/">https://objccn.io/issue-9-1/</a></p>

<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000</a></p>

<h2 id="toc_0">unicode码</h2>

<p>unicode码表示 <code>U+F8FF</code> 可以用 <code>\uF8FF</code>即为unicode编码 F8FF即为这个字符的16进制表示</p>

<p>多个字符的unicode码可以组合为一个新的字符 例如<code>\ud83c\udf49</code>可以组合为<code>🍉</code>,一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<p>补充:<br/>
注意:<br/>
 <code>Swift</code>与<code>OC</code>不同，swift中将每个字符都看作可扩展的字形群,因此对于é(&quot;\u{65}\u{301}&quot;)看作一个字符,而对于OC这是两个字符,而对两者说字符串长度就是字符的数量</p>

<blockquote>
<p>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式<br/>
可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数<br/>
量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一<br/>
个长字符串，需要注意<code>characters</code>属性必须遍历全部的<code>Unicode</code>标量，来确定字符串的字符数量。<br/>
另外需要注意的是<strong>通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的 <code>length</code>属性相同</strong>。 <strong>NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集</strong>。作为佐证，当一个 NSString的length属性被一个Swift的String值访问时，实际上是调用了<code>utf16Count</code></p>
</blockquote>

<h2 id="toc_1">获取字符串中字符的unicode码</h2>

<pre><code class="language-objectivec">//其16进制就是字符‘的’的unicode码
unichar character = [@“的” characterAtIndex:0];
</code></pre>

<p>对于上面说的🍉这种多个unicode码组合字符 其index0位置为d83c index1位置为df49 由两个字符组成</p>

<blockquote>
<p>iOS开发中用<code>unichar</code>是两字节长的<code>char</code>，代表<code>unicode</code>的一个字符</p>
</blockquote>

<pre><code class="language-objectivec">//将unicode码转为字符
NSLog(@&quot;%@&quot;,[NSString stringWithCharacters:&amp;character length:1]);
</code></pre>

<p>补充:<br/>
与<code>char</code>的初始化相同 unichar a = &#39;2&#39;可以用单引号初始化unichar<br/>
不论char还是iOS开发中用的unichar 只能用上面的初始化方法初始化字符为ascii码</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14968918049808.html">NSURL</a></h1>
			<p class="meta"><time datetime="2017-06-08T11:16:44+08:00" 
			pubdate data-updated="true">06/08/2017</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>URL(统一资源定位符) 是一种 URI，URN(统一资源名称) 也是一种 URI，所以 URI (统一资源标志符)可被视为定位符，名称或两者兼备</p>

<h2 id="toc_0">URL Encode</h2>

<p><a href="http://www.jianshu.com/p/38f5f53dfbad">[iOS-Foundation] NSURL</a><br/>
<code>URL</code>采用<code>ASCII</code>编码格式，所以不支持如中文等非<code>ASCII</code>码字符，另外<code>URL</code>中保留的分隔符号(?、&amp;、=等)也无法作为内容，否则会引起歧义。<br/>
这就需要通过编码，用安全的字符来表示这些不符合要求的字符，格式是%加两位安全字符，所以 URL 编码也称为百分号编码。</p>

<pre><code class="language-objectivec">//Encode编码
NSString *urlString = @&quot;?&quot;;
NSString *encodedString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLHostAllowedCharacterSet]];
//encodedString值为 %3F
//替换不符合要求UTF-8编码为百分号编码字符
@interface NSCharacterSet (NSURLUtilities)
+ (NSCharacterSet *)URLUserAllowedCharacterSet;
+ (NSCharacterSet *)URLPasswordAllowedCharacterSet;
+ (NSCharacterSet *)URLHostAllowedCharacterSet;
+ (NSCharacterSet *)URLPathAllowedCharacterSet;
+ (NSCharacterSet *)URLQueryAllowedCharacterSet;
+ (NSCharacterSet *)URLFragmentAllowedCharacterSet;
@end
</code></pre>

<pre><code class="language-objectivec">//Unencode解码
+ (NSString *)decodeURLString:(NSString *)URLString {
    // 有时从服务端获取的 URL 中，空格被编码为+, 
    // 而方法- stringByRemovingPercentEncoding只替换百分号编码，
    // 所以要在执行该方法前，先将`+`替换掉(真正的加号字符是被百分号编码的)
    NSString *result = [URLString stringByReplacingOccurrencesOfString:@&quot;+&quot; withString:@&quot; &quot;];
    //替换所有百分号编码为UTF-8编码字符
    result = [result stringByRemovingPercentEncoding];
    return result;
}
</code></pre>

<h2 id="toc_1">NSURL</h2>

<p><a href="https://developer.apple.com/documentation/foundation/nsurl?preferredLanguage=occ">NSURL苹果官方文档</a></p>

<p>我们通过<code>NSURL</code>对象来构建一个资源定位符。对于本地文件的资源定位符,我们可以直接操作这些问价你的属性（比如修改文件的的最后修改日期）,对于远程资源我们可以将<code>NSURL</code>对象传递给其他API来获取内容,<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">Next About the URL Loading System</a></p>

<p><code>URL</code>对象是指向本地文件的首选方案,大多数进行文件数据读写对象都接受一个<code>NSURL</code>对象而不是一个文件路径.例如：可以用文件<code>NSURL</code>获取<code>NSString</code>  <code>initWithContentsOfURL:encoding:error:</code>,获取<code>data</code>  <code>initWithContentsOfURL:options:error:</code></p>

<p>你也可以用url资源定位符进行需要的操作,例如在<code>macOS</code>的<code>NSWorkspace</code>类和<code>iOS</code>的<code>UIApplication</code>类提供的<code>OpenURL:</code>方法来打开一个指定的URL位置</p>

<p>此外,我们可以通过使用粘贴板来对<code>NSURL</code>对象进行引用（AppKit框架的一部分）</p>

<p><code>NSURL</code>对应<code>Core Foundation</code>中的<a href="https://developer.apple.com/documentation/corefoundation/cfurlref?language=objc">CFURLRef</a>,我们可以查看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2">Toll-Free Bridging</a>来获取更多类似的与<code>Core Foundation</code>相对应的信息</p>

<p>补充：<br/>
Swift提供了<a href="https://developer.apple.com/documentation/foundation/url?language=objc">URL</a>结构，负责连接<code>NSURL</code>类，可以在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13"> Classes and Structures</a>中查看更多信息</p>

<h3 id="toc_2">URL结构</h3>

<p>一个<code>NSURL</code>对象由两部分组成:一部分是可能为<code>nil</code>的<code>base URL</code>和一部分与<code>base URL</code>有相对关系的字符串<code>relativeString</code>。如果一个<code>NSURL</code>对象没有<code>base</code>部分只有<code>string</code>部分那么它被认为是绝对地址,否则为相对的.</p>

<pre><code class="language-objectivec">//file:///path/to/user/ as the base URL and folder/file.html
/**
    我们指定 file:///path/to/user/ 为baseURL folder/file 为字符串部分
*/
NSURL *baseURL = [NSURL fileURLWithPath:@&quot;file:///path/to/user/&quot;];
NSURL *URL = [NSURL URLWithString:@&quot;folder/file.html&quot; relativeToURL:baseURL];
NSLog(@&quot;absoluteURL = %@&quot;, [URL absoluteURL]);//file:///path/to/user/ as the base URL and folder/file.html
/**
    这个URL的
    absoluteString:  file:///file:/path/to/folder/file.html
    baseURL:  file:///file:/path/to/user
    relativeString： folder/file.html
*/
</code></pre>

<p>对于一个<code>URL</code>我们可以将其分为很多部分,例如一个url如下：<br/>
<code>https://johnny:p4ssw0rd@www.example.com:443/script.ext;param=value?query=value#ref</code></p>

<table>
<thead>
<tr>
<th>Component</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>scheme</td>
<td>https</td>
</tr>
<tr>
<td>user</td>
<td>johnny</td>
</tr>
<tr>
<td>password</td>
<td>p4ssw0rd</td>
</tr>
<tr>
<td>host</td>
<td><a href="http://www.example.com">www.example.com</a></td>
</tr>
<tr>
<td>port</td>
<td>443</td>
</tr>
<tr>
<td>path</td>
<td>/script.ext</td>
</tr>
<tr>
<td>pathExtension</td>
<td>ext</td>
</tr>
<tr>
<td>pathComponents</td>
<td>[&quot;/&quot;, &quot;script.ext&quot;]</td>
</tr>
<tr>
<td>parameterString</td>
<td>param=value</td>
</tr>
<tr>
<td>query</td>
<td>query=value</td>
</tr>
<tr>
<td>fragment</td>
<td>ref</td>
</tr>
</tbody>
</table>

<p><code>NSURL</code>也提供了很多属性让我们来获取每部分</p>

<h3 id="toc_3">书签以及安全范围</h3>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_18.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_16.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"><strong>多线程&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&&%E9%94%81.html"><strong>线程安全&&锁&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="RunLoop.html"><strong>RunLoop&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="KVC&&KVO.html"><strong>KVC&&KVO&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="runtime%E5%AD%A6%E4%B9%A0.html"><strong>runtime学习&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>OC高级编程-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="block%E5%AD%A6%E4%B9%A0.html"><strong>block学习&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><strong>官方文档-内存管理&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="GPU&&%E6%B8%B2%E6%9F%93.html"><strong>GPU&&渲染&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%B0%88(%E6%91%98%E5%BD%95).html"><strong>设计模式架构谈(摘录)&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0.html"><strong>组件化开发学习&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.html"><strong>iOS编译流程&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="dyld(%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8).html"><strong>dyld(程序启动)&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Mach-O%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3.html"><strong>Mach-O文件了解&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="iOS-CoreAnimation.html"><strong>iOS-CoreAnimation&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="CoreGraphic.html"><strong>CoreGraphic&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ARKit.html"><strong>ARKit&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AFNetworking.html"><strong>AFNetworking&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="AsyncDisplayKit.html"><strong>AsyncDisplayKit&nbsp;(16)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="ReactnativeCocoa.html"><strong>ReactnativeCocoa&nbsp;(13)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="PromiseKit.html"><strong>PromiseKit&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.html"><strong>项目监控&nbsp;(8)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="APP%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96.html"><strong>APP体积优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96.html"><strong>启动优化&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Instrument%E5%AD%A6%E4%B9%A0.html"><strong>Instrument学习&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="LLDB.html"><strong>LLDB&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html"><strong>自动化测试&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="git.html"><strong>git&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Cocoapods.html"><strong>Cocoapods&nbsp;(4)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E6%8B%BE%E9%81%97.html"><strong>拾遗&nbsp;(36)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E9%9D%A2%E8%AF%95.html">面试&nbsp;(12)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">iOS开发知识点拾遗&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%BE%E9%81%97.html">知识点拾遗&nbsp;(13)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%20%E5%B0%8F%E7%9F%A5%E8%AF%86.html">iOS 小知识&nbsp;(8)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="Swift-BaseLearning.html"><strong>Swift基础知识&nbsp;(28)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Computer-programming.html"><strong>计算机编程&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>JavaScript学习笔记&nbsp;(41)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E5%9F%BA%E7%A1%80.html">基础&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A.html">知识普及&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Flex.html">Flex&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="ES6.html">ES6&nbsp;(17)</a>&nbsp;&nbsp;
	        
	        	<a href="React.html">React&nbsp;(10)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="React-Native.html"><strong>React-Native&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Python.html"><strong>Python&nbsp;(14)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E7%AE%97%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>算法读书笔记&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15718858302183.html">官方文档</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710288132412.html">Collections and asynchronous updates</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15710248960458.html">Layout Specs</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707800044047.html">Node Lifecycle</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15707737201639.html">线程</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>