<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2018-08-24T15:47:20+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Promise]]></title>
    <link href="https://acefish.github.io/15471197068949.html"/>
    <updated>2019-01-10T19:28:26+08:00</updated>
    <id>https://acefish.github.io/15471197068949.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Promise 写法</h2>

<pre><code class="language-javascript">//构造一个Promise
const promise = new Promise((resolve, reject) =&gt; {
    // resolve 或者  reject只返回一个 一次 然后就会停止监听了
    // setTimeout(() =&gt; {
    //     resolve(&quot;这是返回的结果&quot;)
        
    // }, 2000);
    setTimeout(() =&gt; {
     reject(Error(&quot;这是错误的信息结果&quot;))
    }, 3000);
})
//监听这个promise返回结果
promise.then(result =&gt; {
    console.log(result)
}).catch(err =&gt; {
    console.log(err)
})
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象]]></title>
    <link href="https://acefish.github.io/15471147696850.html"/>
    <updated>2019-01-10T18:06:09+08:00</updated>
    <id>https://acefish.github.io/15471147696850.html</id>
    <content type="html"><![CDATA[
<p>JS对象可以通过<code>[ ]</code>来取值和赋值属性或者方法</p>

<h2 id="toc_0">ES6对象写法改变</h2>

<h3 id="toc_1">简写对象属性</h3>

<p>当属性名和变量名相同时 可以省写,只写一个属性名即可</p>

<pre><code class="language-javascript">    const name = &quot;lyy&quot;
    const age = 25
    const birthday = &quot;1994-10&quot;
    
      
    const lyy = {
        name: name, //旧版写法
        age, //es6简写形式
        birthday,
    }
</code></pre>

<h3 id="toc_2">简写对象方法</h3>

<p>对象方法可以简写省略: 和 function 关键字</p>

<pre><code class="language-javascript">const lyy = {       
    showName() { //es6简写

    },
    showAge: function() { //旧版写法

    }
}
</code></pre>

<h3 id="toc_3">对象计算属性</h3>

<p><code>[ ]</code>方括号属性 -- 计算属性</p>

<pre><code class="language-javascript">let id = 1;

const userId  = {
    [`userId-${++id}`] : id,
    [`userId-${++id}`] : id,
    [`userId-${++id}`] : id,
}
//{userId-2: 2, userId-3: 3, userId-4: 4}


const keyArr = [&quot;name&quot;, &quot;age&quot;, &quot;birthday&quot;]
const valueArr = [&quot;lyy&quot;, 27, &quot;1993-12&quot;]

const poeple = {
    [keyArr.shift()] : valueArr.shift(),
    [keyArr.shift()] : valueArr.shift(),
    [keyArr.shift()] : valueArr.shift()
}
console.log(poeple) //{name: &quot;lyy&quot;, age: 27, birthday: &quot;1993-12&quot;}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组]]></title>
    <link href="https://acefish.github.io/15471038798384.html"/>
    <updated>2019-01-10T15:04:39+08:00</updated>
    <id>https://acefish.github.io/15471038798384.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Array.from()</h2>

<p><code>Array.from()</code>用于将可迭代对象(有Sysmbol.iterator接口对象)和类数组对象(有lengths属性对象)装换为真正的数组Array对象</p>

<p><code>Array.from(obj, func)</code><br/>
将类数组或者遍历对象转换为数组对象，再将每个数组元素调用func方法处理(类似map)</p>

<pre><code class="language-javascript">//lis是个类数组对象
const lis = document.querySelectorAll(&quot;li&quot;)

const liName = Array.from(lis, li =&gt; li.textContent)
console.log(liName)


function sum() {
    //arguments是类数组对象
    return Array.from(arguments).reduce((pre, curr) =&gt; pre+curr, 0)
}
</code></pre>

<h2 id="toc_1">Array.of()</h2>

<p>Array.of()是为了弥补 Array(count)方法的歧义</p>

<pre><code class="language-javascript">Array(2) //[undefined, undefined]
Array(2,7) //[2, 7]

Array.of(2) //[2]
Array.of(2, 7) //[2, 7]
</code></pre>

<h2 id="toc_2">数组ES6新方法</h2>

<ol>
<li><p>find()</p>
<p>find(func) 参数为一个函数 返回bool 返回第一个函数返回为true的元素 找到符合条件的即会停止遍历</p>
<pre><code class="language-javascript">const numbers = [11, 32, 24, 12]
const result = numbers.find((element, index, array) =&gt; element == 11)<br/>
console.log(result) // 11
</code></pre></li>
<li><p>findIndex()</p>
<p>findIndex(func) 参数为一个函数 返回bool 返回第一个函数返回为true的元素的下标值 找到符合条件的即会停止遍历</p>
<pre><code class="language-javascript">const numbers = [11, 32, 24, 12]
const result = numbers.find((element, index, array) =&gt; element == 11)<br/>
console.log(result) // 0
</code></pre></li>
<li><p>some()</p>
<p>some(func) 返回bool 判断数组中是否至少有一个符合func条件 遇到符合条件的停止遍历</p></li>
<li><p>every()</p>
<p>every(func) 返回bool 判断数组中是否全部符合func条件 会遍历全部</p></li>
</ol>

<h2 id="toc_3">Array常用方法</h2>

<ol>
<li><p>slice<br/>
<code>arr.slice(fromIndex, toIndex)</code><br/>
获取数组从开始索引到结束索引切片后的子数组</p>
<blockquote>
<p>如果结束索引大于数组长度,就获取到数组结尾停止</p>
</blockquote></li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[遍历]]></title>
    <link href="https://acefish.github.io/15470891496440.html"/>
    <updated>2019-01-10T10:59:09+08:00</updated>
    <id>https://acefish.github.io/15470891496440.html</id>
    <content type="html"><![CDATA[
<p>ES有新的遍历方式 <code>for of</code></p>

<pre><code class="language-javascript">const fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;mango&quot;]
fruits.describe = &quot;this is all describe&quot;

Array.prototype.firstName = function() {
    return this[0]
}
</code></pre>

<h2 id="toc_0">常用遍历方式</h2>

<ol>
<li><p>for循环<br/>
写法比较繁琐</p>
<pre><code class="language-javascript">for (let index = 0; index &lt; fruits.length; index++) {
    if(fruits[index] == &quot;banana&quot;) {<br/>
        continue;<br/>
    }<br/>
    console.log(&quot;for循环&quot; + fruits[index])                <br/>
}<br/>
/*<br/>
for循环apple<br/>
for循环banana<br/>
for循环orange<br/>
for循环mango<br/>
*/
</code></pre></li>
<li><p>for each</p>
<p>可以使用箭头函数 写法便捷 但是不能使用continue 和 break</p>
<pre><code class="language-javascript">fruits.forEach(fruit =&gt; {
// if(fruit == &quot;banana&quot;) {<br/>
//     continue;<br/>
// }<br/>
console.log(&quot;for each &quot;+fruit)<br/>
});<br/>
/*<br/>
for each apple<br/>
for each banana<br/>
for each orange<br/>
for each mango<br/>
*/
</code></pre></li>
<li><p>for in</p>
<p>forin 遍历获取的是key 需要额外取值value<br/>
forin不仅仅可以遍历可迭代对象<br/>
<strong>forin遍历可以获取对象的原型方法和对象方法、属性</strong></p>
<pre><code class="language-javascript">for (const key in fruits) {
    if(fruits[key] == &quot;banana&quot;) {<br/>
        continue;<br/>
    }<br/>
    console.log(&quot;for in key &quot;+ key+ &quot; value &quot; + fruits[key])<br/>
}<br/>
/*<br/>
for in key 0 value apple<br/>
for in key 2 value orange<br/>
for in key 3 value mango<br/>
for in key describe value this is all describe<br/>
for in key firstName value function() {<br/>
    return this[0]<br/>
}<br/>
*/
</code></pre>
<p>forin遍历不可迭代对象</p>
<pre><code class="language-javascript">const fankai = {
    name: &quot;fankai&quot;,<br/>
    age: 26<br/>
}<br/>
for (const value in fankai) {<br/>
    console.log(value)<br/>
}
</code></pre></li>
<li><p>for of</p>
<p>遍历可迭代对象</p>
<pre><code class="language-objectivec">for (const fruit of fruits) {
    if(fruit == &quot;banana&quot;) {<br/>
        continue;<br/>
    }<br/>
    console.log(&quot;for of &quot;+ fruit)<br/>
}<br/>
/**<br/>
* for of apple<br/>
* for of orange<br/>
* for of mango<br/>
*/
</code></pre></li>
</ol>

<h3 id="toc_1">for of</h3>

<p>只能遍历可迭代对象<br/>
可迭代对象就是部署了<code>iterable</code>接口 或者定义了<code>Symbol.iterator</code>方法的数据结构。<br/>
<code>js</code>内置了一些带遍历器接口的数据结构,例如Array、map</p>

<p>iterable接口 内置了<code>next</code>方法,调用该方法返回对象,该对象包含值<code>value</code>，以及是否遍历结束的标识<code>done</code>，value中包含了当前的索引以及索引对应的值</p>

<p><img src="media/15470891496440/15471018365126.jpg" alt="" style="width:544px;"/></p>

<p><code>entries()</code>可以获取包含数组的键值对</p>

<pre><code class="language-javascript">//entries() 获取数组的可迭代对象 该对象包含数组的键值对(key/value)
for (let [index, fruit] of fruits.entries()) {
    console.log(index, fruit)
}
</code></pre>

<h4 id="toc_2">for of 常用实例</h4>

<p>for of循环遍历除了可以遍历数组外 还经常用于其他地方:</p>

<ol>
<li><p>遍历方法参数<code>arguments</code></p>
<pre><code class="language-javascript">function sum() {
    for (const variable of arguments) {<br/>
        console.log(variable)<br/>
    }<br/>
}
</code></pre></li>
<li><p>遍历字符串</p>
<pre><code class="language-javascript">for (const char of &quot;object&quot;) {
    console.log(char)<br/>
}
</code></pre></li>
<li><p>遍历DOM元素</p>
<pre><code class="language-javascript">const lis = document.querySelectorAll(&quot;li&quot;)
for (const li of lis) {<br/>
}
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解构]]></title>
    <link href="https://acefish.github.io/15470311819265.html"/>
    <updated>2019-01-09T18:53:01+08:00</updated>
    <id>https://acefish.github.io/15470311819265.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">对象解构</h2>

<p>为了方便一次性取出对象中的多个值,而不需要一一的取值赋值</p>

<pre><code class="language-javascript">const fk = {
    name: &quot;fankai&quot;,
    age: 26,
    family: {
        farther: &quot;fkfarther&quot;,
        mother: &quot;fkmother&quot;,
        brother: &quot;lyy&quot;
    }
}
</code></pre>

<p>常用的对象解构</p>

<pre><code class="language-javascript">const {name, age} = fk
console.log(name) //fankai
console.log(name) //26

//当变量已经被声明过
let name
//使用括号括起来 否则js会认为是语句
({name, age} = fk)
</code></pre>

<p>使用与属性名不同的变量名</p>

<pre><code class="language-javascript">const {farther: far, mother: mon, brother} = fk.family
console.log(far)
</code></pre>

<p>当变量对应属性不存在时(即必须为undefined),使用默认值</p>

<pre><code class="language-javascript">const {farther, sister = &quot;hava no sisiter&quot;} = fk.family
console.log(sister) //hava no sisiter
</code></pre>

<h3 id="toc_1">数组解构</h3>

<p>可以一次性从数组中取出多个值</p>

<pre><code class="language-javascript">const numbers = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]

//数组解构
const [a, b] = numbers
console.log(a) //one
console.log(b) //two

//如果有可以用空,来越过数组中变量
const [m, ,n] = numbers
console.log(m) //one
console.log(n) //three

//...onthers 来获取剩下所有值
const [c, ...others] = numbers
console.log(c) //one
console.log(others) //[&quot;two&quot;, &quot;three&quot;, &quot;four&quot;]

//当不存在该值 即 该值为undefined时 使用默认值
const [d, g, , ,f=&quot;five&quot;] = numbers
console.log(f) //five
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串]]></title>
    <link href="https://acefish.github.io/15470129072619.html"/>
    <updated>2019-01-09T13:48:27+08:00</updated>
    <id>https://acefish.github.io/15470129072619.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">字符串函数ES6</h2>

<ol>
<li><p>startWith(str, index)<br/>
返回boolean<br/>
判断字符串是否从指定位置开始<br/>
index可以省略表示 字符串是否从头开始</p>
<pre><code class="language-javascript">const myName = &quot;zheshi shenme?&quot;
myName.startsWith(&quot;zhe&quot;) //true<br/>
myName.startsWith(&quot;shi&quot;, 3) //true
</code></pre></li>
<li><p>endWith(str, index)<br/>
返回boolean<br/>
判断字符串是否结束在指定位置</p>
<pre><code class="language-javascript">const myName = &quot;zheshi shenme?&quot;
myName.endsWith(&quot;?&quot;) //true<br/>
myName.endsWith(&quot;shi&quot;, 6) //true
</code></pre></li>
<li><p>includes(str, index)<br/>
返回boolean<br/>
判断字符串从index往后的字符串中是否包含子字符串</p>
<pre><code class="language-javascript">const myName = &quot;zheshi shenme?&quot;
myName.endsWith(&quot;?&quot;) //true<br/>
myName.endsWith(&quot;shi&quot;, 6) //true
</code></pre></li>
<li><p>repeat(count)<br/>
<code>str.repeat(count)</code>返回一个str重复coun次的字符串</p>
<pre><code class="language-javascript">const str = &quot;哈&quot;
let result = str.repeat(5) //哈哈哈哈哈
</code></pre>
<p>可以使用<code>repeat</code>来实现对齐功能</p></li>
</ol>

<h2 id="toc_1">模板字符串/字符</h2>

<p>ES6中引入模板字符串</p>

<p>使用反引号括起来字符串  用<code>${}</code>括起来变量或表达式</p>

<pre><code class="language-javascript">const myName = &quot;lyy&quot;
const logStr1 = &quot;my name is &quot; + myName
const logStr = `my name is ${myName}`
console.log(logStr1)
</code></pre>

<blockquote>
<p>特点:模板字符串会保留字符串中所有的空白符号 比如:空格、回车等</p>
</blockquote>

<p>示例程序:<br/>
使用拼接html的字符串，可以直观的使用标签以及格式来书写html</p>

<blockquote>
<p>特点:模板字符串是可以嵌套的</p>
</blockquote>

<pre><code class="language-javascript">const todoArr = [
    {name: &quot;go to home&quot;, completed: true},
    {name: &quot;open book&quot;, completed: true},
    {name: &quot;write book&quot;, completed: false}
]

const template = `
    &lt;ul&gt;
     ${todoArr.map(todo =&gt; `
        &lt;li&gt; 
        ${todo.name} completed: ${todo.completed ? `yes` : `no`} 
        &lt;/li&gt;`).join(&quot;&quot;)} 
    &lt;/ul&gt;
`
document.write(template)
</code></pre>

<h3 id="toc_2">标签模板字符串</h3>

<p>标签模板字符串<br/>
用模板字符串作为函数的参数</p>

<pre><code class="language-javascript"> &lt;script&gt;
        function highlight(string, ...args) {
            //string 为 [&quot;&quot;, &quot; will to do &quot;, &quot;&quot;]
            //args 为 变量数组  [&quot;Mary&quot;, &quot;go to home&quot;]
            const highlighted = args.map(value =&gt; `&lt;span class = &quot;highlight&quot;&gt; ${value} &lt;/span&gt;`)
            const str = string.reduce((preValue, currentValue, i) =&gt; `${preValue}${currentValue}${highlighted[i] || &quot;&quot;}`, &quot;&quot;)
            return str
        }

        const userName = &quot;Mary&quot;

        const userTodo = &quot;go to home&quot;
        //``模板字符串作为函数参数 第一个参数为字符串被变量分割的字符串数组 
        // 当以变量靠头或者结尾时 前后会有空字符串
        // 第二个参数为所有的变量数组
        const template = highlight`${userName} will to do ${userTodo}`

        console.log(template)
        document.body.innerHTML = template
    
    &lt;/script&gt;
</code></pre>

<h4 id="toc_3">用标签模板字符串预防xss攻击</h4>

<p>xss攻击是指跨站脚本攻击，恶意将html或者js等web代码植入用户页面中进行攻击</p>

<p>可以使用<code>DOMPurify.sanitize</code>第三方框架来净化用户输入代码</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数参数]]></title>
    <link href="https://acefish.github.io/15469449620960.html"/>
    <updated>2019-01-08T18:56:02+08:00</updated>
    <id>https://acefish.github.io/15469449620960.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">默认参数</h2>

<p>ES6提供了更方便的写默认参数方式</p>

<pre><code class="language-javascript">function getSum(a=10, b=2) {
    return a+b
}

getSum() //12
getSum(1, 3) //4
getSum(1) //3
getSum(undefined, 10) //20  当要省略不是最后的参数时 需要使用也只能使用undefined
</code></pre>

<h2 id="toc_1">剩余参数</h2>

<p>用于当参数不止一个时，方便我们一次获取多个参数</p>

<pre><code class="language-javascript">function sum(...args) {
    return args.reduce((prev, current) =&gt; prev+current, 0)
}
sum(1,2,3,4) //10

const numbers = [11, 32, 24, 12]
//数组需要扩展运算符
sum(...numbers) //79

function userScoreSum(name, ...score) {
    const sum = score.reduce((pre, curr) =&gt; pre+curr, 0)
    console.log(`${name}得分为${sum}`)
}
userScoreSum(&quot;lyy&quot;, 100, 99, 99) //lyy得分为298
</code></pre>

<h2 id="toc_2">扩展运算符</h2>

<p>将可迭代(遍历)对象每个元素扩展为一个参数序列</p>

<pre><code class="language-javascript">const numbersArr1 = [1, 3, 6]
const numbersArr2 = [2, 4, 6]

//[1, 3, 6, 2, 4 ,6]
const totalNums = numbersArr1.concat(numbersArr2) 

//[1, 3, 6, 55, 2, 4 ,6]
const totalNums2 = [...numbersArr1, 55,...numbersArr2]

</code></pre>

<h3 id="toc_3">扩展运算符 运用</h3>

<ol>
<li><p>获取数组副本</p>
<p>我们经常使用其来实现获取可遍历对象的副本，而避免其引用</p>
<pre><code class="language-javascript">//避免使用引用类型 而操作num3时 影响num2数组
const totalNums3 = [...totalNums2]
</code></pre></li>
<li><p>替代Array.from() 获取每个字符 将可遍历或者类数组对象变为数组对象</p>
<pre><code class="language-javascript">const lis = [...document.querySelectorAll(&quot;li&quot;)]
</code></pre></li>
<li><p>扩展数组元素拼接</p></li>
<li><p>将数组元素扩展为函数参数</p>
<pre><code class="language-javascript">const numbersArr1 = [1, 3, 6]
const numbersArr2 = [2, 4, 6]<br/>
numbersArr1.push(numbersArr2)<br/>
console.log(numbersArr1) //[1, 3, 6, [2, 4, 6]]]<br/>
numbersArr1.push(...numbersArr2) //[1, 3, 6, 2, 4, 6]
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[箭头函数]]></title>
    <link href="https://acefish.github.io/15469392062682.html"/>
    <updated>2019-01-08T17:20:06+08:00</updated>
    <id>https://acefish.github.io/15469392062682.html</id>
    <content type="html"><![CDATA[
<p>箭头函数即 省略function关键字 添加 =&gt; 符号</p>

<pre><code class="language-javascript">    const numArr = [1, 2, 3, 4]
    
    //function函数
    const num2 = numArr.map(function(num) {
        return  num*num
    })
    //箭头函数
    const numArr2 = numArr.map((num) =&gt; {
        return num*num
    })
</code></pre>

<h2 id="toc_0">特点</h2>

<h3 id="toc_1">参数</h3>

<p>当只有一个参数时,箭头函数中的()可省略,多个参数在括号中用,分割</p>

<pre><code class="language-javascript">    //箭头函数 
    const numArr2 = numArr.map(num =&gt; {
        return num*num
    })
</code></pre>

<h3 id="toc_2">隐式返回</h3>

<p>箭头函数可以隐式返回<br/>
此时可以省略大括号和return关键字</p>

<pre><code class="language-javascript">    //大括号 和 return关键字必须同时省略
    const numArr2 = numArr.map((num) =&gt; num*num)
</code></pre>

<h3 id="toc_3">匿名函数</h3>

<p>箭头函数是匿名函数</p>

<blockquote>
<p>当要使用匿名函数时  我们可以将函数赋值给其他变量 然后使用</p>
</blockquote>

<h3 id="toc_4">箭头函数的this继承父作用域</h3>

<p><strong>箭头函数没有自己的this值, 它的this值继承自父作用域</strong></p>

<p>普通函数的this值是在运行时动态绑定的</p>

<p>因此当我们需要执行函数绑定this为当前运行对象时 可以使用箭头函数</p>

<pre><code class="language-javascript">   const people = {
       ownname: &quot;fk&quot;,
       names: [&quot;lyy&quot;, &quot;tt&quot;],
       showName: function() {
            this.names.map(function(name){
                //此时函数未回调的独立函数 this为window
                console.log(this) //window
                 //因为this此时为window 因此获取不到执行对象
                console.log(this.ownname+&quot;名字&quot;+name)
            })
       },
       showName2: function() {
            this.names.map(name =&gt; {
                //此时箭头函数的this继承了showname函数为people对象 
                //可以获取到对象
                console.log(this.ownname+&quot;名字&quot;+name)
            })
       }
   }
   people.showName()
   people.showName2()
</code></pre>

<blockquote>
<p>当一个函数是独立函数时(常出现在回调函数中),即独立运行 而不是作为对象的方法执行时，该方法中的<code>this</code>会指向window对象，此时我们可以使用 <code>call</code> <code>apply</code> <code>by</code>等绑定执行对象 或者 使用箭头函数</p>
</blockquote>

<h2 id="toc_5">不使用箭头函数的情况</h2>

<h3 id="toc_6">作为构造函数、为原型或对象增加方法</h3>

<p>当作为构造函数或者为原型对象添加方法时 不能使用箭头函数,因为此时获取不到this对象,需要使用传统的function函数</p>

<h3 id="toc_7">当函数没有父级作用域时而我们需要this时</h3>

<p>当箭头函数作为对象方法的调用时,此时不能用箭头函数,因为此时箭头函数的this为window而不是该对象，此时使用传统function函数,作为对象方法执行可以将this绑定为当前对象</p>

<h3 id="toc_8">当需要arguments对象时</h3>

<p>箭头函数中没有<code>arguments</code>对象<br/>
我们可以使用ES6新增的 <code>...arg</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[变量声明]]></title>
    <link href="https://acefish.github.io/15469354561176.html"/>
    <updated>2019-01-08T16:17:36+08:00</updated>
    <id>https://acefish.github.io/15469354561176.html</id>
    <content type="html"><![CDATA[
<p>使用建议：</p>

<ol>
<li>默认使用const</li>
<li>当需要修改时改为let</li>
<li>尽量不在使用var</li>
</ol>

<h2 id="toc_0">let var const</h2>

<ol>
<li><p>var 是函数级别作用域，可以再同一作用域重复声明同一变量</p>
<p>var的问题:</p>
<ul>
<li>函数级作用域,表示在block外（例如if语句、for语句等）外访问内部声明的变量，会经常声明出全局变量</li>
<li>var声明的变量可重复声明 会导致难以定位的bug</li>
</ul>
<p>因此推荐使用<code>let</code></p></li>
<li><p>let 是block级别函数作用域</p></li>
<li><p>const 声明常量 不能修改值类型 但是可以修改引用类型</p></li>
</ol>

<h3 id="toc_1">代替立即执行函数</h3>

<pre><code class="language-javascript">//用var声明私有变量时 只能用立即执行函数
(function () {
    var name = &quot;fk&quot;
})()

//用let或者const时 只需要一个块即可
{
    let name = &quot;lyy&quot;
}

</code></pre>

<h3 id="toc_2">变量提示</h3>

<p>var存在变量提升 可以在变量为声明之前访问和使用变量</p>

<p>let虽然也存在变量提升 但是在变量在声明之前是处于临时性死区 在声明之前使用会报错</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式]]></title>
    <link href="https://acefish.github.io/15469181321574.html"/>
    <updated>2019-01-08T11:28:52+08:00</updated>
    <id>https://acefish.github.io/15469181321574.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">正则写法</h2>

<p>有两种写法</p>

<pre><code class="language-javascript">//js风格写法
// i ignore 忽略大小写
// g global 全局匹配找到所有符合条件
var re = new RegExp(&#39;a&#39;, &quot;i&quot;)
//perl风格写法
var re1 = /a/
</code></pre>

<h2 id="toc_1">常用字符串操作</h2>

<p>以下语法可以用字符串操作 也可以用正则表达式增加作用</p>

<ol>
<li><p>search<br/>
获取字符出现的位置，存在返回字符串出现位置,否则返回-1</p>
<pre><code class="language-javascript">var str = &quot;abcde&quot;
var index = str.search(&quot;a&quot;)
</code></pre></li>
<li><p>substring<br/>
获取字符串的子串</p>
<pre><code class="language-javascript">var str = &quot;abcde&quot;
//开始位置和结束位置 左闭右开<br/>
var subStr = str.substring(1, 2) //b<br/>
//只传入开始位置 从开始位置一直到结束<br/>
var subStr1 = str.substring(1) 
</code></pre></li>
<li><p>charAt()<br/>
获取该位置的字符</p>
<pre><code class="language-javascript">var str = &quot;abcde&quot;
var char = str.charAt(3) //d
</code></pre></li>
<li><p>split() <br/>
将字符串按特定字符切分为数组</p>
<pre><code class="language-javascript">var str = &quot;ab-cd-e&quot;
var arr = str.split(&quot;-&quot;) //[ab, cd, e]
</code></pre></li>
<li><p>match</p>
<p>获取符合条件的结果</p>
<pre><code class="language-javascript">var re = new RegExp(&quot;\\d+&quot;, &quot;g&quot;)
// var re = /\d+/g<br/>
var str = &quot;1AbBc33Cd3DeE2rRtT&quot;<br/>
str.match(re) //[1, 33, 3, 2]
</code></pre></li>
<li><p>replace </p>
<p>替换所有符合条件的字符</p>
<pre><code class="language-javascript">var re = new RegExp(&quot;\\d+&quot;, &quot;g&quot;)
// var re = /\d+/g<br/>
var str = &quot;1AbBc33Cd3DeE2rRtT&quot;<br/>
str.replace(re, &quot;dog&quot;) //dogAbBcdogCddogDeEdogrRtT
</code></pre></li>
<li><p>test<br/>
检测字符串中是否有符合规则的部分 返回boolean</p></li>
</ol>

<h2 id="toc_2">正则写法</h2>

<h3 id="toc_3">匹配</h3>

<pre><code class="language-javascript">\d  数字 [0-9]
\D  除了数字[^0-9]

\w  英文、数字、下划线 [a-z0-9_]
\W  非英文、数字、下划线 [^a-z0-9_]

\s  空白字符
\S  非空白字符 

.   表示为任意字符
</code></pre>

<h3 id="toc_4">元字符</h3>

<p>由<code>[]</code>括起来</p>

<pre><code class="language-javascript">//表示范围
[0-9] 表示0-9中任意字符
//表示任意字符
[abc] 表示出现的a、b、c出现哪个都行
//用来排除
[^0-9] 表示出现非数字
</code></pre>

<h3 id="toc_5">量词</h3>

<p>表示出现的个数<br/>
由<code>{}</code>括起来</p>

<pre><code class="language-javascript">{n} 表示出现n次
{n,m} 表示最少n次 最多m次
{n,}    最少n次 最多不限
+  等效于 {1,} 最少1次 做多不限
? 等效于 {0,1} 最少0次 最多1次  可有可无
* 等效于 {0,}  表示可以没有 也可以有无数次
</code></pre>

<h3 id="toc_6">行首 行尾</h3>

<pre><code class="language-javascript">^  当此字符不在元字符中时 表示行首
$   表示行尾
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookie]]></title>
    <link href="https://acefish.github.io/15468536285872.html"/>
    <updated>2019-01-07T17:33:48+08:00</updated>
    <id>https://acefish.github.io/15468536285872.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">特性</h2>

<ol>
<li><p>同一网站(域名)的所有页面共享一套cookie</p></li>
<li><p>cookie的数量和大小是有限的</p></li>
<li><p>cookie是有过期时间的<br/>
如果不主动设置过期时间,cookie会在浏览器关闭就清除</p></li>
</ol>

<h2 id="toc_1">使用</h2>

<p><code>document.cookie</code><br/>
通过赋值和取值来实现cookie操作</p>

<ol>
<li><p>设置cookie</p>
<pre><code class="language-javascript">//此时cookie中会有两天记录 而不会被覆盖
document.cookie = &quot;username=lyy&quot;<br/>
document.cookie = &quot;password=123456&quot;<br/>
//设置有效期限的cookie<br/>
var currentDate = new Date()<br/>
var expiresDate =  currentDate.setDate(currentDate.getDate+100)<br/>
//使用这种格式设置时间 <br/>
document.cookie = &quot;name=fk;expires=&quot;+expiresDate
</code></pre></li>
<li><p>读取cookie<br/>
cookie是用分号空格进行分离的</p></li>
<li><p>删除cookie<br/>
当cookie过期时 删除cookie<br/>
我们通过将cookie的过期时间设置为-1天 即将其设置为已过期 来删除cookie</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BOM]]></title>
    <link href="https://acefish.github.io/15468326596010.html"/>
    <updated>2019-01-07T11:44:19+08:00</updated>
    <id>https://acefish.github.io/15468326596010.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常用windows</h2>

<ul>
<li><p>window.open<br/>
打开新的窗口</p>
<pre><code class="language-javascript">var newWindow = window.open(&#39;about:blank&#39;, &#39;_blank&#39;)
newWindow.document.write(textarea1.value)
</code></pre></li>
<li><p>window.close</p>
<pre><code class="language-javascript">////关闭当前窗口，但是在不同浏览器有一些不同
window.close() 
</code></pre></li>
<li><p>window.navigator<br/>
获取一些浏览器的属性</p>
<pre><code class="language-javascript">//获取浏览器的属性
window.navigator.userAgent
</code></pre></li>
<li><p>window.location</p>
<pre><code class="language-javscript">//获取网页网址 可以通过赋值这个属性来打开新的网页
window.location
</code></pre></li>
<li><p>window.onload</p></li>
<li><p>window.onscroll</p></li>
<li><p>window.onresize <br/>
当窗口尺寸发生变化时</p></li>
</ul>

<h3 id="toc_1">尺寸</h3>

<ol>
<li><p>可视区尺寸<br/>
可视区域尺寸 会随着窗口大小变化而变化</p>
<pre><code class="language-javascript">//高
document.documentElement.clientHeight<br/>
//宽<br/>
document.documentElement.clientWidth
</code></pre></li>
<li><p>滚动高度</p>
<pre><code class="language-javascript">//只支持IE
document.documentElement.scrollTop<br/>
//火狐等浏览器<br/>
document.body.scrollTop<br/>
//兼容版本<br/>
document.documentElement.scrollTop || document.body.scrollTop
</code></pre></li>
<li><p>当前对象尺寸</p>
<pre><code class="language-javascript">//当前对象高度
offsetHeight<br/>
//当前对象宽度<br/>
offsetWidth
</code></pre></li>
</ol>

<h2 id="toc_2">弹框</h2>

<pre><code class="language-javascript">//警告弹框
alert(&quot;&quot;)
//确认弹框 返回boolean
confirm(&quot;&quot;)
//输入框 返回字符串或者null
prompt(&quot;提示&quot;, &quot;默认填充内容&quot;)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS中系统对象]]></title>
    <link href="https://acefish.github.io/15468310700235.html"/>
    <updated>2019-01-07T11:17:50+08:00</updated>
    <id>https://acefish.github.io/15468310700235.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>本地对象<br/>
本地对象常指那些我们平常 常用对象<br/>
<code>Object、Function、Array、String、Boolean、Number、Date、RegExp、Error</code>等</p></li>
<li><p>内置对象<br/>
内置对象指那些系统中内置的对象，即一些概念中的对象例如:<code>Global</code><br/><br/>
内置库中不需要我们实例化对象可以直接使用的:<code>Math</code>等</p></li>
<li><p>宿主对象<br/>
指JS运行环境(常指浏览器)中提供的对象: DOM BOM </p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveObjC]]></title>
    <link href="https://acefish.github.io/15459662586152.html"/>
    <updated>2018-12-28T11:04:18+08:00</updated>
    <id>https://acefish.github.io/15459662586152.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础知识</h2>

<p>常用的 <code>RACSignal</code>为冷信号  <code>RACSubject</code>为热信号<br/>
冷信号 即为订阅之后才开始执行的消息，订阅几次 就执行几次<br/>
热信号 为创建信号就开始执行的消息 无需订阅</p>

<h2 id="toc_1">常用类</h2>

<h3 id="toc_2">RCASignal信号</h3>

<pre><code class="language-objectivec">//1.创建信号 

//可以在创建信号中立即发送信号 但是不能在block结束返回前销毁该信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [subscriber sendNext:@&quot;发送的消息内容&quot;];
        return nil;
}];
//立即发送给定的错误信息
NSError *error = [[NSError alloc] init];
[RACSignal error:error];
//返回一个信号 该信号立即发送给定值 然后 complete
[RACSignal return:@&quot;value&quot;];
//返回信号 该信号直接 complete
[RACSignal empty];

//2.信号处理

//2.1 concat 返回一个信号signal3 当signal1 complete时订阅信号就signal2信号变化 我们可以通过订阅 signal3 来收到信号两个信号的值变化
RACSignal *signal3 = [signal1 concat:signal2]

//2.2  flattenMap 串联信号 当收到第一个消息的值变化时 开始执行第二个信号 此时我们订阅信号2  只会收到信号2值改变信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [subscriber sendNext:@&quot;发送的消息内容&quot;];
        });
        return nil;
    }];
RACSignal *signal2 = [signal flattenMap:^__kindof RACSignal * _Nullable(id  _Nullable value) {
    return  [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [subscriber sendNext:@&quot;signal2 发送的消息内容&quot;];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [subscriber sendNext:@&quot;signal2 3秒后发送的消息内容&quot;];
        });
        return nil;
    }];
}];

//2.2 map 对信号1中收到的值进行处理返回信号2 
RACSignal *signal2 = [signal map:^id _Nullable(NSString *  _Nullable value) {
    return [value substringFromIndex:2];
}];

//2.3 filter 过滤信号值
RACSignal *signal2 = [signal filter:^BOOL(NSString *  _Nullable value) {
    return YES;
}];

//2.4 ignore 忽略特定值的信号
RACSignal *signal2 = [signal ignore:@&quot;发送的消&quot;];

//2.5 startwith: 将这个值 拼接到信号值开头 返回新的信号 
RACSignal *signal2 = [signal startWith:@&quot;start with发送的消息内容&quot;];

//2.6 skip: 忽略开始的count个信号值改变
RACSignal *signal2 = [signal skip:1];

//2.7 take: 返回一个只接收前count个信号的信号值改变  其后发送的信号会失败
RACSignal *signal2 = [signal take:2];

//2.8  scanWithStart: reduce: 遍历信号1值变化 block中next即为信号1的信号值  
//      running为累计值 初始为start值 
RACSignal *signal2 = [signal scanWithStart:@&quot;1&quot; reduce:^NSString * _Nullable(NSString *  _Nullable running, NSString *  _Nullable next) {
    running = [[NSMutableString stringWithFormat:@&quot;%@%@&quot;, running, next] copy];
    return running;
}];

//2.9 takeUntilBlock: 忽略这符合条件的信号以及之后的信号
//     takeWhileBlock: 返回符合条件的信号值
//      skipUntilBlock: 只返回符合条件以及之后的信号
//      skipWhileBlock: 忽略符合条件的信号
RACSignal *signal2 = [signal takeUntilBlock:^BOOL(NSString *  _Nullable x) {
    return [x hasPrefix:@&quot;3秒&quot;];
}];

//2.10 distinctUntilChanged 只返回值不一样的信号
RACSignal *signal2 = [signal distinctUntilChanged];


//3. 订阅

//subscribeNext： 订阅信号值改变  error 订阅错误信号 completed 订阅完成信号 
RACDisposable *disposable = [signal3 subscribeNext:^(NSString *  _Nullable x) {
    NSLog(@&quot;signal3收到订阅值:%@&quot;, x);
} error:^(NSError * _Nullable error) {
    NSLog(@&quot;signal3收到错误订阅:%@,&quot; error);
} completed:^{
    NSLog(@&quot;signal3收到成功订阅;&quot;);
}];

//取消订阅
[disposable dispose];


</code></pre>

<h3 id="toc_3">RACSubject信号</h3>

<pre><code class="language-objectivec">//RACSubject 继承于 RACSignal 使用这个对象 可以直接发送和接收信号值改变  而不需要关心 创建信号和注销订阅问题
RACSubject *subject = [RACSubject subject];

[subject subscribeNext:^(NSString *x) {
    NSLog(@&quot;接受新值%@&quot;, x);
} completed:^{
    NSLog(@&quot;接受完成情况&quot;);
}];

[subject sendNext:@&quot;新的值1&quot;];

</code></pre>

<h3 id="toc_4">RACTuple 元组</h3>

<p>元组功能</p>

<h3 id="toc_5">NSArray NSDictionary 集合操作</h3>

<p>RAC扩展了NSArray 和  NSDictionary 拥有 <code>rac_sequence</code>(<code>RACSequence</code>类)属性</p>

<h3 id="toc_6">RACSequence</h3>

<pre><code class="language-objectivec">    //1. 获取一个 发送集合中值改变的信号
    arr.rac_sequence.signal
    //2. 用信号来遍历集合
    [arr.rac_sequence.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;%@&quot;, x);
    }];
    //3. head
    NSLog(@&quot;第一个元素%@&quot;, arr.rac_sequence.head);
    //4. tail
    NSLog(@&quot;除了第一个元素外的所有元素集合%@&quot;, arr.rac_sequence.tail);
    
    //5. 从左侧开始遍历 start: 累计的初始值 accumulator: 累计值 value:当前值 count: 最终值
    NSNumber *count = [intArr.rac_sequence foldLeftWithStart:@(10) reduce:^NSNumber* (NSNumber *accumulator, NSNumber *value) {
        NSLog(@&quot;%@--- %@&quot;, accumulator, value);

        return @(accumulator.integerValue + value.integerValue);
    }];
    NSLog(@&quot;%@&quot;, count);
    
    //6. 同样可以从右边开始遍历
    
    //7. 遍历集合 判断是否存在符合条件 当遇到block返回YES 返回YES不再执行
    BOOL exist = [intArr.rac_sequence any:^BOOL(NSNumber *value) {
        return value.integerValue == 2;
    }];
    NSLog(@&quot;%@&quot;, exist ? @&quot;存在&quot; : @&quot;不存在&quot;); //存在
    //8. 遍历集合 判断是否所有元素都满足条件
    BOOL pass = [intArr.rac_sequence all:^BOOL(id  _Nullable value) {
        return [value isKindOfClass:[NSNumber class]];
    }];
    NSLog(@&quot;%@&quot;, pass ? @&quot;通过&quot; : @&quot;不通过&quot;); //存在
    //9. 遍历集合找到第一个符合条件的元素
    id obj = [intArr.rac_sequence objectPassingTest:^BOOL(id  _Nullable value) {
        if ([value isKindOfClass:[NSNumber class]]) {
            NSNumber *value1 = (NSNumber *)value;
            if (value1.integerValue % 3 == 0) {
                return YES;
            }
        }
        return NO;
    }];
    NSLog(@&quot;第一个通过测试的是%@&quot;, obj); //9
    
    //10. 用户动态生成sequenceh headblock和tailblock只会执行一次
    //是惰性加载生成的
    //必须保证headblock和tailblock是线程安全的
    RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @(11);
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence sequenceWithHeadBlock:^id _Nullable{
            return @(11);
        } tailBlock:^RACSequence * _Nonnull{
            return [RACSequence sequenceWithHeadBlock:^id _Nullable{
                return @(22);
            } tailBlock:^RACSequence * _Nonnull{
                return @[@(33)].rac_sequence;
            }];
        }];
    }];
    
    [sequence.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;%@&quot;, x);
    }];
</code></pre>

<h3 id="toc_7">UI操作</h3>

<h4 id="toc_8">UIControl</h4>

<pre><code class="language-objectivec"> RACSignal *signal = [self.btn rac_signalForControlEvents:UIControlEventTouchUpInside];
[signal subscribeNext:^(UIButton *  _Nullable x) {
    NSLog(@&quot;&quot;);
}];
</code></pre>

<h4 id="toc_9">UIButton</h4>

<pre><code class="language-objectivec">//当 按钮被点击时 执行 command中的block
self.btn.rac_command 
</code></pre>

<h4 id="toc_10">RACCommand</h4>

<pre><code class="language-objectivec">//初始化command 用一个信号
self.btn.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {
        return [RACSignal empty];
    }];
    
//executionSignals  属性为 command执行时的信号
[self.btn.rac_command.executionSignals subscribeNext:^(RACSignal&lt;id&gt; * _Nullable x) {
    NSLog(@&quot;信号值执行了&quot;);
}];
    
</code></pre>

<h4 id="toc_11">UITextfield</h4>

<pre><code class="language-objectivec">//rac_textSignal 获取textfield内容改变信号
[self.textfield.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
    NSLog(@&quot;输出内容%@&quot;, x);
}];
</code></pre>

<h3 id="toc_12">NSNotification</h3>

<pre><code class="language-objectivec">//通知事件 无需主动移除通知
[[[NSNotificationCenter defaultCenter] rac_addObserverForName:@&quot;&quot; object:nil] subscribeNext:^(NSNotification * _Nullable x) {
    
}];
</code></pre>

<h3 id="toc_13">Delegate</h3>

<pre><code class="language-objectivec">[[self.view rac_signalForSelector:@selector(nameBtnDidClick:)] subscribeNext:^(RACTuple * _Nullable x) {
    
}];
</code></pre>

<h3 id="toc_14">KVO</h3>

<pre><code class="language-objectivec">//这样设置KVO 无需主动移除
//监听btn frame变化 
[[self.btn rac_valuesForKeyPath:@&quot;frame&quot; observer:self] subscribeNext:^(id  _Nullable x) {
        
}];

//使用宏定义快捷设置KVO （推荐）
[RACObserve(self.btn, frame) subscribeNext:^(id  _Nullable x) {
    
}];

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveObjC]]></title>
    <link href="https://acefish.github.io/15450317285396.html"/>
    <updated>2018-12-17T15:28:48+08:00</updated>
    <id>https://acefish.github.io/15450317285396.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文内容来自github <a href="https://github.com/ReactiveCocoa/ReactiveObjC">ReactiveObjC的官方文档</a></p>
</blockquote>

<h2 id="toc_0">介绍</h2>

<p>ReactiveObjC 是一个函数相应式编程的OC框架，为我们提供了组合、转换流的api</p>

<p>RAC没有使用可修改或可替换的变量，而是提供了信号(<code>RACSignal</code>)来捕获当前或者未来的信号，我们通过串联、绑定、响应信号，就可以无需持续的观察和更新值来检测变化</p>

<p>例如: 为了检测一个textField的text的最新内容,我们不需要每秒钟就去获取其值的变化,使用RAC更像KVO可以实时获取到其内容变化,与KVO不同的时 我们使用<code>block</code>而不是使用<code>-observeValueForKeyPath:ofObject:change:context:</code></p>

<p>信号也可以帮助我们进行异步操作,就像对未来结果的许诺,极大的帮助我们简化网络请求等异步操作代码</p>

<p><strong>RAC主要提供了一个统一的方法 来处理异步行为，包括delegate、kvo、target-action、notification、block</strong></p>

<ol>
<li><p>监测属性值变化</p>
<pre><code class="language-objectivec">类似kvo
//检测self.username属性变化<br/>
//RACObserve(TARGET, KEYPATH)是一个创建检测值变化的信号<br/>
//subscribeNext 当检测的信号变化时 就会执行这个信号<br/>
[RACObserve(self, username) subscribeNext:^(NSString *newName) {<br/>
       NSLog(@&quot;%@&quot;, newName);<br/>
}];
</code></pre></li>
<li><p>监测过滤出来的部分信号值<br/>
与kvo不同的是，我们可以串联、操作这些信号</p>
<pre><code class="language-objectivec">//过滤 信号中以&quot;j&quot;开头的信号值的变化
[[RACObserve(self, username)<br/>
filter:^(NSString *newName) {<br/>
    return [newName hasPrefix:@&quot;j&quot;];<br/>
}]<br/>
subscribeNext:^(NSString *newName) {<br/>
    NSLog(@&quot;%@&quot;, newName);<br/>
}];
</code></pre></li>
<li><p>通过RAC我们可以很方便的通过信号监测变化,而不需要通过观察和设置其它属性</p>
<pre><code class="language-objectivec">//combineLatest: reduce:方法 合并一组信号,当其中任意一个信号的最新值变化时,会执行该block 并返回新的值
RAC(self, createEnabled) = [RACSignal<br/>
combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ]<br/>
reduce:^(NSString *password, NSString *passwordConfirm) {<br/>
    return @([passwordConfirm isEqualToString:password]);<br/>
}];
</code></pre></li>
<li><p>信号不止类似kvo可以监测属性，还可以监测其它任何随时间变化的值或者流</p>
<pre><code class="language-objectivec">//RACCommand 创建一个与UI有关的信号 此处是按钮点击信号,当按钮被点击时执行该block
//rac_command是按钮类别的属性，当按钮被点击自动发送<br/>
self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {<br/>
NSLog(@&quot;button was pressed!&quot;);<br/>
return [RACSignal empty];<br/>
}];
</code></pre></li>
<li><p>RAC表示网络操作</p>
<pre><code class="language-objectivec">//创建一个信号 当self.loginCommand执行其block
self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {<br/>
    return [client logIn];<br/>
}];<br/>
//executionSignals 返回上面RACComond中block返回的信号的信号,即当上面block返回时 会触发该信号 并可以监测block返回的信号的变化<br/>
[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {<br/>
    // Log a message whenever we log in successfully.<br/>
    [loginSignal subscribeCompleted:^{<br/>
        NSLog(@&quot;Logged in successfully!&quot;);<br/>
    }];<br/>
}];<br/>
//当按钮点击时 执行该self.loginCommand<br/>
self.loginButton.rac_command = self.loginCommand;
</code></pre></li>
<li><p>表示异步操作的信号间可以链接来表示更加复杂的行为(在一组操作完成后开始另外一个操作)</p>
<pre><code class="language-objectivec">//merge: 合并两个信号 返回一个新的信号
//subscribeCompleted: 订阅返回完成的信号<br/>
[[RACSignal merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]]<br/>
subscribeCompleted:^{<br/>
    NSLog(@&quot;They&#39;re both done!&quot;);<br/>
}];
</code></pre></li>
<li><p>信号可以串联起来 避免使用block嵌套来表示依赖</p>
<pre><code class="language-objectivec">//
[[[[client<br/>
    logInUser]<br/>
    flattenMap:^(User *user) {<br/>
        // Return a signal that loads cached messages for the user.<br/>
        return [client loadCachedMessagesForUser:user];<br/>
    }]<br/>
    flattenMap:^(NSArray *messages) {<br/>
        // Return a signal that fetches any remaining messages.<br/>
        return [client fetchMessagesAfterMessage:messages.lastObject];<br/>
    }]<br/>
    subscribeNext:^(NSArray *newMessages) {<br/>
        NSLog(@&quot;New messages: %@&quot;, newMessages);<br/>
    } completed:^{<br/>
        NSLog(@&quot;Fetched all messages.&quot;);<br/>
    }];
</code></pre></li>
<li><p>获取异步操作的结果 </p>
<pre><code class="language-objectivec">//当异步图片下载完成后赋值到图片上
//deliverOn: 创建信号并执行在其他队列线程  [RACScheduler scheduler] background线程  RACScheduler.mainThreadScheduler]主线程<br/>
RAC(self.imageView, image) = [[[[client<br/>
fetchUserWithUsername:@&quot;joshaber&quot;]<br/>
deliverOn:[RACScheduler scheduler]]<br/>
map:^(User *user) {<br/>
    // Download the avatar (this is done on a background queue).<br/>
    return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];<br/>
}]<br/>
// Now the assignment will be done on the main thread.<br/>
deliverOn:RACScheduler.mainThreadScheduler];
</code></pre></li>
</ol>

<h2 id="toc_1">示例</h2>

<h3 id="toc_2">1. 处理多来源的异步操作或事件状态</h3>

<p>不使用RAC的情况</p>

<p>页面中的登录按钮 只有在<code>usernameTextField</code> <code>passwordTextField</code> 不为空 并且当前不在登录状态 才可以点击</p>

<pre><code class="language-objectivec">static void *ObservationContext = &amp;ObservationContext;

- (void)viewDidLoad {
    [super viewDidLoad];

    [LoginManager.sharedManager addObserver:self forKeyPath:@&quot;loggingIn&quot; options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext];
    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];

    [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];
}

- (void)dealloc {
    [LoginManager.sharedManager removeObserver:self forKeyPath:@&quot;loggingIn&quot; context:ObservationContext];
    [NSNotificationCenter.defaultCenter removeObserver:self];
}

- (void)updateLogInButton {
    BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0;
    BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn;
    self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;
}

- (IBAction)logInPressed:(UIButton *)sender {
    [[LoginManager sharedManager]
        logInWithUsername:self.usernameTextField.text
        p**assword:self.passwordTextField.text
        success:^{
            self.loggedIn = YES;
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
}

- (void)loggedOut:(NSNotification *)notification {
    self.loggedIn = NO;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if (context == ObservationContext) {
        [self updateLogInButton];
    } else {
        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
    }
}
</code></pre>

<p>使用RAC来写的话</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    @weakify(self);

    RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue);
        }];

    [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {
        @strongify(self);

        RACSignal *loginSignal = [LoginManager.sharedManager
            logInWithUsername:self.usernameTextField.text
            password:self.passwordTextField.text];

            [loginSignal subscribeError:^(NSError *error) {
                @strongify(self);
                [self presentError:error];
            } completed:^{
                @strongify(self);
                self.loggedIn = YES;
            }];
    }];

    RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter
        rac_addObserverForName:UserDidLogOutNotification object:nil]
        mapReplace:@NO];
}
</code></pre>

<h3 id="toc_3">2.串联异步操作的依赖</h3>

<pre><code class="language-objectivec">//logInWithSuccess 登录成功 -&gt; loadCachedMessagesWithSuccess 加载本地数据   -&gt;  fetchMessagesAfterMessage 请求本地为缓存的最新的数据

//不使用色RAC 使用block嵌套
[client logInWithSuccess:^{
    [client loadCachedMessagesWithSuccess:^(NSArray *messages) {
        [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {
            NSLog(@&quot;Fetched all messages.&quot;);
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
    } failure:^(NSError *error) {
        [self presentError:error];
    }];
} failure:^(NSError *error) {
    [self presentError:error];
}];

//RAC版本
[[[[client logIn]
    then:^{
        return [client loadCachedMessages];
    }]
    flattenMap:^(NSArray *messages) {
        return [client fetchMessagesAfterMessage:messages.lastObject];
    }]
    subscribeError:^(NSError *error) {
        [self presentError:error];
    } completed:^{
        NSLog(@&quot;Fetched all messages.&quot;);
    }];
</code></pre>

<h3 id="toc_4">3.用RAC实现 OC中 集合没有的 map、filter、fold/reduce等方法</h3>

<pre><code class="language-objectivec">//获取数组中字符串长度大于2并且拼接字符串`foobar`
NSMutableArray *results = [NSMutableArray array];
for (NSString *str in strings) {
    if (str.length &lt; 2) {
        continue;
    }

    NSString *newString = [str stringByAppendingString:@&quot;foobar&quot;];
    [results addObject:newString];
}


RACSequence *results = [[strings.rac_sequence
    filter:^ BOOL (NSString *str) {
        return str.length &gt;= 2;
    }]
    map:^(NSString *str) {
        return [str stringByAppendingString:@&quot;foobar&quot;];
    }];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa 版本]]></title>
    <link href="https://acefish.github.io/15446921413334.html"/>
    <updated>2018-12-13T17:09:01+08:00</updated>
    <id>https://acefish.github.io/15446921413334.html</id>
    <content type="html"><![CDATA[
<p>reactiveCocoa 分为两个版本 </p>

<ol>
<li>OC版本的 <strong>ReactiveObjC</strong></li>
<li>swift版本的 <strong>ReactiveSwift</strong></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础]]></title>
    <link href="https://acefish.github.io/15446723749030.html"/>
    <updated>2018-12-13T11:39:34+08:00</updated>
    <id>https://acefish.github.io/15446723749030.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常见编程风格</h2>

<p>目前已知常用的编程风格:</p>

<ol>
<li><p>面向过程</p></li>
<li><p>面向对象</p></li>
<li><p>链式编程<br/>
将多个操作通过 . 连接起来 增加代码的可读性<br/>
例如: masonry框架</p></li>
<li><p>响应式编程<br/>
不考虑事件发生顺序 只考虑结果 发生的事件像流一样传播出去，我们关注数据流和变化传播<br/>
例如: KVO运用</p></li>
<li><p>函数式编程<br/>
将操作写成一系列嵌套的函数或者方法调用，将其他函数作为参数</p>
<p>其在OC中实质即:向方法中传入block，方法中嵌套block调用，对代码进行聚合管理</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ajax]]></title>
    <link href="https://acefish.github.io/15444371982559.html"/>
    <updated>2018-12-10T18:19:58+08:00</updated>
    <id>https://acefish.github.io/15444371982559.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-javascript">    &lt;script&gt;
            var oAjax = new XMLHttpRequest()
            //1. 请求方式
            //2. 目标资源位置
            //3. 是否异步
            oAjax.open(&quot;GET&quot;, &quot;https://www.baidu.com/&quot;, true)
            oAjax.send()
            //
            oAjax.onreadystatechange = function () {
                /**
                * readyState
                *   0：未初始化 还没调用open()方法
                *   1：载入 已调用send()方法 正在发送请求
                *   2：载入完成  已经调用send()方法 已收到全部相应内容
                *   3：解析 正在解析响应内容
                *   4：完成 响应内容解析完成 可以在客户端使用
                */
                if (oAjax.readyState == 4) {
                    if (oAjax.status == 200) {
                        alert(&quot;success&quot;)
                        alert(oAjax.responseText)
                    } else {
                        alert(&quot;fail&quot;)
                    }
                }
            }
        &lt;/script&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS补充]]></title>
    <link href="https://acefish.github.io/15442641358694.html"/>
    <updated>2018-12-08T18:15:35+08:00</updated>
    <id>https://acefish.github.io/15442641358694.html</id>
    <content type="html"><![CDATA[
<ol>
<li><strong>全局变量 &amp;&amp; window属性</strong><br/>
js中的全局变量 其实是<code>window</code>的属性<br/>
在js中用没有定义的变量 会报错<br/>
在js中用没有定义的属性 会undefine</li>
<li><strong>面对对象的特点</strong>
<ol>
<li>抽象: 只注重我们需要的方面 忽略我们不需要的对象的特性</li>
<li>封装: 封装为api 外部只能通过定义的接口 访问数据</li>
<li>继承: 子类继承父类特性 解决重用性问题 （多重继承）</li>
<li>多态: 对强语言较为有用,允许不同类对同一消息作出不同响应</li>
</ol></li>
</ol>

<h2 id="toc_0">原型 prototype</h2>

<p>类似css中的class  用于给一类对象设置通用的属性或者方法</p>

<p>在js 我们经常在构造方法中实现属性 而在原型中实现方法</p>

<h2 id="toc_1">创建对象方式</h2>

<ol>
<li><p>用<code>new Object()</code></p>
<pre><code class="language-javascript">var obj = new Object()
obj1.name = &quot;lyy&quot;
</code></pre></li>
<li><p>用json对象</p>
<pre><code class="language-javascript">var person = {
    firstName:&quot;John&quot;,<br/>
    lastName:&quot;Doe&quot;,<br/>
    age:50,<br/>
    eyeColor:&quot;blue&quot;<br/>
};
</code></pre></li>
<li></li>
</ol>

<h2 id="toc_2">call</h2>

<pre><code class="language-javascript">//js中调用函数
show()
//等效于
show.call()
</code></pre>

<p><code>call</code>可以改变函数调用中的<code>this</code>,对于call调用函数 第一个参数即为<code>this</code></p>

<p>可以通过<code>call</code>来调用父级的方法<br/>
可以通过赋值原型来继承父级的其它方法，因为原型直接赋值是引用类型的 因此需要遍历赋值</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DOM]]></title>
    <link href="https://acefish.github.io/15442514838005.html"/>
    <updated>2018-12-08T14:44:43+08:00</updated>
    <id>https://acefish.github.io/15442514838005.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>像素是计算机能接受的最小单位 因此对于带有小数的像素值，会舍去小数</p>
</blockquote>

<h2 id="toc_0">操作元素属性方式</h2>

<ol>
<li>oDiv.style.display = &quot;none&quot;</li>
<li>oDiv.style[&quot;display&quot;] = &quot;none&quot;</li>
<li><p>DOM方式</p>
<ul>
<li>获取: getAttribute</li>
<li>设置: setAttribute</li>
<li>删除: removeAttribute</li>
</ul>
<pre><code class="language-javascript">oText.setAttribute(&quot;value&quot;, &quot;text&quot;)
</code></pre></li>
</ol>

<h2 id="toc_1">用class获取元素</h2>

<pre><code class="language-javascript">oParent.className //获取className
</code></pre>

<h2 id="toc_2">获取节点</h2>

<h3 id="toc_3">子节点</h3>

<pre><code class="language-javascript">//获取所有自己点
var oUl = document.getElementById(&quot;ul1&quot;)
oUl.childNodes // 属性 获取到所有 包括文本节点和元素节点
oUl.children //属性 获取所有的元素节点
oUl.nodeType  // 获取节点的节点类型  
</code></pre>

<p>子节点 只算自己下一层的所有元素个数</p>

<ol>
<li><p>文本节点<br/>
<code>nodetype</code>为 3</p></li>
<li><p>元素节点<br/>
<code>nodetype</code>为 1</p></li>
</ol>

<h3 id="toc_4">父节点</h3>

<pre><code class="language-javascript">oUl.parentNode
</code></pre>

<h3 id="toc_5">首尾节点</h3>

<pre><code class="language-javascript">firstChild  //获取第一个子节点
firstElementChild //获取第一个元素子节点

lastChild  // 
lastElementChild //
</code></pre>

<h3 id="toc_6">兄弟节点</h3>

<pre><code class="language-javascript">nextSibling
nextElementSibling

previsionSibling
nextElementSibling
</code></pre>

<h2 id="toc_7">操作节点</h2>

<h3 id="toc_8">创建元素节点</h3>

<p><code>creatElement(标签名)</code> 创建一个节点<br/>
<code>appendChild(节点)</code> 追加一个节点 (追加的节点如果已有其它父节点 会先从父节点删除)</p>

<h3 id="toc_9">插入元素</h3>

<p><code>insertBefore(原有节点)</code> 在原有节点前插入节点 </p>

<h3 id="toc_10">删除元素</h3>

<p><code>removeChild(节点)</code>  删除一个节点</p>

<h2 id="toc_11">文档碎片</h2>

<p>避免多次操作元素 导致页面多次渲染造成的性能问题，将多次操作元素的操作合并，进行一次渲染即可</p>

<pre><code class="language-javascript">var oUl = document.getElementById(&quot;ul1&quot;)
var oFrag = document.createDocumentFragment()
Frag.appendChild(subLiElement)
oUl.appendChild(oFrag)
</code></pre>

<blockquote>
<p>问题不大，理论上，只有在很多次的元素操作才会出现问题,并且低级浏览器几乎没有任何影响</p>
</blockquote>

<h2 id="toc_12">document.write</h2>

<p>会先清空 再写</p>

<h2 id="toc_13">document是属于浏览器的</h2>

<p>我们常使用的<code>document.write(&#39;&#39;)</code>其实是<code>window.document.write(&#39;&#39;)</code>的简写</p>

]]></content>
  </entry>
  
</feed>
