<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2019-07-31T16:05:04+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[AsyncDisplayKit]]></title>
    <link href="https://acefish.github.io/15645543599204.html"/>
    <updated>2019-07-31T14:25:59+08:00</updated>
    <id>https://acefish.github.io/15645543599204.html</id>
    <content type="html"><![CDATA[
<p>即刻团队的 <a href="https://medium.com/jike-engineering/asyncdisplaykit%E4%BB%8B%E7%BB%8D-%E4%B8%80-6b871d29e005">AsyncDisplayKit介绍</a></p>

<p><a href="https://texturegroup.org/docs/getting-started.html">AsyncDisplayKit-TextTrue</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[离屏渲染]]></title>
    <link href="https://acefish.github.io/15644708593081.html"/>
    <updated>2019-07-30T15:14:19+08:00</updated>
    <id>https://acefish.github.io/15644708593081.html</id>
    <content type="html"><![CDATA[
<p>学习自即刻团队的<a href="https://zhuanlan.zhihu.com/p/72653360">离屏渲染</a></p>

<h2 id="toc_0">iOS渲染架构</h2>

<p>在WWDC的Advanced Graphics and Animations for iOS Apps（WWDC14 419，关于UIKit和Core Animation基础的session在早年的WWDC中比较多）中有这样一张图：</p>

<p><img src="media/15644708593081/15644710697530.jpg" alt=""/></p>

<p>可以看到是CPU和GPU协作完成了渲染操作。CPU主要在Application这一层操作，之后在RenderServer线程，CoreAnimation会将具体操作转换成发送GPU的draw calls（以前是call OpenGL 现在有部分转为Metal）,进行渲染</p>

<h2 id="toc_1">离屏渲染</h2>

<p>当需要在屏幕上显示内容时，至少需要一块与屏幕像素数据量一样大的<code>frame buffer</code>，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。如果有时因为面临限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后在写入<code>frame buffer</code>，这个过程就被称为<strong>离屏渲染</strong></p>

<h3 id="toc_2">CPU&quot;离屏渲染&quot;？</h3>

<p>在UIView中自己执行的drawRect方法，cpu会申请一块内存区域等待有可能到来的绘画操作。<br/>
在CPU中进行的光栅化操作（如文字渲染、图片解码）等<br/>
都无法直接绘制到GPU掌管的frame buffer，只能暂存在另外一块内存中<br/>
这些发生在CPU中这些“离屏渲染”并不是真正意义上的，而是属于&quot;软件渲染&quot;范畴的</p>

<h3 id="toc_3">GPU离屏渲染</h3>

<p>我们知道，渲染主要由CoreAnimation的Render Server模块，通过调用显卡驱动提供的OpenGL/Metal接口执行。在执行渲染时，<code>Render Server</code>遵循画家算法，layer按照次序输出至frameBuffer，覆盖即刻得到最终的显示结果，然后交由GPU进行渲染显示到屏幕上</p>

<p>但是有部分场景是无法这样实现的，因为GPU虽然可以按照画家算法进行输出，但是无法再某曾渲染完成后，再回头擦除或者改变其中的某部分。这就意味着，对于layer如果不能单词遍历就完成渲染，那就只能另开一块内存，借助这个临时中转区域来完成多次的修改/剪裁操作(这就是离屏渲染了)。</p>

<h3 id="toc_4">常见离屏渲染场景</h3>

<ol>
<li><strong>corenerRadus+clipsToBounds</strong>
因为此时子layer也会被裁减，但是在没有统一组合后也是无法获得统一裁剪后的图像，因此需要开辟另外一块内存，在渲染和切角完成后，输出到frame buffer中<br/>
注意如果没有clipsToBounds，也不会触发离屏渲染了</li>
<li><strong>shadow</strong>
原因其实与圆角差不多，在没有将画布上所有内容组合完成之前也是无法知道阴影形状的，因此需要额外的内存空间。<br/>
当然，如果我们能在整个画布都没有渲染完成之前就知道阴影部分的形状（设置阴影的shadowPath），也可以绘制阴影而不触发离屏渲染</li>
<li><p><strong>group opacity</strong><br/>
此时的alpha并不是加到某一层，而是整个layer树，因此只能等渲染完成再加上alpha，最后和底下的其它layer相折叠，得到实际的颜色。因此这也是需要另外开辟存储空间的</p></li>
<li><p><strong>mask</strong></p>
<p>mask由layer和其上的子layer组合，而且可能有透明度，因此是会触发离屏渲染的</p></li>
<li><p><strong>UIBlurEffect</strong><br/>
<img src="media/15644708593081/15645419693084.jpg" alt="" style="width:500px;"/></p></li>
</ol>

<h3 id="toc_5">离屏渲染解决方案</h3>

<p>因为离屏渲染开销很大，特别是在滚动视图中，每帧都会触发cell的重绘，因此在无法避免时，就尽量降低性能影响，通过<code>CALayer</code>提供的<code>shouldRasterize</code>设置其为true后，<code>Render Server</code>会强制吧layer的渲染结果(包括其子layer，以及圆角、阴影、group opacity等等)保存在一块内存中，这样接下来就可以被复用，而不会再次离屏渲染了</p>

<p>注意:</p>

<ul>
<li><code>shouldRasterize</code>主旨在于降低性能损失，但是至少会触发一次离屏渲染，如果layer本不复杂，也没有圆角 阴影等，打开这个只会没必要的多一次离屏渲染</li>
<li>一旦缓存超过100ms没有被使用，会被自动废弃</li>
<li>layer的内容必须是静态的，因为一旦发生变化缓存就失效了，就有需要重新离屏渲染，然后缓存，这就需要我们极力避免的情况</li>
</ul>

<h3 id="toc_6">CPU渲染的使用</h3>

<p>因为GPU对图形处理的更高性能，以及其更好的并行计算能里，我们倾向于让GPU完成渲染任务，而CPU有更多时间来处理复杂的app的复杂逻辑。</p>

<p>但是针对一些特殊情况，比如文字渲染(CoreText),图片渲染(ImageIO),因为此时GPU并不擅长此类工作，因为需要先由CPU处理好之后，将结果作为<a href="https://texturegroup.org/docs/automatic-layout-examples-2.html">texture</a>传给GPU.</p>

<p>比如，我们可以使用<code>CoreGraphic</code>来给图形设置圆角(将圆角以外的部分设置为透明)，这样的话就全部由CPU完成，不再需要使用<code>corerRadius</code>。而且这样的话，我们也可以做到灵活控制裁剪和缓存的时机，避开CPU和GPU繁忙，平衡性能波动</p>

<p>注意：</p>

<ol>
<li>渲染不是CPU强项，调用CoreGraphics会消耗其相当一部分时间，因此通常将CPU渲染放在后台完成(AsyncDisplayKit的实现思想)。然后再回到主线程，将渲染结果传给CoreAnimation</li>
<li>CPU渲染性能不够 只能渲染静态的元素，如文字、图片等</li>
<li>渲染结果的bitmap数据量较大，占用较大内存，应该在使用完成后，及时释放，否则容易OOM</li>
<li>使用CPU渲染就不要再触发离屏渲染了</li>
<li>多使用Instuments工具测试性能</li>
</ol>

<h2 id="toc_7">即刻团队对即刻APP的优化</h2>

<ol>
<li>即刻大量应用AsyncDisplayKit(Texture)作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。</li>
<li>对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角</li>
<li>对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果</li>
<li>对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做</li>
<li>对于所有的阴影，使用shadowPath来规避离屏渲染</li>
<li>对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存</li>
<li>对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[渲染]]></title>
    <link href="https://acefish.github.io/15643878437057.html"/>
    <updated>2019-07-29T16:10:43+08:00</updated>
    <id>https://acefish.github.io/15643878437057.html</id>
    <content type="html"><![CDATA[
<p>学习自 <a href="https://time.geekbang.org/column/article/101639">iOS开发高手课</a></p>

<h2 id="toc_0">渲染原理</h2>

<p>App界面是由CPU和GPU共同计算处理</p>

<p>CPU内部流水线结构拥有并行计算能力，一般用于显示内容的计算。而GPU的并行计算能力更强，能够通过计算将图形结果显示到屏幕像素中。<strong>渲染就是将内存中的图形数据经过转换显示到屏幕上的过程。而负责执行这个过程的就是GPU</strong></p>

<p>在渲染的过程中，GPU是需要处理屏幕上的每个像素点，并保证这些像素点的更新时流畅的</p>

<p>GPU的主要工作就是将3D坐标转换为2D坐标，再把2D坐标转为实际像素，实现的过程分为: <strong>顶点着色器（确定形状的点）、形状装配（确定形状的线）、几何着色器（确定三角形个数）、光栅化（确定屏幕像素点）、片段着色器（对像素点着色）、测试与混合（检查深度和透明度）六个阶段</strong></p>

<p>而我们<code>OpenGL</code>的标准库提供了编程能力，为了更方便的操作控制GPU</p>

<p>在渲染的过程中，<code>CPU</code>主要用来处理渲染内容的计算，比如<em>视图创建、布局、图片解码</em>等，内容计算完成后，再传给GPU进行渲染。CPU和GPU的相互配合，充分利用手机硬件来提升用户使用app的体验。而我们见到的界面卡顿等，就是以内CPU的计算时间超过屏幕刷新率的时间</p>

<blockquote>
<p>在对比原生、大前端和Flutter谁更流畅，不就是对比在渲染过程中CPU计算内容谁会更快，谁就会更流畅了</p>
</blockquote>

<h2 id="toc_1">原生渲染流程</h2>

<p>原生的界面渲染，主要分为一下四步:</p>

<ol>
<li>更新视图树，同步视图树</li>
<li>CPU计算要显示的内容，包括视图创建（设置Layer属性）、布局计算、视图绘制（创建Lay的Backing Image）、图像解码转换等。当runLoop在<code>BeforeWaiting</code>和<code>Exit</code>时，通知注册的监听，然后对图层打包，打包完成后，将打包数据发送给一个独立负责渲染的进程<code>Render Server</code></li>
<li>数据在到达renderServer后会被反序列化，得到图层树，按照图层树的图层顺序、RGBA值,图层frame过滤图层中被遮挡的部分，过滤后将图层树转换为渲染树，渲染树的信息会转换为OpenGL ES/Metal。前面CPU所处理的这些事情统称为<code>Commit Transaction</code></li>
<li><code>Render Server</code>会调用GPU,GPU开始进行前面提到的顶点着色器，形状装配、几何着色、光栅化、片段着色、测试与混合六个阶段。完成这6个阶段后，再将CPU和GPU计算后的数据显示在屏幕的每个像素点上。</li>
</ol>

<p><img src="media/15643878437057/15644670559791.jpg" alt="" style="width:648px;"/></p>

<p>补充:</p>

<blockquote>
<p>渲染过程中的<code>Commit Trasaction</code>的布局计算会重载视图的<code>LayoutSubViews</code>方法，以及执行<code>addSubviews</code>方法来添加视图。视图绘制会重载视图的<code>drawReact</code>方法。这个方法都是iOS开发中常用的</p>

<p>我们执行的移动视图、删除视图、隐藏、显示视图、调用setNeedsDispaly或者setNeedsDispalyInRect方法 都会触发界面更新，执行渲染流程</p>
</blockquote>

<h2 id="toc_2">大前端渲染</h2>

<p>大前端的开发框架主要有两类：基于webView的和类似React Native的</p>

<p>第一类的WebView的大前端渲染，主要在webKit中完成。webKit的渲染层来自以前MacOS的LayerRendering架构，而iOS也基于这一套架构。所以本质上来看WebKit和iOS的原生渲染差别不大</p>

<p>ReactNative渲染直接走的原生渲染</p>

<p>至于我们觉得大前端渲染比原生慢的原因主要是：</p>

<ol>
<li><p>从第一次内容加载来看，即使本地加载，<strong>大前端也比原生多出脚本代码解析工作</strong>。webView需要额外解析<code>HTML+CSS+Javascript</code>代码，而类React Native方案则需要解析<code>Json+Javascript</code>。 当然<code>HTML+CSS</code>的复杂度要高于<code>JSON</code>,因此解析起来会更加慢一点。即，首次加载时，WebView会比类ReactNative慢</p></li>
<li><p>从语言的本身解释执行性能来看，<strong>大前端加载后的界面更新会通过Javascript解释执行</strong>，而Javascript解释执行性能要比原生差，特别是解释执行复杂逻辑或大量计算时。所以大前端的运算速度，要比原生慢上不少</p></li>
<li><p>除了首次加载解析耗时外，js语言本身解释慢导致的性能问题这两点之外，WebView的渲染进程是单独的，每帧的更新都要通过IPC调用GPU进程。而频繁的IPC进程通信也会有性能损耗</p></li>
<li><p>webView的单独渲染进程还无法访问GPU的context，这样两个进程就么法共享纹理资源。纹理资源无法直接使用GPU的Context光栅化，那就只能通过IPC传给GPU进程，这也导致可GPU无法发挥自身的性能优势。由于WebView的光栅化无法及时同步到GPU，滑动时就容易出现白屏，就很难避免了。</p></li>
</ol>

<p>相对于原生渲染来说，webView或者类ReactNative都因为脚本语言本身的西恩那个问题而存在性能差距。</p>

<h2 id="toc_3">Flutter渲染</h2>

<p>Flutter界面是由<code>Widget</code>组成，所有的Widget组成<code>Widget Tree</code>，界面更新时会更新<code>Widget Tree</code>，然后再更新<code>Element Tree</code>，最后更新<code>RenderObject Tree</code></p>

<p>接下来的渲染流程，Flutter渲染在FrameWork层会有Build、Widget Tree、Element Tree、RenderObject Tree、Layout、Paint、Composited Layed等几个阶段。将Layer进行组合，生成纹理，使用OpenGL接口像GPU提交渲染内容进行光栅化与合成，是在Flutter的C++层，使用的时<code>Skia</code>库。包括提交到GPU进程后，合成计算，显示屏幕的过程和iOS原生基本是类似的，因此性能相差不多</p>

<p>Flutter的主要优势是在于，它可以同时运行于Android和iOS两个平台。但是苹果公司在WWDC 2019上退出SwiftUI和Preview后，Flutter界面编写和Hot Reload的有事会逐渐降低</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACDelegateProxy]]></title>
    <link href="https://acefish.github.io/15611008346251.html"/>
    <updated>2019-06-21T15:07:14+08:00</updated>
    <id>https://acefish.github.io/15611008346251.html</id>
    <content type="html"><![CDATA[
<p>将代理用<code>RACDelegateProxy</code>实现</p>

<pre><code class="language-objectivec">RACDelegateProxy *proxy = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UITableViewDelegate)];
objc_setAssociatedObject(self, _cmd, proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
proxy.rac_proxiedDelegate = self;
[[proxy rac_signalForSelector:@selector(tableView:didSelectRowAtIndexPath:)]
 subscribeNext:^(RACTuple *value) {
     [value.first deselectRowAtIndexPath:value.second animated:YES];
 }];
self.tableView.delegate = (id&lt;UITableViewDelegate&gt;)proxy;

//等效于
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACChannel]]></title>
    <link href="https://acefish.github.io/15609354619260.html"/>
    <updated>2019-06-19T17:11:01+08:00</updated>
    <id>https://acefish.github.io/15609354619260.html</id>
    <content type="html"><![CDATA[
<p><code>RACChannel</code>是一对一的双向的数据流</p>

<h2 id="toc_0">RACChannel</h2>

<p>在channel中向外暴露的有两个属性<code>terminal</code></p>

<pre><code class="language-objectivec">@property (nonatomic, strong, readonly) RACChannelTerminal&lt;ValueType&gt; *leadingTerminal;
@property (nonatomic, strong, readonly) RACChannelTerminal&lt;ValueType&gt; *followingTerminal;
</code></pre>

<p>初始化<code>terminal</code>方法 </p>

<pre><code class="language-objectivec">- (instancetype)init {
    self = [super init];

    RACReplaySubject *leadingSubject = [RACReplaySubject replaySubjectWithCapacity:0];
    RACReplaySubject *followingSubject = [RACReplaySubject replaySubjectWithCapacity:1];
    
    [[leadingSubject ignoreValues] subscribe:followingSubject];
    [[followingSubject ignoreValues] subscribe:leadingSubject];

    _leadingTerminal = [[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject];
    _followingTerminal = [[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject]
    return self;
}
</code></pre>

<ol>
<li>可以看到<code>leadingSubject</code>是由<code>Capacity:0</code>的<code>RACReplaySubject</code> 而 <code>followingSubject</code>是由<code>Capacity:1</code>的<code>RACReplaySubject</code></li>
<li><code>ignoreValues</code>通过订阅相互信号的错误信息，当一端出现错误信息能保证相互发送，防止当一方出错时 另外一方还在工作</li>
<li><code>followingSubject</code>的<code>Capacity</code>为1，有初始值，因此当订阅followingTerminal信息时 可以直接进行初始化状态</li>
</ol>

<h2 id="toc_1">RACChannelTerminal: RACSignal&lt; RACSubscriber&gt;</h2>

<h3 id="toc_2">初始化</h3>

<p><code>ChannelTerminal</code>初始化,使用一个用于subcribe的<code>RACSignal</code>的value 和一个用于发送值的<code>id&lt;RACSubscriber&gt;</code>的otherTerminal</p>

<p>期指那个<code>value</code>表示当前端点，<code>otherTerminal</code>表示远程端点</p>

<pre><code class="language-objectivec">@property (nonatomic, strong, readonly) RACSignal&lt;ValueType&gt; *values;
@property (nonatomic, strong, readonly) id&lt;RACSubscriber&gt; otherTerminal;

- (instancetype)initWithValues:(RACSignal *)values otherTerminal:(id&lt;RACSubscriber&gt;)otherTerminal {
    self = [super init];
    _values = values;
    _otherTerminal = otherTerminal;
    return self;
}
</code></pre>

<h3 id="toc_3">订阅信号</h3>

<p>订阅信号 其实订阅和接收的是<code>self.values</code>的信号，即订阅的时当前信号消息</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
    return [self.values subscribe:subscriber];
}
</code></pre>

<h3 id="toc_4">发送</h3>

<p>如果向<code>Terminal</code>发送消息  会被转发到远程端点上，因此当前端点的订阅者并不能接收到当前端点发送的消息</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
    [self.otherTerminal sendNext:value];
}
</code></pre>

<h3 id="toc_5">使用</h3>

<p>我们不应该直接初始化<code>RACChannelTerminal</code>实例，而可以通过 初始化RACChannle的方式生成</p>

<h2 id="toc_6">RACChannel的使用</h2>

<h3 id="toc_7">RACChannel+UIControl</h3>

<pre><code class="language-objectivec">UIControl rac_channelForControlEvents:(UIControlEvents)controlEvents key:(NSString *)key nilValue:(nullable id)nilValue {
    RACChannel *channel = [[RACChannel alloc] init];
    
    RACSignal *eventSignal = [[[self
        rac_signalForControlEvents:controlEvents]
        mapReplace:key]
        takeUntil:[[channel.followingTerminal
            ignoreValues]
            catchTo:RACSignal.empty]];
            
            [[self
        rac_liftSelector:@selector(valueForKey:) withSignals:eventSignal, nil]
        subscribe:channel.followingTerminal];
        
        RACSignal *valuesSignal = [channel.followingTerminal
        map:^(id value) {
            return value ?: nilValue;
        }];
    [self rac_liftSelector:@selector(setValue:forKey:) withSignals:valuesSignal, [RACSignal return:key], nil];

    return channel.leadingTerminal;
}

</code></pre>

<ol>
<li><code>eventSignal</code> 获取事件触发的<code>signal</code> 并将error转换为empty信号，发送的值即为key</li>
<li><code>rac_liftSelector:with:</code> 执行一个<code>selector</code>方法,<code>rac_liftSelector:@selector(valueForKey:)</code>即为获取<code>UIControl</code>的事件的<code>key</code>的值</li>
<li><code>subscribe:channel.followingTerminal</code> 即为 channel的<code>followingTerminal</code>订阅， 综合起来就是 每次事件触发时 获取<code>key</code>的value值 然后发送<code>followingTerminal</code>  而followTerminal的<code>sendNext</code>，触发leadingSubject的<code>sendNext</code>，即将事件触发时获取到的value值发送给leadingSubject的订阅者 即 leadingTerminal的订阅者</li>
<li><p><code>valueSignal</code> 订阅<code>followingTerminal</code>即 订阅 followSubject的消息，即为收到leadingTerminal发送的消息</p></li>
<li><p><code>[self rac_liftSelector:@selector(setValue:forKey:) withSignals:valuesSignal, [RACSignal return:key], nil];</code>  收到<code>leadingTerminal</code>发送的消息后将收到的值传给当前的控件，保证数据同步</p></li>
</ol>

<p>综合起来来说，就是在<code>controlEvent</code>事件发生时，将key的value值发送给<code>followingTerminal</code>，并在接收来自<code>leadingTerminal</code>消息后，更新控件的key属性对应的value值</p>

<h4 id="toc_8">UITextField+TextChannel</h4>

<pre><code class="language-objectivec">- (RACChannelTerminal *)rac_newTextChannel {
    return [self rac_channelForControlEvents:UIControlEventAllEditingEvents key:@keypath(self.text) nilValue:@&quot;&quot;];
}
</code></pre>

<h3 id="toc_9">RACChannel+KVO</h3>

<p>RACChannel提供了<code>RACKVOChannel</code>来实现对象的某个属性值进行观测， 常可以用来进行与UIKit组件或者其他对象属性进行高效的双向绑定</p>

<h4 id="toc_10">RACKVOChannel :RACChannel</h4>

<p>在KVO的channel中 我们常通过<code>RACChannelTo</code>宏定义来直接使用，观测某对象属性</p>

<pre><code class="language-objectivec">//参数分别为 对象、属性和默认值
#define RACChannelTo_(TARGET, KEYPATH, NILVALUE)

    [[RACKVOChannel alloc] initWithTarget:(TARGET) 
    keyPath:@keypath(TARGET, KEYPATH) nilValue:(NILVALUE)]
    [@keypath(RACKVOChannel.new, followingTerminal)]
</code></pre>

<p>例如：</p>

<pre><code class="language-objectivec">RACChannelTerminal *integerChannel = [[RACKVOChannel alloc] initWithTarget:self keyPath:@&quot;integerProperty&quot; nilValue:@42][@&quot;followingTerminal&quot;];
</code></pre>

<p>先来看<code>RACKVOChannel</code>的初始化方法</p>

<pre><code class="language-objectivec">- (instancetype)initWithTarget:(__weak NSObject *)target keyPath:(NSString *)keyPath nilValue:(id)nilValue {

    //KVO对象属性值并发送
    [strongTarget rac_observeKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:nil block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {
        [self.leadingTerminal sendNext:value];
    }]
    
    // 收到订阅值 并设置对象的属性值
    [[self.leadingTerminal
        finally:^{
            [observationDisposable dispose];
        }]
        subscribeNext:^(id x) {
            NSObject *object = (keyPathComponentsCount &gt; 1 ? [self.target valueForKeyPath:keyPathByDeletingLastKeyPathComponent] : self.target);
            if (object == nil) return;
            [object setValue:x ?: nilValue forKey:lastKeyPathComponent];
        } error:^(NSError *error) {
        }];
    
}
</code></pre>

<p>使用RACKVOChannel的初始化方法即获得了一个Channel对象，对此对象执行 <code>[@keypath(RACKVOChannel.new, followingTerminal)]</code>来获取terminal对象是因为重写了以下两个方法:</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)objectForKeyedSubscript:(NSString *)key {
    RACChannelTerminal *terminal = [self valueForKey:key];
    return terminal;
}

- (void)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(NSString *)key {
    RACChannelTerminal *selfTerminal = [self objectForKeyedSubscript:key];
    [otherTerminal subscribe:selfTerminal];
    [[selfTerminal skip:1] subscribe:otherTerminal];
}
</code></pre>

<p>重写这两个方法 就会使在调用<code>setObject: forKeyedSubscript:</code>时执行<code>-subscribe:</code>方法完成双向绑定</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACMulticastConnection: NSObject]]></title>
    <link href="https://acefish.github.io/15609234167437.html"/>
    <updated>2019-06-19T13:50:16+08:00</updated>
    <id>https://acefish.github.io/15609234167437.html</id>
    <content type="html"><![CDATA[
<p><code>RACMulticastConnection</code>用于信号的一对多传播</p>

<pre><code class="language-objectivec">@property (nonatomic, strong, readonly) RACSignal&lt;ValueType&gt; *signal;
{
RACSubject *_signal;
}
@property (nonatomic, readonly, strong) RACSignal *sourceSignal;

</code></pre>

<p>这个signal属性即为对外开发的信号，其实现是使用RACSubject对象，而<code>sourceSignal</code>即为订阅的原信号</p>

<p>在初始化方法中初始化这两个对象:</p>

<pre><code class="language-objectivec">- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject { 
    _sourceSignal = source;
    _signal = subject;
}
</code></pre>

<h2 id="toc_0">使用</h2>

<p>我们不应该直接初始化<code>RACMulticastConnection</code>对象  使用<code>RACSignal</code>的实例化方法初始化这个实例对象:</p>

<pre><code class="language-objectivec">- (RACMulticastConnection *)publish {
    RACSubject *subject = [RACSubject subject];
    RACMulticastConnection *connection = [self multicast:subject];
    return connection;
}

- (RACMulticastConnection *)multicast:(RACSubject *)subject {
    RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
    return connection;
}
</code></pre>

<p>可以很简单的看出来这两个方法只是简单的声明了<code>RACSubject</code>对象，并初始化一个<code>RACMulticastConnection</code>对象并返回</p>

<h2 id="toc_1">connect &amp;&amp; autoconnect</h2>

<p>具体信号的订阅是在connect方法中，只有执行了connect方法 才会订阅该信号 才能接收信号</p>

<pre><code class="language-objectivec">- (RACDisposable *)connect {
    self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
}
</code></pre>

<p><code>autoconnect</code>方法返回一个信号  当订阅了该信号时就会执行connect方法 订阅<code>sourceSignal</code>从而收到信号值</p>

<pre><code class="language-objectivec">- (RACSignal *)autoconnect {

    return [RACSignal
        createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
            RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];
            [self connect];
            }];
        }]
}
</code></pre>

<h2 id="toc_2">补充</h2>

<p>当使用<code>publish</code>方法返回的<code>RACMulticastConnection</code>对象时，只有当<code>connect</code>之前订阅的才能收到消息，而在connect之后订阅的对象并不能收到消息</p>

<p>因此此时我们可以使用<code>RACReplaySubject</code>对象，可以通过<code>[RACSignal replay]</code>方法实现</p>

<pre><code class="language-objectivec">- (RACSignal *)replay {
    RACReplaySubject *subject = [RACReplaySubject subject];
    RACMulticastConnection *connection = [self multicast:subject];
    [connection connect];
    return connection.signal;
}
</code></pre>

<p>除此之外 还有</p>

<p>Capacity:1 的ReplaySubject</p>

<pre><code class="language-objectivec">- (RACSignal *)replayLast {
    RACReplaySubject *subject = [RACReplaySubject replaySubjectWithCapacity:1];
    RACMulticastConnection *connection = [self multicast:subject];
    [connection connect];
    return connection.signal;
}
</code></pre>

<p>只有在返回的信号在被第一次订阅时 才会执行connect方法</p>

<pre><code class="language-objectivec">- (RACSignal *)replayLazily {
    RACMulticastConnection *connection = [self multicast:[RACReplaySubject subject]];
    return [RACSignal
        defer:^{
            [connection connect];
            return connection.signal;
        }];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACCommand: NSObject]]></title>
    <link href="https://acefish.github.io/15608261485816.html"/>
    <updated>2019-06-18T10:49:08+08:00</updated>
    <id>https://acefish.github.io/15608261485816.html</id>
    <content type="html"><![CDATA[
<p><code>RACCommand</code> 继承自<code>NSObject</code> 用于管理<code>RACSignal</code>信号</p>

<h2 id="toc_0">RACCommand使用示例</h2>

<pre><code class="language-objectivec">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {
        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
            NSInteger integer = [input integerValue];
            for (NSInteger i = 0; i &lt; integer; i++) {
                [subscriber sendNext:@(i)];
            }
            [subscriber sendCompleted];
            return [RACDisposable disposableWithBlock:^{
                NSLog(@&quot;信号销毁了&quot;);
            }];
        }];
    }];
    
    [[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) {
        NSLog(@&quot;收到消息---%@&quot;,x);
    } error:^(NSError * _Nullable error) {
        NSLog(@&quot;error了&quot;);
    } completed:^{
        NSLog(@&quot;completed了&quot;);
    }];
    
    [command execute:@1];
    [RACScheduler.mainThreadScheduler afterDelay:0.1
                                        schedule:^{
                                            [command execute:@2];
                                        }];
    [RACScheduler.mainThreadScheduler afterDelay:0.2
                                        schedule:^{
                                            [command execute:@3];
                                        }];
                                        
                            
    //log结果
    收到消息---0
    信号销毁了
    收到消息---0
    收到消息---1
    信号销毁了
    收到消息---0
    收到消息---1
    收到消息---2
    信号销毁了
    completed了
</code></pre>

<ol>
<li>通过<code>switchToLatest</code>方法来获取信号中的信号</li>
<li>因为默认情况下<code>RACCommand</code>是不支持并发操作的，需要在上次命令发送完成后，再发送下次信号</li>
</ol>

<pre><code class="language-objectivec">@property (nonatomic, strong, readonly) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;
</code></pre>

<p>通过以上示例可以看出整个流程中，传入一个block，这个block通过传入值生成对应的<code>signal</code>, 而command属性<code>executionSignals</code>即为这些信号的信号</p>

<p>通过 <code>execute</code>方法 出入值 </p>

<h2 id="toc_1">RACCommand</h2>

<p>在<code>Command</code>内部 是由几个很重要的信号组成的</p>

<h3 id="toc_2">初始化</h3>

<p>初始化方法需要传入<code>signalBlock</code>， 该block通过input传入值 生成一个<code>RACSignal</code><br/>
 在初始化方法中初始化了重要的信号</p>

<pre><code class="language-objectivec"> RACCommand initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;id&gt; * (^)(id input))signalBlock {
    _addedExecutionSignalsSubject = [RACSubject new];
    _allowsConcurrentExecutionSubject = [RACSubject new];
    _signalBlock = [signalBlock copy];
    _executionSignals =...
    _errors = ...
    _executing = ...
    _immediateEnabled = ...
    _enabled = ...
 }
</code></pre>

<h3 id="toc_3">addedExecutionSignalsSubject</h3>

<p><code>addedExecutionSignalsSubject</code>即为包含信号的信号 当传入值时通过signalblock生成的signal即包含在改信号中</p>

<p><code>addedExecutionSignalsSubject</code>信号在<code>execute:</code>执行时，对信号进行订阅和发送</p>

<pre><code class="language-objectivec">- (RACSignal *)execute:(id)input { 
    BOOL enabled = [[self.immediateEnabled first] boolValue];
    if (!enabled) {
        return [RACSignal error:error];
    }
    RACSignal *signal = self.signalBlock(input);
    //订阅信号
    RACMulticastConnection *connection = [[signal
        subscribeOn:RACScheduler.mainThreadScheduler]
        multicast:[RACReplaySubject subject]];
    //发送信号
    [self.addedExecutionSignalsSubject sendNext:connection.signal];
    [connection connect];
    return connection.signal;
}
</code></pre>

<h3 id="toc_4">immediateExecuting &amp;&amp; _executing 表示当前有操作执行的信号</h3>

<p>immediateExecuting的逻辑是：<br/>
    1. <code>catchTo</code>捕获<code>addedExecutionSignalsSubject</code>信号中的error信号，转换为empty<br/>
    2. <code>flattenMap:</code>将每个信号的开始和结束时间点转为1和-1信号（<code>start为1 then为-1</code>）<br/>
    3. <code>scanWithStart:@0 reduce:</code> 将上一步得到的1和-1进行叠加得到0 或者 非0<br/>
        1. <code>map:</code>将0/非0 转为 NO/YES 表示当前是否有信号正在处理</p>

<pre><code class="language-objectivec">RACSignal *immediateExecuting = [[[[self.addedExecutionSignalsSubject
        flattenMap:^(RACSignal *signal) {
            return [[[signal
                catchTo:[RACSignal empty]]
                then:^{
                    return [RACSignal return:@-1];
                }]
                startWith:@1];
        }]
        scanWithStart:@0 reduce:^(NSNumber *running, NSNumber *next) {
            return @(running.integerValue + next.integerValue);
        }]
        map:^(NSNumber *count) {
            return @(count.integerValue &gt; 0);
        }]
        startWith:@NO];
</code></pre>

<p>将immediateExecuting 信号进行优化  <strong>表示当前是否有任务执行</strong></p>

<pre><code class="language-objectivec">_executing = [[[[immediateExecuting
        deliverOn:RACScheduler.mainThreadScheduler]
        // This is useful before the first value arrives on the main thread.
        startWith:@NO]
        distinctUntilChanged]
        replayLast]
</code></pre>

<h3 id="toc_5">moreExecutionsAllowed  表示是否允许更多信号执行</h3>

<p>简单来看就是 当不允许并发时（默认不允许并发），<code>[immediateExecuting not]</code></p>

<pre><code class="language-objectivec">RACSignal *moreExecutionsAllowed = [RACSignal
        if:[self.allowsConcurrentExecutionSubject startWith:@NO]
        then:[RACSignal return:@YES]
        else:[immediateExecuting not]];
</code></pre>

<h3 id="toc_6">executionSignals</h3>

<pre><code class="language-objectivec"> @property (nonatomic, strong, readonly) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;
</code></pre>

<p><code>executionSignals</code>是一个包含信号的信号<br/>
executionSignals 只是简单的将<code>self.addedExecutionSignalsSubject</code>信号中的所有错误信号<code>NSError</code>转换为了<code>empty</code>信号</p>

<pre><code class="language-objectivec">_executionSignals = [[self.addedExecutionSignalsSubject
        map:^(RACSignal *signal) {
            return [signal catchTo:[RACSignal empty]];
        }]
        deliverOn:RACScheduler.mainThreadScheduler]
</code></pre>

<h3 id="toc_7">_enabled 信号 表示当前命令是否可以被再次执行</h3>

<pre><code class="language-objectivec">RACSignal *enabledSignal = [RACSignal return:@YES];

_immediateEnabled = [[[[RACSignal
    combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]
    and]
    takeUntil:self.rac_willDeallocSignal]
    replayLast];
    
//保证信号中的第一个值在订阅线程，而其他值在主线程派发
_enabled = [[[[self.immediateEnabled
    take:1]
    concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]
    distinctUntilChanged]
    replayLast]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACSignal信号的订阅与发送]]></title>
    <link href="https://acefish.github.io/15604257329990.html"/>
    <updated>2019-06-13T19:35:32+08:00</updated>
    <id>https://acefish.github.io/15604257329990.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">RACSignal</h2>

<h4 id="toc_1">订阅信号</h4>

<p>订阅信号动作 就是创建一个遵循<code>&lt;RACSubscriber&gt;</code>代理的对象 该对象将接受到信号时要做的动作block保存起来</p>

<pre><code class="language-objectivec">RACSignal subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock {
    
    RACSubscriber *subscriber = [[self alloc] init];
    subscriber-&gt;_next = [next copy];
    subscriber-&gt;_error = [error copy]    
    subscriber-&gt;_completed = [completed copy];
    
    [self subscribe:subscriber];
    
}
</code></pre>

<p>具体订阅该信号要做的事情  因为不同子类的信号发送事件不同  需要被子类重写</p>

<pre><code class="language-objectivec">RACSignal subscribe:(id&lt;RACSubscriber&gt;)subscriber {
    //被子类重写
}
</code></pre>

<h3 id="toc_2">RACSubscriber<RACSubscriber></h3>

<p>遵循<code>RACSubscriber</code>代理 即可发送信号值</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
    self.nextBlock(value);
}
- (void)sendError:(NSError *)e{
    self.errorBlock(e);
}
- (void)sendCompleted {
    self.completedBlock();
}
</code></pre>

<p>发送信号值 即执行保存的执行事件block</p>

<h3 id="toc_3">RACDynamicSignal</h3>

<p>DynamicSignal 即在创建信号时要发送的的信号值已经设定  而在重写<code>subscribe</code>方法时只需要将其发送的值与 next、error、completed block进行匹配执行即可</p>

<h4 id="toc_4">创建信号</h4>

<p><code>DynamicSignal</code>创建信号 创建时已经包含了信号已经要发送的值<br/>
将<code>id&lt;RACSubscriber&gt;</code>信号发送者要发送的值的事件block 存起来，存到signal的<code>_didSubscribe</code>block属性中</p>

<pre><code class="language-objectivec">RACDynamicSignal createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe {
    RACDynamicSignal *signal = [[self alloc] init];
      signal-&gt;_didSubscribe = [didSubscribe copy];
}
</code></pre>

<h4 id="toc_5">订阅信号</h4>

<p>订阅信号 即 执行创建信号时保存起来的<code>didSubscribe</code> block  send创建信号时发送的值 </p>

<pre><code class="language-objectivec">RACDynamicSignal subscribe:(id&lt;RACSubscriber&gt;)subscriber  {
    self.didSubscribe(subscriber);
}
</code></pre>

<h2 id="toc_6">RASSubject &lt; RACSubscriber &gt;: RACSignal</h2>

<p><code>Subject</code>维持一个数组保存所有需要sendEvent的<code>Subscriber</code>,当需要发送</p>

<h4 id="toc_7">订阅信号</h4>

<p>因为继承自<code>RACSignal</code> 需要重写<code>subscribe:</code>方法</p>

<pre><code class="language-objectivec">RASSubject )subscribe:(id&lt;RACSubscriber&gt;)subscriber {
    [self.subscribers addObject:subscriber];
}
</code></pre>

<h4 id="toc_8">发送信号</h4>

<p>发送信号值 即 遍历数组中的Subcriber 依次send 然后执行subscriber 中保存的nextBlock事件block</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
    [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:value];
    }];
}
</code></pre>

<h3 id="toc_9">RACBehaviorSubject &amp;&amp; RACReplaySubject</h3>

<h4 id="toc_10">RACBehaviorSubject</h4>

<p>在内部的<code>currentValue</code>属性会保存上次发送的值 这样在订阅该信号时即能收到最后发送的信号值，进行初始化</p>

<pre><code class="language-objectivec">+ (instancetype)behaviorSubjectWithDefaultValue:(id)value {
    RACBehaviorSubject *subject = [self subject];
    subject.currentValue = value;
    return subject;
}
</code></pre>

<h5 id="toc_11">发送信号</h5>

<p>在发送信号时 保存信号作为最后发送的信号</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
    self.currentValue = value;
    [super sendNext:value];
}
</code></pre>

<h5 id="toc_12">订阅信号</h5>

<p>重写<code>subscribe</code>方法  在每次订阅信号时 发送当前保存的值即最后发送的信号</p>

<pre><code class="language-objectivec">RACBehaviorSubject  subscribe:(id&lt;RACSubscriber&gt;)subscriber {
    [super subscribe:subscriber];
       [subscriber sendNext:self.currentValue];
}
</code></pre>

<h4 id="toc_13">RACReplaySubject</h4>

<pre><code class="language-objectivec">@property (nonatomic, strong, readonly) NSMutableArray *valuesReceived;
</code></pre>

<p>内部有个数组保存了一定量发送过的信号 默认为<code>RACReplaySubjectUnlimitedCapacity</code>（NSUIntegerMax），即保存所有已经发送过的信号，也可以通过<code>initWithCapacity</code>初始化，制动保存多少个已经发送过的信号</p>

<pre><code class="language-objectivec">- (instancetype)initWithCapacity:(NSUInteger)capacity {
    self = [super init];
    
    _capacity = capacity;
    _valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);
    
    return self;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACSignal]]></title>
    <link href="https://acefish.github.io/15578383647199.html"/>
    <updated>2019-05-14T20:52:44+08:00</updated>
    <id>https://acefish.github.io/15578383647199.html</id>
    <content type="html"><![CDATA[
<p>本文学习自<a href="https://github.com/halfrost/Analyze/blob/master/contents/ReactiveObjC/RACSignal.md">『状态』驱动的世界：ReactiveCocoa</a></p>

<p><code>RACSignal</code>继承自<code>RACStream</code>，对该抽象类的方法进行了重写实现</p>

<h3 id="toc_0"><code>return</code>方法</h3>

<pre><code class="language-objectivec">+ (RACSignal *)return:(id)value {
    return [RACReturnSignal return:value];
}
/**
RACReturnSignal *signal = [[self alloc] init];
signal-&gt;_value = value;
*/
</code></pre>

<h3 id="toc_1"><code>-bind</code>方法</h3>

<pre><code class="language-objectivec">
/**
实现过程
1. 订阅原始信号值
2. 当原信号发送值时，使用bindblock对其进行转换
3. 如果bindblock返回一个信号，订阅该信号，并在收到该信号值时，将所有值传递给接收者subscriber
4. 如果bindblock请求终止就向原信号发出`-sendError:`消息
5. 当所有信号完成，向订阅者发送`-sendCompleted`
6. 无论何时 当信号发生错误，向订阅者发送-sendError: 消息
*/

- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block
</code></pre>

<p><code>-bind</code>方法在原始信号每次发出消息时，执行<code>RACSignalBindBlock</code>对其进行变换生成一个新的信号</p>

<p>示例:</p>

<pre><code class="language-objectivec">//示例1：
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendNext:@4];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        //简单的利用bind将 原始信号的值进行了一个变换
        value = @(value.integerValue * value.integerValue);
        return [RACSignal return:value];
    };
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;signal: %@&quot;, x);
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;bindSignal: %@&quot;, x);
}];
</code></pre>

<h3 id="toc_2">-concat方法</h3>

<pre><code class="language-objectivec">- (RACSignal *)concat:(RACSignal *)signal {
    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {

        [self subscribeNext:^(id x) {
            [subscriber sendNext:x];
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            [signal subscribe:subscriber];
        }];
    }] setNameWithFormat:@&quot;[%@] -concat: %@&quot;, self.name, signal];
}
</code></pre>

<p>当原始信号<code>completed</code>后 subcribe contact的信号</p>

<h3 id="toc_3">-zipWith方法</h3>

<ul>
<li>(RACSignal *)zipWith:(RACSignal *)signal<br/>
将两个信号值进行zip 即每次发出一个为<code>RACTuple</code>值为[signal1value, signal2value]的值 当其中一个error或者completed即停止zipSignal</li>
</ul>

<h2 id="toc_4">信号的创建</h2>

<p>RACSignal的<code>createSignal</code>方法</p>

<pre><code class="language-objectivec">//RACSignal
+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe {
    return [RACDynamicSignal createSignal:didSubscribe];
}

//RACDynamicSignal
+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe {
    RACDynamicSignal *signal = [[self alloc] init];
    signal-&gt;_didSubscribe = [didSubscribe copy];
    return [signal setNameWithFormat:@&quot;+createSignal:&quot;];
}
</code></pre>

<p>signal保存了<code>didSubscribe</code>并在每次有订阅者订阅当前信号时 都会执行一遍，向订阅者发送消息</p>

<h3 id="toc_5">RACSignal类簇</h3>

<p><code>RACSignal</code>拥有不同功能的子类</p>

<ol>
<li><p><code>RACDynamicSignal</code>：用于 <code>+ createSignal:</code></p></li>
<li><p><code>RACEmptySignal</code> 用于 <code>+ empty</code></p>
<pre><code class="language-objectivec">+ (RACSignal *)empty {
    return [[[self alloc] init] setNameWithFormat:@&quot;+empty&quot;];<br/>
}<br/>
- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {<br/>
    return [RACScheduler.subscriptionScheduler schedule:^{<br/>
        [subscriber sendCompleted];<br/>
    }];<br/>
}
</code></pre></li>
<li><p><code>RACReturnSignal</code>  用于 <code>+ return</code></p>
<pre><code class="language-objectivec">+ (RACSignal *)return:(id)value {
    RACReturnSignal *signal = [[self alloc] init];<br/>
      signal-&gt;_value = value;<br/>
      return signal;<br/>
}<br/>
//将value简单保存 在有其它订阅者时 向订阅者发送value<br/>
- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {<br/>
        NSCParameterAssert(subscriber != nil);<br/>
        return [RACScheduler.subscriptionScheduler schedule:^{<br/>
            [subscriber sendNext:self.value];<br/>
            [subscriber sendCompleted];<br/>
        }];<br/>
}
</code></pre></li>
<li><p><code>RACErrorSignal</code>  用于 <code>+ error</code></p>
<pre><code class="language-objectivec">+ (RACSignal *)error:(NSError *)error {
    RACErrorSignal *signal = [[self alloc] init];<br/>
    signal-&gt;_error = error;<br/>
#ifdef DEBUG<br/>
    [signal setNameWithFormat:@&quot;+error: %@&quot;, error];<br/>
#else<br/>
    signal.name = @&quot;+error:&quot;;<br/>
#endif<br/>
    return signal;<br/>
}<br/>
- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {<br/>
       return [RACScheduler.subscriptionScheduler schedule:^{<br/>
    [subscriber sendError:self.error];<br/>
}];<br/>
}
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACStream]]></title>
    <link href="https://acefish.github.io/15578193513091.html"/>
    <updated>2019-05-14T15:35:51+08:00</updated>
    <id>https://acefish.github.io/15578193513091.html</id>
    <content type="html"><![CDATA[
<p><code>RACStream</code>是继承自NSObject最基础的类，其它的子类例如<code>RCSignal</code>、<code>RACSequence</code>均继承自该类</p>

<p><code>RACStream</code>作为一个抽象类存在，本身并不提供任何方法的实现，内部方法均为抽象方法，在调用时抛出异常</p>

<pre><code class="language-objectivec">+ (__kindof RACStream *)empty {
    NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
}
- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block
// return 根据该value 返回一个RACStream对象
+ (__kindof RACStream *)return:(id)value
- (__kindof RACStream *)concat:(RACStream *)stream
- (__kindof RACStream *)zipWith:(RACStream *)stream

</code></pre>

<p>但是在RACStream的Operations分类<code>RACStream (Operations)</code>提供了更丰富的方法</p>

<pre><code class="language-objectivec">//对信号的值进行map映射
- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block {
    Class class = self.class;

    return [[self bind:^{
        return ^(id value, BOOL *stop) {
            id stream = block(value) ?: [class empty];
            NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);

            return stream;
        };
    }] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];
}
- (__kindof RACStream *)flatten
- (__kindof RACStream *)map:(id (^)(id value))block
- (__kindof RACStream *)mapReplace:(id)object

//根据规则过滤
- (__kindof RACStream *)filter:(BOOL (^)(id value))block
- (__kindof RACStream *)ignore:(id)value

//对RACTuple中每个值进行处理 
- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock

//将RACStream 前拼上一个新的值
- (__kindof RACStream *)startWith:(id)value

//跳过固定个数的值
- (__kindof RACStream *)skip:(NSUInteger)skipCount
//接收前固定个数的值
- (__kindof RACStream *)take:(NSUInteger)count

//将一组Stream按照block的规则合并为一个  
+ (__kindof RACStream *)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, id))block
+ (__kindof RACStream *)zip:(id&lt;NSFastEnumeration&gt;)streams
+ (__kindof RACStream *)zip:(id&lt;NSFastEnumeration&gt;)streams reduce:(RACGenericReduceBlock)reduceBlock

//一组Stream contact(连接)
+ (__kindof RACStream *)concat:(id&lt;NSFastEnumeration&gt;)streams

//用初始值开始reduce 返回每次block之后的结果
- (__kindof RACStream *)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id, id, NSUInteger))reduceBlock

//忽略不符合条件的
- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate
- (__kindof RACStream *)takeWhileBlock:(BOOL (^)(id x))predicate

//忽略不符合条件的 直到第一个符合条件的
- (__kindof RACStream *)skipUntilBlock:(BOOL (^)(id x))predicate
- (__kindof RACStream *)skipWhileBlock:(BOOL (^)(id x))predicate

//忽略未改变值的改变
- (__kindof RACStream *)distinctUntilChanged
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MatrixiOS学习]]></title>
    <link href="https://acefish.github.io/15560883411509.html"/>
    <updated>2019-04-24T14:45:41+08:00</updated>
    <id>https://acefish.github.io/15560883411509.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">学习到的知识点</h2>

<h4 id="toc_1">1.使用协议和继承进行规范开发</h4>

<p>在项目中定义了plugin的基类<code>MatrixPlugin</code>继承自协议<code>MatrixPluginProtocol</code>，而接下来的组件开发，只需要继承自<code>MatrixPlugin</code>，然后实现协议中的方法即可</p>

<p>而当回调时，也不需要知道具体是哪个<code>plugin</code>，只需指定其实一个继承了协议的插件即可:<br/>
<code>- (void)onInit:(id&lt;MatrixPluginProtocol&gt;)plugin</code>,就可以使用其在协议中指定的方法</p>

<h4 id="toc_2">2.利用运行时实现NSCoding协议</h4>

<p>利用运行时方法获取对象类以及父类的所有属性变量属性变量，执行<code>encodeObject</code>和<code>decodeObjectForKey</code>方法</p>

<p><a href="media/15560883411509/MatrixBaseModel.mm">MatrixBaseMode</a></p>

<h4 id="toc_3">3. 对于app中常用文件路径可以专门写个工具类，为避免每次都访问使用单例</h4>

<pre><code class="language-objectivec">+ (NSString *)matrixCacheRootPath
{
    static NSString *s_rootPath;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
        s_rootPath = [paths[0] stringByAppendingString:@&quot;/Matrix&quot;];
        if ([[NSFileManager defaultManager] fileExistsAtPath:s_rootPath] == NO) {
            [[NSFileManager defaultManager] createDirectoryAtPath:s_rootPath withIntermediateDirectories:YES attributes:nil error:nil];
        }
    });
    return s_rootPath;
}
</code></pre>

<h4 id="toc_4">4.判断app是否处于调试环境下</h4>

<pre><code class="language-objectivec">+ (BOOL)isBeingDebugged
{
    // Returns true if the current process is being debugged (either
    // running under the debugger or has a debugger attached post facto).
    int                 junk;
    int                 mib[4];
    struct kinfo_proc   info;
    size_t              size;
    
    // Initialize the flags so that, if sysctl fails for some bizarre
    // reason, we get a predictable result.
    
    info.kp_proc.p_flag = 0;
    
    // Initialize mib, which tells sysctl the info we want, in this case
    // we&#39;re looking for information about a specific process ID.
    
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PID;
    mib[3] = getpid();
    
    // Call sysctl.
    
    /**
     *int sysctl(int *name, u_int namelen, void *old, size_t *oldlen, void *newp, size_t newlen);
     *name参数是一个用以指定查询的信息数组；
     *namelen用以指定name数组的元素个数；
     *old是用以函数返回的缓冲区；
     *oldlen用以指定oldp缓冲区长度；
     *newp和newlen在设置时使用；
     *当进程被调试器依附时，kinfo_proc结构下有一个kp_proc结构域，
     kp_proc的p_flag的被调试标识将被设置，即会进行类似如下的设置：
     kinfo_proc.kp_proc.p_flag&amp;P_TRACED
     其中P_TRACED的定义如下：
     #define P_TRACED        0x00000800
     */
    
    
    size = sizeof(info);
    junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, NULL, 0);
    assert(junk == 0);
    
    // We&#39;re being debugged if the P_TRACED flag is set.
    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);
}
</code></pre>

<p>以及一些获取app基本信息的方法<br/>
<a href="media/15560883411509/MatrixDeviceInfo.mm">MatrixDeviceInfo</a></p>

<h4 id="toc_5">5. atexit(func)在app正常退出时调用函数</h4>

<p><code>atexit</code>函数是一个特殊的函数，它在正常退出程序时调用的函数<br/>
atexit设置的函数会在exit过程中被调用，exit调用终止处理函数的顺序和atexit登记的顺序相反</p>

<p>进程终止的方式有8种:</p>

<ol>
<li>从main函数返回</li>
<li>调⽤用exit函数</li>
<li>调⽤用_exit或_Exit； </li>
<li>最后⼀一个线程从启动例程返回；</li>
<li>最后⼀一个线程调⽤用pthread_exit</li>
<li>调⽤用abort函数； </li>
<li>接到一个信号并终⽌； </li>
<li>最后⼀一个线程对取消请求做出响应<br/>
其中前5种为正常终止，而后3种为异常终止</li>
</ol>

<p><code>_exit</code>和<code>_Exit</code>立即进入内核，而exit会进行一些清理工作<br/>
exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。 </p>

<h4 id="toc_6">6. 使用dispatch_block_cancel()来取消执行某些未来执行的block</h4>

<h4 id="toc_7">7. MatrixAppRebootAnalyzer中对App启动和关闭状态的监控</h4>

<p>Matrix中对应用被杀原因检测<br/>
<img src="media/15560883411509/15562491518956.jpg" alt="" style="width:500px;"/></p>

<h4 id="toc_8">8.获取CPU</h4>

<p><code>WCCPUHandler</code>文件中对于CPU usage的计算</p>

<h4 id="toc_9">9.获取线程信息</h4>

<p><code>WCGetMainThreadUtil</code>文件中使用基于KSCrash获取堆栈</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mach-O文件结构]]></title>
    <link href="https://acefish.github.io/15559005276972.html"/>
    <updated>2019-04-22T10:35:27+08:00</updated>
    <id>https://acefish.github.io/15559005276972.html</id>
    <content type="html"><![CDATA[
<p>参考资料:<br/>
<a href="http://jianli2017.top/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pod repo update]]></title>
    <link href="https://acefish.github.io/15556625620569.html"/>
    <updated>2019-04-19T16:29:22+08:00</updated>
    <id>https://acefish.github.io/15556625620569.html</id>
    <content type="html"><![CDATA[
<p>我们平时开发pod update或者pod install , 这里其实 pod的工作就是根据pod库名在master/Specs/中找到对应的库，若指定版本则找到指定版本的podspec,否则找最高版本的podspec，找到后根据podsepc文件中的配置下载指定的库资源。</p>

<p>那么pod repo update 的工作就是更新pod资源目录，也就是master下的资源，简单说 如果有一个第三方库发布了一个最新的版本，如果你不执行pod repo update，那么你的本地是不会知道有一个最新版本的，还会一直以你本地的资源目录为准。那么你永远都拿不到这个库的最新版本。</p>

<p>使用pod update是默认会执行一遍pod repo update ，所以会发现如果你的pod库引用多了，每次pod update都很慢，网络如果不好更是经常会断掉，就是因为你在更新pod时，也更新了资源目录</p>

<p>pod update 工作流程 :</p>

<ul>
<li>先拉取远程最新目录，再根据目录中的资源重新更新一遍pod</li>
<li>如果你的podfile中每个库都指定了版本还好，如果没有，那么每次都是拉一遍最新库， 这时候就要用到命令
<code>
pod update --no-repo-update
</code></li>
</ul>

<p>有些时候会引用一些私有库 ， <code>pod repo update</code> 会把<code>~/.cocoapods/repos/</code>这个目录下所有的资源库目录都更新一遍，有时候不想更新master，只想更新某个具体的私有库 可以使用<code>pod repo update ~/.cocoapods/repos/***/</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[otool命令]]></title>
    <link href="https://acefish.github.io/15554889031358.html"/>
    <updated>2019-04-17T16:15:03+08:00</updated>
    <id>https://acefish.github.io/15554889031358.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instruments Help]]></title>
    <link href="https://acefish.github.io/15553150729300.html"/>
    <updated>2019-04-15T15:57:52+08:00</updated>
    <id>https://acefish.github.io/15553150729300.html</id>
    <content type="html"><![CDATA[
<p>官方文档<a href="https://help.apple.com/instruments/mac/current/#//apple_ref/doc/uid/TP40004652-CH5">Instruments Help</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO]]></title>
    <link href="https://acefish.github.io/15551517319694.html"/>
    <updated>2019-04-13T18:35:31+08:00</updated>
    <id>https://acefish.github.io/15551517319694.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">官方文档地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的泛型]]></title>
    <link href="https://acefish.github.io/15550609641165.html"/>
    <updated>2019-04-12T17:22:44+08:00</updated>
    <id>https://acefish.github.io/15550609641165.html</id>
    <content type="html"><![CDATA[
<p><a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC]]></title>
    <link href="https://acefish.github.io/15549735665033.html"/>
    <updated>2019-04-11T17:06:06+08:00</updated>
    <id>https://acefish.github.io/15549735665033.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE">官方文档地址</a></p>

<p><code>KVC(Key-value coding)</code>是由<code>NSKeyValueCoding</code>非正式协议(其实就是我们所的分类或类别)启用的机制，通过该机制提供了对属性的间接访问。<br/>
当对象符合键值编码时，属性可以通过字符串参数进行接口寻址。<br/>
这种对属性的间接访问机制提供了对实例变量和其相关访问器方法的直接访问</p>

<blockquote>
<p>键值编码是一个基本概念，是许多其他Cocoa技术的基础，例如键值观察(KVO)，Cocoa绑定，CoreData和AppleScript能力。在某些情况下，键值编码还有助于简化代码。</p>
</blockquote>

<p>通过KVC 我们可以实现以下功能:</p>

<ol>
<li>获取对象属性</li>
<li>操作对象属性</li>
<li>在集合对象上进行集合运算符运算</li>
<li>获取非对象属性</li>
<li>通过keyPath来获取对象属性</li>
</ol>

<p><code>NSObject</code>的<code>NSKeyValueCoding</code>分类实现了KVC方法，并提供默认实现;而<code>NSArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code>等都又提供了自己的实现</p>

<p><img src="media/15549735665033/15550373964851.jpg" alt="" style="width:200px;"/></p>

<p>为了使对象符合键值编码，应确保其实现了NSKeyValueCoding非正式协议，并实现了相应的方法，<code>NSObject</code>使用了<code>NSKeyValueCoding</code>协议并为它们和其它基本方法提供了默认实现。因此从NSObject派生的对象，大部分工作已经完成；</p>

<p>符合键值编码的对象可以实现其他Cocoa的技术:</p>

<ol>
<li>KVO</li>
<li>Cocoa绑定：这一系列技术完全实现了模型 - 视图 - 控制器范例，其中模型封装应用程序数据，视图显示和编辑数据，控制器在两者之间进行调解。 阅读<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i">Cocoa Bindings编程主题</a>以了解有关Cocoa绑定的更多信息。</li>
<li>CoreData: <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075">文档地址</a></li>
<li>AppleScript：  <a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i">AppleScript Overview</a></li>
</ol>

<h2 id="toc_0">API</h2>

<h4 id="toc_1">直接访问对象属性</h4>

<pre><code class="language-objectivec">- (nullable id)valueForKey:(NSString *)key;
- (void)setValue:(nullable id)value forKey:(NSString *)key;
</code></pre>

<pre><code class="language-objectivec">//点语法访问器
myAccount.currentBalance = @(100.0);
[myAccount setCurrentBalance:@(100.0)];

//KVC
[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];
NSNumber *currentBalance = [myAccount valueForKey:@&quot;currentBalance&quot;];

Person *owerModel = [[Person alloc] init];
[myAccount setValue:owerModel forKeyPath:@&quot;ower&quot;];
</code></pre>

<blockquote>
<p>对于<code>forKey:</code>不常用，因为我们均可以使用<code>forKeyPath:</code>来代替，对于keyPath只有一层也是可以的</p>
</blockquote>

<h4 id="toc_2">路径访问属性</h4>

<pre><code class="language-objectivec">- (nullable id)valueForKeyPath:(NSString *)keyPath;
- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;
</code></pre>

<pre><code class="language-objectivec">//键路径是以点分隔的多个键字符串  指定了要遍历的对象属性序列
[myAccount setValue:@&quot;lyy&quot; forKeyPath:@&quot;ower.name&quot;];
NSString *name = [myAccount valueForKeyPath:@&quot;ower.name&quot;];
</code></pre>

<h4 id="toc_3">键未定义异常</h4>

<p>当找不到key命名的属性时，会调用获取值的 </p>

<pre><code class="language-objectivec">- (id)valueForUndefinedKey:(NSString *)key;
- (void)setValue:(id)value forUndefinedKey:(NSString *)key;
</code></pre>

<p>找不到系统会默认引发一个<code>NSUndefinedKeyException</code>异常，可以通过重写这两个方法避免崩溃</p>

<blockquote>
<p>对于keyPath的方式访问属性，kayPath的键对应对象属性序列，到哪一级找不到对应属性，就会触发对应该级对象的这个两个方法，而不是总触发第一级对象的</p>
</blockquote>

<h4 id="toc_4">对于非对象值</h4>

<p>当<code>setValue</code>时，如果属性不是对象值，而是标量或者结构体时，KVC会自动将value拆箱然后赋值给属性<br/>
同理，当<code>valueForKey/keyPath:</code>会自动将属性值装箱，返回一个<code>NSNumber</code>或者<code>NSValue</code></p>

<pre><code class="language-objectivec">//封装为为NSValue
NSPoint、NSRange、NSRect、NSSize
</code></pre>

<h4 id="toc_5">对于nil</h4>

<ul>
<li><p>对于属性为对象值时，可以直接设置对象值为nil，或者获取对象指为nil</p></li>
<li><p>对于属性为非对象值，即为标量或者结构体时，此时系统无法帮我们拆箱,会触发<code>setNilValueForKey:</code>方法，并且引发一个<code>NSInvalidArgumentException</code>异常，可以通过重写该方法避免</p></li>
</ul>

<h3 id="toc_6">多值访问</h3>

<pre><code class="language-objectivec">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;
- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;
</code></pre>

<p>提供了可以同时获取和设置多个值的方法，相当于一次性掉了多次<code>valueForKey</code>和<code>setValue:forKey:</code>，当key值不存在时也会触发<strong>键未定义异常</strong>的崩溃和避免崩溃方法<br/>
注意： 这两个方法中只能设置的为key，而不能使用keyPath</p>

<h3 id="toc_7">访问集合属性</h3>

<p>对于属性为集合对象，与获取普通对象属性相同，可以直接获取和设置到集合对象属性值</p>

<pre><code class="language-objectivec">[myAccount setValue:dataArr forKey:@&quot;transactionsArray&quot;];
NSArray *obj = [myAccount valueForKeyPath:@&quot;transactionsArray&quot;];
</code></pre>

<p>另外一个较常用的功能,我们可以使用<code>valueForKeypath:</code>直接获取数组中每个对象的属性值集合</p>

<pre><code class="language-objectivec">NSArray *obj1 = [myAccount valueForKeyPath:@&quot;transactionsArray.payee&quot;];
</code></pre>

<p>在keyPath中遇到数组时，会对数组中的每个元素都执行接下来的<code>valueForKeyPath:</code>,最后返回一个值的集合</p>

<p>但是对于集合的属性集合<code>setValue:forkey/KeyPath:</code>并不好用，其并不会将value中的数组分别复制给key中的属性，而是会将value直接赋值给每个key中的属性</p>

<h3 id="toc_8">操作集合属性</h3>

<p>对于集合属性 我们想要修改其内容 需要先用<code>valueForKeyPath</code>获取到其不可变属性值，然后用其创建可变对象值然后修改，再用<code>setValueForKeyPath</code>方法重新设置回去，较麻烦</p>

<p>苹果提供了直接可以获取集合属性的可变对象进行操作的方法</p>

<pre><code class="language-objectivec">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;
- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;

- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath;

- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;
- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;
</code></pre>

<p>会返回一个行为继承于<code>NSMutableArray/NSMutableOrderedSet/NSMutableSet</code>的内置对象，对这个对象直接操作(例如增加、删除元素)，系统会根据我们的操作直接修改原对象<br/>
这样修改维护集合中的对象，还可以<strong>支持键值观察机制</strong></p>

<blockquote>
<p>这种方法只适合直接修改集合属性，而不适合修改集合属性的属性值集合，原因和不对其使用<code>setValue:forkey/KeyPath:</code>原因相同</p>
</blockquote>

<h3 id="toc_9">属性验证</h3>

<p>NSKeyValueCoding协议提供了支持属性验证的方法。 可以通过调用</p>

<pre><code class="language-objectivec">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;

- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;
</code></pre>

<p>协议的默认实现会像实例搜索是否存在实现了<code>validate&lt;Key&gt;:error:</code>方法，默认为返回YES表示验证成功，我们可以再这个方法中实现自己的验证逻辑</p>

<pre><code class="language-objectivec">BankAccount *myAccount = [[BankAccount alloc] init];
NSError *error;
NSNumber *balance = @(100.0);
BOOL result = [myAccount validateValue:&amp;balance forKey:@&quot;currentBalance&quot; error:&amp;error];

//BankAccount.m
- (BOOL)validateCurrentBalance:(id *)ioValue error:(NSError *__autoreleasing *)outError {
    if (!ioValue || ((NSNumber *)*ioValue).integerValue &gt;= 100) {
        *outError = [NSError errorWithDomain:@&quot;错误qqq&quot; code:123 userInfo:@{@&quot;key&quot;: @&quot;金额太大了&quot;}];
        return NO;
    }
    return YES;
}
</code></pre>

<p>当然如果不想每个不同key验证都写一次验证方法的话，就直接继承实现自己的validateValue</p>

<pre><code class="language-objectivec">- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable __autoreleasing *)outError {
    
    if (!ioValue || ((NSNumber *)*ioValue).integerValue &gt;= 100) {
        *outError = [NSError errorWithDomain:@&quot;错误qqq&quot; code:123 userInfo:@{@&quot;key&quot;: @&quot;金额太大了&quot;}];
        return NO;
    }
    return YES;
}
</code></pre>

<blockquote>
<p><code>- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</code>怎么使用呢????</p>
</blockquote>

<h2 id="toc_10">集合运算符</h2>

<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW9">官方文档</a></p>

<p>使用<code>valueForKeyPath:</code>时，可以在路径中嵌入<strong>集合运算符</strong><br/>
集合运算符是在<code>@</code>关键字标识，指定了getter应该执行的操作，以便在数据返回之前以某种方式操作数据</p>

<p><img src="media/15549735665033/15550626615233.jpg" alt="" style="width:500px;"/></p>

<p>当keyPath包含集合运算符时，@前路径为左键路径，表示相对操作对象的集合路径，当操作对象直接为集合对象时，可以省略左键路劲;@运算符后的为右键路径，表示操作的集合中的属性，除了<code>@count</code>都需要右键路径</p>

<p>集合运算符共有三种类型:</p>

<ul>
<li><p>聚合运算符<br/>
以某种方式合并集合中的对象，并返回和右键路径属性相同类型的一个值;（@count例外）</p>
<ol>
<li><p><strong>@avg</strong> 读取右键属性值，并将其转为<code>double</code>类型(将nil转为0)，计算其算术平均值，返回一个<code>NSNumber</code>对象</p>
<pre><code class="language-objectivec">NSNumber *transactionAverage = [self.transactions valueForKeyPath:@&quot;@avg.amount&quot;];
</code></pre></li>
<li><p><strong>@count</strong> 获取集合中元素个数，忽略右键属性(如果有)</p>
<pre><code class="language-objectivec">NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@&quot;@count&quot;];
</code></pre></li>
<li><p><strong>@max</strong> 搜索右键属性对应的值集合 返回最大的那个(比较时忽略nil)<br/>
比较使用的时<code>compare:</code>方法，因此右键属性值必须能响应该方法</p>
<pre><code class="language-objectivec">NSDate *latestDate = [self.transactions valueForKeyPath:@&quot;@max.date&quot;];
</code></pre>
<blockquote>
<p><code>Foundation</code>中内置很多类都已经实现了该方法，我们也可以通过自己实现<code>- (NSComparisonResult)compare:(id)other</code>方法来实现自定义model的compare</p>
</blockquote></li>
<li><p><strong>@min</strong><br/>
与@max同理</p></li>
<li><p><strong>@sum</strong> 将集合中右键元素都转为double类型(将nil转为0)求和</p></li>
<li><p><strong>@count</strong></p></li>
</ol>
<pre><code class="language-objectivec">    NSInteger count = [[myAccount.transactionsArray valueForKeyPath:@&quot;@count&quot;] integerValue];
</code></pre></li>
<li><p>数组运算符<br/>
返回一个NSArray实例，返回集合中属性的子集</p>
<p><strong>@distinctUnionOfObject</strong>返回一个数组其中包含了右键属性的不重复的值的集合(不包含nil元素)；</p>
<pre><code class="language-objectivec">NSArray *arr = [myAccount valueForKeyPath:@&quot;transactionsArray.@distinctUnionOfObjects.amount&quot;];
</code></pre>
<p><strong>@unionOfObjects</strong> 返回右键属性值的集合并不会去重(不包含nil元素)</p></li>
<li><p>嵌套操作符<br/>
嵌套运算符处理嵌套的集合，集合的条目本身就包含了一个集合</p></li>
</ul>

<p><strong>@distinctUnionOfArrays</strong> 返回右键集合属性的所有集合元素中不重复值的集合</p>

<pre><code class="language-objectivec">    NSArray *arr = [objArray valueForKeyPath:@&quot;@distinctUnionOfArrays.transactionsArray.payee&quot;];
</code></pre>

<p><strong>unionOfArrays</strong> 返回右键集合属性的所有元素集合（不去重）</p>

<pre><code class="language-objectivec">    NSArray *arr1 = [objArray valueForKeyPath:@&quot;@unionOfArrays.transactionsArray.payee&quot;];
</code></pre>

<p><strong>@distinctUnionOfSets</strong> 与<code>distinctUnionOfArrays</code>类似 不同的是 其需要NSSet实例属性包含NSSet集合</p>

<h2 id="toc_11">KVC的搜索规则</h2>

<!--学习自简书[KVC原理剖析](https://www.jianshu.com/p/1d39bc610a5b)
-->

<p>NSObject提供的<code>NSKeyValueCoding</code>协议默认实现，将基于键的访问映射到对象属性。这些协议方法使用key参数在自己对象实例中搜索访问器、实例变量以及某些约定命名方法</p>

<h3 id="toc_12">基础Getter的搜索模式</h3>

<p><code>valueForKey:</code>的默认实现，会根据key参数在对象实例中进行以下搜索流程:</p>

<ol>
<li>按顺序搜索实例变量中的方法名类似:<code>get&lt;Key&gt;</code>、<code>&lt;Key&gt;</code>、<code>is&lt;Key&gt;</code>或者<code>_&lt;Key&gt;</code>的方法,如果找到直接跳到第5步</li>
<li><p>搜索实例中匹配<code>countOf&lt;Key&gt;</code>方法和<code>objectIn&lt;Key&gt;AtIndex:</code>方法(对应NSArray类的基本方法)以及<code>&lt;key&gt;AtIndexes:</code>(对应NSArray的<code>objectsAtIndexes:</code>方法)，如果找到第一个方法以及至少后两个方法中的一个，就创建一个相应NSArray所有方法的集合代理对象并返回，否则执行第3步</p>
<p>这个代理对象会将接收到的所有NSArray消息转换为<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>方法的组合来交给原始对象响应。如果原始对象还实现了<code>get&lt;Key&gt;:range:</code>可选方法，也会在适当时候是使用；这个数组代理对象工作起来就像真的NSArray一样</p>
<blockquote>
<p>代理对象的作用只是将交给其的方法进行组合，转交给原始对象响应，让其工作的像一个真的数组一样</p>
</blockquote></li>
<li><p>搜索名字为<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf &lt;Key&gt;</code>的三个方法(对应NSSet类定义方法)，如果找到这个3个方法就返回一个响应所有NSSet方法的代理对象，否则执行第4步<br/>
其会将随后收到的所有NSSet方法转换为上面3个方法的组合，让这个代理对象就像真的NSSet一样</p></li>
<li><p>如果上面方法都没找到，并且接收对象的<code>accessInstanceVariablesDirectly</code>类方法返回YES。就按顺序搜索<code>_&lt;key&gt;</code>、<code>_isKey</code>、<code>&lt;Key&gt;</code>、<code>is&lt;Key&gt;</code>实例变量名，找到的话执行第5步，否则执行第6步</p></li>
<li><p>如果是对象就直接返回，如果为非对象就装箱返回</p></li>
<li><p>如果都没找到就触发<code>valueForUndefineKey:</code>异常</p></li>
</ol>

<h3 id="toc_13">基础Setter模式搜索</h3>

<ol>
<li>按顺序搜索名字为<code>set&lt;Key&gt;</code>或者<code>_set&lt;Key&gt;</code>的访问器，找到就直接调用</li>
<li>如果找不到简单访问器，并且类方法<code>accessInstanceVariablesDirectly</code>类方法返回YES，并且按顺序查找<code>&lt;Key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>实例变量，如果找到直接设置值</li>
<li>以上两步都找不到,带用<code>setValue:forUndefinedKey:</code>默认会引发异常</li>
</ol>

<h3 id="toc_14">可变数组的搜索模式</h3>

<p><code>mutableArrayValueForKey:</code>用一下流程返回一个可变数组的代理对象</p>

<ol>
<li><p>搜索方法<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>(对应NSMutableArray的私有方法<code>insertObject:atIndex:</code>和<code>removeObjectAtIndex:</code>)，或者方法名为<code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>（对应NSMutableArray的为<code>insertObjects:atIndexes:</code>和<code>removeObjectsAtIndexes:</code>）。假如对象有至少一个insert方法或者一个remove方法，就返回一个响应<code>NSMutableArray</code>方法的代理对象。</p>
<p>代理对象通过发送一些组合的消息insertObject:in<Key>AtIndex:, removeObjectFrom<Key>AtIndex:, insert<Key>:atIndexes:,和remove<Key>AtIndexes:给<code>mutableArrayValueForKey:</code>消息的原始接收者来响应这些插入或者删除方法</p>
<p>当接收<code>mutableArrayValueForKey：</code>的原始消息对象实现名称为<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>的（可选）替换方法时，代理对象也会在适当时使用这些方法以获得最佳性能。</p>
<blockquote>
<p>代理的可变对象会响应所有NSMUtalbeArray方法，并将其转交给原始的对象消息接受者，对集合数组进行修改</p>
</blockquote></li>
<li><p>如果对象没有可变数组方法，就搜索名称为<code>set&lt;Key&gt;:</code>的访问器方法，这种情况会向<code>mutableArrayValueForKey:</code>的原始接收者发出<code>set&lt;Key&gt;</code>方法来，来响应NSMutableArray代理对象的消息</p>
<blockquote>
<p>注意: 这种方法的机制会比上一步的效率低得多，它会重复创建集合而不是修改原有集合,在使用KVC时应该尽量避免这种情况</p>
</blockquote></li>
<li><p>加入以上2中都没找到哦，并且对象响应<code>accessInstanceVariablesDirectly</code>类方法返回YES，就按顺序搜索<code>_&lt;Key&gt;</code>和<code>&lt;Key&gt;</code>的实例变量<br/>
找到这样的实例变量，就返回一个代理对象，会把NSMutableArray消息转发给实例变量</p></li>
<li><p>如果以上消息都失败了，就返回一个NSMutableArray的代理对象，该对象在收到<code>NSMutablrArray</code>消息后向<code>mutableArrayValueForKey:</code>原始接受者发出<code>setValue:ForUndefineKey:</code>消息，会引起<code>NSUndefinedKeyException</code>异常</p></li>
</ol>

<h3 id="toc_15">MutableOrderedSet的搜索模式</h3>

<p><code>mutableOrderedSetValueForKey</code> 与 数组搜索模式类似 ，只是其第一步搜索的方法为<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>、 <code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>和可选方法<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject: 或 replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></p>

<h3 id="toc_16">MutableSet搜索模式</h3>

<p>和mutableArray类似</p>

<p>第一步方法为:<br/>
<code>add&lt;Key&gt;Object:</code>和 <code>remove&lt;Key&gt;Object:</code> <code>add&lt;Key&gt;:</code>和<code>remove&lt;Key&gt;:</code>和可选方法<code>intersect&lt;Key&gt;: or set&lt;Key&gt;:</code></p>

<p>多了第二步骤搜索:<br/>
加入<code>mutableSetValueForKey</code>方法调用者是<code>manager object</code>则搜索模式不在继续,详情看CoreData核心编程指南</p>

<h2 id="toc_17">KVC性能</h2>

<p>KVC性能没有直接访问属性快，但是性能消耗微乎其微;<br/>
但是需要注意对操作可变集合对象的搜索模式，最好自己实现方法，避免重复创建集合进行赋值，这样性能消耗太大</p>

<h2 id="toc_18">注意</h2>

<ol>
<li>KVC本质是运行时查找对象实例的方法或变量，因此可以利用其访问私有变量，因此可以利用这一点，修改系统组件的样式或属性</li>
<li>为避免KVC的硬编码，可以采用<code>NSStringFromSelector(@selector(METHODNAME))</code></li>
<li>可以用KVC来触发KVO，即使在对象没有set访问器方法的情况下，即直接时候使用kvc赋值给对象的实例变量而该变量没有set方法时</li>
</ol>

<p>参考资料: <a href="https://www.jianshu.com/p/1d39bc610a5b">KVC原理剖析</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[main函数之前发生了什么]]></title>
    <link href="https://acefish.github.io/15549543814877.html"/>
    <updated>2019-04-11T11:46:21+08:00</updated>
    <id>https://acefish.github.io/15549543814877.html</id>
    <content type="html"><![CDATA[
<p>学习自sunnyxx的<a href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></p>

<h2 id="toc_0">dyld</h2>

<h3 id="toc_1">动态链接库</h3>

<p>iOS中用到系统frameWork都是动态链接的</p>

<p>使用<code>otool</code>命令查看依赖的动态库</p>

<pre><code class="language-objectivec">otool -L TestMain

TestMain:
    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
    /System/Library/Frameworks/UIKit.framework/UIKit
    /System/Library/Frameworks/Foundation.framework/Foundation
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
    /usr/lib/libobjc.A.dylib    /usr/lib/libSystem.B.dylib 
</code></pre>

<p>除了我们添加或依赖的系统动态库，还有默认添加的lib:<code>libobjc</code>（objc和runtime需要依赖的库），<code>libSystem</code>包含了很多系统界别的lib,常用到的有：</p>

<ul>
<li>libdispatch(GCD)</li>
<li>libsystem_c(C语言库)</li>
<li>libsystem_blocks(Block)</li>
<li>libcommonCrypto(加密库，比如常用的md5函数)</li>
</ul>

<p>这些库都是<code>dylib</code>格式</p>

<h3 id="toc_2">dyld(the dynamic link editor)</h3>

<p>Apple的动态链接器，系统kernel做好启动程序的准备后由dyld负责,dyld作用顺序概括:</p>

<ol>
<li>从kernel留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li>
<li>non-lazy符号立即link到可执行文件，lazy的存到表里</li>
<li>为可执行文件执行静态初始化</li>
<li>找到可执行文件的main函数，准备参数并调用</li>
<li>程序执行中 绑定lazy符号、提供runtime动态加载、提供调试器的接口</li>
<li>程序main函数return后执行static terminator</li>
<li>某些场景下 main函数结束后调用libSystem的__exit函数</li>
</ol>

<p>dyld是开源的，<a href="https://github.com/opensource-apple/dyld">源码github地址</a></p>

<p>在项目源码中有<code>dyldStartup.s</code>这个汇编文件，实现了<code>__dyld_start</code>,其主要实现了:</p>

<ol>
<li>调用dyldbootstrap::start()方法</li>
<li>上个方法返回了main函数地址，填入参数并调用main函数</li>
</ol>

<p><img src="media/15549543814877/15549648909838.jpg" alt="" style="width:350px;"/></p>

<p>栈底的dyldbootstrap::start()方法，继而调用了dyld::_main()方法，其中完成了刚才说的递归加载动态库过程，由于libSystem默认引入，栈中出现了libSystem_initializer、libdispatch_init、_objc_init等的初始化方法。</p>

<h2 id="toc_3">ImageLoader</h2>

<p>image指二进制文件，里面是各种符号和代码等，因此ImageLoader是将这些文件加入内存</p>

<h2 id="toc_4">runtime与load</h2>

<p><code>libSystem</code>是是若干系统lib的集合容器，里面就一个<code>init.c</code>文件，因此调用<code>libSystem_initializer</code>会逐步调用到<code>_objc_init</code>，这个就是objc和runtime<br/>
的初始化入口</p>

<p>这里除了初始化runtime环境外，_objc_init绑定了新image被加载后的<code>callback</code>：</p>

<pre><code class="language-objectivec">dyld_register_image_state_change_handler(
dyld_image_state_bound, 1, &amp;map_images);
dyld_register_image_state_change_handler(
dyld_image_state_dependents_initialized, 0, &amp;load_images);
</code></pre>

<p>当新的image被加载进来之后由<code>runtime</code>去解析这个二进制文件的符号表和代码</p>

<p><img src="media/15549543814877/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-11%2014.28.40.png" alt=" 屏幕快照 2019-04-11 14.28.40" style="width:300px;"/></p>

<p>整个调用顺序:</p>

<ol>
<li>dyld将整个应用程序二进制文件初始化</li>
<li>由ImageLoader读取image，其中包括了代码、类和方法各种符号</li>
<li>因为runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime处理</li>
<li>runtime调用回调函数<code>map_image</code>做解析处理，之后<code>load_images</code>调用<code>call_load_methods</code>方法，遍历所有加载的class，然后按照继承和层架关系调用Class和其Category的<code>+load()</code>方法</li>
</ol>

<h3 id="toc_5">load方法收集</h3>

<p>在<code>loadImage</code>后 会调用<code>prepare_load_methods</code>方法来获取所有类的列表，并且收集其中load方法。这个方法中会调用<code>schedule_class_load</code>遍历类递归至根节点来收集完成的关系树，并执行<code>add_class_to_loadable_list</code>将其加入执行列表， 然后调用<code>call_load_methods</code>方法，其会创建一个<code>autoreleasePool</code>使用函数指针来动态调用类和<code>Category</code>的<code>+load</code>方法</p>

<p>此时，可执行文件中和动态库所有符号<code>Class、Protocol、Selector、IMP...</code>等都已经按照格式加载到内存，并被runtime管理，这样之后，<code>runtime</code>运行时机制和那些方法（动态添加class、swizzle等）才能生效</p>

<h2 id="toc_6">真正的main函数</h2>

<p>当前面的这些操作结束，dyld会清理现场，将调用栈回归，调用真正的main函数</p>

<p><img src="media/15549543814877/15549695741385.jpg" alt="" style="width:300px;"/></p>

<h2 id="toc_7">补充</h2>

<p>此处只提及了runtime这个分支的初始化以及所做的事情，真正流程比这个复杂的多，还有类似<code>GCD</code><code>XPC</code>等系统库分支</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIApplicationMain]]></title>
    <link href="https://acefish.github.io/15547885598364.html"/>
    <updated>2019-04-09T13:42:39+08:00</updated>
    <id>https://acefish.github.io/15547885598364.html</id>
    <content type="html"><![CDATA[
<p>创建一个应用程序对象和代理，并且设置事件循环(包括应用的runloop)</p>

<pre><code class="language-objectivec">int UIApplicationMain(int argc, char * _Nullable *argv, NSString *principalClassName, NSString *delegateClassName);
//argc: argv参数的个数
//argv: 提供给main函数的参数
//principalClassName: 设置UIApplicaion类或其子类的名字，可以为nil即默认为UIApplication
//delegateClassName: 设置代理，假如从应用的main nib file加载可以该参数传空
</code></pre>

<blockquote>
<p>If the application’s Info.plist file specifies a main nib file to be loaded, by including the NSMainNibFile key and a valid nib file name for the value, this function loads that nib file.</p>
</blockquote>

]]></content>
  </entry>
  
</feed>
