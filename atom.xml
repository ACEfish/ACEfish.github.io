<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish的博客]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2017-06-17T09:13:57+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[集合类型]]></title>
    <link href="https://acefish.github.io/14978615246204.html"/>
    <updated>2017-06-19T16:38:44+08:00</updated>
    <id>https://acefish.github.io/14978615246204.html</id>
    <content type="html"><![CDATA[
<p><code>Swift</code>语言提供<code>Arrays</code>(有序数据集)、<code>Sets</code>(无序不重复数据集)和<code>Dictionaries</code>(无序键值对)三种基本的集合类型用来存储集合数据</p>

<p><code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确<br/>
Swift 的Arrays、Sets和Dictionaries类型被实现为<code>泛型集合</code>。</p>

<h2 id="toc_0">集合可变性</h2>

<p>当集合为变量，集合是可变的,当不需要集合改变时建议创建为不可变的,有利于优化</p>

<h2 id="toc_1">数组</h2>

<p>存储同一类型值,可以重复</p>

<h3 id="toc_2">创建空数组</h3>

<pre><code class="language-swift">var someInts = [Int]()//创建空数组
通过构造函数的类型，数组可以推断为[Int]
//创建特定数据类型的空数组
</code></pre>

<pre><code class="language-swift">someInts.append(3)
//可以从上面推断出数组为Int类型,因此可以直接创建空数组
someInts = []
//直接创建空数组
</code></pre>

<h3 id="toc_3">带有默认值的数组</h3>

<p>创建特定大小并且所有数据都被默认构造数组方法</p>

<pre><code class="language-swift">var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]
</code></pre>

<h3 id="toc_4">通过两个数组相加创建一个数组</h3>

<p>可以用<code>+</code>将两种相同数据类型数组组合为一个新的数组,新的数组类型与这两个数组类型相同</p>

<h3 id="toc_5">用数组字面量构造数组</h3>

<p>用数组字面量来进行数组构造,这是用一个或者多个数值构造数组</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编码]]></title>
    <link href="https://acefish.github.io/14976139025239.html"/>
    <updated>2017-06-16T19:51:42+08:00</updated>
    <id>https://acefish.github.io/14976139025239.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">unicode码</h2>

<p>unicode码表示 <code>U+F8FF</code> 可以用 <code>\uF8FF</code>即为unicode编码 F8FF即为这个字符的16进制表示</p>

<p>多个字符的unicode码可以组合为一个新的字符 例如<code>\ud83c\udf49</code>可以组合为<code>🍉</code>,一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<p>补充:<br/>
注意:<br/>
 <code>Swift</code>与<code>OC</code>不同，swift中将每个字符都看作可扩展的字形群,因此对于é(&quot;\u{65}\u{301}&quot;)看作一个字符,而对于OC这是两个字符,而对两者说字符串长度就是字符的数量</p>

<blockquote>
<p>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式<br/>
可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数<br/>
量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一<br/>
个长字符串，需要注意<code>characters</code>属性必须遍历全部的<code>Unicode</code>标量，来确定字符串的字符数量。<br/>
另外需要注意的是<strong>通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的 <code>length</code>属性相同</strong>。 <strong>NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集</strong>。作为佐证，当一个 NSString的length属性被一个Swift的String值访问时，实际上是调用了<code>utf16Count</code></p>
</blockquote>

<h2 id="toc_1">获取字符串中字符的unicode码</h2>

<pre><code class="language-objc">//其16进制就是字符‘的’的unicode码
unichar character = [@“的” characterAtIndex:0];
</code></pre>

<p>对于上面说的🍉这种多个unicode码组合字符 其index0位置为d83c index1位置为df49 由两个字符组成</p>

<blockquote>
<p>iOS开发中用<code>unichar</code>是两字节长的<code>char</code>，代表<code>unicode</code>的一个字符</p>
</blockquote>

<pre><code class="language-objc">//将unicode码转为字符
NSLog(@&quot;%@&quot;,[NSString stringWithCharacters:&amp;character length:1]);
</code></pre>

<p>补充:<br/>
与<code>char</code>的初始化相同 unichar a = &#39;2&#39;可以用单引号初始化unichar<br/>
不论char还是iOS开发中用的unichar 只能用上面的初始化方法初始化字符为ascii码</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串和字符]]></title>
    <link href="https://acefish.github.io/14976096897839.html"/>
    <updated>2017-06-16T18:41:29+08:00</updated>
    <id>https://acefish.github.io/14976096897839.html</id>
    <content type="html"><![CDATA[
<p>字符串是字符的集合,用<code>string</code>类型表示. 一个<code>String</code>的内容可以用许多方式读取，包括作为一个<code>Character</code>值的集合</p>

<p><code>Swift</code>的<code>String</code>和<code>Character</code>类型提供了快速和兼容<code>Unicode</code>的方式供代码使用。<br/>
String 类型是一种快速、现代化的字符串实现。 每一个字符串都是由编码无关的<code>Unicode</code>字<br/>
符组成，并支持访问字符的多种<code>Unicode</code>表示形式</p>

<h2 id="toc_0">字符串字面量</h2>

<pre><code class="language-swift">//someString 常量通过字符串字面量进行初始化
let someString = &quot;Some string literal value&quot;
</code></pre>

<h2 id="toc_1">初始化空字符串</h2>

<pre><code class="language-swift">var emptyString = &quot;&quot; // 空字符串字面量
var anotherEmptyString = String() // 初始化方法


if emptyString.isEmpty {
print(&quot;Nothing to see here&quot;)
}
// 打印输出：&quot;Nothing to see here&quot;
</code></pre>

<h2 id="toc_2">字符串可变性</h2>

<pre><code class="language-swift">//通过指定为变量使其可修改
var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;
// variableString 现在为 &quot;Horse and carriage&quot;
</code></pre>

<p>与OC中的<code>NSString</code>和<code>NSMutableSting</code>确定是否可更改不同,<code>Swift</code>中类似其他值取决于其被定义为常量还是变量</p>

<h2 id="toc_3">字符串是值类型</h2>

<p><strong><code>Swift</code>的<code>String</code>类型是值类型</strong>。如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。<strong>任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作</strong>。这样保证了在函数/方法中传递的是字符串的值。 </p>

<blockquote>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
</blockquote>

<p>注意:<code>Swift</code>的<code>String</code>是值类型而<code>NSString</code>是引用类型,<code>NSString</code>的意思是初始化了一个指针指向了这个字符串，但Swift <code>String</code>的意思则是把字符串字面量赋值给变量</p>

<h2 id="toc_4">使用字符</h2>

<p>可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code> 属性来获取每一个字符的值</p>

<pre><code class="language-swift">for character in &quot;Dog!?&quot;.characters {
    print(character)
}
// 
</code></pre>

<pre><code class="language-swift">//声明一个Character类型
let exclamationMark: Character = &quot;!&quot;

//用character类型数组初始化字符串
let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]
let catString = String(catCharacters)
print(catString)

</code></pre>

<h2 id="toc_5">连接字符串和字符</h2>

<p>字符串可以通过加法相加在一起<br/>
可以通过<code>+=</code>运算符将一个字符串添加到一个已经存在字符串变量上</p>

<pre><code class="language-swift">let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2

var instruction = &quot;look over&quot;
instruction += string2
</code></pre>

<p>可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部</p>

<pre><code class="language-swift">//初始化字符也是用双引号
let exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
// welcome 现在等于 &quot;hello there!&quot;
</code></pre>

<blockquote>
<p>初始化字符也是用双引号与c中使用单引号不同</p>
</blockquote>

<h2 id="toc_6">字符串插值</h2>

<p>可以用以反斜线为前缀的圆括号将常量、变量或表达式插入字符串中</p>

<pre><code class="language-swift">let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
// message 是 &quot;3 times 2.5 is 7.5&quot;
</code></pre>

<blockquote>
<p>插值字符串中写在括号中的表达式不能包含非转义反斜杠 ()，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>

<h2 id="toc_7">Unicode</h2>

<p>Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p>

<h3 id="toc_8">Unicode标量</h3>

<p><code>Unicode</code>标量是对应字符或者修饰符的唯一的21位数字</p>

<blockquote>
<p>Unicode 码位(code poing) 的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF<br/>
Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位，其码位范围是 U+D800 到 U+DFFF 。<br/>
不是所有的21位<code>Unicode</code>标量都代表一个字符，因为有一些标量是留作未来分配的。</p>
</blockquote>

<h3 id="toc_9">字符串字面量的特殊字符</h3>

<p>特殊字符</p>

<ul>
<li>转义字符 <code>\0</code> (空字符)、 <code>\\</code>(反斜线)、 <code>\t</code> (水平制表符)、 <code>\n</code> (换行符)、 <code>\r</code>(回车符)、 <code>\&quot;</code> (双引号)、 <code>\&#39;</code> (单引号)</li>
<li><code>Unicode</code>标量，写成<code>\u{n}</code>(u为小写)，其中n为任意一到八位十六进制数且可用的<code>Unicode</code>位码。</li>
</ul>

<pre><code class="language-swift">let char: Character = &quot;\u{24}&quot;// $, Unicode 标量 U+0024
let blackHeart = &quot;\u{2665}&quot; // ?, Unicode 标量 U+2665
</code></pre>

<h3 id="toc_10">可扩展的字形群集</h3>

<p>每一个<code>Swift</code>的<code>Character</code>类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<pre><code class="language-swift">/*
    字母 é 可以用单一的 Unicode 标量 é (U+00E9)来表示
    一个标准的字母e(U+0065)加上一个急促重音的标量(U+0301)，这样一对标量就表示了同样的字母é 
*/
let eAcute: Character = &quot;\u{E9}&quot; // é
let combinedEAcute: Character = &quot;\u{65}\u{301}&quot; // e 后面加上 ?
// eAcute 是 é, combinedEAcute 是 é
</code></pre>

<p>因此我们可以用很多复杂的脚本字符来表示单一的Character值</p>

<p>例如</p>

<pre><code class="language-swift">/*
    可拓展的字符群集可以使包围记号的标量包围其他Unicode标量，作为一个单一的Character值
*/
let enclosedEAcute: Character = &quot;\u{20DD}&quot;//&quot;⃝&quot;
let enclosedEAcute11: Character = &quot;\u{E9}\u{20DD}&quot;//é⃝
</code></pre>

<h2 id="toc_11">计算字符数量</h2>

<p>使用字符串的<code>characters</code>属性的<code>count</code>属性获取字符数量</p>

<p>注意:<br/>
我们在使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时不一定会改变字符数量</p>

<pre><code class="language-swift">var word = &quot;cafe&quot;//这时候字符数量是4
word += &quot;\u{301}&quot; //这时候字符数量还是4 因为e和新增的字符组合为é

let eAcute = &quot;\u{00E9}&quot; // é
eAcute.characters.count //字符数量为1
let combinedEAcute = &quot;\u{65}\u{301}&quot; //
combinedEAcute.characters.count //字符数量为1

</code></pre>

<p>注意:<br/>
 <code>Swift</code>与<code>OC</code>不同，swift中将每个字符都看作可扩展的字形群,因此对于é(&quot;\u{65}\u{301}&quot;)看作一个字符,而对于OC这是两个字符,而对两者说字符串长度就是字符的数量</p>

<blockquote>
<p>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式<br/>
可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数<br/>
量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一<br/>
个长字符串，需要注意<code>characters</code>属性必须遍历全部的<code>Unicode</code>标量，来确定字符串的字符数量。<br/>
另外需要注意的是<strong>通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的 <code>length</code>属性相同</strong>。 <strong>NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集</strong>。作为佐证，当一个 NSString 的 length 属性被一个Swift的 String 值访问时，实际上是调用了 <code>utf16Count</code></p>
</blockquote>

<h2 id="toc_12">访问和修改字符串</h2>

<h3 id="toc_13">字符串索引</h3>

<p><code>String.Index</code>对应着字符串中的每一个<code>Character</code>的位置，因此这个index相相当于是字符串中字符的索引</p>

<p>因为字符串中每个<code>Character</code>是可扩展的字符群集,所以想要知道每个字符的位置就必须将String便利一边才能确定</p>

<blockquote>
<p>这个index不一定是连续的</p>
</blockquote>

<pre><code class="language-swfit">let combinedEAcute = &quot;🍉&quot;
combinedEAcute.characters.count //1
combinedEAcute.startIndex //0
combinedEAcute.endIndex//2
let indx = combinedEAcute.index(after: combinedEAcute.startIndex)//2
</code></pre>

<p><code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引<br/>
<code>endIndex</code>属性可以可以获取<strong>最后一个<code>Character</code>的后一个位置的索引。</strong>因此<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的</p>

<p>可以使用<code>String</code>的<code>index(before:)</code>或<code>index(after:)</code>来获取前一个或者后一个,或者用<code>index(:_offsetBy:)</code>取得对应偏移量的索引</p>

<p>获取对应下标索引的字符:</p>

<pre><code class="language-swift">let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex]// G
greeting[greeting.index(before: greeting.endIndex)]// !
//当越界是或引发运行时的错误(可以在编译时就检测出来)
</code></pre>

<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符</p>

<pre><code class="language-swift">for index in greeting.characters.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
// 打印输出 &quot;G u t e n T a g ! &quot;
</code></pre>

<blockquote>
<p>我们在上面在<code>String</code>中获取的index的方法,可以用于在任意一个确认的并遵循<code>Collection</code>协议的类型里面(例如Array、Dictionary、Set)</p>
</blockquote>

<h3 id="toc_14">插入和删除</h3>

<p>调用<code>insert(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符，调用<code>insert(contentsOf:at:)</code>方法可以在一个字符串的指定索引插入一个段字符串。</p>

<pre><code class="language-swift">//注意必须是变量
var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, at: welcome.endIndex)
// welcome 变量现在等于 &quot;hello!&quot;
welcome.insert(contentsOf:&quot; there&quot;.characters, at: welcome.index(before: welcome.endIndex))
// welcome 变量现在等于 &quot;hello there!&quot;
</code></pre>

<p>调用<code>remove(at:)</code>方法可以在一个字符串的指定索引删除一个字符，调用<code>removeSubrange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>

<pre><code class="language-swift">welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 &quot;hello there&quot;
let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex
welcome.removeSubrange(range)
// welcome 现在等于 &quot;hello&quot;
</code></pre>

<blockquote>
<p><code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code>和<code>removeSubrange(_:)</code>方法在任意一个确认的并遵循<code>RangeReplaceableCollection</code>协议的类型里面，如上文所示是使用在 <code>String</code>中，您也可以使用在<code>Array</code>、<code>Dictionary</code>和<code>Set</code>中。</p>
</blockquote>

<h2 id="toc_15">比较字符串</h2>

<h3 id="toc_16">字符串/字符相等</h3>

<p>直接用 <code>==</code> 和 <code>!=</code>进行比较</p>

<p>判断标准等于的标准是:当有同样的语义和外观,就被认为是相等的,即使他们的可扩展字形群集可能由不同的<code>Unicode</code>标量构成</p>

<p>例如:<br/>
((U+00E9)标准等于((U+0065)(U+0301))) (都是<code>é</code>表示的有效方式)<br/>
U+0041(英语中的A)不等于U+0410(俄语中的A)尽管外观看着一样</p>

<h3 id="toc_17">前缀/后缀</h3>

<p>通过字符串的<code>hasPrefix(_:) / hasSuffix(_:)</code>方法来检查字符串是否用于特定前缀/后缀</p>

<h2 id="toc_18">字符串的Unicode表示</h2>

<p>当<code>Unicode</code>字符串写进文本文件或者其他存储时，<code>Unicode</code>会用几种<code>编码格式</code>编码(如：UTF-8 UTF-16 UTF-32) 每一个字符串中的小块编码都被称<code>代码单元</code></p>

<p>除了前面说过的用<code>for-in</code>对字符串遍历,然后访问每个<code>character</code>值的方式外:<br/>
其他三种<code>Unicode</code>兼容方式访问字符串</p>

<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的Unicode标量值集合，也就是字符串的UTF-32编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>

<p>let dogString = &quot;Dog‼🐶&quot;(其中“!!”为U+203C 🐶为U+1F436)</p>

<h4 id="toc_19">UTF-8表示</h4>

<p>通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示， 其为<code>String.UTF8View</code>类型的属性， <code>UTF8View</code>是无符号8位(UInt8)值的集合，每一个UInt8值都是一个字符的UTF-8表示</p>

<pre><code class="language-swift">for codeUnit in dogString.utf8 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)// 68 111 103 226 128 188 240 159 144 182
/*
前三个10进制 codeUnit 值 ( 68 , 111 , 103 ) 代表了字符 D 、 o 和 g ，它们的 UTF-8 表示与
ASCII 表示相同。 接下来的三个10进制 codeUnit 值 ( 226 , 128 , 188 ) 是 DOUBLE 
EXCLAMATION MARK 的3字节 UTF-8 表示。 最后的四个 codeUnit 值 ( 240 , 159 , 144 , 182 ) 
是 DOG FACE 的4字节UTF-8 表示。
*/
</code></pre>

<blockquote>
</blockquote>

<h4 id="toc_20">UTF-16表示</h4>

<p>与utf-8类似,访问其utf-16属性,是<code>String.UTF16View</code>类型(<code>UInt16</code>值集合)</p>

<pre><code class="language-swift">for codeUnit in dogString.utf16 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 55357 56374
</code></pre>

<h4 id="toc_21">Unicode标量表示</h4>

<p>通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的<code>Unicode</code>标量表示。为<code>UnicodeScalarView</code>类型的属性(<code>UnicodeScalar</code>类型的值的集合)。<br/>
<code>UnicodeScalar</code>是21位的<code>Unicode</code>代码点,拥有一个<code>value</code>属性，可以返回对应的21位数值，用 UInt32 来表示：</p>

<pre><code class="language-swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 128054
</code></pre>

<blockquote>
<p>我们平常代码中的Unicode编码就是这种21位<br/>
UTF-32也是编码一样为21位，因此swift中的有了unicodeScalars属性也就没有utf32属性</p>
</blockquote>

<p>每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值</p>

<pre><code class="language-Swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar) &quot;, terminator: &quot;&quot;)
}
// D o g !! 🐶
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 基本运算符]]></title>
    <link href="https://acefish.github.io/14974389141976.html"/>
    <updated>2017-06-14T19:15:14+08:00</updated>
    <id>https://acefish.github.io/14974389141976.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">赋值运算符</h2>

<pre><code class="language-swift">//赋值符可以赋值元组
let (x, y) = (1, 2)
// 现在 x 等于 1，y 等于 2
</code></pre>

<p>注意点:<br/>
与OC不同，赋值符不返回值,防止把想要判断相等运算符（ == ）的地方写成赋值符导致的错误</p>

<h2 id="toc_1">算术运算符</h2>

<pre><code class="language-swift">//加法运算符也可用于 String 的拼接
&quot;hello, &quot; + &quot;world&quot; // 等于 &quot;hello, world&quot;
</code></pre>

<p>注意:<br/>
与<code>OC</code>不同,<code>Swift</code>默认情况下不允许在数值运算中出现溢出情况.(可以使用<code>Swift</code>提供的溢出运算符实现溢出运算)</p>

<h2 id="toc_2">求余运算</h2>

<p>求余运算(<code>%</code>)在其他语言也叫取模运算</p>

<h3 id="toc_3">一元负号/正号运算符</h3>

<p>一元负/正号符（ -/+ ）写在操作数之前，中间没有空格。<br/>
负号或者正号可以抵消</p>

<h2 id="toc_4">组合赋值运算符</h2>

<p>例如:<br/>
<code>a += 2</code> //这组合赋值运算符也是没有返回值的（和赋值运算符一样）</p>

<h2 id="toc_5">比较运算符</h2>

<p>和OC中是相同的,返回一个表达式是否成立的布尔值</p>

<blockquote>
<p><code>Swift</code> 也提供恒等（<code>===</code>）和不恒等（<code>!==</code>）这两个比较符来判断两个对象是否引用同一个对象实例</p>
</blockquote>

<p>注意:</p>

<p><strong>元组的比较方法:</strong><br/>
当元组中的值可以比较时，你也可以使用这些运算符来比较它们的大小。例如，因为<code>Int</code>和<code>String</code>类型的值可以比较，所以类型为<code>(Int, String)</code>的元组也可以被比较。相反，<code>Bool</code> 不能被比较，也意味着存有布尔类型的元组不能被比较</p>

<p>比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的</p>

<pre><code class="language-swift">//当比较到1小于2就判断为ture 不会再比较下去
(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true，因为 1 小于 2
(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;) // true，因为 3 等于 3，但是 apple 小于 bird
(4, &quot;dog&quot;) == (4, &quot;dog&quot;) // true，因为 4 等于 4，dog 等于 dog
</code></pre>

<blockquote>
<p>Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。</p>
</blockquote>

<h2 id="toc_6">三目运算</h2>

<h2 id="toc_7">空合运算符</h2>

<p>空合运算符<code>（a ?? b）</code>将对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>。表达式<code>a</code>必须是<code>Optional</code>类型。默认值<code>b</code>的类型必须要和<code>a</code>存储值的类型保持一致。</p>

<p>空合运算符有<code>a != nil ? a! : b</code>相当于这种表达</p>

<p>注意:<br/>
空合运算符也采用了短路求值,即当a为非空时,那么就不会再去计算b的值</p>

<h2 id="toc_8">区间运算符</h2>

<h3 id="toc_9">闭区间运算符</h3>

<p><code>a...b</code>定义一个包含从a到b(包括a和b)</p>

<pre><code class="language-swift">for index in 1...5 {
    print(&quot;\(index) * 5 = \(index * 5)&quot;)
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
</code></pre>

<h3 id="toc_10">半开区间运算符</h3>

<p><code>a..&lt;b</code>定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间</p>

<h2 id="toc_11">逻辑运算符</h2>

<p>与<code>&amp;&amp;</code> 或<code>||</code> 非<code>!</code></p>

<blockquote>
<p>与或非运算也是使用短路计算的</p>
</blockquote>

<p>注意:<br/>
<code>Swift</code>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是左结合的，即从左向右读,优先计算左边,建议加上括号来增加代码可读性</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见名词]]></title>
    <link href="https://acefish.github.io/14974079542932.html"/>
    <updated>2017-06-14T10:39:14+08:00</updated>
    <id>https://acefish.github.io/14974079542932.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">M2M</h3>

<p>M2M ：M2M是将数据从一台终端传送到另一台终端，也就是机器与机器（Machine to Machine）的对话</p>

<h3 id="toc_1">QoS</h3>

<p>QoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block实现原理]]></title>
    <link href="https://acefish.github.io/14972592855571.html"/>
    <updated>2017-06-12T17:21:25+08:00</updated>
    <id>https://acefish.github.io/14972592855571.html</id>
    <content type="html"><![CDATA[
<p>原文地址<a href="http://blog.ibireme.com/2013/11/27/objc-block/">objc 中的 block</a></p>

<h2 id="toc_0">block中的数据结构</h2>

<p><code>block</code>的定义:</p>

<pre><code class="language-objc">struct Block_descriptor_1 {
    uintptr_t reserved;
    uintptr_t size;
};
 
struct Block_layout {
    void *isa;
    volatile int32_t flags; // contains ref count
    int32_t reserved; 
    void (*invoke)(void *, ...);
    struct Block_descriptor_1 *descriptor;
    // imported variables
};
</code></pre>

<p>在oc中，凡是首地址是<code>*isa</code>的结构体指针，都可以认为是对象.这样在<code>objc</code>中，<code>block</code>实际上就算是对象。</p>

<pre><code class="language-objc">void foo_(){
    int i = 2;
    NSNumber *num = @3;
 
    long (^myBlock)(void) = ^long() {
        return i * num.intValue;
    };
 
    long r = myBlock();
}
//我们对上面的block的简单使用转换为c形式
//通用的block数据结构
struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};
//通用的block数据结构描述
struct __foo_block_desc_0 {
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);
    void (*dispose)(struct __foo_block_impl_0*);
};
 
//myBlock的数据结构定义
struct __foo_block_impl_0 {
    struct __block_impl impl;//包含通用数据结构定义
    struct __foo_block_desc_0* Desc;//对本block的结构描述指针
    int i;  //捕获的变量
    NSNumber *num;  //捕获的变量
};
 
//block数据的描述
static struct __foo_block_desc_0 __foo_block_desc_0_DATA = {
    0,
    sizeof(struct __foo_block_impl_0), //本block的占的自己空间大小（便分配空间）
    __foo_block_copy_0,
    __foo_block_dispose_0 //通用数据结构描述
};
 
//block中的方法
static long __foo_block_func_0(struct __foo_block_impl_0 *__cself) {//这个函数引用这个block的数据结构
    int i = __cself-&gt;i; // bound by copy
    NSNumber *num = __cself-&gt;num; // bound by copy
 
    return i * num.intValue;
}
 
void foo(){
    int i = 2;
    NSNumber *num = @3;
 
    struct __foo_block_impl_0 myBlockT;
    struct __foo_block_impl_0 *myBlock = &amp;myBlockT;
    myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;
    myBlock-&gt;impl.Flags = 570425344;
    myBlock-&gt;impl.FuncPtr = __foo_block_func_0;
    myBlock-&gt;Desc = &amp;__foo_block_desc_0_DATA;
    myBlock-&gt;i = i;
    myBlock-&gt;num = num;
 
    long r = myBlock-&gt;impl.FuncPtr(myBlock);
}

</code></pre>

<p>创建<code>block</code>就是创建了一个结构体,用<code>block捕获的变量</code>来初始化结构体体中数据,block内部的代码提取为block结构体中的c函数,这个c函数参数为一个指向本block的指针,执行时将这个struct指针传过去,通过这个指针获取block捕获的变量进行c函数的计算</p>

<p><code>block</code>中包含了被引用的自由变量(由struct持有)，也包含了控制成分的代码块(由函数指针持有)符合闭包(<code>closure</code>)的概念。</p>

<h2 id="toc_1">block的copy</h2>

<p><code>block</code>中的<code>isa</code>指向的是该<code>block</code>的<code>Class</code>.这些Class都有:</p>

<ul>
<li>_NSConcreteStackBlock ---- 栈上创建的block</li>
<li>_NSConcreteMallocBlock ---- 堆上创建的block</li>
<li>_NSConcreteGlobalBlock ---- 作为全局变量的block</li>
<li>_NSConcreteWeakBlockVariable ---- 用于GC不再讨论</li>
<li>_NSConcreteAutoBlock ---- 用于GC不再讨论</li>
<li>_NSConcreteFinalizingBlock ---- 用于GC不再讨论</li>
</ul>

<p>1.全局block<br/>
全局block是当一个block内部没有捕获任何外部变量时，就会是一个全局block类型。此时，这个block与一个函数无异。所以，那么它就应该有和函数一样的静态特性。而且，我们在调用block的时候，其实和普通C函数的调用很相似，都是名称加括号：block()。 全局block的地址是在全局变量常量区的</p>

<p><strong>当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。</strong></p>

<p>函数返回时，函数的栈帧被销毁，这个<code>block</code>的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用<code>Block_copy()</code>方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送<code>retain</code>，增加<code>block</code>的引用计数。</p>

<h2 id="toc_2">__block类型变量</h2>

<p>默认捕获到的对象直接赋值给<code>block</code>结构体，不能修改,那么当我们给其加上<code>__block</code>修饰时,原本的捕获的int值位置变为一个<code>struct</code>，这个struct首地址也为<code>*isa</code>.</p>

<p>因此，这个值才能被<code>block</code>共享、并且不受栈帧生命周期的限制、在<code>block</code>被<code>copy</code>后，能够随着<code>block</code>复制到堆上。</p>

<h2 id="toc_3">注意事项:</h2>

<p>1.静态存储区的变量：例如全局变量、方法中的static变量<br/>
<strong>引用，可修改</strong>。</p>

<p>2.block接受的参数<br/>
传值，可修改，和一般函数的参数相同。</p>

<p>3.栈变量 (被捕获的上下文变量)<br/>
const，不可修改。 当block被copy后，block会对 id类型的变量产生强引用。<br/>
每次执行block时,捕获到的变量都是最初的值。</p>

<p>4.栈变量 (有__block前缀)<br/>
引用，可以修改。如果时id类型则不会被<code>block retain</code>,必须手动处理其内存管理。<br/>
如果该类型是C类型变量，<code>block</code>被<code>copy</code>到<code>heap</code>后,该值也会被挪动到<code>heap</code></p>

<h2 id="toc_4">使用注意点:</h2>

<ol>
<li><p>内存方面</p>

<p><code>Block_copy()</code>和<code>Block_release()</code>必须一一匹配，否则会内存泄漏或crash。</p>

<p><code>__block</code>这个修饰词会将原本的简单类型转化为较大的<code>struct</code>，这会给内存、调用带来额外的开销，使用时需要注意。</p></li>
<li><p>ARC模式下的block使用<br/>
在ARC模式下我们 不用手动<code>copy/release</code>，<br/>
但是</p>

<pre><code class="language-objc">void (^aBlock)(void);//定义一个aBlock对象（__strong）
aBlock = ^{ printf(&quot;ok&quot;); };
//只要一个block被赋值给一个strong变量，会自动copy
//strong变量就是一个强引用指针  copy到堆后将对地址赋值给这个指针 对象引用着这个block
</code></pre>

<p>block是对象，所以这个aBlock默认是有__strong修饰符的，即<code>aBlock</code>对该block有<code>strong <br/>
references</code>。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的<br/>
block基本都是在堆上的。</p>

<pre><code class="language-objc">//对于这个例子
void (^aBlock)(void) = nil; 
if (!aBlock) {
    aBlock = ^{ printf(&quot;hehe&quot;); };
}
//block此时block已经被释放,该处留下了一个`dangling pointer`
aBlock();
</code></pre>

<p>这种情况 苹果建议尽量避免这种情况。</p></li>
<li><p>block易引起的循环引用问题</p>

<p>当block被copy之后(如开启了ARC、或把block放入dispatch queue)，该block对它捕获的对象产生<br/>
strong references (非ARC下是retain),所以有时需要避免block copy后产生的循环引用。</p>

<p>如果用self引用了block，block又捕获了self，这样就会有循环引用。因此，需要用weak来声明self</p>

<pre><code class="language-objc">    - (void)configureBlock {
    XYZBlockKeeper * __weak weakSelf = self;
    self.block = ^{
    [weakSelf doSomething]; //捕获到的是弱引用
    }
    }
    //当前前对象的成员变量对象，同样也会造成对self的引用
    - (void)configureBlock {
    id tmpIvar = _ivar; //临时变量,避免了self引用
    self.block = ^{
    [tmpIvar msg];
    }
    }
</code></pre>

<p>为了避免循环引用，可以这样理解<code>block</code>：<code>block</code>就是一个对象，它捕获到的值就是这个对象的<code>@property(strong)</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三方登录分享]]></title>
    <link href="https://acefish.github.io/14972581397752.html"/>
    <updated>2017-06-12T17:02:19+08:00</updated>
    <id>https://acefish.github.io/14972581397752.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">shareSdk使用</h2>

<p><a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">集成步骤</a><br/>
对于<code>shareSDK</code>中初始化第三方应用平台,我们可以通过<code>ShareSDK registerApp:@&quot;iosv1101&quot; activePlatforms:</code>方法中传入各个平台的appkey等信息进行初始化,或者添加各个平台的<code>URL type</code>然后简单的用<code>share SDK</code>中<code>connect</code>方法进行初始化</p>

<p>注意：<br/>
1. 在<code>shareSDK.xml</code>文件中传入各个平台的<code>key</code>和<code>serect</code><br/>
2. 现在需要在<code>plist</code>文件添加第三方应用白名单才可以打开第三方应用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURL]]></title>
    <link href="https://acefish.github.io/14968918049808.html"/>
    <updated>2017-06-08T11:16:44+08:00</updated>
    <id>https://acefish.github.io/14968918049808.html</id>
    <content type="html"><![CDATA[
<p>URL(统一资源定位符) 是一种 URI，URN(统一资源名称) 也是一种 URI，所以 URI (统一资源标志符)可被视为定位符，名称或两者兼备</p>

<h2 id="toc_0">URL Encode</h2>

<p><a href="http://www.jianshu.com/p/38f5f53dfbad">[iOS-Foundation] NSURL</a><br/>
<code>URL</code>采用<code>ASCII</code>编码格式，所以不支持如中文等非<code>ASCII</code>码字符，另外<code>URL</code>中保留的分隔符号(?、&amp;、=等)也无法作为内容，否则会引起歧义。<br/>
这就需要通过编码，用安全的字符来表示这些不符合要求的字符，格式是%加两位安全字符，所以 URL 编码也称为百分号编码。</p>

<pre><code class="language-objc">//Encode编码
NSString *urlString = @&quot;?&quot;;
NSString *encodedString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLHostAllowedCharacterSet]];
//encodedString值为 %3F
//替换不符合要求UTF-8编码为百分号编码字符
@interface NSCharacterSet (NSURLUtilities)
+ (NSCharacterSet *)URLUserAllowedCharacterSet;
+ (NSCharacterSet *)URLPasswordAllowedCharacterSet;
+ (NSCharacterSet *)URLHostAllowedCharacterSet;
+ (NSCharacterSet *)URLPathAllowedCharacterSet;
+ (NSCharacterSet *)URLQueryAllowedCharacterSet;
+ (NSCharacterSet *)URLFragmentAllowedCharacterSet;
@end
</code></pre>

<pre><code class="language-objc">//Unencode解码
+ (NSString *)decodeURLString:(NSString *)URLString {
    // 有时从服务端获取的 URL 中，空格被编码为+, 
    // 而方法- stringByRemovingPercentEncoding只替换百分号编码，
    // 所以要在执行该方法前，先将`+`替换掉(真正的加号字符是被百分号编码的)
    NSString *result = [URLString stringByReplacingOccurrencesOfString:@&quot;+&quot; withString:@&quot; &quot;];
    //替换所有百分号编码为UTF-8编码字符
    result = [result stringByRemovingPercentEncoding];
    return result;
}
</code></pre>

<h2 id="toc_1">NSURL</h2>

<p><a href="https://developer.apple.com/documentation/foundation/nsurl?preferredLanguage=occ">NSURL苹果官方文档</a></p>

<p>我们通过<code>NSURL</code>对象来构建一个资源定位符。对于本地文件的资源定位符,我们可以直接操作这些问价你的属性（比如修改文件的的最后修改日期）,对于远程资源我们可以将<code>NSURL</code>对象传递给其他API来获取内容,<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">Next About the URL Loading System</a></p>

<p><code>URL</code>对象是指向本地文件的首选方案,大多数进行文件数据读写对象都接受一个<code>NSURL</code>对象而不是一个文件路径.例如：可以用文件<code>NSURL</code>获取<code>NSString</code>  <code>initWithContentsOfURL:encoding:error:</code>,获取<code>data</code>  <code>initWithContentsOfURL:options:error:</code></p>

<p>你也可以用url资源定位符进行需要的操作,例如在<code>macOS</code>的<code>NSWorkspace</code>类和<code>iOS</code>的<code>UIApplication</code>类提供的<code>OpenURL:</code>方法来打开一个指定的URL位置</p>

<p>此外,我们可以通过使用粘贴板来对<code>NSURL</code>对象进行引用（AppKit框架的一部分）</p>

<p><code>NSURL</code>对应<code>Core Foundation</code>中的<a href="https://developer.apple.com/documentation/corefoundation/cfurlref?language=objc">CFURLRef</a>,我们可以查看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2">Toll-Free Bridging</a>来获取更多类似的与<code>Core Foundation</code>相对应的信息</p>

<p>补充：<br/>
Swift提供了<a href="https://developer.apple.com/documentation/foundation/url?language=objc">URL</a>结构，负责连接<code>NSURL</code>类，可以在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13"> Classes and Structures</a>中查看更多信息</p>

<h3 id="toc_2">URL结构</h3>

<p>一个<code>NSURL</code>对象由两部分组成:一部分是可能为<code>nil</code>的<code>base URL</code>和一部分与<code>base URL</code>有相对关系的字符串<code>relativeString</code>。如果一个<code>NSURL</code>对象没有<code>base</code>部分只有<code>string</code>部分那么它被认为是绝对地址,否则为相对的.</p>

<pre><code class="language-objc">//file:///path/to/user/ as the base URL and folder/file.html
/**
    我们指定 file:///path/to/user/ 为baseURL folder/file 为字符串部分
*/
NSURL *baseURL = [NSURL fileURLWithPath:@&quot;file:///path/to/user/&quot;];
NSURL *URL = [NSURL URLWithString:@&quot;folder/file.html&quot; relativeToURL:baseURL];
NSLog(@&quot;absoluteURL = %@&quot;, [URL absoluteURL]);//file:///path/to/user/ as the base URL and folder/file.html
/**
    这个URL的
    absoluteString:  file:///file:/path/to/folder/file.html
    baseURL:  file:///file:/path/to/user
    relativeString： folder/file.html
*/
</code></pre>

<p>对于一个<code>URL</code>我们可以将其分为很多部分,例如一个url如下：<br/>
<code>https://johnny:p4ssw0rd@www.example.com:443/script.ext;param=value?query=value#ref</code></p>

<table>
<thead>
<tr>
<th>Component</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>scheme</td>
<td>https</td>
</tr>
<tr>
<td>user</td>
<td>johnny</td>
</tr>
<tr>
<td>password</td>
<td>p4ssw0rd</td>
</tr>
<tr>
<td>host</td>
<td><a href="http://www.example.com">www.example.com</a></td>
</tr>
<tr>
<td>port</td>
<td>443</td>
</tr>
<tr>
<td>path</td>
<td>/script.ext</td>
</tr>
<tr>
<td>pathExtension</td>
<td>ext</td>
</tr>
<tr>
<td>pathComponents</td>
<td>[&quot;/&quot;, &quot;script.ext&quot;]</td>
</tr>
<tr>
<td>parameterString</td>
<td>param=value</td>
</tr>
<tr>
<td>query</td>
<td>query=value</td>
</tr>
<tr>
<td>fragment</td>
<td>ref</td>
</tr>
</tbody>
</table>

<p><code>NSURL</code>也提供了很多属性让我们来获取每部分</p>

<h3 id="toc_3">书签以及安全范围</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 基础部分]]></title>
    <link href="https://acefish.github.io/14968373667230.html"/>
    <updated>2017-06-07T20:09:26+08:00</updated>
    <id>https://acefish.github.io/14968373667230.html</id>
    <content type="html"><![CDATA[
<p>Swift 包含了C和Objective-C上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。 Swift 还提供了三个基本的集合类型<code>Array</code> ，<code>Set</code> 和<code>Dictionary</code><br/>
除了我们熟悉的类型，<code>Swift</code>还增加了<code>Objective-C</code>中没有的高阶数据类型比如元组（<code>Tuple</code>）。<br/>
<code>Swift</code>还增加了可选（Optional）类型，用于处理值缺失的情况。</p>

<p><code>Swift</code>是一门类型安全的语言，这意味着<code>Swift</code>可以让你清楚地知道值的类型。</p>

<h2 id="toc_0">常量和变量</h2>

<p>常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>

<h3 id="toc_1">声明常量和变量</h3>

<p>用<code>let</code>来声明常量，用<code>var</code>来声明变量</p>

<pre><code class="language-Swift">//一行中声明多个
var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<p>注意:<strong>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。</strong></p>

<h3 id="toc_2">类型标注</h3>

<p>声明常量或者变量的时候可以加上类型标注，在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。(声明时如果有初始值，Swift可以推断出这个常量或者变量的类型)</p>

<pre><code class="language-Swift">//可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：
var red, green, blue: Double
</code></pre>

<h3 id="toc_3">常量和变量的命名</h3>

<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>

<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。（不推荐）</p>

<h3 id="toc_4">输出常量和变量</h3>

<p>用 <code>print(someValue, separator:, terminator:)</code> 函数来输出当前常量或变量的值:<br/>
<code>separator</code>用来设置各个值间的拼接字符串<br/>
<code>terminator</code>用来设置输出结果结束后的结束字符，默认为“\n”换行</p>

<pre><code class="language-swift">print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
//输出结果(并没有换行)
//111--222结束符 111--222结束符
</code></pre>

<p><code>Swift</code>用<strong>字符串插值</strong>（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，<code>Swift</code>会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>

<pre><code class="language-Swift">/*
    若只是要print一个变量或者常量可以直接print，但是如果要将这个拼接到字符串中需要这
    样做
*/
print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)
// 输出 &quot;The current value of friendlyWelcome is Bonjour!
</code></pre>

<h2 id="toc_5">注释</h2>

<p>单行注释用双正斜杠<code>（ // ）</code>作为起始标记:<br/>
多行注释用：</p>

<pre><code class="language-swift">/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>

<p>多行注释可以去嵌套注释，我们可以方便的注释掉大段代码 即使代码中已经包含注释(oc中是没有多行注释的)</p>

<h2 id="toc_6">分号</h2>

<p><code>Swift</code>并不需要在末尾添加分号,但是如果单行内写多条语句时,必须用分号分开;</p>

<h2 id="toc_7">整数</h2>

<p><code>Swift</code> 提供了8，16，32和64位的有符号和无符号整数类型(即分别为1、2、4、8字节)。<br/>
命名:比如8位无符号整数类型是 UInt8 ，32位有符号整数类型是 Int32 。</p>

<h3 id="toc_8">范围</h3>

<p>我们可以用不同整数类型的<code>min</code>和<code>max</code>属性获取对应类型的最小值和最大值：</p>

<pre><code class="language-swift">//返回的类型正是其对应类型
let minValue = UInt8.min // minValue 为 0，是 UInt8 类型
let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型
</code></pre>

<p>Swift提供了整数类型<code>Int</code>和<code>UInt</code>其长度和当前平台<code>原生字长</code>相同</p>

<p>补充:<br/>
尽量不要使用<code>UInt</code> ，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断</p>

<h2 id="toc_9">浮点数</h2>

<p><code>Swift</code>提供了两种有符号浮点数类型：</p>

<ul>
<li>Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float 表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>

<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择<code>Double</code>。</p>

<h2 id="toc_10">类型安全和类型推断</h2>

<p><code>Swift</code>是一个类型安全（type safe）的语言。因此它会在编译时进行类型检查,将不匹配的类型标记为错误。但是也不奥每个都显示的指定类型,编译器可以在编译代码的时候自动推断出表达式的类型。</p>

<pre><code class="language-swift">//当推断浮点数的类型时，Swift 总是会选择 Double 而不是 Float 
let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>

<h2 id="toc_11">数值型字面量</h2>

<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是 <code>0b</code></li>
<li>一个八进制数，前缀是 <code>0o</code></li>
<li>一个十六进制数，前缀是 <code>0x</code></li>
</ul>

<p>对于浮点数用10进制或者16进制表示，可以用指数来表示，10进制的指数为<code>e</code>(可为大写或小写)，16进制使用大写或者小写的<code>p</code></p>

<pre><code class="language-swift">1.25e2 表示 1.25 × 10^2，等于 125.0 
1.25e-2 表示 1.25 × 10^-2，等于 0.0125
0xFp2 表示 15 × 2^2，等于 60.0
0xFp-2 表示 15 × 2^-2，等于 3.75
</code></pre>

<p>补充:<br/>
为了可读性：整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>

<pre><code class="language-swift">let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>

<h2 id="toc_12">数值型类型转换</h2>

<p>前面说过,即使知道整数常量或者变量为非负也推荐使用<code>Int</code>类型，这样可以保证我们的的变量或常量可以直接被复用并且可以匹配整数类字面量的类型推断</p>

<p>我们通常使用其他整数类型是为了处理外部明确长度的数据或者优化性能、内存。这样直接使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>

<h3 id="toc_13">整数转换</h3>

<p><code>Swift</code>任何时候都不会隐式进行类型转换，所以我们应该根据情况进行显式的进行类型装换，这样代码的转换意图也更清晰</p>

<pre><code class="language-swift">let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>

<p><code>SomeType(ofInitialValue)</code> 是调用<code>Swift</code>构造器并传入一个初始值的默认方法(但是也不能接受任意类型的值,只能传入<code>SomeType</code>内部有对应构造器的值)</p>

<h3 id="toc_14">整数和浮点数转换</h3>

<p>整数和浮点数之间可以互相转换</p>

<pre><code class="language-swift">let pi = Double(3);
let integerPi = Int(3.1415)
//这样转换的话会向下取整
</code></pre>

<h2 id="toc_15">类型别名</h2>

<p>给现有类型定义另外一个名字,使用<code>typealias</code>关键字来定义类型别名<br/>
<code>typealias AudioSample = UInt16</code><br/>
<strong>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名</strong>：</p>

<h2 id="toc_16">布尔值</h2>

<p><code>Swift</code>提供基本布尔类型<code>Bool</code>，有两个布尔常量:<code>ture</code>和<code>false</code><br/>
Swift中的Bool是非常严格的必须为ture或者false，而不是OC中的非0为真</p>

<h2 id="toc_17">元组</h2>

<p>元组将多个值组合为一个复合值，其中可以为任意类型</p>

<p>元组只适用于我们临时组织数据,不适合创建复杂的数据结构，如果不是临时使用请使用类或者结构体</p>

<pre><code class="language-Swift">//定义元组
let http404Error = (404, &quot;Not Found&quot;)
//元组解析 也可以将 (statusCode, statusMessage) 看为定义的元组名称
let (statusCode, statusMessage) = (404, &quot;Not Found&quot;)
//元组解析 利用 _ 忽略其他的部分
let (justTheStatusCode, _) = http404Error
print((statusCode, statusMessage).0, (statusMessage), http404Error.1)


let (status200Code, status200Message) = (statusCode: 200, description: &quot;OK&quot;)
status200Code
(status200Code, status200Message).1
//这种方式报错,因为用(status200Code, status200Message) 已经将元组内容部分解析,定义的名称已经被覆盖了
//(status200Code, status200Message).status200Code 
let status400 : (statusCode: Int, description: String) = (404, &quot;Not Found&quot;)
status400.statusCode
</code></pre>

<h2 id="toc_18">可选类型</h2>

<p>可选类型用来处理值可能缺失的情况</p>

<p><code>OC</code>中并没有这个类型,在oc中为了表达这个意思我们通常让方法返回一个特殊值(比如 <code>NSNotFound</code>)，来让我们对特殊值进行判断，<code>Swift</code>提供了一个可选类型可以按时任意类型值得缺失很方便.</p>

<p>可选类型的值: 要不有值为X 要不为没有值</p>

<pre><code class="language-swift">//我们将String强转为Int 因为并不是所有字符串都能转为整数,因此返回可选类型
let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;
</code></pre>

<p>问号表示是可选类型Int，就是有可能包含<code>Int</code>也有可能不包含值</p>

<h3 id="toc_19">nil</h3>

<p>在<code>Swift</code>中的<code>nil</code>和OC中并不同,在OC中<code>nil</code>指向一个不存在的对象指针,而<code>Swift</code>中nil不是一个指针,是一个确定的值来表示值得缺失,任何可选状态都可被置为<code>nil</code>，不仅是对象类型。<code>nil</code>只能设置可选类型的值,如果想设置一个常量或者变量,需要先将其设置为可选类型</p>

<pre><code class="language-swift">var serverResponseCode: Int? = 404
serverResponseCode = nil
//对于未赋值的可选类型 默认值为 nil
var surveyAnswer: String?
</code></pre>

<h3 id="toc_20">if语句以及强行解析</h3>

<p>对于一个可选类型值,可以通过 在其后加上<code>!</code>强制解析来获取其值,但是对于不存在的值加！会导致错误,因此在强制解析前需要判断非空</p>

<pre><code class="language-swift">if convertedNumber != nil {
print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;)
}
</code></pre>

<h3 id="toc_21">可选绑定</h3>

<p>上面强行解析后这个值还是可选类型,为了避免这种情况我们可以使用<strong>可选绑定</strong>,用着<code>if</code>或<code>while</code>语句中,通过判断可选类型是否有值,有值得话将其赋值给一个确定类型的变量或者常量,这样就可以使用这个变量或者常量来避免使用可选类型的值避免使用强行解析</p>

<blockquote>
<p>缺点是这样创建的常量或者变量只能在这个if语句中使用</p>
</blockquote>

<pre><code class="language-swift">if let actualNumber = Int(possibleNumber) {
print(&quot;\&#39;\(possibleNumber)\&#39; has an integer value of \(actualNumber)&quot;)
} else {
print(&quot;\&#39;\(possibleNumber)\&#39; could not be converted to an integer&quot;)
}
//如果 Int(possibleNumber)不是nil就可创建一个常量actualNumber指向这个值

</code></pre>

<h3 id="toc_22">隐式解析可选类型</h3>

<p>有时在可选类型第一次被赋值后,就可以确定其总是有值,这时候我们可以声明其为隐式解析可选类型来避免每次都判断解析<br/>
通过将可选类型后的 <code>?</code> 替换为<code>!</code>来声明隐式解析可选类型</p>

<blockquote>
<p>可以将隐式解析可选类型当做一个可以自动解析的可选类型<br/>
使用隐式解析必须确保这个值不会为空 否则和对空值进行强行解析一样会出错</p>
</blockquote>

<pre><code class="language-swift">let possibleString: String? = &quot;An optional string.&quot;
let forcedString: String = possibleString! // 需要感叹号来获取值

let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString // 不需要感叹号
</code></pre>

<h3 id="toc_23">错误处理</h3>

<p><code>Swift</code>允许我们在函数声明中通过添加 <code>throw</code>类型来判处错误消息<br/>
当我们调用一个可能抛出错误消息的函数时,应该在表达式前置<code>try</code>关键字</p>

<blockquote>
<p>这里只是简单了解</p>
</blockquote>

<pre><code class="language-swift">func makeASandwich() throws {
// ...
}
do {
    try makeASandwich()
    eatASandwich()//没有错误抛出会执行这个函数
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)//匹配的错误抛出 函数被调用并且会
}
</code></pre>

<h2 id="toc_24">断言</h2>

<p>有时我们需要在代码中判断某些条件是否满足条件来决定是否继续执行,这时候我们需要断言</p>

<h3 id="toc_25">使用断言进行调试</h3>

<p>断言会在运行时判断一个逻辑条件是否为<code>ture</code>。如果条件判断为<code>true</code>，代码运行会继续进<br/>
行；如果条件判断为<code>false</code> ，代码执行结束，你的应用被终止。</p>

<p>我们在调试环境中触发一个断言，可以检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>

<p>你可以使用全局<code>assert(_:_:file:line:)</code>函数来写一个断言.<br/>
向这个函数传入一个结果为 <code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>

<pre><code class="language-swift">let age = -3
assert(age &gt;= 0, &quot;A person&#39;s age cannot be less than zero&quot;)
// 因为 age &lt; 0，所以断言会触发
</code></pre>

<blockquote>
<p>当代码使用优化编译的时候，断言将会被禁用，例如在<code>Xcode</code>中，使用默认的<code>target Release</code>配置选项来<code>build</code>时，断言会被禁用。</p>
</blockquote>

<h3 id="toc_26">何时使用断言</h3>

<p>当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。</p>

<blockquote>
<p>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

<p>断言的适用情景:</p>

<ul>
<li>整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是 nil ，但是后面的代码运行需要一个非 nil 值。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift简介]]></title>
    <link href="https://acefish.github.io/14966582354331.html"/>
    <updated>2017-06-05T18:23:55+08:00</updated>
    <id>https://acefish.github.io/14966582354331.html</id>
    <content type="html"><![CDATA[
<p><code>Swift</code>采用了<code>Objective-C</code>的命名参数以及动态对象模型，可以无缝对接到现有的<code>Cocoa</code>框架，并且可以兼容<code>Objective-C</code>代码。在此基础之上，<code>Swift</code> 还有许多新特性并且支持过程式编程和面向对象编程。</p>

<p>特性:<br/>
程序入口:<br/>
<code>print(&quot;Hello, world!&quot;)</code><br/>
在<code>Swift</code>中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口 点，所以你也不需要<code>main()</code> 函数。</p>

<h2 id="toc_0">基础知识</h2>

<h3 id="toc_1">简单值</h3>

<p><strong>使用 <code>let</code> 来声明常量，使用 <code>var</code> 来声明变量</strong>。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能 为它赋值一次。</p>

<pre><code class="language-swift">let firstConstant = 10
var firstVariable:Double
</code></pre>

<p>在声明的同时赋值的话不需要声明类型,编译器可以推断出来，但是如果信息不够（没有初始值）,必须要在变量后声明类型;</p>

<p><strong>值永远不会被隐式转换为其他类型,如果要转换请显式转换</strong><br/>
整形转为字符串</p>

<pre><code class="language-swift">//显式强制类型装换
let width = 94
let widthLabel = &quot;The width is&quot; + String(width)
//使用 \() 来把一个浮点计算转换成字符串
let apples = 3
let appleSummary:String = &quot;I have \(apples) apples.&quot;
</code></pre>

<p>使用方括号<code>[]</code>来创建数组和字典，并使用<code>下标或者键(key)</code>来访问元素。最后一个元素后面允许有个逗号</p>

<pre><code class="language-swift">var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]
shoppingList[1] = &quot;bottle of water&quot;
var occupations = [
    &quot;Malcolm&quot;: &quot;Captain&quot;,
    &quot;Kaylee&quot;: &quot;Mechanic&quot;,
]
occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发中的九种锁]]></title>
    <link href="https://acefish.github.io/14964011409915.html"/>
    <updated>2017-06-02T18:59:00+08:00</updated>
    <id>https://acefish.github.io/14964011409915.html</id>
    <content type="html"><![CDATA[
<p>我们在使用多线程的时候多个线程可能会访问同一块资源，这样就很容易引发数据错乱和数据安全等问题，这时候就需要我们保证每次只有一个线程访问这一块资源，锁 应运而生。</p>

<p>补充:<a href="http://www.cnblogs.com/huangjianwu/p/4575763.html">实现锁的多种方式和锁的高级用法</a><br/>
<a href="http://www.jianshu.com/p/938d68ed832c">iOS中保证线程安全的几种方式与性能对比</a></p>

<h2 id="toc_0">一、OSSpinLock 自旋锁</h2>

<p>OSSpinLock 自旋锁，性能最高的锁。在任何时刻只会有一个线程能获得锁,而其他线程忙着等待直到获得锁。缺点是<code>spinlock</code>使用不当(如临界区执行时间过长)会导致<code>cpu busy</code>飙高。不适合较长时间任务</p>

<pre><code class="language-objc">__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@&quot;需要线程同步的操作1 开始&quot;);
    sleep(3);
    NSLog(@&quot;需要线程同步的操作1 结束&quot;);
    OSSpinLockUnlock(&amp;theLock);

});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@&quot;需要线程同步的操作2&quot;);
    OSSpinLockUnlock(&amp;theLock);

});
</code></pre>

<pre><code class="language-objc">//
OS_SPINLOCK_INIT： 默认值为 0,在 locked 状态时就会大于 0，unlocked状态下为 0
OSSpinLockLock(&amp;oslock)：上锁，参数为 OSSpinLock 地址
OSSpinLockUnlock(&amp;oslock)：解锁，参数为 OSSpinLock 地址
OSSpinLockTry(&amp;oslock)：尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO
/**
当前线程锁失败，也可以继续其它任务，用 trylock 合适
当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock
*/
</code></pre>

<p>注意:<br/>
<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a></p>

<h2 id="toc_1">二、dispatch_semaphore 信号量</h2>

<p>是GCD的用来同步的一种方式<br/>
在没有等待情况出现时，它的性能比<code>pthread_mutex</code>还要高，但一旦有等待情况出现时，性能就会下降许多。相对于<code>OSSpinLock</code>来说，它的优势在于等待时不会消耗<code>CPU</code>资源。</p>

<pre><code class="language-objc">  dispatch_semaphore_t signal = dispatch_semaphore_create(1);
    dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(2);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        dispatch_semaphore_signal(signal);
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@&quot;需要线程同步的操作2&quot;);
        dispatch_semaphore_signal(signal);
    });
</code></pre>

<pre><code class="language-objc">dispatch_semaphore_create(1)： 传入值必须 &gt;=0, 若传入为 0 则阻塞线程并等待timeout,
时间到后会执行其后的语句
dispatch_semaphore_wait(signal, overTime)：可以理解为 lock,会使得 signal 值 -1，若信号量的值大于0，就可以继续往下执行,否则等待,如果在等待时间期间信号量一直为0，则会在`timeOut`后自动执行其后的语句。
//
dispatch_semaphore_signal(signal)：可以理解为 unlock,会使得 signal 值 +1
</code></pre>

<p>补充:<a href="http://www.cnblogs.com/snailHL/p/3906112.html">关于dispatch_semaphore的使用</a></p>

<h2 id="toc_2">三、@synchronized</h2>

<pre><code class="language-objc"> NSObject *obj = [[NSObject alloc] init];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        @synchronized(obj) {
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(3);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        }
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        @synchronized(obj) {
            NSLog(@&quot;需要线程同步的操作2&quot;);
        }
    });
</code></pre>

<p><code>@synchronized(obj)</code>指令使用的<code>obj</code>为该锁的唯一标识，只有当标识相同时，才为满足互斥.<br/>
<code>@synchronized</code>指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，<code>@synchronized</code>块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>补充：<a href="http://ios.jobbole.com/82826/">关于 @synchronized，这儿比你想知道的还要多</a></p>

<h2 id="toc_3">四、NSLock</h2>

<pre><code class="language-objc">    NSLock *lock = [[NSLock alloc] init];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        //[lock lock];
        [lock lockBeforeDate:[NSDate date]];
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(2);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        [lock unlock];

    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
            NSLog(@&quot;锁可用的操作&quot;);
            [lock unlock];
        }else{
            NSLog(@&quot;锁不可用的操作&quot;);
        }

        NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
        if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
            NSLog(@&quot;没有超时，获得锁&quot;);
            [lock unlock];
        }else{
            NSLog(@&quot;超时，没有获得锁&quot;);
        }

    });
    //运行结果
    2016-06-29 20:45:08.864 SafeMultiThread[35911:575795] 需要线程同步的操作1 开始
    2016-06-29 20:45:09.869 SafeMultiThread[35911:575781] 锁不可用的操作
    2016-06-29 20:45:10.869 SafeMultiThread[35911:575795] 需要线程同步的操作1 结束
    2016-06-29 20:45:10.870 SafeMultiThread[35911:575781] 没有超时，获得锁

</code></pre>

<p><code>lock</code>一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在<code>lock</code>外等待，只到<code>unlock</code>，才可访问</p>

<p><code>NSLock</code>是<code>Cocoa</code>提供给我们最基本的锁对象，这也是我们经常所使用的，除了常使用的<code>lock</code>和<code>unlock</code>方法外,还提供了:<br/>
<code>trylock</code>：能加锁返回<code>YES</code>并执行加锁操作，相当于<code>lock</code>，反之返回<code>NO</code><br/>
<code>lockBeforeDate</code>：这个方法表示会在传入的时间内尝试加锁，若能加锁则执行加锁操作并返回<code>YES</code>，反之返回<code>NO</code></p>

<h2 id="toc_4">五、NSRecursiveLock递归锁</h2>

<pre><code class="language-objc">    NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        static void (^RecursiveMethod)(int);

        RecursiveMethod = ^(int value) {

            [lock lock];
            if (value &gt; 0) {

                NSLog(@&quot;value = %d&quot;, value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            [lock unlock];
        };

        RecursiveMethod(5);
    });
    //执行结果
    2016-06-30 19:09:41.414 SafeMultiThread[30949:450684] value = 5
    2016-06-30 19:09:42.418 SafeMultiThread[30949:450684] value = 4
    2016-06-30 19:09:43.419 SafeMultiThread[30949:450684] value = 3
    2016-06-30 19:09:44.424 SafeMultiThread[30949:450684] value = 2
    2016-06-30 19:09:45.426 SafeMultiThread[30949:450684] value = 1
    
    
    //在上面如果用NSLock的话就会造成死锁的情况
    NSLock *lock = [[NSLock alloc] init];
    /**
        在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次
        锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死
        锁，线程被阻塞住了。
    */
</code></pre>

<p><code>NSRecursiveLock</code>递归锁，可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。<br/>
递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>补充:<a href="http://www.cocoachina.com/ios/20150513/11808.html">NSRecursiveLock递归锁的使用</a></p>

<h2 id="toc_5">六、NSConditionLock条件锁</h2>

<p>只是<code>lock</code>和<code>unlock</code>通常并不能满足我们的使用，我们通常在满足某条件的情况下才会打开这把锁，这时候我们可以使用<code>NSConditionLock条件锁</code></p>

<pre><code class="language-objc">    NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    if([cLock tryLockWhenCondition:0]){
        NSLog(@&quot;线程1&quot;);
       [cLock unlockWithCondition:1];
    }else{
         NSLog(@&quot;失败&quot;);
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [cLock lockWhenCondition:3];
    NSLog(@&quot;线程2&quot;);
    [cLock unlockWithCondition:2];
});

//线程3
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [cLock lockWhenCondition:1];
    NSLog(@&quot;线程3&quot;);
    [cLock unlockWithCondition:3];
});
/**
    我们在初始化 NSConditionLock 对象时，给了他的标示为 0
    执行 tryLockWhenCondition:时，我们传入的条件标示也是 0,所 以线程1 加锁成功
    执行 unlockWithCondition:时，这时候会把condition由 0 修改为 1
    因为condition 修改为了  1， 会先走到 线程3，然后 线程3 又将 condition 修改为 3
    最后 走了 线程2 的流程
*/
    
</code></pre>

<p><img src="media/14964011409915/14967500416387.png" alt=""/></p>

<p>相比于 NSLock 多了个<code>condition</code>参数，我们可以理解为一个条件标示.<br/>
我们还用它实现了任务支架你的依赖</p>

<pre><code class="language-objc">//可用功能如下:
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;

@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;

@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
</code></pre>

<h2 id="toc_6">七、NSCondition</h2>

<p>一种最基本的条件锁。手动控制线程<code>wait</code>和<code>signal</code>。</p>

<pre><code class="language-objc">NSCondition *condition = [[NSCondition alloc] init];

    NSMutableArray *products = [NSMutableArray array];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@&quot;wait for product&quot;);
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@&quot;custome a product&quot;);
            [condition unlock];
        }

    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }

    });
    
2016-06-30 20:21:25.295 SafeMultiThread[31256:513991] wait for product
2016-06-30 20:21:25.296 SafeMultiThread[31256:513994] produce a product,总量:1
2016-06-30 20:21:25.296 SafeMultiThread[31256:513991] custome a product
</code></pre>

<p><code>[condition lock]</code>一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问<br/>
<code>[condition unlock]</code>与lock 同时使用<br/>
<code>[condition wait]</code>让当前线程处于等待状态<br/>
<code>[condition signal]</code>CPU发信号告诉线程不用在等待，可以继续执行</p>

<pre><code class="language-objc">- (void)wait;//进入等待状态(当一个线程调用wait时其他线程就可以获得这个锁)
- (BOOL)waitUntilDate:(NSDate *)limit;//让一个线程等待一定的时间
- (void)signal;//唤醒一个等待的线程
- (void)broadcast;//唤醒所有等待的线程
</code></pre>

<p>补充:<br/>
这里需要注意wait和signal的问题：<br/>
    1: 其实，wait函数内部悄悄的调用了unlock函数（猜测，有兴趣可自行分析），也就是说在调用wati函数后，这个NSCondition对象就处于了无锁的状态，这样其他线程就可以对此对象加锁并触发该NSCondition对象。当NSCondition被其他线程触发时，在wait函数内部得到此事件被触发的通知，然后对此事件重新调用lock函数（猜测），而在外部看起来好像接收事件的线程（调用wait的线程）从来没有放开NSCondition对象的所有权，wati线程直接由阻塞状态进入了触发状态一样。这里容易造成误解。<br/>
    2: wait函数并不是完全可信的。也就是说wait返回后，并不代表对应的事件一定被触发了，因此，为了保证线程之间的同步关系，使用NSCondtion时往往需要加入一个额外的变量来对非正常的wait返回进行规避。<br/>
   3: 关于多个wait时的调用顺序，测试发现与wait执行顺序有关。</p>

<h2 id="toc_7">八、pthread_mutex互斥锁</h2>

<pre><code class="language-objc">  __block pthread_mutex_t theLock;
    pthread_mutex_init(&amp;theLock, NULL);

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            pthread_mutex_lock(&amp;theLock);
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(3);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
            pthread_mutex_unlock(&amp;theLock);

    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            sleep(1);
            pthread_mutex_lock(&amp;theLock);
            NSLog(@&quot;需要线程同步的操作2&quot;);
            pthread_mutex_unlock(&amp;theLock);

    });
2016-06-30 21:13:32.440 SafeMultiThread[31429:548869] 需要线程同步的操作1 开始
2016-06-30 21:13:35.445 SafeMultiThread[31429:548869] 需要线程同步的操作1 结束
2016-06-30 21:13:35.446 SafeMultiThread[31429:548866] 需要线程同步的操作2
    /**
        与OSSpinLock类似,pthread_mutex 中也有个pthread_mutex_trylock(&amp;pLock)，和上面提
        到的 OSSpinLockTry(&amp;oslock)区别在于，前者可以加锁时返回的是 0，否则返回一个错误提示
        码；后者返回的 YES和NO
    */
</code></pre>

<pre><code class="language-objc">1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);
初始化锁变量mutex。attr为锁属性，NULL值为默认属性。
2：pthread_mutex_lock(pthread_mutex_t mutex);加锁
3：pthread_mutex_tylock(*pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。
4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁
5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放
</code></pre>

<p><code>YYKit</code>源码<br/>
<img src="media/14964011409915/14967514267813.png" alt=""/></p>

<h2 id="toc_8">九、pthread_mutex(recursive)递归锁</h2>

<p>之前的lock是和unlock成对出现，同一线程多次 lock 是不允许的，而递归锁允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</p>

<pre><code class="language-objc">static pthread_mutex_t pLock;
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁
pthread_mutex_init(&amp;pLock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用

//1.线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveBlock)(int);
    RecursiveBlock = ^(int value) {
        pthread_mutex_lock(&amp;pLock);
        if (value &gt; 0) {
            NSLog(@&quot;value: %d&quot;, value);
            RecursiveBlock(value - 1);
        }
        pthread_mutex_unlock(&amp;pLock);
    };
    RecursiveBlock(5);
});
//如果我们用 pthread_mutex_init(&amp;pLock, NULL) 初始化会出现死锁的情况，递归锁能很好的避免这种情况的死锁；
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[时间 时区]]></title>
    <link href="https://acefish.github.io/14958652887586.html"/>
    <updated>2017-05-27T14:08:08+08:00</updated>
    <id>https://acefish.github.io/14958652887586.html</id>
    <content type="html"><![CDATA[
<p>1.时区 时间</p>

<p>对于机器时间 <br/>
我们平常的<br/>
周六 = 7 周日 = 1 周一 = 2</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定时器]]></title>
    <link href="https://acefish.github.io/14958642376440.html"/>
    <updated>2017-05-27T13:50:37+08:00</updated>
    <id>https://acefish.github.io/14958642376440.html</id>
    <content type="html"><![CDATA[
<p>dispatch_source_set_timer  创建的定时器也会在启动时立马执行一次要执行block  而不是等指定时间后再触发</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView]]></title>
    <link href="https://acefish.github.io/14957029093514.html"/>
    <updated>2017-05-25T17:01:49+08:00</updated>
    <id>https://acefish.github.io/14957029093514.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">1.代理</h3>

<p>对于我们在代码中修改textView的内容是不会走delegate中的这个方法的</p>

<pre><code class="language-objc">- (void)textViewDidChange:(UITextView *)textView {}
</code></pre>

<p>也不会走这个监听</p>

<pre><code class="language-objc">[ITNotificationCenter addObserver:self selector:@selector(textViewChangeContent:) name:UITextViewTextDidChangeNotification object:nil];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TableView]]></title>
    <link href="https://acefish.github.io/14956786717356.html"/>
    <updated>2017-05-25T10:17:51+08:00</updated>
    <id>https://acefish.github.io/14956786717356.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">preservesSuperviewLayoutMargins</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xib使用]]></title>
    <link href="https://acefish.github.io/14956304598531.html"/>
    <updated>2017-05-24T20:54:19+08:00</updated>
    <id>https://acefish.github.io/14956304598531.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">SizeClasses</h2>

<p><code>SizeClass</code>并不是对控件进行布局而是用于区分不同的屏幕尺寸<br/>
SizeClass之所以能适配所有型号，就是因为三个属性Compact(紧凑),Any(所有),regular(常规)。</p>

<h2 id="toc_1">适配不同设备的xib</h2>

<h3 id="toc_2">创建适配不同设备的xib</h3>

<p><img src="media/14956304598531/870B58F4-145B-4697-906B-682877E8518A.png" alt="870B58F4-145B-4697-906B-682877E8518A"/><br/>
<code>Install</code>选项勾选即可选择这个控件是否在此类设备中显示而左边的得弹框则可以选择此类设备是指:通过选择Width 和 Height  可以选定 是ipad 还是 iphone</p>

<h3 id="toc_3">创建针对不同设备的约束</h3>

<p><img src="media/14956304598531/DED74B15-FD5B-49EF-903D-D53E1CF680B6.png" alt="DED74B15-FD5B-49EF-903D-D53E1CF680B6"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设备标识]]></title>
    <link href="https://acefish.github.io/14956302391950.html"/>
    <updated>2017-05-24T20:50:39+08:00</updated>
    <id>https://acefish.github.io/14956302391950.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDatePicker]]></title>
    <link href="https://acefish.github.io/14955051645893.html"/>
    <updated>2017-05-23T10:06:04+08:00</updated>
    <id>https://acefish.github.io/14955051645893.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">UIDatePicker</h2>

<h3 id="toc_1">1.显示24小时制</h3>

<pre><code class="language-objc">self.timePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;en_GB&quot;];
</code></pre>

<h3 id="toc_2">2.添加事件</h3>

<pre><code class="language-objc">//与pickView不同
[self.timePicker addTarget:self action:@selector(timeChanged:) forControlEvents:UIControlEventValueChanged];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD]]></title>
    <link href="https://acefish.github.io/14954386080339.html"/>
    <updated>2017-05-22T15:36:48+08:00</updated>
    <id>https://acefish.github.io/14954386080339.html</id>
    <content type="html"><![CDATA[
<p>DISPATCH_TIME_FOREVER会一直等待block结束</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#pragma]]></title>
    <link href="https://acefish.github.io/14954384117214.html"/>
    <updated>2017-05-22T15:33:31+08:00</updated>
    <id>https://acefish.github.io/14954384117214.html</id>
    <content type="html"><![CDATA[
<p>#pragma clang diagnostic push</p>

]]></content>
  </entry>
  
</feed>
