<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish的博客]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2017-03-22T10:34:46+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[缓冲]]></title>
    <link href="https://acefish.github.io/14906168166224.html"/>
    <updated>2017-03-27T20:13:36+08:00</updated>
    <id>https://acefish.github.io/14906168166224.html</id>
    <content type="html"><![CDATA[
<p><code>Core Animation</code>使用缓冲来使动画移动更平滑更自然。我们来试着研究如何对你的动画控制和自定义缓冲曲线。</p>

<h3 id="toc_0">动画速度</h3>

<p><code>velocity = change / time</code>（假设速度不变也就是“线性步调”）</p>

<p>其实速度在动画整个移动过程中并不一定是恒定不变的,是有加速度的,为了实现这种加速度,一种方法是使用物理引擎来对运动物体的摩擦和动量来建模，然而这会使得计算过于复杂。我们称这种类型的方程为缓冲函数，幸运的是，<code>Core Animation</code>内嵌了一系列标准函数提供给我们使用。</p>

<h4 id="toc_1">CAMediaTimingFunction</h4>

<p>显式动画<code>CAAnimation</code>的<code>timingFunction</code>属性就是<code>CAMediaTimingFunction</code>类对象<br/>
隐式动画用<code>CATransaction</code>的<code>+setAnimationTimingFunction:</code>方法，来调整动画时间函数</p>

<p><code>CAMediaTimingFunction</code>用<code>+timingFunctionWithName:</code>方法构造对象：</p>

<pre><code class="language-objc">//几种常量
kCAMediaTimingFunctionLinear//。默认。线性计时函数
kCAMediaTimingFunctionEaseIn//慢慢加速然后突然停止
kCAMediaTimingFunctionEaseOut//全速开始 慢慢减速停止
kCAMediaTimingFunctionEaseInEaseOut//慢慢加速然后再慢慢减速
kCAMediaTimingFunctionDefault//类似淡入淡出但是加速和减速过程更慢
/**
    UIView 的动画方法默认kCAMediaTimingFunctionEaseInEaseOut
    CAAinamtion 默认kCAMediaTimingFunctionLinear
*/
</code></pre>

<pre><code class="language-objc">[CATransaction begin];
[CATransaction setAnimationDuration:1.0];
[CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];
//set the position
self.colorLayer.position = [[touches anyObject] locationInView:self.view];
//commit transaction
[CATransaction commit];
</code></pre>

<h4 id="toc_2">UIView 的动画缓冲</h4>

<p>UIView 动画的缓冲选项，<code>options</code>参数</p>

<pre><code class="language-objc">UIViewAnimationOptionCurveEaseInOut//默认
UIViewAnimationOptionCurveEaseIn
UIViewAnimationOptionCurveEaseOut
UIViewAnimationOptionCurveLinear
</code></pre>

<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    //perform the animation
    [UIView animateWithDuration:1.0 delay:0.0 options:UIViewAnimationOptionCurveEaseOut
    animations:^{
        //set the position
        self.colorView.center = [[touches anyObject] locationInView:self.view];
    }
    completion:NULL];
}
</code></pre>

<h4 id="toc_3">缓冲和关键帧动画</h4>

<p>对于关键帧动画：我们不想给整个动画过程应用这个效果，我们希望对每个动画的过程重复这样的缓冲.<br/>
<code>CAKeyframeAnimation</code> 有一个 <code>NSArray</code> 类型的<code>timingFunctions</code>属性，我们<br/>
可以用它来对每次动画的步骤指定不同的计时函数。这个数组个数需要与<strong>关键帧(keyframes)个数减一</strong>,它是每两个关键帧之间的效果.</p>

<pre><code class="language-objc">    //create a keyframe animation
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.duration = 2.0;
    animation.values = @[
    (__bridge id)[UIColor blueColor].CGColor,
    (__bridge id)[UIColor redColor].CGColor,
    (__bridge id)[UIColor greenColor].CGColor,
    (__bridge id)[UIColor blueColor].CGColor ];
    //add timing function
    CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn];
    animation.timingFunctions = @[fn, fn, fn];
    //apply animation to layer
    [self.colorLayer addAnimation:animation forKey:nil];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图层时间]]></title>
    <link href="https://acefish.github.io/14905958336865.html"/>
    <updated>2017-03-27T14:23:53+08:00</updated>
    <id>https://acefish.github.io/14905958336865.html</id>
    <content type="html"><![CDATA[
<p>我们可以用<code>CAAnimation</code>和它的子类实现的多种图层动画。但是动画是需要持续时间的,因此我们来学习一下计时的<code>CAMediaTiming</code>，跟踪时间。</p>

<h3 id="toc_0">CAMediaTiming 协议</h3>

<p><code>CAMediaTiming</code> 协议定义了<strong>在一段动画内用来控制逝去时间的属性的集合</strong>。<code>CALayer</code> 和<code>CAAnimation</code>都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>

<h4 id="toc_1">持续和重复</h4>

<p><code>duration</code>(<code>CAMediaTiming</code>的属性之一)是<code>CFTimeInterval</code>类型(双精度浮点型),对将要进行的动画的一次迭代指定了时间。<br/>
<code>repeatCount</code>(<code>CAMediaTiming</code>的属性之一)，代表动画重复的迭代次数。<br/>
通过上面两个属性我们可以创建重复动画</p>

<p>创建重复动画的另外方式:<br/>
<code>repeatDuration</code>属性。它让动画重复一个指定的时间，而不是指定次数。如果我们将 <code>repeatDuration</code>设置为<code>INFINITY</code>(无限大)动画无限循环播放，设置<code>repeatCount</code>为<code>INFINITY</code>也有同样的效果。(但是<strong>这两个属性我们只能设置一个</strong>)<br/>
<code>autoreverses</code>属性,设置是否在每次间隔交替循环过程中自动回放（常用于播放非循环动画）。</p>

<h4 id="toc_2">相对时间</h4>

<p><code>beginTime</code>指定了动画开始之前的的延迟时间（默认是0即立刻执行）。</p>

<p><code>speed</code>是一个时间的倍数，默认<code>1.0</code>，减少它会减慢图层/动画的时间，增加它会加快速度。如果2.0的速度，那么对于一个 duration 为1的动画，实际上在0.5秒的时候就已经完成了。</p>

<p><code>timeOffset</code>和<code>beginTime</code>类似，但是和增加<code>beginTime</code>导致的延迟动画不同，增加<code>timeOffset</code>只是让动画快进到某一点，例如，对于一个持续1秒的动画来说，设置<code>timeOffset</code>为0.5意味着动画将从一半的地方开始。<br/>
和<code>beginTime</code>不同的是，<code>timeOffset</code>并不受 <code>speed</code> 的影响。所以如果你把<code>speed</code> 设为2.0，把 <code>timeOffset</code> 设置为0.5，那么你的动画将从动画最后结束的地方开始，因为1秒的动画实际上被缩短到了0.5秒。然而即使使用了 <code>timeOffset</code>让动画从结束的地方开始，它仍然播放了一个完整的时长，这个动画仅仅是循环了一圈，然后从头开始播放。</p>

<h4 id="toc_3">fillMode</h4>

<p><code>fillMode</code> 属性是一个<code>NSString</code>类型，接受以下常量:</p>

<pre><code class="language-objc">kCAFillModeForwards
kCAFillModeBackwards
kCAFillModeBoth
kCAFillModeRemoved//默认
</code></pre>

<p>默认是 <code>kCAFillModeRemoved</code>，当动画不再播放的时候就显示图层模型指定的值</p>

<p>向前，向后或者即向前又向后去填充动画状态，使得动画在开始前或者结束后仍然保持开始和结束那一刻的值。<br/>
这就对避免在动画结束的时候急速返回提供另一种方案。但是，需要把 removeOnCompletion 设置为 NO ，另外需要给动画添加一个非空的键，于是可以在不需要动画的时候把它从图层上移除.</p>

<h3 id="toc_4">层级关系时间</h3>

<p>动画时间也是有层级关系的,每个动画和图层在时间上都有它自己的层级概念,相对于父图层.对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层（图层的时间属性）。类似的使用<code>CAAnimationGroup</code>时将动画都被按照层级组合.(CAAnimationGroup将动画层级组合)（动画属性）</p>

<p>对<code>CALayer</code>或者 <code>CAGroupAnimation</code> 调整 <code>duration</code> 和 <code>repeatCount / repeatDuration</code> 属性并不会影响到子动画。但是 <code>beginTime</code>， <code>timeOffset</code> 和 <code>speed</code> 属性将会影响到子动画。<code>beginTime</code>指定了父图层开始动画（或者组合关系中的父动画）和对象将要开始自己动画之间的偏移。调整<code>CALayer</code> 和<code>CAGroupAnimation</code>的 <code>speed</code> 属性将会对动画以及子动画速度应用一个缩放的因子。</p>

<h4 id="toc_5">全局时间和本地时间</h4>

<p>全局时间:<br/>
CoreAnimation有一个全局时间的概念，也就是所谓的马赫时间（“马赫”实际上是iOS和Mac OS系统内核的命名）（返回了设备自从上次启动后的秒数）。马赫时间在设备上所有进程都是全局的--但是在不同设备上并不是全局的.</p>

<pre><code class="language-objc">//CACurrentMediaTime 函数来访问马赫时间
CFTimeInterval time = CACurrentMediaTime();
</code></pre>

<p>这个值我们并不关心,但是它对我们的对时间实测提供了一个基准,可以提供相对值.</p>

<p><strong>注意</strong><br/>
当设备休眠的时候马赫时间会暂停，也就是所有的<code>CAAnimations</code>（基于马赫时间）同样也会暂停。因此马赫时间对长时间测量并不有用。比如用 CACurrentMediaTime 去更新一个实时闹钟并不明智。</p>

<p>本地时间:<br/>
每个 CALayer 和 CAAnimation 实例都有自己本地时间的概念，是根据父图层/动画层级关系中的 beginTime ， timeOffset 和 speed 属性计算出来的.</p>

<p>类似坐标系转换：</p>

<pre><code class="language-objc">- (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)layer;
- (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)layer;
</code></pre>

<h4 id="toc_6">暂停，倒回和快进</h4>

<p>设置动画的<code>speed</code>属性为0可以暂停动画，但在动画被添加到图层之后不太可能再修改它了，所以不能对正在进行的动画使用这个属性(注意这是动画的speed属性)。</p>

<p>如果移除图层正在进行的动画，图层将会急速返回动画之前的状态。但如果在动画移除之前拷贝呈现图层到模型图层，动画将会看起来暂停在那里。但是不好的地方在于不能再恢复动画了。<br/>
给图层添加一个<code>CAAnimation</code>实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。相反，直接用 <code>- animationForKey:</code> 来检索图层正在进行的动画可以返回正确的动画对象，但是修改它的属性将会抛出异常。</p>

<p>暂停的方法：<br/>
可以利用<code>CAMediaTiming</code>来暂停图层本身。如果把图层的 <code>speed</code> 设置成0，它会暂停任何添加到图层上的动画。类似的，设置<code>speed</code> 大于1.0将会快进，设置成一个负值将会倒回动画。</p>

<p>通过增加主窗口图层的speed，可以暂停整个应用程序的动画.我们可以利用改变speed来加速所有视图动画来进行自动化测试.</p>

<pre><code class="language-objc">self.window.layer.speed = 100;
</code></pre>

<h3 id="toc_7">手动动画</h3>

<p>我们可以通过设置动画<code>speed</code>属性为0,禁用动画的自动播放,然后通过设置<code>timeOffset</code>来显示动画序列.这样就可以运用手势来控制动画.</p>

<p>例如:</p>

<pre><code class="language-objc">//设置平移手势
- (void)pan:(UIPanGestureRecognizer *)pan
{
    //get horizontal component of pan gesture
    CGFloat x = [pan translationInView:self.view].x;
    //convert from points to animation duration //using a reasonable scale factor
    x /= 200.0f;
    //update timeOffset and clamp result
    CFTimeInterval timeOffset = self.doorLayer.timeOffset;
    timeOffset = MIN(0.999, MAX(0.0, timeOffset - x));
    self.doorLayer.timeOffset = timeOffset;
    //reset pan gesture
    [pan setTranslation:CGPointZero inView:self.view];
}
</code></pre>

<p>其实如果是这样的话,对于比较复杂的动画我们可以这样的方法,但是对于比较简单图层我们完全可以直接用移动手势来设置图层<code>transform</code>,</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAAnimation]]></title>
    <link href="https://acefish.github.io/14903444013647.html"/>
    <updated>2017-03-24T16:33:21+08:00</updated>
    <id>https://acefish.github.io/14903444013647.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">keyPath</h3>

<ol>
<li><p>@&quot;backgroundColor&quot;  背景颜色<br/>
<code>(__bridge id)[UIColor blueColor].CGColor</code></p></li>
<li><p>@&quot;transform&quot;  动画<code>CATransform3D</code><br/>
<code>animation.toValue = [NSValue valueWithCATransform3D:transform];</code></p></li>
<li><p>@&quot;position&quot; 中心位置<br/>
可以直接设置值<br/>
也可以<strong>常用于CAKeyAnimation动画路径设置</strong></p></li>
</ol>

<pre><code class="language-objc">CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];
animation1.keyPath = @&quot;position&quot;;
animation1.path = bezierPath.CGPath;
animation1.rotationMode = kCAAnimationRotateAuto;
</code></pre>

<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[显式动画]]></title>
    <link href="https://acefish.github.io/14903384285214.html"/>
    <updated>2017-03-24T14:53:48+08:00</updated>
    <id>https://acefish.github.io/14903384285214.html</id>
    <content type="html"><![CDATA[
<p>隐式动画是在iOS平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础<br/>
显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画</p>

<h3 id="toc_0">属性动画</h3>

<p><code>core animation</code>里面有个很重要的类<code>CAPropertyAnimation</code>(属性动画)，它有两个子类，<code>CABasicAnimation</code>和<code>CAKeyFrameAnimation</code>。</p>

<h4 id="toc_1">属性动画</h4>

<p><code>CAAnimation</code>在动画结束时会属性会回到原值所以<br/>
我们在做了显式动画后可以用<code>CAAnimationDelegate</code>中<code>- animationDidStop:finished:</code>方法来更新图层属性（一般设置其为终值）,更新属性的时候我们需要一个新的事务并且禁用图层行为.否则会有两次动画.</p>

<pre><code class="language-objc">- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag
{
    //set the backgroundColor property to match animation toValue
    [CATransaction begin];
    [CATransaction setDisableActions:YES];
    self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;
    [CATransaction commit];
}
</code></pre>

<p>但是如果我们有多个动画这个代理回调是无法区分是哪个图层的调用.<br/>
1.因为这个代理传进来的动画的深拷贝,所以没有办法通过设置动画属性来分辨.<br/>
2.使用<code>-addAnimation:forKey:</code>给动画设置不同key,<code>-animationForKey:</code>找到对应的key来对比，可实现但是比较复杂<br/>
3.最简单的方法,<code>CAAnimation</code>实现了KVC,但是更像一个 NSDictionary ，可以让你<strong>随意设置键值对</strong>，即使和你使用的动画类所声明的属性并不匹配。</p>

<pre><code class="language-objc">//初始化动画时用KVC设置键值对
CABasicAnimation *animation = [CABasicAnimation animation];
[self updateHandsAnimated:NO];
animation.keyPath = @&quot;transform&quot;;
animation.toValue = [NSValue valueWithCATransform3D:transform];
animation.duration = 0.5;
animation.delegate = self;
[animation setValue:handView forKey:@&quot;handView&quot;];
[handView.layer addAnimation:animation forKey:nil];
- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag
{
    //通过kvc获取存储的值
    UIView *handView = [anim valueForKey:@&quot;handView&quot;];
    handView.layer.transform = [anim.toValue CATransform3DValue];
}
</code></pre>

<p><code>CABasicAnimation</code>只能作用于一个属性,只能有初始值和结束值</p>

<h4 id="toc_2">关键帧动画</h4>

<p><code>CABasicAnimation</code>揭示了大多数隐式动画背后依赖的机制,但是显式地给图层添加<code>CABasicAnimation</code>相较于<code>隐式动画</code>而言，只能说费力不讨好。</p>

<p><code>CAKeyframeAnimation</code>和<code>CABasicAnimation</code> 类似同样是<code>CAPropertyAnimation</code> 的一个子类它依然作用于单一的一个属性,但是它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>

<p><code>CAKeyframeAnimation</code>关键帧动画:只我们只需要绘制关键帧的动画，然后<code>Core Animation</code>在每帧之间进行插入。</p>

<pre><code class="language-objc">- (IBAction)changeColor
{
    //create a keyframe animation
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.duration = 2.0;
    animation.values = @[
    (__bridge id)[UIColor blueColor].CGColor,
    (__bridge id)[UIColor redColor].CGColor,
    (__bridge id)[UIColor greenColor].CGColor,
    (__bridge id)[UIColor blueColor].CGColor ];
    //apply animation to layer
    [self.colorLayer addAnimation:animation forKey:nil];
}
</code></pre>

<p>是因为<code>CAKeyframeAnimation</code>并不能自动把当前值作为第一帧（就像<code>CABasicAnimation</code> 那样把 <code>fromValue</code> 设为 <code>nil</code> ），所以动画会在开始的时候突然由原来色变为蓝色,结束时又突然由结束色变为原来色.</p>

<p>上面是使用<code>animation.values</code>来设置关键帧，我还可以用<code>path 属性</code>指定运动序列.<br/>
我们要绘制一个<code>CGPath</code>的三次贝塞尔曲线，可以通过使用一个基于C的<code>Core Graphics</code>绘图指令来创建，不过用<code>UIKit</code>提供的<code>UIBezierPath</code>类会更简单.</p>

<pre><code class="language-objc">UIBezierPath *bezierPath = [[UIBezierPath alloc] init];
[bezierPath moveToPoint:CGPointMake(0, 150)];
[bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];
CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
animation.keyPath = @&quot;position&quot;;
animation.duration = 4.0;
animation.path = bezierPath.CGPath;
[shipLayer addAnimation:animation forKey:nil];
</code></pre>

<p>苹果很人性化的给我们提供了<code>rotationMode</code>属性,设置它为常量 <code>kCAAnimationRotateAuto</code>图层将会根据曲线的切线自动旋转。<br/>
<code>animation.rotationMode = kCAAnimationRotateAuto;</code></p>

<h4 id="toc_3">虚拟属性</h4>

<p>属性动画实际上是针对于关键路径而不是一个键,这就意味着可以对<code>子属性</code>甚至是<code>虚拟属性</code>做动画.</p>

<p>例如:想要对物体做旋转动画,需要作用于<code>transform</code> 属性，因为<code>CALayer</code>没有显式提供角度或者方向之类的属性</p>

<pre><code class="language-objc">CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform&quot;;
animation.duration = 2.0;
animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];
[shipLayer addAnimation:animation forKey:nil];
/**
这样确实会旋转180°但是如果我们把M_PI改为2*M_PI就不会旋转了
即使我们设置了byValue也无效,因为变换矩阵并不会像角度值一样叠加
*/
</code></pre>

<p>对于<code>CATransform3D</code>因为0度旋转和360度旋转的矩阵完全相同,所以<code>fromValue</code> = <code>toValue</code>因此不会旋转的</p>

<p>我们当然可以用关键帧动画,修改<code>transform</code>属性，实时地重新计算每个时间点的每个变换效果。这是非常复杂的，不推荐</p>

<p>推荐:<br/>
我们可以<br/>
对<code>transform.rotation</code>关键路径应用动画，而不是<code>transform</code>本身<br/>
<code>objc<br/>
CABasicAnimation *animation = [CABasicAnimation animation];<br/>
animation.keyPath = @&quot;transform.rotation&quot;;<br/>
animation.duration = 2.0;<br/>
animation.byValue = @(M_PI * 2);<br/>
[shipLayer addAnimation:animation forKey:nil];<br/>
</code><br/>
这样我们就可以简单使用角度而不用复杂的矩阵,就可以使用<code>byValue</code>了. 还可以额外使用<code>transform.position</code> 或者<code>transform.scale</code></p>

<p><code>transform.rotation</code>属性其实并不存在,这是因为<code>CATransform3D</code>不是对象而是结构体，它就是一个 <code>CALayer</code> 用于处理动画变换的虚拟属性。当我们<code>transform.rotation</code>等虚拟属性做动画时，<code>Core Animation</code>自动地根据通过 <code>CAValueFunction</code> 来计算的值来更新<code>transform</code> 属性。<br/>
<code>CAValueFunction</code>用于把我们赋给虚拟的 <code>transform.rotation</code>简单浮点值转换成真正的用于摆放图层的<code>CATransform3D</code> 矩阵值。可以通过设置 <code>CAPropertyAnimation</code> 的<code>valueFunction</code>属性来改变，于是你设置的函数将会覆盖默认的函数。</p>

<h3 id="toc_4">动画组</h3>

<h4 id="toc_5">动画组</h4>

<p><code>属性动画</code>仅仅作用于单独的属性,<code>CAAnimationGroup</code>是另一个继承于 <code>CAAnimation</code> 的子类，它添加了一个 <code>animations</code> 数组的属性，用来组合别的动画。</p>

<pre><code class="language-objc">CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];
animation1.keyPath = @&quot;position&quot;;
animation1.path = bezierPath.CGPath;
animation1.rotationMode = kCAAnimationRotateAuto;
//create the color animation
CABasicAnimation *animation2 = [CABasicAnimation animation];
animation2.keyPath = @&quot;backgroundColor&quot;;
animation2.toValue = (__bridge id)[UIColor redColor].CGColor;
//create group animation
CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];
groupAnimation.animations = @[animation1, animation2];
groupAnimation.duration = 4.0;
//add the animation to the color layer
[colorLayer addAnimation:groupAnimation forKey:nil];
</code></pre>

<h3 id="toc_6">过渡</h3>

<p><strong>属性动画只对图层的可动画属性起作用</strong>，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。</p>

<p>因为隐式动画或者属性动画都只能对图层的可动画属性做动画,如果这个属性不可动画，这时候我们就需要<code>过渡</code>了。过渡动画会影响到整个图层的变化,它首先展示的之前的图层外观,然后通过一个交换过渡到新的外观.</p>

<p>我们用<code>CATransition</code>来创建过渡动画,它也是<code>CAAnimation</code>子类,有一个<code>type</code>和<code>subtype</code>来标识变换效果。</p>

<pre><code class="language-objc">//type:
kCATransitionFade//默认,淡入淡出
kCATransitionMoveIn //新图层从顶部滑入
kCATransitionPush //推出老图层
kCATransitionReveal //滑动出原图层，显示新外观,而不是滑动入新图层
//这是系统提供的,我们也可以自定义过渡动画效果
</code></pre>

<p><code>type</code>过渡类型都有一个默认的动画方向（从左侧滑入）,可以通过<code>subtype</code>控制方向</p>

<pre><code>//subtype
kCATransitionFromRight
kCATransitionFromLeft//
kCATransitionFromTop
kCATransitionFromBottom
</code></pre>

<p><strong>注意</strong><br/>
与属性动画类似我们通过<code>-addAnimation:forKey:</code>方法，但是它对指定图层一次只能用一次<code>CATransition</code>，因此，过渡动画都会对它的键设置成“transition”，也就是常量 kCATransition 。</p>

<h4 id="toc_7">隐式过渡</h4>

<p>过渡动画和属性动画类似也是有隐式,如果设置了<code>CALayer</code>的<code>contents</code>属性,但是对于与视图关联的图层隐式过渡动画是被禁用的,但是如果是自己创建的图层<code>contents</code>图片做的改动都会自动附上淡入淡出的动画。</p>

<p><strong>注意</strong><br/>
虽然我们用<code>过渡动画</code>来对图层的某些不可动画属性做动画,但是也不是说过渡动画不能对可动画属性做动画.</p>

<pre><code class="language-objc">    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionPush;
    transition.subtype = kCATransitionFromRight;
    [self.containerView.layer addAnimation:transition forKey:nil];
    self.containerView.backgroundColor = [UIColor redColor];
</code></pre>

<h4 id="toc_8">图层树动画</h4>

<p>添加过渡动画<code>不需要指定属性</code>,它涉及到整个图层树的改变,因此我们可以在即使不能准确得知图层改变什么的情况下对图层做动画.</p>

<p>确保<code>CATransition</code>添加到的图层在过渡动画发生时不会在树状结构中被移除，否则<code>CATransition</code>将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的<code>superlayer</code>。</p>

<h4 id="toc_9">自定义动画</h4>

<p><code>UIView</code>也有提供过渡动画函数:<br/>
 <code>UIView +transitionFromView:toView:duration:options:completion:</code>和 <code>+transiti<br/>
onWithView:duration:options:animations:</code></p>

<p>这些过渡方法中<code>options</code>参数可以由如下常量指定：</p>

<pre><code class="language-objc">UIViewAnimationOptionTransitionFlipFromLeft//以Y轴从左向右旋转
UIViewAnimationOptionTransitionFlipFromRight
UIViewAnimationOptionTransitionCurlUp//从上向下翻页效果
UIViewAnimationOptionTransitionCurlDown
UIViewAnimationOptionTransitionCrossDissolve//溶解渐变效果
UIViewAnimationOptionTransitionFlipFromTop//以X轴从下向上旋转
UIViewAnimationOptionTransitionFlipFromBottom
</code></pre>

<p>因此只需要根据要实现效果<code>CATransition</code>还是<code>UIView</code>的过渡方法就行了.</p>

<p>如果真的要实现自定义的过渡效果:<br/>
因为过渡动画的原则就是对原始的图层外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果。如果我们会对图层截图,就可以用属性动画来代替过渡动画了.</p>

<p>对图层截图的方法:<code>CALayer</code>有一个 <code>- renderInContext:</code>方法，可以通过把它绘制到<code>Core Graphics</code>的上下文中捕获当前内容的图片，然后在另外的视图中显示出来。如果我们把这个截屏视图置于原始视图之上，就可以遮住真实视图的所有变化，于是重新创建了一个简单的过渡效果。</p>

<pre><code class="language-objc">- (IBAction)performTransition
{
    //preserve the current view snapshot
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);
    [self.view.layer renderInContext:UIGraphicsGetCurrentContext()];
    UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();
    //insert snapshot view in front of this one
    UIView *coverView = [[UIImageView alloc] initWithImage:coverImage];
    coverView.frame = self.view.bounds;
    [self.view addSubview:coverView];
    //update the view (we&#39;ll simply randomize the layer background color)
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.view.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];
    //perform animation (anything you like)
    [UIView animateWithDuration:1.0 animations:^{
        //scale, rotate and fade the view
        CGAffineTransform transform = CGAffineTransformMakeScale(0.01, 0.01);
        transform = CGAffineTransformRotate(transform, M_PI_2);
        coverView.transform = transform;
        coverView.alpha = 0.0;
    } completion:^(BOOL finished) {
        //remove the cover view now we&#39;re finished with it
        [coverView removeFromSuperview];
    }];
}
</code></pre>

<p><strong>注意</strong><br/>
<code>- renderInContext:</code>捕获了图层的图片和子图层，但是不能对子图层正确地处理变换效果，而且对视频和OpenGL内容也不起作用。但是用<code>CATransition</code>，或者用私有的截屏方式就没有这个限制了。</p>

<h3 id="toc_10">动画过程中取消动画</h3>

<p>添加动画:<code>-addAnimation:forKey:</code><br/>
检索动画:<code>- (CAAnimation *)animationForKey:(NSString *)key</code><br/>
<em>不支持动画过程中修改动画</em><br/>
移除指定动画:<code>- (void)removeAnimationForKey:(NSString *)key;</code><br/>
移除所有动画:<code>- (void)removeAllAnimations;</code></p>

<p><strong>注意</strong><br/>
一般说来，动画在结束之后被自动移除，除非设置<code>removedOnCompletion</code>为<code>NO</code>，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UISlider]]></title>
    <link href="https://acefish.github.io/14901616296287.html"/>
    <updated>2017-03-22T13:47:09+08:00</updated>
    <id>https://acefish.github.io/14901616296287.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-objc">slider.continuous = YES;//默认YES  如果设置为NO，则每次滑块停止移动后才触发事件
[slider addTarget:self action:@selector(sliderChange:) forControlEvents:UIControlEventValueChanged]; 
//手动设置滑块的值，并是否动画移动过去：
- (void)setValue:(float)value animated:(BOOL)animated; 
//给滑动按钮设置图片 
- (void)setThumbImage:(nullable UIImage *)image forState:(UIControlState)state; 
//给滑道左侧设置图片 
- (void)setMinimumTrackImage:(nullable UIImage *)image forState:(UIControlState)state; 
//给滑道右侧设置图片 
- (void)setMaximumTrackImage:(nullable UIImage *)image forState:(UIControlState)state;  
@property(nullable,nonatomic,readonly) UIImage *currentThumbImage;  
@property(nullable,nonatomic,readonly) UIImage *currentMinimumTrackImage;  
@property(nullable,nonatomic,readonly) UIImage *currentMaximumTrackImage; 


//定制UISlider
- (CGRect)minimumValueImageRectForBounds:(CGRect)bounds;  //返回左边图片大小  
- (CGRect)maximumValueImageRectForBounds:(CGRect)bounds;  //返回右边图片大小  
- (CGRect)trackRectForBounds:(CGRect)bounds;              //返回滑道大小  


//我们通常通过重写（而不是主动调用）这个方法来控制滑块大小来消除我们改变滑块图片导致的两端缝隙
/**
 @bounds The bounding rectangle of the slider.
 @rect The drawing rectangle for the slider’s track, as returned by the `trackRectForBounds:` method.
 @value The current value of the slider.
 
 @return The computed drawing rectangle for the thumb image.
*/
- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value;  //返回滑块大小 


</code></pre>

<p>举个栗子：</p>

<pre><code class="language-objc">//自定义滑块图片后这样可以消除两端间隙
- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value
{
    rect.origin.x = rect.origin.x - 10 ;
    rect.size.width = rect.size.width +20;
    return CGRectInset ([super thumbRectForBounds:bounds trackRect:rect value:value], 10 , 10);
}

//还可以
-(CGRect)trackRectForBounds:(CGRect)bounds {
    bounds.origin.x=15;
    bounds.origin.y=bounds.size.height/3;
    bounds.size.height=bounds.size.height/5;
    bounds.size.width=bounds.size.width-30;
    returnbounds;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[隐式动画]]></title>
    <link href="https://acefish.github.io/14901598468257.html"/>
    <updated>2017-03-22T13:17:26+08:00</updated>
    <id>https://acefish.github.io/14901598468257.html</id>
    <content type="html"><![CDATA[
<p><code>CATransaction</code> 隐式动画<br/>
<code>CATransition</code> 过渡动画</p>

<p>我们在前面介绍了图层的相关知识,现在我们开始学本次的重点<strong>动画</strong><br/>
<strong>注意</strong><br/>
<code>CALayer</code>呈现图层&lt;--&gt;模型图层<br/>
我们在创建<code>CALayer</code>对象存储了我们设置的属性值（只是存值所以是模型图层）,但是模型图层显示或者说是呈现时就会基于模型图层创建一个呈现图层,然后我们所能看到的都是基于这个呈现图层的.</p>

<h3 id="toc_0">事务</h3>

<p><code>Core Animation</code>基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要你在<code>Core Animation</code>中手动打开，相反需要明确地关闭，否则他会一直存在。</p>

<p>当我们改变了<code>CALayer</code>的一个可做动画的属性时,但是他并不会立刻在屏幕上显示出来。它默认会从先前的值平滑过渡到新值,不需要做额外操作。这就是<code>隐式动画</code>,之所以叫<code>隐式</code>是因为我们并没有指定任何动画的类型.我们改变属性之后是<code>Core Animation</code>来决定如何并且何时去做动画（这是隐式当然也可以显式动画）.</p>

<p>隐式动画的动画执行的时间取决于当前<code>事务</code>的设置，动画类型取决于图层行为。</p>

<p><code>事务</code>是<strong><code>Core Animation</code>用来包含一系列属性动画集合的机制</strong>，当用事务去改变可以做动画的图层属性都不会立刻变化,而是等到这个事务提交之后,才开始图层属性过渡到新值的动画.</p>

<p>我们用<code>CATransaction</code>类来管理<code>事务</code>,这个类管理的事务并不能访问,也没有属性或者实例方法，并且也不能用<code>+alloc</code> 和<code>-init</code>方法创建它。但是可以用 <code>+begin</code> 和 <code>+commit</code> 分别来入栈或者出栈。</p>

<p>任何可以做动画的图层属性的改变都会被添加到目前<code>栈顶</code>的<code>事务</code>中.我们可以用<code>+setAnimationDuration:</code>设置 或者<code>+animationDuration</code>获取当前的栈顶事务的动画时间(默认0.25秒)</p>

<p><code>Core Animation</code>会在每个<code>run loop</code>周期中自动开始一次新的事务,，即使你不显式的用<code>[CATransaction begin]</code> 开始一次事务，任何在一次<code>run loop</code>循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。  </p>

<pre><code class="language-objc">/*我们在设置某个属性动画的事务属性（比如时间）时,我们通常会自己创建一个新的事务,
否则会有可能影响到事务中其他属性动画*/
[CATransaction begin];
//set the animation duration to 1 second
[CATransaction setAnimationDuration:1.0];

self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
//commit the transaction
[CATransaction commit];
</code></pre>

<p><strong>补充</strong><br/>
<code>UIView</code>有两个方法，<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>，就是通过设置 <code>CATransaction</code>实现的,至于UIView的另外一个<code>+animateWithDuration:animations:</code>，只是将这些属性动画做成了一个block以避免开发者由于对<code>+begin</code> 和<code>+commit</code> 匹配的失误.</p>

<h3 id="toc_1">完成块</h3>

<p>我们在做基于<code>UIView</code>的<code>block</code>动画时可以在动画结束时提供一个完成动作. <br/>
<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。</p>

<pre><code class="language-objc">[CATransaction begin];
[CATransaction setAnimationDuration:1.0];
[CATransaction setCompletionBlock:^{
//rotate the layer 90 degrees
CGAffineTransform transform = self.colorLayer.affineTransform;
transform = CGAffineTransformRotate(transform, M_PI_2);
self.colorLayer.affineTransform = transform;
}];
self.colorLayer.backgroundColor = [UIColor redColor];
[CATransaction commit];
/**
注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出
栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。
*/
</code></pre>

<h3 id="toc_2">图层行为</h3>

<p><code>UIKit</code>默认禁用了隐式动画.即UIView把它关联的图层属性改编动画特性关闭了</p>

<p>我们先来看一下<code>隐式动画</code>是怎么实现的:<br/>
<strong>我们把改变属性时<code>CALayer</code>自动应用的动画称作<code>行为</code>.</strong><br/>
当我们改变了<code>CALayer</code>的属性时，会调用<code>-actionForKey:</code>方法，传递属性的名称。然后</p>

<ul>
<li>图层首先检测它是否有委托，并且是否实现 CALayerDelegate 协议指定的 <code>-actionForLayer:forKey</code> 方法。如果有，直接调用并返回结果。</li>
<li>如果没有委托，或者委托没有实现<code>-actionForLayer:forKey</code>方法，图层接着检查包含属性名称对应行为映射的<code>actions</code>字典。</li>
<li>如果<code>actions</code>字典 没有包含对应的属性，那么图层接着在它的<code>style</code>字典接着搜索属性名。</li>
<li>最后，如果在 <code>style</code> 里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的<code>-defaultActionForKey:</code>方法。</li>
</ul>

<p><code>-actionForKey:</code>是用来找这个属性对应的动画(action),要么返回空（这种情况下将不会有动画发生），要么是<code>CAAction</code>协议对应的对象，最后<code>CALayer</code>拿这个结果去对先前和当前的值做动画。</p>

<p>UIKit禁用隐式动画的方法就是,：每个<code>UIView</code> 对它关联的图层都扮演了一个委托，并且提供了<code>-actionForLayer:forKey</code> 的实现方法。当不在一个动画块的实现中，<code>UIView</code> 对所有图层行为返回 <code>nil</code>，但是在动画<code>block</code>范围之内，它就返回了一个非空值。</p>

<p><strong>注意</strong><br/>
1. 这里所说的关联是指UIView关联的图层即宿主图层,而对于其他add的图层并不是关联的图层所以是没有禁用隐式动画的</p>

<p>当然对于<code>CATransacition</code>我们可以用<code>+setDisableActions:</code>来选择关闭/打开隐式动画<br/>
<code>[CATransaction setDisableActions:YES]; //关闭隐式动画</code></p>

<ul>
<li>UIView 关联的图层禁用了隐式动画，对这种图层做动画的办法就是使用 <code>UIView</code> 的动画函数（而不是依赖 <code>CATransaction</code> ），或者继承 <code>UIView</code> ，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画（具体细节见第八章）。</li>
<li>对于单独存在的图层，我们可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code> 字典来控制隐式动画(actions 字典可以写更少的代码)。</li>
</ul>

<p><code>行为</code>通常是一个被Core Animation隐式调用的显式动画对象。<br/>
我们来改变一个图层属性的行为:</p>

<pre><code class="language-objc">/**
我们使用的是一个实现了 CATransaction 的实例，叫做推进过渡
改变了CALayer的背景颜色属性行为.改变背景颜色，新的色块都是从左侧滑入，
而不是默认的渐变效果
*/
CATransition *transition = [CATransition animation];
transition.type = kCATransitionPush;
transition.subtype = kCATransitionFromLeft;
self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
//add it to our view
[self.layerView.layer addSublayer:self.colorLayer];
</code></pre>

<h3 id="toc_3">呈现与模型</h3>

<p>我们在改变一个<code>CALayer</code>的属性时，属性值确实会立即更新(这个属性值在设置时就会立刻生效)但是苹果并没有立即呈现出来。</p>

<p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<code>模型</code>。而<code>Core Animation</code>则负责根据图层<code>行为</code>和<code>事务设置</code>去更新视图的这些属性在屏幕上的状态.</p>

<p>我们的手机屏幕是每60秒重绘一次,如果我们要做的动画时长大于1/60,就需要在新值之前对屏幕重绘,即知道当前属性值.<strong>每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中</strong>,可以通过<code>-presentationLayer</code>方法来访问.</p>

<p>图层树(模型图层树)&lt;---&gt;呈现树:呈现树通过图层树中所有图层的呈现图层所形成。只有在图层首次在屏幕上呈现时候才会被创建,在之前获取呈现图层时会返回nil的.</p>

<p>在模型图层上调用<code>- presentationLayer</code>能获取呈现图层,同样的调用<code>–modelLayer</code>是会获取模型图层(通常是self).</p>

<p><img src="media/14901598468257/14903368056823.jpg" alt=""/></p>

<p>通常我们只需要和模型图层交互即可让<code>Core Animation</code>更新显示.<br/>
但是以下两种情况下呈现图层会很有效：  </p>

<ul>
<li>实现一个基于定时器的动画,而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果你想让你做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用 <code>-hitTest:</code> 会显得更有意义</li>
</ul>

<pre><code class="language-objc">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    //get the touch point
    CGPoint point = [[touches anyObject] locationInView:self.view];
    //check if we&#39;ve tapped the moving layer
    if ([self.colorLayer.presentationLayer hitTest:point]) {
        self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    } else {
        //otherwise (slowly) move the layer to new position
        [CATransaction begin];
        [CATransaction setAnimationDuration:4.0];
        self.colorLayer.position = point;
        [CATransaction commit];
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[蓝牙连接]]></title>
    <link href="https://acefish.github.io/14900564888280.html"/>
    <updated>2017-03-21T08:34:48+08:00</updated>
    <id>https://acefish.github.io/14900564888280.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1. 获取蓝牙信号强度</h4>

<p><img src="media/14900564888280/14900565184282.jpg" alt=""/></p>

<h4 id="toc_1">2. 后台读取蓝牙信号强度</h4>

<p>如果程序在后台还需要获取蓝牙蓝牙信号强度，那么肯定是需要支持后台的，要设置后台模式，设置<code>use bluetooth LE accessories</code>这样我们在后台就可以继续读取<code>RSSI</code>和回调了<br/>
<img src="media/14900564888280/14900567067529.jpg" alt=""/></p>

<p>在实际使用的过程当中，发现设置了后台模式后，读取<code>RSSI</code>的值持续时间不够长，读取一会就不继续读取了，后来各种测试发现，自己使用一个定时器持续读取蓝牙设备的<code>battery</code>，之所以读取<code>battery</code>，是因为设备的<code>service</code>中存在读取<code>battery</code>的<code>serviceID</code>。试验中，发现如果不定时读取该值，在后台运行的时候读取<code>RSSI</code>值就会中断</p>

<h4 id="toc_2">3.RSSI和距离关系</h4>

<p>根据RSSI值，得到设备与手机之间的距离公式大概如下:<br/>
<code>powe(10, (abs(rssi) - 59) / (10 * 2.0))</code>; <br/>
大概有这么一个关系，不是很准确。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1.weak是怎么实现的]]></title>
    <link href="https://acefish.github.io/14899954232802.html"/>
    <updated>2017-03-20T15:37:03+08:00</updated>
    <id>https://acefish.github.io/14899954232802.html</id>
    <content type="html"><![CDATA[
<p>在Objective-C中，用__weak修饰的指针，会在所指向的那个Objective-C对象被释放后，自动指向nil。</p>

<p>参考<a href="http://www.jianshu.com/p/fe9865814668">weak是怎么实现的</a></p>

<p>通俗的解释就是，在Objective-C的运行时环境中，维护了一种<strong>weak表</strong>，这张<strong>哈希表</strong>用对象的首地址作为键，将由若干个__weak修饰的指针自身的地址组成的数组作为值。当一个Objective-C对象被释放后，通过这个对象的起始地址来找到所有指向它的__weak指针，并将它们指向nil。</p>

<p>ARC下，编译器会生成一个全局的散列表数组，每个散列表的大小上限为128Byte，取这个数值也是为了和cache line size（64Byte）对齐，对于iOS系统，这个数组的大小为8*128（Byte），可以存放8张散列表<code>SideTable</code>结构体。<br/>
一个对象的首地址经过哈希之后可以确定这个对象映射到那个<code>SideTable</code>。<br/>
一个<code>SideTable</code>结构体中包含了一个<code>weak_table</code>:</p>

<pre><code class="language-objc">struct SideTable {
    //.......
    weak_table_t weak_table;
    //.......
};

struct weak_table_t {
    weak_entry_t *weak_entries;
    size_t    num_entries;
    uintptr_t mask;
    uintptr_t max_hash_displacement;
};
</code></pre>

<p>根据对象首地址查找weak_entry的方法为weak_entry_for_referent()，可以看到其中对对象首地址做了一次哈希，得到了对应的index。如果发生碰撞，则index依次+1，遍历整个数组，检查是否能获得正确的weak_entry_t对象。</p>

<pre><code class="language-objc">#define WEAK_INLINE_COUNT 4
struct weak_entry_t {
    DisguisedPtr&lt;objc_object&gt; referent;
    union {
        struct {
            weak_referrer_t *referrers;//就是这个weak指针指向的对象地址
            uintptr_t        out_of_line : 1;
            uintptr_t        num_refs : PTR_MINUS_1;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line=0 is LSB of one of these (don&#39;t care which)
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
};
</code></pre>

<p>其中的<code>weak_referrer_t</code>实际就是指向Objective-C对象的指针的地址的类型：</p>

<pre><code class="language-objc">typedef objc_object ** weak_referrer_t;
</code></pre>

<p>弱引用销毁过程:</p>

<p>在<code>runtime</code>的代码中，可以找到一个叫做<code>weak_clear_no_lock</code>的方法，它的注释表明，这个方法会被<code>dealloc</code>方法调用，然后将被销毁对象所对应的所有弱引用指针都置为<code>nil</code>。</p>

<p>过程:<br/>
1. 利用即将被销毁的对象的首地址，找到对应的weak_entry_t。<br/>
2. 从weak_entry_t对象中获取指向weak_referrer_t数组的指针。<br/>
3. 遍历这个数组，对于数组中的每个元素，检查是否真的指向即将被销毁的对象的首地址，如果是，则将它指向nil，如果不是则报错。<br/>
4. 释放这个weak_entry_t对象，并更新weak_table_t中的entry数目。如果有必要，对weak_table_t进行缩容。</p>

<p>补充:<br/>
当使用一个__weak指针时，<code>objc_loadWeakRetained()</code>和<code>objc_release()</code>函数都被调用了。</p>

<p>其中<code>objc_loadWeakRetained()</code>会调用<code>retainWeakReference</code>方法，如果某个类重写了<code>retainWeakReference</code>方法并返回<code>NO</code>，则这个<code>__weak</code>指针获取的就永远是<code>nil</code>了。</p>

<p>为什么需要在使用一个__weak指针时调用objc_loadWeakRetained()函数呢:是为了确保在使用这个__weak指针的过程中，指向的对象不被释放。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[专用图层]]></title>
    <link href="https://acefish.github.io/14896343426276.html"/>
    <updated>2017-03-16T11:19:02+08:00</updated>
    <id>https://acefish.github.io/14896343426276.html</id>
    <content type="html"><![CDATA[
<p>是Core Animation图层不仅仅能作用于图片和颜色而已。</p>

<p>补充点:<br/>
想UIView的图层上添加另外一个UIView的图层是会有两个UIVIew的（UIView的层级关系）<br/>
像一个纯Layer上添加另外一个UIView的图层,就仅仅只是添加了这个视图的图层,这个视图不会在视图的层级关系中体现.</p>

<h3 id="toc_0">CAShapeLayer</h3>

<p><code>CAShapeLayer</code> 是一个通过矢量图形而不是<code>bitmap</code>来绘制的图层子类.<br/><br/>
即<code>CAShapeLayer</code>与<code>CGPath</code>搭配来绘制图形.与用<code>Core Graphics</code>直接向原始的<code>CALyer</code>的内容中绘制一个路径相比：  </p>

<ul>
<li>渲染快速（ CAShapeLayer 使用了硬件加速）</li>
<li>高效使用内存（CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形）</li>
<li>不会被图层边界剪裁掉（CAShapeLayer 可以在边界之外绘制）</li>
<li>不会出现像素化（当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化）</li>
</ul>

<h4 id="toc_1">CGPath</h4>

<p><code>CGPath</code>来创建形状,一定要闭合,可以设置一些属性lineWith、lineCap 、lineJoin等,但是一个图层只有一次机会设置,如果想要想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。  </p>

<pre><code class="language-objc">//create shape layer
CAShapeLayer *shapeLayer = [CAShapeLayer layer];
shapeLayer.strokeColor = [UIColor redColor].CGColor;
shapeLayer.fillColor = [UIColor clearColor].CGColor;
shapeLayer.lineWidth = 5;
shapeLayer.lineJoin = kCALineJoinRound;
shapeLayer.lineCap = kCALineCapRound;
shapeLayer.path = path.CGPath;
</code></pre>

<h4 id="toc_2">圆角</h4>

<p>我们虽然可以用<code>CALayer</code>的<code>cornerRadius</code>可以设置圆角，但是我使用<code>CAShapeLayer</code>来单独指定每个角的形状.</p>

<pre><code class="language-objc">CGRect rect = CGRectMake(50, 50, 100, 100);
CGSize radii = CGSizeMake(20, 20);
UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;
//create path
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
</code></pre>

<p>然后我们可以通过这个图层路径绘制一个既有直角又有圆角的视图,如果我们想依照此图形来剪裁视图内容，我们可以把<strong><code>CAShapeLayer</code>作为视图的宿主图层</strong>，而不是添加一个子视图</p>

<h3 id="toc_3">CATextLayer</h3>

<p>如果我们想要在一个图层中显示文字,我们可以通过借助图层的代理,直接将字符串用<code>Core<br/>
Graphics</code>写入图层的内容--&gt;这就是UILabel实现  </p>

<p>如果不用上面的方式,我们还有比较简单的方式:<br/>
<code>Core Animation</code>提供了一个<code>CALayer</code>的子类<code>CATextLayer</code>，它以图层的形式包含了<code>UILabel</code>几乎所有的绘制特性，并且额外提供了一些新的特性。而且<code>CATextLayer</code>也要比 <code>UILabel</code> 渲染得快得多</p>

<pre><code class="language-objc">CATextLayer *textLayer = [[CATextLayer alloc] init];
    textLayer.frame = self.textLayerView.bounds;
    [self.textLayerView.layer addSublayer:textLayer];
    //用retina屏进行渲染,否则文字会像素化
    textLayer.contentsScale = [UIScreen mainScreen].scale;
    //颜色 默认黑色
    textLayer.foregroundColor = [UIColor yellowColor].CGColor;
    
    textLayer.alignmentMode = kCAAlignmentJustified;
    
    //这个属性为yes后为根据内容进行多行显示,Yes就是一行
    textLayer.wrapped = NO;
    
    UIFont *font = [UIFont systemFontOfSize:15];
    CFStringRef fontName = (__bridge CFStringRef)(font.fontName);
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    textLayer.font = fontRef;
    //字体大小是单独设置的
    textLayer.fontSize = 10;
    //设置显示字体
    textLayer.string = @&quot;zhe shi yi ge textLayer&quot;;
</code></pre>

<p><code>CATextLayer</code> 的 <code>font</code> 属性不是一个 <code>UIFont</code> 类型，而是一个 <code>CFTypeRef</code> 类型。这样可以根据你的具体需要来决定字体属性应该是用 <code>CGFontRef</code> 类型还是 <code>CTFontRef</code> 类型（<code>Core Text</code>字体）。</p>

<p>因为 <code>CTFontRef</code> 和 <code>CGFontRef</code> 并不像UIFont一样包含点大小，因此我们需要<strong>单独设置字体大小</strong>;</p>

<p>CATextLayer 的<code>string</code>属性是<code>id</code>类型的，因此我们可以用<code>NSString</code>和<code>NSAttributedString</code>来指定文本。  <strong>注意</strong>， <code>NSAttributedString</code> 并不是 <code>NSString</code> 的子类。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>

<h4 id="toc_4">富文本</h4>

<p>iOS6之后，苹果给UILabel和UIKit添加直接的属性字符串支持.从iOS3.2开始 CATextLayer 就已<br/>
经支持属性化字符串了(可以这样支持低版本 不过他吗太低了吧)。<br/><br/>
我们可以看下CATextLayer的富文本:</p>

<pre><code class="language-objc">//convert UIFont to a CTFont
CFStringRef fontName = (__bridge CFStringRef)font.fontName;
CGFloat fontSize = font.pointSize;
CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);

//set text attributes
NSDictionary *attribs = @{(__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor, 
(__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
[string setAttributes:attribs range:NSMakeRange(0, [text length])];

attribs = @{(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,
(__bridge id)kCTUnderlineStyleAttributeName:@(kCTUnderlineStyleSingle),(__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
[string setAttributes:attribs range:NSMakeRange(6, 5)];
//release the CTFont we created earlier
CFRelease(fontRef);
//set layer text
textLayer.string = string;

</code></pre>

<h4 id="toc_5">行距和字距</h4>

<p>由于绘制的实现机制不同（<code>Core Text</code>和<code>WebKit</code>），用 <code>CATextLayer</code> 渲染和用 <code>UILabel</code> 渲染出的文本行距和字距也不是不尽相同的。(影响不大)</p>

<h4 id="toc_6">UILabel替代品</h4>

<p>CATextLayer 比 UILabel 有着更好的性能表现,虽然UILabel很好用,但是如果我们非要找个UILabel替代品的话,有以下方法:</p>

<ol>
<li><p>继承 UILabel后添加一个子图层 CATextLayer 并重写显示文本的方法。<br/>
但是仍然会有由<code>UILabel</code>的<code>-drawRect:</code>方法创建的空寄宿图。而且由于CALayer不能自动布局,我们不能根据内容自动方法图层.</p></li>
<li><p>用 CATextLayer 作为宿主图层的 UILabel 子类<br/>
每一个 <code>UIView</code> 都是寄宿在一个 <code>CALayer</code> 的示例上。这个图层是由视图自动创建和管理的，这个图层一旦被创建就无法替代,但是我们可以继承了<code>UIView</code>，重写其<code>+layerClass</code>UIView 会在初始化的时候调用 +layerClass 方法，然后用它的返回类型来创建宿主图层。</p></li>
</ol>

<p>把 CATextLayer 作为宿主图层的另一好处就是视图自动设置了 contentsScale 属性。</p>

<p><strong>用 <code>+layerClass</code> 来创建基于不同图层的视图是一个简单可复用的方法</strong></p>

<h3 id="toc_7">CATransformLayer</h3>

<p>我们之前说过所有图层都把他的子图层平面化到一个场景中,因此没法做出3D的层级体系变换.<code>CALayer</code>中存在<code>CATransfromLayer</code>，它不同于一般图层，它不显示自己内容，只有当存在了一个能作用于子图层的变换它才真正存在。</p>

<p>我们在前面创建过一个立方体的固体对象,但是因为这次我们是向CATransformLayer上添加图层，而不是之前的<code>contaninView</code>,我们<strong>不能向一个没有寄宿图的图层上添加有寄宿图图层</strong>(就是不能向一个不是UIVIew的Layer中添加另外一个UIView的layer，否则在视图体系中显示的添加的这个不是视图而是图层),因此我们选择向<code>CATransfromLayer</code>添加立方体图层.</p>

<pre><code class="language-objc">//举一段代码栗子
//create cube layer
CATransformLayer *cube = [CATransformLayer layer];
//add cube face 1（添加立方体的一个面）
CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);
//[self faceWithTransform:ct] 这个方法根据Transform3D返回了一个这种变换的图层
[cube addSublayer:[self faceWithTransform:ct]];
//添加6个面后
...
//center the cube layer within the container
CGSize containerSize = self.containerView.bounds.size;
cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
/**
设置这个立方体的旋转（我们可以不用设置containerView的subTransform属性来进行立方体变换,而且可
以有几个立方体就能变换几种）
*/
cube.transform = transform;

//设置contaninView的sublayerTransform保证透视和灭点
CATransform3D pt = CATransform3DIdentity;
pt.m34 = -1.0 / 500.0;
self.containerView.layer.sublayerTransform = pt;
//将不同形状的cube添加
[self.containerView.layer addSublayer:cube1];
</code></pre>

<h3 id="toc_8">CAGradientLayer</h3>

<p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的（绘制使用了硬件加速）.<br/>
<code>CAGradientLayer</code>只适合做这种渐变没法定制,例如做环形渐变等,那样的话只能用<code>Core Graphic</code>了</p>

<h4 id="toc_9">基础渐变</h4>

<p>这是最简单的渐变,这些渐变色彩放在一个数组中，并赋给<code>colors</code>(<code>CGColorRef</code>类型)属性。</p>

<p>CAGradientLayer 也有<code>startPoint</code>和<code>endPoint</code>属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。</p>

<pre><code class="language-objc">CAGradientLayer *gradientLayer = [CAGradientLayer layer];
gradientLayer.frame = self.containerView.bounds;
[self.containerView.layer addSublayer:gradientLayer];
//set gradient colors
gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];
//set gradient start and end points
gradientLayer.startPoint = CGPointMake(0, 0);
gradientLayer.endPoint = CGPointMake(1, 1);
</code></pre>

<p><img src="media/14896343426276/14897191786083.jpg" alt=""/></p>

<h4 id="toc_10">多重渐变</h4>

<p><code>colors</code>属性是个数组,因此可以设置很多颜色的多重渐变.默认这些颜色在我们指定的空间是均匀渲染的,但是我们可以设置<code>location</code>属性来调整空间。<br/>
<code>location</code>属性浮点型数组(以<code>NSNumber</code>包装),是以单位坐标(针对做渐变区域的单位坐标)系进行标定。0.0代表着渐变的开始，1.0代表着结束。<br/>
<code>loaction</code>属性不一定非要设置,但是如果设置了,数组大小一定要与<code>colors</code>数组大小相同,否则会得到白色渐变.  </p>

<pre><code class="language-objc">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor blueColor].CGColor,(__bridge id)[UIColor greenColor].CGColor];
/**
    这个数组的意义是0.0-0.25为红色到黄色的渐变区域,0.25-0.5为黄色到绿色的渐变区域,
    0.5之后为绿色的完全区域
*/
    gradientLayer.locations = @[@(0.1),@(0.5),@(0.9)];
    gradientLayer.startPoint = CGPointMake(0.25, 0.25);
    gradientLayer.endPoint = CGPointMake(0.5, 0.5);
</code></pre>

<p><img src="media/14896343426276/14897305344880.jpg" alt=""/></p>

<h3 id="toc_11">CAReplicatorLayer</h3>

<p><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>

<h4 id="toc_12">重复图层</h4>

<p><code>instanceCount</code>属性指定了图层需要重复多少次<br/>
<code>instanceTransform</code> 指定了一个 <code>CATransform3D</code> 3D变换，复制图层在被创建时产生的和上一个制图层的位移(位移的锚点是<code>CAReplicatorlayer</code>的中心点)<br/>
<code>instanceDelay</code>在短时间内的复制延时,一般用在动画上(支持动画的延时)<br/>
 <code>preservesDepth</code>如果设置为YES,图层将保持于CATransformLayer类似的性质和相同的限制<br/>
 <code>instanceColor</code>设置这些复制图层的颜色,默认位白色(注意有可能会和要复制的图层的颜色冲突)<br/>
 变换是逐步增加的，每个实例都是相对于前一实例布局。因此这些复制体最终不会出现在同一位置上</p>

<pre><code class="language-objc">CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
replicator.frame = self.containerView.bounds;
[self.containerView.layer addSublayer:replicator];
//重复多少次
replicator.instanceCount = 10;

CATransform3D transform = CATransform3DIdentity;
transform = CATransform3DTranslate(transform, 0, 200, 0);
transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
transform = CATransform3DTranslate(transform, 0, -200, 0);
replicator.instanceTransform = transform;

replicator.instanceBlueOffset = -0.1;
replicator.instanceGreenOffset = -0.1;

CALayer *layer = [CALayer layer];
layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
layer.backgroundColor = [UIColor whiteColor].CGColor;
[replicator addSublayer:layer];

</code></pre>

<p>由于我们设置了<code>instanceBlueOffset</code>和 <code>instanceGreenOffset</code>属性.的颜色也在变化.除了这两个还有<code>instanceBlueOffset</code> <code>instanceAlphaOffset</code>这都是改变某个颜色通道的值</p>

<p><code>CAReplicatorLayer</code> 真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了 <code>CAEmitterLayer</code> ，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：<code>反射</code>。</p>

<h4 id="toc_13">反射</h4>

<p>创建一个指定视图的镜像照片,我们只需要使用<code>CAReplicatorLayer</code>并用一个负比例变换创建一个复制图层即可.</p>

<pre><code class="language-objc">+ (Class)layerClass
{
return [CAReplicatorLayer class];
}
- (void)setUp
{
//configure replicator
CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;
layer.instanceCount = 2;
//move reflection instance below original and flip vertically
//核心代码是这个动画
CATransform3D transform = CATransform3DIdentity;
CGFloat verticalOffset = self.bounds.size.height + 2;
transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
transform = CATransform3DScale(transform, 1, -1, 0);
layer.instanceTransform = transform;
//reduce alpha of reflection layer
layer.instanceAlphaOffset = -0.6;
}
- (id)initWithFrame:(CGRect)frame
{
//this is called when view is created in code
if ((self = [super initWithFrame:frame])) {
[self setUp];
}
return self;
}
- (void)awakeFromNib
{
//this is called when view is created from a nib
[self setUp];
}
</code></pre>

<p>这个镜像的是整个ReflectView视图内容(是视图层次)<br/>
因为现在这个VIew的layer已经变为<code>CAReplicatorLayer</code>所以我们对这个layer本身改变什么是不会镜像的,当然如果add的Layer内容也会被镜像</p>

<p>大神写的自适应渐变淡出效果的<a href="https://github.com/nicklockwood/ReflectionView">ReflectView</a></p>

<h3 id="toc_14">CAScrollLayer</h3>

<p>之前我们显示大图层中的一小部分是使用图层的<code>contentRect</code>属性,但是如果我们想要滑动可视区域的话这样就不是很好的办法.</p>

<p><code>CALayey</code>提供了一个子类<code>CAScrollLayer</code>.<br/>
 <code>CAScrollLayer</code> 有一个 <code>-scrollToPoint:</code>方法，它自动适应 <code>bounds</code> 的原点以便图层内容现在滑动的地方。</p>

<p>因为<code>Core Animation</code>是不处理用户输入的,所以<code>CAScrollLayer</code>并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹.</p>

<pre><code class="language-objc">//来用 CAScrollLayer 来常见一个基本的 UIScrollView 替代品
+ (Class)layerClass
{
    return [CAScrollLayer class];
}
//添加平移手势
//在平移手势中滚动视图
CGPoint offset = self.bounds.origin;
offset.x -= [recognizer translationInView:self].x;
offset.y -= [recognizer translationInView:self].y;
//scroll the layer
[(CAScrollLayer *)self.layer scrollToPoint:offset];
//reset the pan gesture translation
[recognizer setTranslation:CGPointZero inView:self];
//当然我们可以自己做边界检查
</code></pre>

<p>其实<strong><code>UIScrollView</code> 并没有用 <code>CAScrollLayer</code></strong>，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>

<p>那么这个<code>CAScrollLayer</code>的作用是什么呢?<br/>
在<code>CAScrollerLayer</code>的头文件中有一个<code>CALayer (CALayerScrolling)</code>的扩展分类,实现了一些：</p>

<pre><code class="language-objc">- (void)scrollPoint:(CGPoint)p;
- (void)scrollRectToVisible:(CGRect)r;
@property(readonly) CGRect visibleRect;
</code></pre>

<p>其实这些方法或者属性并不是给<code>CALayer</code>添加了滑动功能,事实上他们只是放置在<code>CAScrollLayer</code>中的图层的实用方法,<code>scrollPoint:</code>方法从图层树中查找并找到第一个可用的<code>CAScrollLayer</code>，然后滑动它使得指定点成为可视的。<code>scrollRectToVisible:</code>方法实现了同样的事情只不过是作用在一个矩形上的。<code>visibleRect</code> 属性决定图层（如果存在的话）的哪部分是当前的可视区域。当涉及到实现图层滑动的时候就可以用上了</p>

<h3 id="toc_15">CATiledLayer</h3>

<p>我们有可能会需要加载一张高像素图片,这时候我们不适合读取整张图片到内存中,因为载入大图会非常的慢,将会阻塞线程造成卡顿.<br/>
能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为<code>OpenGL</code>纹理，同时<code>OpenGL</code>有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为<code>Core Animation</code>强制用CPU处理图片而不是更快的GPU</p>

<p>这时候我们可以用<code>CATiledLayer</code>,它可以将大图分解成小片然后将他们单独按需载入<br/>
<strong>CATiledLayer 很好地和 UIScrollView 集成在一起。</strong></p>

<pre><code class="language-objc">- (void)viewDidLoad
{
    [super viewDidLoad];
    //add the tiled layer
    
    /**
    CATiledLayer 很好地和 UIScrollView 集成在一起。除了设置图层和滑动视图边界
    以适配整个图片大小，我们真正要做的就是实现 -drawLayer:inContext: 方法，当
    需要载入新的小图时， CATiledLayer 就会调用到这个方法。
    */
    
    CATiledLayer *tileLayer = [CATiledLayer layer];
    tileLayer.frame = CGRectMake(0, 0, 2048, 2048);
    tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];
    //configure the scroll view
    self.scrollView.contentSize = tileLayer.frame.size;
    //draw layer
    [tileLayer setNeedsDisplay];
}
- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //determine tile coordinate
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);
    //load tile image
    NSString *imageName = [NSString stringWithFormat: @&quot;Snowman_%02i_%02i&quot;, x, y];
    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;jpg&quot;];
    
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];
    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:bounds];
    UIGraphicsPopContext();
}
</code></pre>

<p><code>CATiledLayer</code> 的默认以淡入的方式载入小图,可以用 <code>fadeDuration</code> 属性改变淡入时长或直接禁用<br/>
掉。</p>

<p><code>CATiledLayer</code> （不同于大部分的<code>UIKit</code> 和<code>Core Animation</code>方法）支持多线程绘制，<code>-drawLayer:inContext:</code>方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。</p>

<p><strong>补充</strong><br/>
我们在使用<code>CATiledLayer *tileLayer = [CATiledLayer layer];</code>时载入图片并不是以以Retina的分辨率显示,我们可以<code>tileLayer.contentsScale = [UIScreen mainScreen].scale;</code>我们只需要设<br/>
置了<code>CATiledLayer</code>的<code>contentsScale</code>即可(因为size是以像素为单位的,所以改变了contentsScale 就自动有了默认的小图尺寸),而不需要手工更新小图的尺寸或是在<code>Retina</code>分辨率下指定一个不同的小图。</p>

<p>我们需要做的是适应小图渲染代码以对应安排 <code>scale</code>的变化</p>

<pre><code class="language-objc">CGRect bounds = CGContextGetClipBoundingBox(ctx);
CGFloat scale = [UIScreen mainScreen].scale;
NSInteger x = floor(bounds.origin.x / layer.tileSize.width * scale);
NSInteger y = floor(bounds.origin.y / layer.tileSize.height * scale);
</code></pre>

<h3 id="toc_16">CAEmitterLayer</h3>

<p>iOS后引入了一个新的 <code>CALayer</code> 子类叫做 <code>CAEmitterLayer</code><br/>
<code>CAEmitterLayer</code> 是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果</p>

<p><code>CAEmitterLayer</code>是很多<code>CAEmitterCell</code>的容器.这些<code>CAEmitierCell</code>定义了一个粒子效果.我们就是为不同的粒子效果定义一个或多个<code>CAEmitterCell</code>作为模版，同时<code>CAEmitterLayer</code>负责基于这些模版实例化一个粒子流。</p>

<p><code>CAEmitterCell</code>它有一个<code>contents</code>属性可以定义为一个<code>CGImage</code>，还有一些可设置属性控制着表现和行为。<br/>
举个栗子:</p>

<pre><code class="language-objc">- (void)viewDidLoad
{
    [super viewDidLoad];
    //create particle emitter layer
    CAEmitterLayer *emitter = [CAEmitterLayer layer];
    emitter.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:emitter];
    //configure emitter
    emitter.renderMode = kCAEmitterLayerAdditive;
    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);
    //create a particle template
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
    cell.alphaSpeed = -0.4;
    cell.velocity = 50;
    cell.velocityRange = 50;
    cell.emissionRange = M_PI * 2.0;
    //add particle template to emitter
    emitter.emitterCells = @[cell];
}
@end
</code></pre>

<p><code>CAEMitterCell</code>的属性基本上可以分为三种：</p>

<ul>
<li>这种粒子某一属性的初始值。比如，<code>color</code>属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</li>
<li>粒子某一属性的变化范围。比如<code>emissionRange</code>属性的值是2π，这意味着粒子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</li>
<li>指定值在时间线上的变化。比如，在示例中，我们将<code>alphaSpeed</code>设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐消失的效果。</li>
</ul>

<p><code>CAEmitterLayer</code>的属性它自己控制着整个例子系统的位置和形状。一些属性比如 <code>birthRate</code>， <code>lifetime</code>和<code>celocity</code>，这些属性在<code>CAEmitterCell</code>中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。</p>

<ul>
<li><code>preservesDepth</code>，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</li>
<li><code>renderMode</code>，控制着在视觉上粒子图片是如何混合的。示例中我们把它设置为<code>kCAEmitterLayerAdditive</code> ，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的<code>kCAEmitterLayerUnordered</code>，效果就没那么好看了</li>
</ul>

<p><strong>注意</strong><br/>
之前我们学习了<code>CAReplicatorLayer</code> 它的真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云,或者反射等</p>

<h3 id="toc_17">CAEAGLLayer</h3>

<p>再议</p>

<h3 id="toc_18">AVPlayerLayer</h3>

<p>它不是<code>Core Animation</code>框架的一部分，是在<code>AVFoundation</code>框架中的,但是它，提供了一个<code>CALayer</code> 子类来显示自定义的内容类型.</p>

<p><code>AVPlayerLayer</code> 是用来在iOS上播放视频的。他是高级接口例如<code>MPMoivePlayer</code>的底层实现，提供了显示视频的底层控制。</p>

<p><code>AVPlayerLayer</code>的使用相当简单：你可以用<code>+playerLayerWithPlayer:</code>方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用<code>player</code>属性绑定一个<code>AVPlayer</code>实例。</p>

<pre><code class="language-objc">- (void)viewDidLoad
{
    [super viewDidLoad];
    //get video URL
    NSURL *URL = [[NSBundle mainBundle] URLForResource:@&quot;Ship&quot; withExtension:@&quot;mp4&quot;];
    //create player and player layer
    AVPlayer *player = [AVPlayer playerWithURL:URL];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
    //set player layer frame and attach it to our view
    playerLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:playerLayer];
    //play the video
    [player play];
}
</code></pre>

<p><strong>注意</strong><br/>
因为Core Animation并不支持自动大小和自动布局,因此我们要考虑<code>AVPlayerLayer</code>添加到自己创建的视图View而不是直接加到控制器的View</p>

<p>因为<code>AVPlayerLayer</code>是<code>CALayer</code>的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频(我们可以对Layer进行3D，圆角，有色边框，蒙板，阴影等)。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[变换]]></title>
    <link href="https://acefish.github.io/14894054496048.html"/>
    <updated>2017-03-13T19:44:09+08:00</updated>
    <id>https://acefish.github.io/14894054496048.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">仿射变换</h3>

<p><code>UIView</code>的<code>transform</code>属性是一个<code>CGAffineTransform</code>类型，用于二维空间的旋转，缩放和平移.  </p>

<p><code>CGAffineTransform</code>是一个可以和二维空间向量（例如 CGPoint ）做乘法的3X2的矩阵；</p>

<p><img src="media/14894054496048/14894062959368.jpg" alt=""/></p>

<p>上图中的灰色数值只是为了保证<code>左边列数与右边行数相同</code>可以做矩阵运算，其计算结果不保留也没有任何意义  </p>

<h4 id="toc_1">CGAffineTransform</h4>

<pre><code class="language-objc">CGAffineTransformMakeRotation(CGFloat angle)
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)
/**
旋转和缩放变换都可以很好解释--分别旋转或者缩放一个向量的值。平移变换是指
每个点都移动了向量指定的x或者y值--所以如果向量代表了一个点，那它就平移了
这个点的距离。
*/
</code></pre>

<p><strong>注意</strong><br/><br/>
<code>UIView</code>可以通过设置<code>tranform</code>属性变换,它只是封装了内部的图层变换  </p>

<p><code>CALayer</code>也有<code>transfrom</code>属性，它的类型是<code>CATransfrom3D</code>并不是<code>CGAffiTransfrom</code>  </p>

<p><code>CALayer</code>对应UIView的<code>transform</code>属性的是<code>affineTransform</code>  </p>

<p><code>CGAffiTransfrom</code>一看名字就是基于<code>Core Graphics</code>的</p>

<pre><code class="language-objc">#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0)
//一个pi代表180°
CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);
self.layerView.layer.affineTransform = transform;
</code></pre>

<h4 id="toc_2">混合变换</h4>

<p><code>Core Graphics</code>提供了可在一个一个变换基础上做其他变化的函数  </p>

<pre><code class="language-objc">CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
</code></pre>

<p>还有一个例外的：<br/><br/>
<code>CGAffineTransformIdentity</code>这是一个什么都不做的变换, <code>CGAffineTransform</code> 类型的空值,即单位矩阵。</p>

<pre><code class="language-objc">//要混合两个已经存在的变换矩阵，做一个新的变换
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre>

<p><strong>注意</strong><br/><br/>
当我们按顺序进行一些列变换的时候，变换的顺序是会影响结果的，比如旋转之后的平移和平移之后的旋<br/>
转结果可能不同。</p>

<h3 id="toc_3">3D变换</h3>

<p><code>CGAffineTransform</code> 类型属于<code>Core Graphics</code>框架.因为<code>Core Graphics</code>是一套2D绘图的API，因此仅仅对2D变换有效.  </p>

<p>CALayer的<code>transform</code>属性(<code>CATransform3D</code>类型),可以让图层进行3D移动或者旋转  </p>

<p>和CGAffiTranform类似,<code>CATransform3D</code>也是一个矩阵（在3维空间做变换的4*4矩阵）  </p>

<p><img src="media/14894054496048/14894686780778.jpg" alt=""/></p>

<p><code>Core  Animation</code>框架也有为我们提供一系列方法来创建和组合<code>CATransform3D</code>类型的矩阵，与CGAffiTransform不同的是其平移和缩放多了参数<code>z</code> 旋转 多了<code>x.y.z</code></p>

<pre><code class="language-objc">CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz)
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)
</code></pre>

<p>举个栗子:  </p>

<pre><code class="language-objc">//绕Y轴旋转45度
CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
self.layerView.layer.transform = transform;
</code></pre>

<p><img src="media/14894054496048/14894705472205.jpg" alt=""/></p>

<p><strong>这样的效果看起来并没有旋转而只是水平方向的压缩,这是因为我们用斜的视角看它，并不是透视</strong></p>

<h4 id="toc_4">透视投影</h4>

<p>我们在上面做的变换是等距投影：远处的物体和近处的物体保持同样的缩放比例  </p>

<p>正常情况是物体远离我们由于视角原因会变小才对  我们需要引入<code>投影变换（z变换）</code>来对矩阵做一些修改，<code>Core Animation</code>并没有提供<code>透视变换</code>函数，我们需要手动改动矩阵(easy):  </p>

<p><img src="media/14894054496048/14894710925730.jpg" alt=""/></p>

<p>**m34 默认为0，我们可以设置其为<code>-1/d</code>来应用透视效果(d为视角和屏幕距离,估算测试一下就ok了,大概500-1000,值越小透视效果越明显但是太小会失真，太大又几乎失去透视效果) **</p>

<p>举个栗子:</p>

<pre><code class="language-objc">CATransform3D transform = CATransform3DIdentity;
//apply perspective  我曹 真的直接m34就行了
transform.m34 = - 1.0 / 500.0;
//rotate by 45 degrees along the Y axis
transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);
//apply to layer
self.layerView.layer.transform = transform;
</code></pre>

<h4 id="toc_5">灭点</h4>

<p>在透视绘图时我们说当远离视角的物体会变小,当远到一个极限的时候就会变陈一个点,最终所有物体都会汇聚消失在这同一个点.  即<strong>灭点</strong></p>

<p>在现实中，这个点通常是视图的中心,或者至少是包含所有3D对象的视图中心 </p>

<p><code>Core Animation</code>定义了这个点位于变换图层的<code>anchorPoint</code>（通常位于图层中心，但也有例外）<br/><br/>
这就是说，当图层发生变换时，这个点永远位于图层变换之前<code>anchorPoint</code>的位置。</p>

<p><img src="media/14894054496048/14894744252171.jpg" alt=""/></p>

<p><strong>注意</strong><br/><br/>
当改变一个图层的<code>position</code>，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整 <code>m34</code> 来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（做平移变换是不会改变position的）（而不是直接改变它的<code>position</code>）灭点会处于变化之前的位置,这样的话就能保证所有的3D图层都共享一个灭点。</p>

<h4 id="toc_6">sublayerTransform</h4>

<p>根据上面知识,如果我们多个视图做3D变换,我们需要分别改变其M34并且确保在变换前同一个<code>position</code>,而且我们不能直接在xib中摆放视图,这样就很麻烦了   </p>

<p>CALayer有个属性<code>sublayerTransform</code>.也是<code>CATransform3D</code>类型的,但是它会影响到所有子图层,即我们可以通过设置图层的这个属性来使所有子视图做同样的变换，而且确保了所有子图层灭点在容器图层的中点处.</p>

<p><strong>容器图层做变换时其上图层也都会做变换的,只不过我们如果不设置容器图层的<code>sublayerTransform</code>属性的话，子图层要在做3D变换的话还要再设置m34而且要保证灭点，也就是这个属性作用就只是保证其上的子图层的m34和灭点与父图层一致</strong><br/>
<strong>这个属性对于容器视图来说与transform属性没有什么区别，都是做一个变换</strong></p>

<p><strong>注意</strong><br/><br/>
我们通常设置最大视图的<code>sublayerTransform</code>为<code>CATransform3DIdentity;</code> 这样在其上的子视图可以随意进行3D变换都可保证其灭点位置在同一个位置.  </p>

<h4 id="toc_7">背面</h4>

<p>因为我们做的变换是透视的，我们可以从背面观察这张图像，发现其背面为正面图片的镜像图片,可以知道图层是<code>双面绘制的</code><br/>
有时候我们是永远都看不到图层的背面,所以我们没必要浪费<code>CPU</code>来绘制  </p>

<p><code>CALayer</code>有一个叫做 <code>doubleSided</code> 的属性来控制图层的背面是否要被绘制。<code>BOOL</code>类型,当设置为NO时，如果图层正面从视角中消失，这个图层将不会被绘制.</p>

<p><img src="media/14894054496048/14895754324911.jpg" alt=""/></p>

<h4 id="toc_8">扁平化图层</h4>

<p>我们在做二维变换（用CATranform3D绕z轴旋转也是二维变换）知道当我们做个相反变换的时候是可以将图层或视图恢复原状的。</p>

<p><img src="media/14894054496048/14895772744163.jpg" alt=""/><br/>
如上图,外部图层旋转45度后内部图层反向旋转45度是可以恢复正常状态的  </p>

<p>那么对于3D变换：</p>

<p>我们将外面图层绕Y旋转,然后将内图层绕Y反向旋转<br/><br/>
结果:<br/>
<img src="media/14894054496048/14895796219311.jpg" alt=""/></p>

<p>我们可以看到,内部的图层仍然向左侧旋转，并且发生了扭曲。</p>

<p>这是因为<code>Core Animation</code>内的图层并不都存在同一个3D空间.<strong>每个图层的3D场景其实是扁平化的</strong>，你所看到的3D场景只是绘制在图层表面。</p>

<p>也是因为如此:用<code>Core Animation</code>创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系--在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。在之后我们会用<code>CATransformLayer</code>的子类来解决这个问题</p>

<h3 id="toc_9">固体对象</h3>

<p>一个固态的3D对象  </p>

<p>我们来创建一个固体对象:</p>

<pre><code class="language-objc">//创建固体对象

- (void)three_dimensionaObject {
    CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;
    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);
    self.containView.layer.sublayerTransform = perspective;
    //add cube face 1
    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);
    [self addFaceWith:0 transform:transform];
    
    transform = CATransform3DMakeTranslation(100, 0, 0);
    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
    [self addFaceWith:1 transform:transform];
    
    transform = CATransform3DMakeTranslation(-100, 0, 0);
    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
    [self addFaceWith:2 transform:transform];
    
    transform = CATransform3DMakeTranslation(0, 100, 0);
    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
    [self addFaceWith:3 transform:transform];
    
    transform = CATransform3DMakeTranslation(0, -100, 0);
    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
    [self addFaceWith:4 transform:transform];
    
    transform = CATransform3DMakeTranslation(0, 0, -100);
    [self addFaceWith:5 transform:transform];
}

- (void)addFaceWith:(NSInteger)index transform:(CATransform3D)transform {
    UIView *layV = [self.layViewCollection objectAtIndex:index];
    [self.containView addSubview:layV];
    CGSize containerSize = self.containView.bounds.size;
    layV.center = CGPointMake(containerSize.width / 2.0, containerSize.height/2);
    layV.bounds = CGRectMake(0, 0, 200, 200);
    layV.layer.transform = transform;
}
</code></pre>

<h4 id="toc_10">光亮和阴影</h4>

<p>由于我们只是简单几个图层的拼接,所以这个立体对光线并没有概念(没有棱角).我们需要自己做这个立体的阴影效果.  </p>

<ul>
<li>我们可以直接以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。<br/></li>
<li>如果需要动态地创建光线效果，可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层.但为了计算阴影图层的不透明度，你需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</li>
</ul>

<p>为了达到第二种效果:<br/><br/>
我们这里用<code>GLKit框架</code>来做向量的计算.(需要引入<code>GLKit</code>库来运行代码)每个面的<code>CATransform3D</code>都被转换成<code>GLKMatrix4</code>，然后通过<code>GLKMatrix4GetMatrix3</code>函数得出一个3×3的旋转矩阵。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值</p>

<h4 id="toc_11">点击事件</h4>

<p><img src="media/14894054496048/14896328584294.jpg" alt=""/></p>

<p>我们对于上面的固体对象,并不能点击3触发事件,这是因为我们添加视图时4.5.6是在3之前添加的,点击事件的处理由视图在父视图中的顺序决定，而不是3D空间的z轴顺序.因此即使我们此时看不到4.5.6,但是荏苒会拦截点击事件.  </p>

<p><code>doubleSided</code>属性可以控制是否绘制视图后面的内容,但是设置这个属性为NO不起作用，因为即使背对相机而隐藏的视图仍然会响应点击事件(这和通过设置 hidden 属性或者设置 alpha 为0而隐藏的视图不同，那两种方式将不会响应事件).</p>

<p>我们正确方式是:<br/>
* 把除了表面3的其他视图 userInteractionEnabled 属性都设置成 NO 来禁止事件传递<br/>
* 简单通过代码把视图3覆盖在视图6上<br/>
* 等等</p>

<p><strong>视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图层几何学、视觉效果]]></title>
    <link href="https://acefish.github.io/14892022301750.html"/>
    <updated>2017-03-11T11:17:10+08:00</updated>
    <id>https://acefish.github.io/14892022301750.html</id>
    <content type="html"><![CDATA[
<p>遗忘点:<br/>
1. 用作mask的layer不一定非要静态的,只要有layer的都可以作为蒙版</p>

<p>2.<code>-hitTest:</code>同样接受一个 CGPoint 类型参数,返回的是图层本身或者包含这个坐标点的叶子节点图层.如果这个点在最爱曾图层范围外,返回nil；我们常用这个方法获取点击位置的视图（判断点击在了哪个视图）</p>

<pre><code>CALayer *layer = [self.layerView.layer hitTest:point];
</code></pre>

<h2 id="toc_0">图层几何学</h2>

<h3 id="toc_1">布局</h3>

<p>UIView布局属性:<code>frame</code> <code>bounds</code> <code>center</code><br/><br/>
与之对应<br/>
CALayer布局属性:<code>frame</code> <code>bounds</code> <code>position</code><br/>
center和postion是一样的值，都代表了相对于父图层 <code>anchorPoint</code> 所在的位置</p>

<p>视图的布局属性仅仅是存取方法，对其进行改变其实是改变视图下方CALayer的frame  </p>

<p>视图或者图层的frame是根据其bounds，position和transform计算而来的，其中任意一值发生改变都会导致其frame改变  </p>

<p><img src="media/14892022301750/14892031426669.jpg" alt=""/></p>

<h3 id="toc_2">锚点</h3>

<p>视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。</p>

<p><code>anchorPoint</code>是用来移动图层的把柄</p>

<p>默认<code>anchorPoint</code>是在图层的中心,这个属性UIView并没有暴露出来,这也是视图的<code>position</code>属性被叫做“center”的原因。但是图层的锚点可以移动，锚点的移动会导致frame的改变即位置改变</p>

<p><img src="media/14892022301750/14893741880682.jpg" alt=""/></p>

<p>anchorPoint也是单位坐标，默认是{0.5，0.5}，可以通过指定大于或者小于1，使其在图层范围之外</p>

<p>改变<code>anchorPoint</code>常用于做不随着中心点做动画的动画使用,比如 时钟的表针旋转</p>

<p><strong>注意</strong><br/>
中心和锚点（即position或者center和anchorPoint没有任何关系），锚点的改变不会影响中心点位置，只会影响frame</p>

<h3 id="toc_3">坐标系转换</h3>

<p>CALayer提供了转换坐标系的方法（视图也有）</p>

<pre><code class="language-objc">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;
- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;
- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;
- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;
</code></pre>

<h3 id="toc_4">Z坐标</h3>

<p>UIView是二维坐标 而CALayer则是三维的<br/><br/>
因此CALayer还有两个属性:<code>zPosition</code> <code>anchorPointZ</code> 在Z轴上描述图层位置的浮点类型<br/>
<code>zPosition</code>最实用的功能就是改变图层的显示顺序了，一般给图层增加<code>1.f</code>就可以控制显示顺序了</p>

<h3 id="toc_5">HIT Testing</h3>

<p><code>CALayer</code>并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。    </p>

<p><code>-containsPoint:</code> 接受一个在本图层坐标系吓得一个CGPoint，如果这个点在图层frame内就返回YES。注意必须将这个点转为每个图层坐标系下的坐标</p>

<p><code>-hitTest:</code>同样接受一个 CGPoint 类型参数,返回的是图层本身或者包含这个坐标点的叶子节点图层.如果这个点在最爱曾图层范围外,返回nil；</p>

<pre><code class="language-objc">//举个栗子
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    //get touch position
    CGPoint point = [[touches anyObject] locationInView:self.view];
    //get touched layer
    //获取这个点击的layer
    CALayer *layer = [self.layerView.layer hitTest:point];
    //get layer using hitTest
    if (layer == self.blueLayer) {
        [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil] show];
    } else if (layer == self.layerView.layer) {
        [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;
        message:nil
        delegate:nil
        cancelButtonTitle:@&quot;OK&quot;
        otherButtonTitles:nil] show];
    }
}

</code></pre>

<p><strong>注意</strong></p>

<ol>
<li>当调用图层的<code>-hitTest:</code>方法时，测算的顺序严格依赖于图层树当中的图层顺序（和<code>UIView</code>处理事件类似）。之前提到的<code>zPosition</code>属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。<br/></li>
<li>这两个方法是layer的实例方法 我们可以直接用layer调用而不需要作为系统判断方法</li>
</ol>

<h3 id="toc_6">自动布局</h3>

<p>对于UIView如果想要自动布局我们可以使用<code>UIViewAutoresizingMask</code>  和<code>NSLayoutConstraint</code>API<br/><br/>
CALayer没有自动布局办法<br/>
如果想要随意控制CALayer的布局，我们可以用CALayerDelegate方法:  </p>

<pre><code class="language-objc">- (void)layoutSublayersOfLayer:(CALayer *)layer;
/**当图层的 bounds 发生改变，或者图层的 -setNeedsLayout 方法被调用的时候，这个函数将会被执
行。（但是也没法做大自适应屏幕等自动布局,这也是为什么我们用UIView来布局）*/
</code></pre>

<h2 id="toc_7">视觉效果</h2>

<h3 id="toc_8">圆角</h3>

<p>CALayer有一个叫做<code>conrnerRadius</code>的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角）,默认这个值不影响背景图片或者子图层,但是如果设置<code>maskToBounds</code>为<code>YES</code>,图层中东西都会被截取.</p>

<h3 id="toc_9">图层边框</h3>

<p><code>borderWidth</code>和<code>borderColor</code>，这条线（stroke）沿着图层的bounds绘制,同时也包含图层的角.<br/>
<code>borderWith</code>以点为单位的浮点数<br/><br/>
<code>borderColor</code>边框的颜色默认黑色,<code>CGColorRef</code>类型，不是UIColor所以不是<code>Cocoa</code>内置对象  </p>

<pre><code class="language-objc">// CGColorRef 属性即便是强引用也只能通过assign关键字来声明
@property(nullable) CGColorRef borderColor;
</code></pre>

<p><strong>注意</strong></p>

<ol>
<li>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。（这个之前是显示最前而不是在最前绘制被遮盖）</li>
<li>边框是跟随图层的边界变化的，而不是图层里面的内容</li>
<li>
<img src="media/14892022301750/14893838391060.jpg" alt=""/></li>
</ol>

<h3 id="toc_10">阴影</h3>

<p><code>shadowOpacity</code>默认0。他是一个必须在<code>0.0</code>（不可见）和<code>1.0</code>（完全不透明）之间的浮点数。  </p>

<p>阴影的另外三个属性:<br/><br/>
<code>shadowColor</code>控制阴影的颜色，和 borderColor 和 backgroundColor 一样，它的类型也是 CGColorRef，默认黑色<br/><br/>
<code>shadowOffset</code>阴影的方向和距离 CGSize类型，宽度为阴影横向位移，高度为纵向位移，默认{0,-3},即相对Y轴有3个点的向上位移<br/><br/>
<code>shadowRadius</code>控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。我们推荐为大于0的值,值越大阴影越模糊,图层层次更明显.</p>

<p><img src="media/14892022301750/14893848191222.jpg" alt=""/></p>

<h4 id="toc_11">阴影裁剪</h4>

<p>与边框不同,图层的阴影继承自内容的外形，CoreAnimation会将寄宿图（包括子视图）来结合图层形状创建一个阴影。<br/><br/>
但是由于他们的不同,我们在包括子图层创建阴影后,如果按照边框进行裁剪就会导致部分阴影没有了，这时候我们只能额外创建一个裁剪后的图层形状的阴影图层（可以作为最外层的父图层）来实现效果。</p>

<h3 id="toc_12">shadowPath属性</h3>

<p>因为实时计算阴影是非常消耗资源的,我们可以通过事先指定<code>shadowPath</code>来提高性能.<code>shadowPath</code>是一个<code>CGPathRef</code>类型（一个指向<code>CGPath</code>的指针）。<code>CGPath</code> 是一个<code>Core Graphics</code>对象，用来指定任意的一个矢量图形。我们可以用这个属性在图层形状之外指定阴影形状.  </p>

<p>举个栗子:</p>

<pre><code class="language-objc">
CGMutablePathRef squarePath = CGPathCreateMutable();
CGPathAddRect(squarePath, NULL, self.layerView1.bounds);
self.layerView1.layer.shadowPath = squarePath;
//需要我们手动释放
CGPathRelease(squarePath);
//create a circular shadow
CGMutablePathRef circlePath = CGPathCreateMutable();
CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);
self.layerView2.layer.shadowPath = circlePath; 
CGPathRelease(circlePath);
</code></pre>

<p><code>CGPath</code>适合搭建比较简单的形状,比如举行或者圆,但是如果是复杂的图形推荐<strong>使用<code>UIBezierPath</code></strong>，它是一个由UIKit提供的在<code>CGPath</code>基础上的<code>Objective-C</code>包装类</p>

<h3 id="toc_13">图层蒙版</h3>

<p>CALayer的<code>mask</code>属性是一个CALayer类型,它类似于一个自图层，mask图层定义了父图层的可见区域。  </p>

<p>mask图层的color没用,轮廓才是重要的。对于mask图层中的部分会保留下来,其他部分会被抛弃（对于视图View其实你可以看做其他部分还在只不过颜色为透明色,但是这部分还会拦截点击事件）  </p>

<p>这个<code>Mask</code><strong>不仅仅局限于静态图</strong>，任何有图层的构成都可以作为Mask，因此我们甚至可以用一个动画的layer作为蒙版.</p>

<h3 id="toc_14">拉伸过滤</h3>

<p>这里牵涉到<code>minificationFilter</code>和<code>magnificationFilter</code>属性。  </p>

<p>当图片需要显示不同大小的时候,这种拉伸算法就起到作用。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>

<p><code>CALayer</code>提供给我们三种拉伸过滤方法:</p>

<ul>
<li>kCAFilterLinear </li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>

<p><code>minification</code>（缩小图片）和<code>magnification</code>（放大图片）默认的过滤器都是<code>kCAFilterLinear</code></p>

<p><code>kCAFilterLinear</code>双线性滤波，大多数情况下表现良好，但是当放大倍数较大时会比较模糊不清  </p>

<p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>很相似，是三线性滤波<br/>
<img src="media/14892022301750/14893953542514.jpg" alt=""/></p>

<p><code>kCAFilterNearest</code> 最近过滤 ，就是取样最近的单像素点而不管其他的颜色。总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。<br/>
<img src="media/14892022301750/14893958244715.jpg" alt=""/></p>

<h3 id="toc_15">组透明</h3>

<p>UIView用<code>alpha</code>属性设置透明度<br/>
CALayy用<code>opacity</code>设置图层透明度<br/>
这两个属性都是影响子层级的，比如我们设置一个图层透明度为50%，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。因此经常导致我们我们视图颜色的不协调。</p>

<p>这时候我们可以<br/><br/>
方法一：<br/><br/>
通过设置<code>Info.plist</code>文件中的 <code>UIViewGroupOpacity</code>为<code>YES</code>来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。</p>

<p>方法二：（推荐）<br/><br/>
设置CALayer的一个叫做<code>shouldRasterize</code>属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了</p>

<p>为了启用<code>shouldRasterize</code>属性，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了<code>shouldRasterize</code>属性，你就要确保你设置了 <code>rasterizationScale</code> 属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>

<pre><code class="language-objc">button2.layer.shouldRasterize = YES;
button2.layer.rasterizationScale = [UIScreen mainScreen].scale;
</code></pre>

<p><strong>注意</strong><br/>
当<code>shouldRasterize</code>和<code>UIViewGroupOpacity</code>一起的时候，会出现性能问题（但是好像影响不大）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation]]></title>
    <link href="https://acefish.github.io/14892022094971.html"/>
    <updated>2017-03-11T11:16:49+08:00</updated>
    <id>https://acefish.github.io/14892022094971.html</id>
    <content type="html"><![CDATA[
<p>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可<br/>
视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于<br/>
是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p>

<p><img src="media/14892022094971/14903531605425.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小知识记录]]></title>
    <link href="https://acefish.github.io/14891313543932.html"/>
    <updated>2017-03-10T15:35:54+08:00</updated>
    <id>https://acefish.github.io/14891313543932.html</id>
    <content type="html"><![CDATA[
<p>CoreData中的NSManagedObjectContext在多线程中不安全,如果想要多线程访问CoreData的话，最好的方法是一个线程一个NSManagedObjectContext,每个NSManagedObjectContext对象实例都可以使用同一个NSPersistentStoreCoordinator实例，这个实例可以很安全的顺序访问永久存储，这是因为NSManagedObjectContext会在便用NSPersistentStoreCoordinator前上锁。</p>

<p>ios5.0为NSManagedObjectContext提供了initWithConcurrentcyType方法，其中的一个NSPrivateQueueConcurrencyType，会自动的创建一个新线程来存放NSManagedObjectContext而且它还会自动创建NSPersistentStoreCoordinator,</p>

<p>三层 NSManagedObjectContext 嵌套</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图层树和寄宿图]]></title>
    <link href="https://acefish.github.io/14883679213714.html"/>
    <updated>2017-03-01T19:32:01+08:00</updated>
    <id>https://acefish.github.io/14883679213714.html</id>
    <content type="html"><![CDATA[
<p>注意点:<br/>
1. <code>contentsScale</code> 并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来渲染图层，我们就得手动设置图层的 contentsScale 属性。</p>

<p><code>textLayer.contentsScale = [UIScreen mainScreen].scale;</code><br/>
2. </p>

<h2 id="toc_0">图层、视图</h2>

<p>iOS中所有的视图都从UIView中派生而来。<code>UIView</code> 可以处理触摸事件，可以支持基于<code>Core Graphics</code>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>

<p><em><code>CALay</code>与UIView最大的不同是不处理用户的交互</em>，并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内</p>

<p>每一个 UIView 都有一个 CALayer 实例的图层属性，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作<br/>
实际上视图的这些背后关联的图层才是真正用来在屏幕上显示和做动画， UIView 仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及<code>CoreAnimation</code>底层方法的高级接口。</p>

<p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，<strong>除了<br/>
视图层级和图层树之外，还存在呈现树和渲染树</strong>。</p>

<p>我们用CALayer处理UIView没有暴露出来的功能(UIView没有响应的高级接口，我们只能介入底层):</p>

<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>

<p>标准的<code>Xcode</code>项目模板并没有包含<code>Core Animation</code>相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加<code>QuartzCore</code>框架</p>

<p><strong>视图中的子视图就是图层中的子图层</strong></p>

<h2 id="toc_1">寄宿图</h2>

<p>CALayer的寄宿图（即<strong>图层中包含的图</strong>）</p>

<h3 id="toc_2">contents属性</h3>

<p>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为<code>id</code>，意味着它可以是任何类型的对象。但是,在实践中，如果你给<code>contents</code>赋的不是<code>CGImage</code>，那么你得到的图层将是空白的。<br/>
实际上真正应该赋值的类型是<code>CGImageRef</code>,它是指向<code>CGImage</code>的指针。<br/>
UIImage有一个<code>CGImage</code>属性，它返回一个&quot;<code>CGImageRef</code>&quot;,如果你想把这个值直接赋值给<code>CALayer</code>的 <code>contents</code> ，那你将会得到一个编译错误。因为<code>CGImageRef</code>并不是一个真正的<code>Cocoa</code>对象，而是一个<code>Core Foundation</code>类型。</p>

<pre><code class="language-objc">/**
尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-freebridging），
他们并不是类型兼容的，不过你可以通过bridged关键字转换。
*/
layer.contents = (__bridge id)image.CGImage;
/**
    利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。
*/
</code></pre>

<h4 id="toc_3">contentGravity</h4>

<p>我们这样设置的图片也会适应视图拉伸，CALay也有个属性<code>contentsGravity</code>,它是个NSString类型，<br/>
类似于UIView的<code>contentMode</code>，<code>contentsGravity</code> 的目的是为了决定内容在图层的边界<br/>
中怎么对齐，我们将使用<code>kCAGravityResizeAspect</code>，它的效果等同于<br/>
<code>UIViewContentModeScaleAspectFit</code>.</p>

<pre><code class="language-objc">self.layerView.layer.contentsGravity = kCAGravityResizeAspect;
</code></pre>

<h4 id="toc_4">contentScale</h4>

<p><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置<code>contentsGravity</code>属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。<br/>
如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的<code>Retina</code>屏幕。这并不会对我们在使用<code>kCAGravityResizeAspect</code>时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为<code>kCAGravityCenter</code>（这个值并不会拉伸图片），那将会有很明显的变化</p>

<pre><code class="language-objc">self.layerView.layer.contentsGravity = kCAGravityCenter;
self.layerView.layer.contentsScale = image.scale;

/**
当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的 contentsScale 属性
，否则，你的图片在Retina设备上就显示得不正确啦
*/
layer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<h4 id="toc_5">maskToBounds</h4>

<p>UIView有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code></p>

<h4 id="toc_6">contentRect</h4>

<p>CALayer的 <code>contentsRect</code> 属性允许我们在图层边框里显示寄宿图的一个子域。<br/>
它使用单位坐标,指定0到1之间是一个相对值（像素和点就是绝对值）,相对于寄宿图的尺寸</p>

<p>默认<code>contentRect</code>是{0，0，1，1},着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪<br/>
事实上给 contentsRect 设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>

<p><strong>iOS中的坐标系统:</strong></p>

<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>

<h4 id="toc_7">contentsCenter</h4>

<p><code>contentsCenter</code>是一个CGRect,定义了一个固定的边框和一个在图层上可拉伸的区域.</p>

<p>默认是{0，0，1，1},即当视图大小改变时会均匀大小的拉伸,但是当我们改变这个rect后,横向或者纵向拉伸图片时就只会拉伸我们选定的区域（是rect的区域被拉伸而不是rect之外区域被拉伸）</p>

<p>工作起来的效果和<code>UIImage</code>里的<code>-resizableImageWithCapInsets:</code>方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形</p>

<p><strong>注意</strong><br/>
这个属性我们是可以在xib中直接设置的:<br/>
<img src="media/14883679213714/14891971745538.jpg" alt=""/></p>

<h4 id="toc_8">Custom Drawing</h4>

<p>当然我们设置寄宿图的方法不仅仅只有给<code>content</code>赋值CGImage，我们也可以用Core Grapic直接绘制。我们可以通过继承UIView并且重写<code>-drawRect:</code>方法进行自定义绘制  </p>

<p><code>drawRect</code>方法并没有默认实现，因为对于UIView来说,寄宿图并不是必须的，但是当UIView检测到<code>-drawRect:</code>被调用就会为视图分配一个寄宿图，寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。如果不需要寄宿图就没必要创建这个方法会造成cpu、内存浪费，空的方法也不行.  </p>

<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code> 方法里面的代码利用<code>Core Graphics</code>去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新(通常是因为开发者调用了<code>-setNeedsDisplay</code>方法,尽管影响到表现效果属性值被更改时，视图类型会自动重绘，如bounds属性)。  </p>

<p>虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的<code>CALayer</code>安排了重绘工作和保存了因此产生的图片。</p>

<h4 id="toc_9">CALayeDelegate</h4>

<p><strong>CALaye的代理</strong></p>

<p><strong>这个并不常用</strong></p>

<p>实现了 <code>CALayerDelegate</code> 协议，当<code>CALayer</code>需要一个内容特定的信息时，就会从协议中请求.<br/>
当需要被重绘的时候，CALayer会请求他的代理给他一个寄宿图来显示.</p>

<pre><code class="language-objc">//如果想直接设置contents属性时,可以这样
-(void)displayLayer:(CALayerCALayer *)layer;
//如果代理不实现 -displayLayer: 方法 就会调用
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
/**
    在调用这个方法之前CALayer创建一个合适尺寸的空寄宿图（尺寸由bounds
    和contentScale决定）和一个coreGraphic绘制的上下文环境ctx
*/ 
</code></pre>

<p>举个栗子:</p>

<pre><code class="language-objc">CALayer *blueLayer = [CALayer layer];
[self.layerView.layer addSublayer:blueLayer];
[blueLayer display];//强制layer重绘

//代理
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx
{
    //draw a thick red circle
    CGContextSetLineWidth(ctx, 10.0f);
    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
    CGContextStrokeEllipseInRect(ctx, layer.bounds);
}

</code></pre>

<p><strong>注意</strong><br/>
我们在blueLayer上显式地调用了<code>-display</code>。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</p>

<p>除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议,因为当UIView创建了它的宿主图层时，它就会自动地把图层的<code>delegate</code>设置为它自己，并提供了一个<code>-displayLayer:</code>的实现</p>

<p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拾遗]]></title>
    <link href="https://acefish.github.io/14882730004281.html"/>
    <updated>2017-02-28T17:10:00+08:00</updated>
    <id>https://acefish.github.io/14882730004281.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">super</h2>

<p>在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到<code>super</code></p>

<p>首先我们需要知道的是super与self不同。<code>self</code>是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而<code>super</code>并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用<code>viewDidLoad</code>方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。</p>

<pre><code class="language-objc">struct objc_super { id receiver; Class superClass; };
</code></pre>

<p><code>receiver</code>：即消息的实际接收者<br/>
<code>superClass</code>：指针当前类的父类</p>

<p>当我们使用super来接收消息时，编译器会生成一个<code>objc_super</code>结构体。就上面的例子而言，这个结构体的<code>receiver</code>就是<code>MyViewController</code>对象，与<code>self</code>相同；<code>superClass</code>指向<code>MyViewController的父类UIViewController</code>。</p>

<p>接下来，发送消息时，不是调用<code>objc_msgSend</code>函数，而是调用<code>objc_msgSendSuper</code>函数，其声明如下：</p>

<pre><code class="language-objc">id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );
</code></pre>

<p>该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&gt;receiver去调用这个selector：</p>

<pre><code class="language-objc">objc_msgSend(objc_super-&gt;receiver, @selector(viewDidLoad))
</code></pre>

<p>由于<code>objc_super-&gt;receiver</code>就是<code>self</code>本身，所以该方法实际与下面这个调用是相同的：</p>

<p><code>objc_msgSend(self, @selector(viewDidLoad))</code></p>

<pre><code>![](media/14882730004281/14883295157748.jpg)
</code></pre>

<h2 id="toc_1">库相关操作</h2>

<p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数</p>

<pre><code class="language-objc">// 获取所有加载的Objective-C框架和动态库的名称
const char ** objc_copyImageNames ( unsigned int *outCount );
// 获取指定类所在动态库
const char * class_getImageName ( Class cls );
// 获取指定库或框架中所有类的类名
const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount );
</code></pre>

<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。</p>

<pre><code class="language-objc">NSLog(@&quot;获取指定类所在动态库&quot;);
NSLog(@&quot;UIView&#39;s Framework: %s&quot;, class_getImageName(NSClassFromString(@&quot;UIView&quot;)));
NSLog(@&quot;获取指定库或框架中所有类的类名&quot;);
const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@&quot;UIView&quot;)), &amp;outCount);
for (int i = 0; i &lt; outCount; i++) {
    NSLog(@&quot;class name: %s&quot;, classes[i]);
}
//输出结果
2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库
2014-11-08 12:57:32.690 [747:184013] UIView&#39;s Framework: /System/Library/Frameworks/UIKit.framework/UIKit
2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名
2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings
2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame
2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView
2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar
2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView
2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters
......
</code></pre>

<h2 id="toc_2">块操作</h2>

<p>block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>

<pre><code class="language-objc">// 创建一个指针函数的指针，该函数调用时会调用特定的block
IMP imp_implementationWithBlock ( id block );
// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block
id imp_getBlock ( IMP anImp );
// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝
BOOL imp_removeBlock ( IMP anImp );
</code></pre>

<p><code>imp_implementationWithBlock</code>函数：参数block的签名必须是<code>method_return_type ^(id self, method_args …)</code>形式的。该方法能让我们使用block作为IMP。如下代码所示：</p>

<p>举个栗子：</p>

<pre><code class="language-objc">@interface MyRuntimeBlock : NSObject
@end    
@implementation MyRuntimeBlock
@end
// 测试代码
IMP imp = imp_implementationWithBlock(^(id obj, NSString *str) {
    NSLog(@&quot;%@&quot;, str);
});
class_addMethod(MyRuntimeBlock.class, @selector(testBlock:), imp, &quot;v@:@&quot;);
MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];
[runtime performSelector:@selector(testBlock:) withObject:@&quot;hello world!&quot;];

//输出结果
2014-11-09 14:03:19.779 [1172:395446] hello world!
</code></pre>

<h2 id="toc_3">弱引用操作</h2>

<pre><code class="language-objc">// 加载弱引用指针引用的对象并返回
id objc_loadWeak ( id *location );
// 存储__weak变量的新值
id objc_storeWeak ( id *location, id obj );
</code></pre>

<p><code>objc_loadWeak</code>函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用<code>__weak</code>变量的表达式中使用。</p>

<p><code>objc_storeWeak</code>函数：该函数的典型用法是用于<code>__weak</code>变量做为赋值对象时。</p>

<h2 id="toc_4">宏定义</h2>

<p>在runtime中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示<code>BOOL</code>值的<code>YES/NO</code>；而有些值不常用，如<code>OBJC_ROOT_CLASS</code>。在此我们做一个简单的介绍。</p>

<h3 id="toc_5">布尔值</h3>

<pre><code class="language-objc">#define YES  (BOOL)1
#define NO   (BOOL)0
</code></pre>

<p>这两个宏定义定义了表示布尔值的常量，需要注意的是YES的值是1，而不是非0值。</p>

<h3 id="toc_6">空值</h3>

<pre><code class="language-objc">#define nil  __DARWIN_NULL
#define Nil  __DARWIN_NULL
</code></pre>

<p>其中nil用于空的实例对象，而Nil用于空类对象。</p>

<h3 id="toc_7">分发函数原型</h3>

<pre><code class="language-objc">#define OBJC_OLD_DISPATCH_PROTOTYPES  1
</code></pre>

<p>该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换</p>

<h3 id="toc_8">Objective-C根类</h3>

<pre><code class="language-objc">#define OBJC_ROOT_CLASS
</code></pre>

<p>如果我们定义了一个Objective-C根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。</p>

<p>其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示：</p>

<pre><code class="language-objc">__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)
OBJC_ROOT_CLASS
OBJC_EXPORT
@interface NSObject &lt;NSObject&gt; {
    Class isa  OBJC_ISA_AVAILABILITY;
}
</code></pre>

<h3 id="toc_9">局部变量存储时长</h3>

<pre><code class="language-objc">#define NS_VALID_UNTIL_END_OF_SCOPE
</code></pre>

<p>该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。</p>

<p>我们将局部变量标记为id类型或者是指向ObjC对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。</p>

<h3 id="toc_10">关联对象行为</h3>

<pre><code class="language-objc">enum {
   OBJC_ASSOCIATION_ASSIGN  = 0,
   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,
   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,
   OBJC_ASSOCIATION_RETAIN  = 01401,
   OBJC_ASSOCIATION_COPY  = 01403
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协议与分类]]></title>
    <link href="https://acefish.github.io/14879278087290.html"/>
    <updated>2017-02-24T17:16:48+08:00</updated>
    <id>https://acefish.github.io/14879278087290.html</id>
    <content type="html"><![CDATA[
<p>Objective-C中的分类允许我们通过给一个类添加方法来扩充它（但是通过<code>category</code>不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>

<p>@protocol声明了可以呗其他任何方法类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>

<h2 id="toc_0">基础数据类型</h2>

<h3 id="toc_1">Category</h3>

<p>Category是表示一个指向分类的结构体的指针</p>

<pre><code class="language-objc">ypedef struct objc_category *Category;
struct objc_category {
    char *category_name                          OBJC2_UNAVAILABLE; // 分类名
    char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名
    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表
    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表
    struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表
</code></pre>

<p>这个结构体主要包含了分类定义的实例方法与类方法，<code>instance_methods</code>列表是<code>objc_class</code>中方法列表的一个子集，而<code>class_methods</code>列表是元类方法列表的一个子集。</p>

<h3 id="toc_2">Protocol</h3>

<pre><code class="language-objc">typedef struct objc_object Protocol;
</code></pre>

<p><code>Protocol</code>其中实就是一个对象结构体。</p>

<h2 id="toc_3">操作函数</h2>

<p>Runtime并没有在<code>&lt;objc/runtime.h&gt;</code>头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在<code>objc_class</code>中，我们可以通过针对<code>objc_class</code>的操作函数来获取分类的信息。</p>

<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>

<pre><code class="language-objc">// 返回指定的协议
Protocol * objc_getProtocol ( const char *name );
// 获取运行时所知道的所有协议的数组
Protocol ** objc_copyProtocolList ( unsigned int *outCount );
// 创建新的协议实例
Protocol * objc_allocateProtocol ( const char *name );
// 在运行时中注册新创建的协议
void objc_registerProtocol ( Protocol *proto );
// 为协议添加方法
void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );
// 添加一个已注册的协议到协议中
void protocol_addProtocol ( Protocol *proto, Protocol *addition );
// 为协议添加属性
void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );
// 返回协议名
const char * protocol_getName ( Protocol *p );
// 测试两个协议是否相等
BOOL protocol_isEqual ( Protocol *proto, Protocol *other );
// 获取协议中指定条件的方法的方法描述数组
struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );
// 获取协议中指定方法的方法描述
struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );
// 获取协议中的属性列表
objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );
// 获取协议的指定属性
objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );
// 获取协议采用的协议
Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );
// 查看协议是否采用了另一个协议
BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );
</code></pre>

<p><code>objc_getProtocol</code>函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil。</p>

<p><code>objc_copyProtocolList</code>函数，获取到的数组需要使用free来释放</p>

<p><code>objc_allocateProtocol</code>函数，如果同名的协议已经存在，则返回nil</p>

<p><code>objc_registerProtocol</code>函数，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议</p>

<p>需要强调的是，协议一旦注册后就不可再修改，即无法再通过调用<code>protocol_addMethodDescription</code>、<code>protocol_addProtocol</code>和p<code>rotocol_addProperty</code>往协议中添加方法等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method Swizzling]]></title>
    <link href="https://acefish.github.io/14879241904124.html"/>
    <updated>2017-02-24T16:16:30+08:00</updated>
    <id>https://acefish.github.io/14879241904124.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本文是由发表在南峰子博客的翻译由Mattt Thompson发表于<code>nshipster</code>的Method Swizzling文章</p>
</blockquote>

<p><code>Method Swizzling</code>是改变一个selector的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中<code>selector</code>对应的函数，来修改方法的实现。</p>

<p>本文讲一些Method Swiling中需要注意的问题:</p>

<h2 id="toc_0">Swizzling应该总是在+load中执行</h2>

<p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>

<h2 id="toc_1">Swizzling应该总是在dispatch_once中执行</h2>

<p>因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>

<h2 id="toc_2">选择器、方法与实现</h2>

<p>在Objective-C中，选择器(selector)、方法(method)和实现(implementation)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>

<p>以下是<code>Objective-C Runtime Reference</code>中的对这几个术语一些描述：  </p>

<pre><code>1. Selector(typedef struct objc_selector *SEL)：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。
2. Method(typedef struct objc_method *Method)：在类定义中表示方法的类型
3. Implementation(typedef id (*IMP)(id, SEL, ...))：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。
</code></pre>

<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>

<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。（要将原来的实现映射到一个新的）</p>

<h2 id="toc_3">调用_cmd</h2>

<p>我们自己的实现代码:</p>

<pre><code class="language-objc">- (void)xxx_viewWillAppear:(BOOL)animated {
    [self xxx_viewWillAppear:animated];
    NSLog(@&quot;viewWillAppear: %@&quot;, NSStringFromClass([self class]));
}
</code></pre>

<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在<code>swizzling</code>的过程中，方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的-<code>viewWillAppear:</code>中。在这种情况下，不会产生无限循环。不过如果我们调用的是<code>[self viewWillAppear:animated]</code>，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为<code>xxx_viewWillAppear:</code>了。</p>

<h3 id="toc_4">注意事项</h3>

<p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>

<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li><p>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</p></li>
<li><p>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看<objc/runtime.h>头文件以了解事件是如何发生的。</p></li>
<li><p>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</p></li>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[成员变量与属性]]></title>
    <link href="https://acefish.github.io/14878317610028.html"/>
    <updated>2017-02-23T14:36:01+08:00</updated>
    <id>https://acefish.github.io/14878317610028.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类型编码(Type Encoding)</h2>

<p><strong>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的<code>selector</code>关联在一起。</strong>我们可以使用@encode编译器指令来获取它。当给定一个类型时，<code>@encode</code>返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。任何可以作为<code>sizeof()</code>操作参数的类型都可以用于<code>@encode()</code>。</p>

<p>在<code>Objective-C Runtime Programming Guide</code>中的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>一节中列出了Objective-C中所有的类型编码,需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>

<p><em>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</em><br/>
举个栗子:</p>

<pre><code class="language-objc">float a[] = {1.0, 2.0, 3.0};
NSLog(@&quot;array encoding type: %s&quot;, @encode(typeof(a)));
//输出:
2014-10-28 11:44:54.731 RuntimeTest[942:50791] array encoding type: [3f]
</code></pre>

<p>另外，还有些编码类型，@encode虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。</p>

<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6">Property Type String</a>。</p>

<h2 id="toc_1">成员变量、属性</h2>

<h3 id="toc_2">基础数据类型</h3>

<h4 id="toc_3">Ivar</h4>

<p>Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针</p>

<pre><code class="language-objc">typedef struct objc_ivar *Ivar;
struct objc_ivar {
    char *ivar_name                 OBJC2_UNAVAILABLE;  // 变量名
    char *ivar_type                 OBJC2_UNAVAILABLE;  // 变量类型
    int ivar_offset                 OBJC2_UNAVAILABLE;  // 基地址偏移字节
#ifdef __LP64__
    int space                       OBJC2_UNAVAILABLE;
#endif
}
</code></pre>

<h4 id="toc_4">objc_property_t</h4>

<p><code>objc_property_t</code>是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针</p>

<p><code>typedef struct objc_property *objc_property_t;</code></p>

<h5 id="toc_5">objc_property_attribute_t</h5>

<p><code>objc_property_attribute_t</code>定义了属性的特性(attribute)，它是一个结构体</p>

<pre><code class="language-objc">typedef struct {
    const char *name;           // 特性名
    const char *value;          // 特性值
} objc_property_attribute_t;
</code></pre>

<h3 id="toc_6">关联对象(Associated Object)</h3>

<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(Ivar)放在类声明的头文件中，或者放在类实现的@implementation后面。但这有一个缺点，我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>

<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(<code>Associated Object</code>)。</p>

<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void指针(const void *)。我们还需要指定一个内存管理策略，以告诉Runtime如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>

<pre><code class="language-objc">OBJC_ASSOCIATION_ASSIGN
OBJC_ASSOCIATION_RETAIN_NONATOMIC
OBJC_ASSOCIATION_COPY_NONATOMIC
OBJC_ASSOCIATION_RETAIN
OBJC_ASSOCIATION_COPY
/**
    当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是
    assign，则宿主释放时，关联对象不会被释放；而如果指定的是retain或者是copy，则
    宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动retain/copy。当我们需
    要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。
*/
</code></pre>

<p>使用方法:</p>

<pre><code class="language-objc">static char myKey;
objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);
/**
    Sets an associated value for a given object using a given key and association 
    policy.
    
    object
        The source object for the association.
    key
        The key for the association.
    value
        The value to associate with the key key for object. Pass nil to clear an 
        existing association.
*/
</code></pre>

<p>在这种情况下，self对象将获取一个新的关联的对象anObject，且内存管理策略是自动retain关联对象，当self对象释放时，会自动release关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>

<pre><code class="language-objc">id anObject = objc_getAssociatedObject(self, &amp;myKey);
//Returns the value associated with a given object for a given key.
/**
object
The source object for the association.
key
The key for the association.
*/
</code></pre>

<p>我们可以使用<code>objc_removeAssociatedObjects</code>函数来移除一个关联对象，或者使用<code>objc_setAssociatedObject</code>函数将key指定的关联对象设置为nil。</p>

<p>关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在实际编码中灵活地运用这一特性。</p>

<h3 id="toc_7">成员变量、属性的操作方法</h3>

<h4 id="toc_8">成员变量</h4>

<p>成员变量包含以下方法:</p>

<pre><code class="language-objc">// 获取成员变量名
const char * ivar_getName ( Ivar v );
// 获取成员变量类型编码
const char * ivar_getTypeEncoding ( Ivar v );
// 获取成员变量的偏移量
ptrdiff_t ivar_getOffset ( Ivar v );
</code></pre>

<p><code>ivar_getOffset</code>函数，对于类型id或其它对象类型的实例变量，可以调用<code>object_getIvar</code>和<code>object_setIvar</code>来直接访问成员变量，而不使用偏移量。</p>

<h4 id="toc_9">关联对象</h4>

<p>关联操作函数</p>

<pre><code class="language-objc">// 设置关联对象
void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );
// 获取关联对象
id objc_getAssociatedObject ( id object, const void *key );
// 移除关联对象
void objc_removeAssociatedObjects ( id object );
</code></pre>

<h4 id="toc_10">属性</h4>

<p>属性操作函数:</p>

<pre><code class="language-objc">// 获取属性名
const char * property_getName ( objc_property_t property );
// 获取属性特性描述字符串
const char * property_getAttributes ( objc_property_t property );
// 获取属性中指定的特性
char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );
// 获取属性的特性列表
objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );

</code></pre>

<p><code>property_copyAttributeValue</code>函数，返回的char *在使用完后需要调用free()释放.<br/>
<code>property_copyAttributeList</code>函数，返回值在使用完后需要调用free()释放。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法与消息]]></title>
    <link href="https://acefish.github.io/14878317569666.html"/>
    <updated>2017-02-23T14:35:56+08:00</updated>
    <id>https://acefish.github.io/14878317569666.html</id>
    <content type="html"><![CDATA[
<p>运行时中的<strong>消息处理机制</strong>消息的发送及消息的转发</p>

<p>补充:类的方法链表中存储的是Method链表 而一个Method也是一个结构体指针,这个指针包含<br/>
一个方法 Method，其包含一个方法选标 SEL – 表示该方法的名称，一个types – 表示该方法参数的类型，一个 IMP  - 指向该方法的具体实现的函数指针。</p>

<h2 id="toc_0">基础数据类型</h2>

<h3 id="toc_1">SEL</h3>

<p>SEL又叫选择器，是表示一个方法的<code>selector</code>的指针,为一个指针</p>

<p><code>typedef struct objc_selector *SEL;</code></p>

<p><code>objc_selector</code>结构体的详细定义没有在<objc/runtime.h>头文件中找到。方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。如下代码所示：</p>

<pre><code class="language-objc">SEL sel1 = @selector(method1);
NSLog(@&quot;sel : %p&quot;, sel1);
//输出
2014-10-30 18:40:07.518 RuntimeTest[52734:466626] sel : 0x100002d72
</code></pre>

<p>两个类之间不管有没有关系,只要方法名相同，那么方法的SEL就是一样的.每一个方法都对应着一个<code>SEL</code>。</p>

<p>所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。<br/>
例如:</p>

<pre><code class="language-objc">    - (void)setWidth:(int)width;
    - (void)setWidth:(double)width;
    //上面的写法 这样的定义被认为是一种编译错误 饿哦们需要这样申明
    -(void)setWidthIntValue:(int)width;
    -(void)setWidthDoubleValue:(double)width;
</code></pre>

<p>当然不同的类就算是select相同也没关系 .不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</p>

<p>工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！<br/>
但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是<code>perfect hash</code>）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>

<p><em>本质上，<code>SEL</code>只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。</em></p>

<pre><code class="language-objc">/**
我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:
*/
sel_registerName函数
Objective-C编译器提供的@selector()
NSSelectorFromString()方法
</code></pre>

<h3 id="toc_2">IMP</h3>

<p><code>IMP</code>实际上是一个函数指针，指向方法实现的首地址。是函数指针而不是指针函数<br/>
IMP 是消息最终调用的执行代码，是方法真正的实现代码</p>

<p><code>id (*IMP)(id, SEL, ...)</code><br/>
第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。</p>

<p>前面介绍过的<code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的。由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过SEL方便快速准确地获得它所对应的IMP.取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>

<p>通过取得<code>IMP</code>，我们可以跳过<code>Runtime</code>的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>

<h3 id="toc_3">Method</h3>

<p>介绍完<code>SEL</code>和<code>IMP</code>，我们就可以来讲讲<code>Method</code>了。Method用于表示类定义中的方法，则定义如下：</p>

<pre><code class="language-objc">typedef struct objc_method *Method;
struct objc_method {
    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名
    char *method_types                  OBJC2_UNAVAILABLE;
    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现
}
/**
一个方法 Method，其包含一个方法选标 SEL – 表示该方法的名称，一个types – 表示该方法参数的类
型，一个 IMP  - 指向该方法的具体实现的函数指针。
*/
</code></pre>

<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>

<p>查找IMP 时<br/>
1，首先去该类的方法 cache 中查找，如果找到了就返回它；<br/>
2，如果没有找到，就去该类的方法列表中查找。如果在该类的方法列表中找到了，则将 IMP 返回，并将它加入cache中缓存起来。根据最近使用原则，这个方法再次调用的可能性很大，缓存起来可以节省下次调用再次查找的开销。<br/>
3，如果在该类的方法列表中没找到对应的 IMP，在通过该类结构中的 super_class指针在其父类结构的方法列表中去查找，直到在某个父类的方法列表中找到对应的IMP，返回它，并加入cache中。</p>

<p>4，如果在自身以及所有父类的方法列表中都没有找到对应的 IMP，则进入下文中要讲的消息转发流程。<br/>
是没有找到实现进入消息转发流程</p>

<h4 id="toc_4">objc_method_description</h4>

<p><code>objc_method_description</code>定义了一个Objective-C方法</p>

<pre><code class="language-objc">struct objc_method_description { SEL name; char *types; };
</code></pre>

<h2 id="toc_5">方法相关操作函数</h2>

<p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。</p>

<h3 id="toc_6">方法</h3>

<pre><code class="language-objc">// 调用指定方法的实现
id method_invoke ( id receiver, Method m, ... );
// 调用返回一个数据结构的方法的实现
void method_invoke_stret ( id receiver, Method m, ... );
// 获取方法名
SEL method_getName ( Method m );
// 返回方法的实现
IMP method_getImplementation ( Method m );
// 获取描述方法参数和返回值类型的字符串
const char * method_getTypeEncoding ( Method m );
// 获取方法的返回值类型的字符串
char * method_copyReturnType ( Method m );
// 获取方法的指定位置参数的类型字符串
char * method_copyArgumentType ( Method m, unsigned int index );
// 通过引用返回方法的返回值类型字符串
void method_getReturnType ( Method m, char *dst, size_t dst_len );
// 返回方法的参数的个数
unsigned int method_getNumberOfArguments ( Method m );
// 通过引用返回方法指定位置参数的类型字符串
void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );
// 返回指定方法的方法描述结构体
struct objc_method_description * method_getDescription ( Method m );
// 设置方法的实现
IMP method_setImplementation ( Method m, IMP imp );

// 交换两个方法的实现
void method_exchangeImplementations ( Method m1, Method m2 );

//注意:这里的dst只是一个引用  用来获取我们需要的值 类似返回类变量列表时的个数
</code></pre>

<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到<code>dst</code>中</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>

<h3 id="toc_7">方法选择器</h3>

<pre><code class="language-objc">// 返回给定选择器指定的方法的名称
const char * sel_getName ( SEL sel );
// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器
SEL sel_registerName ( const char *str );
// 在Objective-C Runtime系统中注册一个方法
SEL sel_getUid ( const char *str );
// 比较两个选择器
BOOL sel_isEqual ( SEL lhs, SEL rhs );
</code></pre>

<p><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。</p>

<h2 id="toc_8">方法调用流程</h2>

<p>在Objective-C中，<strong>消息</strong>直到运行时才绑定到<strong>方法实现</strong>上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数:</p>

<pre><code class="language-objc">objc_msgSend(receiver, selector)
//如果方法中还有其他参数
objc_msgSend(receiver, selector, arg1, arg2, ...)
</code></pre>

<p><code>这个函数</code>完成了动态绑定的所有事情:</p>

<pre><code>1. **首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。**
    注意:是找到方法对应的 。。。实现。。。
2. 它调用方法实现，并将接收者对象及方法的所有参数传给它。
3. 最后，它将实现返回的值作为它自己的返回值。
</code></pre>

<p>消息的关键在于我们前面章节讨论过的结构体objc_class，这个结构体有两个字段是我们在分发消息的关注的：</p>

<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即<code>methodLists</code></li>
</ol>

<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。<br/>
<img src="media/14878317569666/14879130604804.jpg" alt=""/></p>

<p>我们通过找类的方法链表找到Method，上图中selector 就是指 Method的 SEL,  address就是指Method的 IMP,因此对于一个实例对象的实例方法我们可以通过这样找到唯一的对应实现</p>

<p><strong>当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程，</strong></p>

<p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。</p>

<h3 id="toc_9">隐藏参数</h3>

<p><code>objc_msgSend</code>有两个隐藏参数：<br/>
    1.消息的接收对象<br/>
    2.方法的selector</p>

<p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。<em>它们是在编译期被插入实现代码的。</em></p>

<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd来引用选择器。</p>

<pre><code class="language-objc">- strange
{
    id  target = getTheReceiver();//此方法已不可用
    SEL method = getTheMethod();
    if ( target == self || method == _cmd )
        return nil;
    return [target performSelector:method];
}
</code></pre>

<p>当然，这两个参数我们用得比较多的是self，_cmd在实际中用得比较少。</p>

<h3 id="toc_10">获取方法地址</h3>

<p>Runtime中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。<br/>
如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>

<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。<br/>
通过下面代码看看<code>methodForSelector</code>的使用:</p>

<pre><code class="language-objc">void (*setter)(id, SEL, BOOL);
int i;
setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];
for (i = 0 ; i &lt; 1000 ; i++)
    setter(targetList[i], @selector(setFilled:), YES);
//注意：这里需要注意的就是函数指针的前两个参数必须是id和SEL。

</code></pre>

<p>当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由<code>Cocoa</code>运行时提供的；它不是<code>Objective-C</code>语言的特性。</p>

<h2 id="toc_11">消息转发</h2>

<p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果object无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perform...</code>的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</p>

<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。</p>

<pre><code class="language-objc">if ([self respondsToSelector:@selector(method)]) {
    [self performSelector:@selector(method)];
}
</code></pre>

<p>不过，我们这边想讨论下不使用respondsToSelector:判断的情况。这才是我们这一节的重点。</p>

<p>当一个对象无法接收某一消息时，就会启动所谓”<strong>消息转发(message forwarding)</strong>“机制，<br/>
默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>

<pre><code class="language-objc">-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940
*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940&#39;
</code></pre>

<p>这段异常信息实际上是由NSObject的”<code>doesNotRecognizeSelector</code>“方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>

<p><strong>消息转发机制分为3部分:</strong></p>

<ol>
<li><strong>动态方法解析</strong></li>
<li><strong>备用接收者</strong></li>
<li><strong>完整转发</strong></li>
</ol>

<h3 id="toc_12">动态方法解析</h3>

<p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。<br/>
在这个方法中，我们有机会为该未知消息新增一个”处理方法””。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。<br/>
举个栗子:</p>

<pre><code class="language-objc">void functionForMethod1(id self, SEL _cmd) {
   NSLog(@&quot;%@, %p&quot;, self, _cmd);
}
    
+ (BOOL)resolveInstanceMethod:(SEL)sel {
    NSString *selectorString = NSStringFromSelector(sel);
    if ([selectorString isEqualToString:@&quot;method1&quot;]) {
        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);
    }
    return [super resolveInstanceMethod:sel];
}
</code></pre>

<p><strong>不过这种方案更多的是为了实现@dynamic属性。</strong></p>

<h3 id="toc_13">备用接受者</h3>

<p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>

<pre><code class="language-objc">- (id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>

<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>

<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。举个栗子：详见运行时实例</p>

<h3 id="toc_14">完整消息转发</h3>

<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。</p>

<pre><code class="language-objc">- (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>

<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(<code>target</code>)和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</p>

<p><code>forwardInvocation:</code>方法的实现有两个任务：</p>

<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送到选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>

<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>

<p>还有一个很重要的问题，我们必须重写以下方法：</p>

<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>

<p>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</p>

<p>完整的示例如下所示：</p>

<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    if (!signature) {
        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) {
            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];
        }
    }
    return signature;
}
- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:_helper];
    }
}
</code></pre>

<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>

<p>从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>

<h3 id="toc_15">消息转发和多重继承</h3>

<p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>

<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如respondsToSelector:和isKindOfClass:只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>

<pre><code class="language-Objc">- (BOOL)respondsToSelector:(SEL)aSelector
{
    if ( [super respondsToSelector:aSelector])
        return YES;
    else {
        /* Here, test whether the aSelector message can     *
         * be forwarded to another object and whether that  *
         * object can respond to it. Return YES if it can.  */
    }
    return NO;  
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时实例:]]></title>
    <link href="https://acefish.github.io/14877347224030.html"/>
    <updated>2017-02-22T11:38:42+08:00</updated>
    <id>https://acefish.github.io/14877347224030.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类与对象</h2>

<pre><code class="language-Objc">//-----------------------------------------------------------
// MyClass.h
@interface MyClass : NSObject &lt;NSCopying, NSCoding&gt;
@property (nonatomic, strong) NSArray *array;
@property (nonatomic, copy) NSString *string;
- (void)method1;
- (void)method2;
+ (void)classMethod1;
@end
//-----------------------------------------------------------
// MyClass.m
#import &quot;MyClass.h&quot;
@interface MyClass () {
    NSInteger       _instance1;
    NSString    *   _instance2;
}
@property (nonatomic, assign) NSUInteger integer;
- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2;
@end
@implementation MyClass
+ (void)classMethod1 {
}
- (void)method1 {
    NSLog(@&quot;call method method1&quot;);
}
- (void)method2 {
}
- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2 {
    NSLog(@&quot;arg1 : %ld, arg2 : %@&quot;, arg1, arg2);
}
@end
//-----------------------------------------------------------
// main.h
#import &quot;MyClass.h&quot;
#import &quot;MySubClass.h&quot;
#import &lt;objc/runtime.h&gt;
int main(int argc, const char * argv[]) {
    @autoreleasepool {
    
        MyClass *myClass = [[MyClass alloc] init];
        unsigned int outCount = 0;
        Class cls = myClass.class;
        // 类名
        NSLog(@&quot;class name: %s&quot;, class_getName(cls));
        NSLog(@&quot;==========================================================&quot;);
        // 父类
        NSLog(@&quot;super class name: %s&quot;, class_getName(class_getSuperclass(cls)));
        NSLog(@&quot;==========================================================&quot;);
        // 是否是元类
        NSLog(@&quot;MyClass is %@ a meta-class&quot;, (class_isMetaClass(cls) ? @&quot;&quot; : @&quot;not&quot;));
        NSLog(@&quot;==========================================================&quot;);
        Class meta_class = objc_getMetaClass(class_getName(cls));
        NSLog(@&quot;%s&#39;s meta-class is %s&quot;, class_getName(cls), class_getName(meta_class));
        NSLog(@&quot;==========================================================&quot;);
        // 变量实例大小
        NSLog(@&quot;instance size: %zu&quot;, class_getInstanceSize(cls));
        NSLog(@&quot;==========================================================&quot;);
        // 成员变量
        Ivar *ivars = class_copyIvarList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Ivar ivar = ivars[i];
            NSLog(@&quot;instance variable&#39;s name: %s at index: %d&quot;, ivar_getName(ivar), i);
        }
        free(ivars);
        Ivar string = class_getInstanceVariable(cls, &quot;_string&quot;);
        if (string != NULL) {
            NSLog(@&quot;instace variable %s&quot;, ivar_getName(string));
        }
        NSLog(@&quot;==========================================================&quot;);
        // 属性操作
        objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            objc_property_t property = properties[i];
            NSLog(@&quot;property&#39;s name: %s&quot;, property_getName(property));
        }
        free(properties);
        objc_property_t array = class_getProperty(cls, &quot;array&quot;);
        if (array != NULL) {
            NSLog(@&quot;property %s&quot;, property_getName(array));
        }
        NSLog(@&quot;==========================================================&quot;);
        // 方法操作
        Method *methods = class_copyMethodList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Method method = methods[i];
            NSLog(@&quot;method&#39;s signature: %s&quot;, method_getName(method));
        }
        free(methods);
        Method method1 = class_getInstanceMethod(cls, @selector(method1));
        if (method1 != NULL) {
            NSLog(@&quot;method %s&quot;, method_getName(method1));
        }
        Method classMethod = class_getClassMethod(cls, @selector(classMethod1));
        if (classMethod != NULL) {
            NSLog(@&quot;class method : %s&quot;, method_getName(classMethod));
        }
        NSLog(@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;, class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @&quot;&quot; : @&quot; not&quot;);
        IMP imp = class_getMethodImplementation(cls, @selector(method1));
        imp();
        NSLog(@&quot;==========================================================&quot;);
        // 协议
        Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);
        Protocol * protocol;
        for (int i = 0; i &lt; outCount; i++) {
            protocol = protocols[i];
            NSLog(@&quot;protocol name: %s&quot;, protocol_getName(protocol));
        }
        NSLog(@&quot;MyClass is%@ responsed to protocol %s&quot;, class_conformsToProtocol(cls, protocol) ? @&quot;&quot; : @&quot; not&quot;, protocol_getName(protocol));
        NSLog(@&quot;==========================================================&quot;);
    }
    return 0;
}

//输出结果


</code></pre>

<h3 id="toc_1">动态创建类</h3>

<pre><code class="language-Objc">Class cls = objc_allocateClassPair(MyClass.class, &quot;MySubClass&quot;, 0);
class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);
class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);
class_addIvar(cls, &quot;_ivar1&quot;, sizeof(NSString *), log(sizeof(NSString *)), &quot;i&quot;);
objc_property_attribute_t type = {&quot;T&quot;, &quot;@\&quot;NSString\&quot;&quot;};
objc_property_attribute_t ownership = { &quot;C&quot;, &quot;&quot; };
objc_property_attribute_t backingivar = { &quot;V&quot;, &quot;_ivar1&quot;};
objc_property_attribute_t attrs[] = {type, ownership, backingivar};
class_addProperty(cls, &quot;property2&quot;, attrs, 3);
objc_registerClassPair(cls);
id instance = [[cls alloc] init];
[instance performSelector:@selector(submethod1)];
[instance performSelector:@selector(method1)];
//输出
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1

</code></pre>

<h3 id="toc_2">动态创建对象</h3>

<pre><code class="language-Objc">id theObject = class_createInstance(NSString.class, sizeof(unsigned));
 
id str1 = [theObject init];
NSLog(@&quot;%@&quot;, [str1 class]);
id str2 = [[NSString alloc] initWithString:@&quot;test&quot;];
NSLog(@&quot;%@&quot;, [str2 class]);
//输出
2014-10-23 12:46:50.781 RuntimeTest[4039:89088] NSString
2014-10-23 12:46:50.781 RuntimeTest[4039:89088] __NSCFConstantString

</code></pre>

<h3 id="toc_3">实例操作函数</h3>

<h4 id="toc_4">对象拷贝</h4>

<pre><code class="language-Objc">NSObject *a = [[NSObject alloc] init];
id newB = object_copy(a, class_getInstanceSize(MyClass.class));
object_setClass(newB, MyClass.class);
object_dispose(a);
</code></pre>

<h4 id="toc_5">获取类定义（获取已注册类）</h4>

<pre><code class="language-Objc">int numClasses;
Class * classes = NULL;
numClasses = objc_getClassList(NULL, 0);
if (numClasses &gt; 0) {
    classes = malloc(sizeof(Class) * numClasses);
    numClasses = objc_getClassList(classes, numClasses);
    NSLog(@&quot;number of classes: %d&quot;, numClasses);
    for (int i = 0; i &lt; numClasses; i++) {
        Class cls = classes[i];
        NSLog(@&quot;class name: %s&quot;, class_getName(cls));
    }
    free(classes);
}
</code></pre>

<h2 id="toc_6">成员变量、属性</h2>

<h3 id="toc_7">关联对象</h3>

<p>假定我们想要动态地将一个Tap手势操作连接到任何UIView中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的UIView对象中。这项任务分两部分。<br/>
首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>

<pre><code class="language-objc">- (void)setTapActionWithBlock:(void (^)(void))block
{
    UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey);
 
    if (!gesture)
    {
        gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)];
        [self addGestureRecognizer:gesture];
        objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);
    }
    objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);
}
</code></pre>

<p>这段代码检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意<code>block</code>对象的关联内存管理策略。<br/>
手势识别对象需要一个<code>target</code>和<code>action</code>，所以接下来我们定义处理方法：</p>

<pre><code class="language-objc">- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture
{
    if (gesture.state == UIGestureRecognizerStateRecognized)
    {
        void(^action)(void) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey);
        if (action)
        {
            action();
        }
    }
}
</code></pre>

<h3 id="toc_8">设置属性</h3>

<p>我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>

<pre><code class="language-objc">@interface MyObject: NSObject
@property (nonatomic, copy) NSString    *   name;                  
@property (nonatomic, copy) NSString    *   status;                 
@end
</code></pre>

<p>接口A、B返回的字典数据如下所示：</p>

<pre><code class="language-objc">@{@&quot;name1&quot;: &quot;张三&quot;, @&quot;status1&quot;: @&quot;start&quot;}
@{@&quot;name2&quot;: &quot;张三&quot;, @&quot;status2&quot;: @&quot;end&quot;}
</code></pre>

<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换方法，为此，我们需要先定义一个映射字典(全局变量)</p>

<pre><code class="language-objc">static NSMutableDictionary *map = nil;
@implementation MyObject    
+ (void)load
{
    map = [NSMutableDictionary dictionary];
    map[@&quot;name1&quot;]                = @&quot;name&quot;;
    map[@&quot;status1&quot;]              = @&quot;status&quot;;
    map[@&quot;name2&quot;]                = @&quot;name&quot;;
    map[@&quot;status2&quot;]              = @&quot;status&quot;;
}
@end
</code></pre>

<p>上面的代码将两个字典中不同的字段映射到MyObject中相同的属性上，这样，转换方法可如下处理：</p>

<pre><code class="language-objc">- (void)setDataWithDic:(NSDictionary *)dic
{
    [dic enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) {
        NSString *propertyKey = [self propertyForKey:key];
        if (propertyKey)
        {
            objc_property_t property = class_getProperty([self class], [propertyKey UTF8String]);
            // TODO: 针对特殊数据类型做处理
            NSString *attributeString = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];
            ...
            [self setValue:obj forKey:propertyKey];
        }
    }];
}
</code></pre>

<h2 id="toc_9">方法和消息</h2>

<h3 id="toc_10">消息转发 -</h3>

<h4 id="toc_11">备用接收者</h4>

<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。<br/>
```objc<br/>
@interface SUTRuntimeMethodHelper : NSObject<br/>
- (void)method2;<br/>
@end<br/>
@implementation SUTRuntimeMethodHelper<br/>
- (void)method2 {<br/>
    NSLog(@&quot;%@, %p&quot;, self, _cmd);<br/>
}<br/>
@end</p>

<h1 id="toc_12">pragma mark -</h1>

<p>@interface SUTRuntimeMethod () {<br/>
    SUTRuntimeMethodHelper *_helper;<br/>
}<br/>
@end<br/>
@implementation SUTRuntimeMethod<br/>
+ (instancetype)object {<br/>
    return [[self alloc] init];<br/>
}<br/>
- (instancetype)init {<br/>
    self = [super init];<br/>
    if (self != nil) {<br/>
        <u>helper = [[SUTRuntimeMethodHelper alloc] init];<br/>
    }<br/>
    return self;<br/>
}<br/>
- (void)test {<br/>
    [self performSelector:@selector(method2)];<br/>
}<br/>
- (id)forwardingTargetForSelector:(SEL)aSelector {<br/>
    NSLog(@&quot;forwardingTargetForSelector&quot;);<br/>
    NSString *selectorString = NSStringFromSelector(aSelector);<br/>
    // 将消息转发给</u>helper来处理<br/>
    if ([selectorString isEqualToString:@&quot;method2&quot;]) {<br/>
        return _helper;<br/>
    }<br/>
    return [super forwardingTargetForSelector:aSelector];<br/>
}<br/>
@end<br/>
```<br/>
这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>

<h4 id="toc_13">完整消息转发</h4>

<pre><code class="language-objc">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];
    if (!signature) {
        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) {
            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];
        }
    }
    return signature;
}
- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) {
        [anInvocation invokeWithTarget:_helper];
    }
}
</code></pre>

<h2 id="toc_14">Method Swizzing</h2>

<p>例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p>

<pre><code class="language-objc">#import &lt;objc/runtime.h&gt;
@implementation UIViewController (Tracking)
+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        Class class = [self class];         
        // When swizzling a class method, use the following:
        // Class class = object_getClass((id)self);
        SEL originalSelector = @selector(viewWillAppear:);
        SEL swizzledSelector = @selector(xxx_viewWillAppear:);
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        BOOL didAddMethod = class_addMethod(class,
                originalSelector,
                method_getImplementation(swizzledMethod),
                method_getTypeEncoding(swizzledMethod));
        if (didAddMethod) {
            class_replaceMethod(class,
                swizzledSelector,
                method_getImplementation(originalMethod),
                method_getTypeEncoding(originalMethod));
        } else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
}
#pragma mark - Method Swizzling
- (void)xxx_viewWillAppear:(BOOL)animated {
    [self xxx_viewWillAppear:animated];
    NSLog(@&quot;viewWillAppear: %@&quot;, self);
}
</code></pre>

<p>在这里，我们通过method swizzling修改了UIViewController的@selector(viewWillAppear:)对应的函数指针，使其实现指向了我们自定义的xxx_viewWillAppear的实现。这样，当UIViewController及其子类的对象调用viewWillAppear时，都会打印一条日志信息。</p>

<p>上面的例子很好地展示了使用method swizzling来一个类中注入一些我们新的操作。当然，还有许多场景可以使用method swizzling，在此不多举例。</p>

]]></content>
  </entry>
  
</feed>
