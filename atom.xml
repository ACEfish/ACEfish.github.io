<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[栗豫塬的博客]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2017-09-19T00:47:13+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[访问控制]]></title>
    <link href="https://acefish.github.io/15057532270985.html"/>
    <updated>2017-09-19T00:47:07+08:00</updated>
    <id>https://acefish.github.io/15057532270985.html</id>
    <content type="html"><![CDATA[
<p><strong>访问控制：限定其他源文件或者模块代码对你的代码的访问级别</strong></p>

<ul>
<li>明确的给单个类型(类,结构体,枚举)设置访问级别</li>
<li>给类型的属性、方法、构造器、下标等设置访问级别</li>
<li>限定协议在一定范围使用，包括协议中的全局变量、常亮、函数</li>
</ul>

<p><code>Swift</code>有显式提供多种访问级别，也有为场景提供了默认的访问级别</p>

<h2 id="toc_0">模块和源文件</h2>

<p><strong><code>Swift</code>中的访问控制基于模块和源文件</strong></p>

<p><mark>模块</mark>指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用<code>import</code>关键字导入另外一个模块。<br/>
在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。</p>

<p><mark>源文件</mark>就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>

<h2 id="toc_1">访问级别</h2>

<p><code>Swift</code>提供了5种访问级别</p>

<ul>
<li><strong>开放访问和公开访问</strong>:可以访问同一模块源文件中的任何实体，在模块外也可以导入该模块来访问源文件中的所有实体。我们通常将框架中的某个借口可以被任何使用时,设置为此级别</li>
<li><strong>内部访问</strong>：可以访问同一模块源文件的任何实体，但是不能从外部访问该模块源文件中的实体。用于某借口只在应用程序或者内部使用时</li>
<li><strong>文件私有访问限制</strong>：限值实体只能被所<em>定义</em>的<em>文件</em>内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
<li><strong>私有访问限值</strong>： 限值实体只能在所定义的<em>作用域</em>使用,需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
</ul>

<p>开放权限由上向下变小</p>

<p>开放访问和公开访问区别:(开放访问只作用于类类型和类的成员)</p>

<ul>
<li>公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。</li>
<li>公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。</li>
<li>开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</li>
<li>开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</li>
<li>把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[泛型]]></title>
    <link href="https://acefish.github.io/15052932669633.html"/>
    <updated>2017-09-13T17:01:06+08:00</updated>
    <id>https://acefish.github.io/15052932669633.html</id>
    <content type="html"><![CDATA[
<p><strong>泛型:</strong>根据自定义的需求，编写适用于任意类型，灵活可用的函数和类型</p>

<h2 id="toc_0">泛型函数</h2>

<p>泛型函数适用与任何类型</p>

<pre><code class="language-swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>函数的泛型版本:<br/>
1）使用占位类型名来代替实际类型名(这里用字母<code>T</code>表示),这里并没有指明T必须是什么类型,而是a与b类型相同,在实际调用时才根据传入类型决定<code>T</code>所代表的类型<br/>
2）在函数名后有<code>&lt;T&gt;</code>，声明了<code>T</code>是函数内定义的占位类型名<br/>
因此，函数<code>swapTwoInts(_:_:)</code>可以接受任意相同类型的参数</p>

<h2 id="toc_1">类型参数</h2>

<p>类型参数指定并命名一个占位类型,紧随在函数名后,用尖括号括起来(如:<code>&lt;T&gt;</code>),也可以提供多个参数用逗号隔开</p>

<p>可以用指定的类型参数作为函数的参数类型或返回类型，</p>

<h2 id="toc_2">命名类型参数</h2>

<p>我们可以使用有意义的单词来表明类型参数和泛型函数关系,当没有联系时,通常使用单个字母来命名</p>

<p><strong>使用大写字母开头的驼峰命名法来为类型参数命名</strong></p>

<h2 id="toc_3">泛型类型</h2>

<p><strong>泛型类型：</strong>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型,类型于<code>Array</code>和<code>Dictionary</code></p>

<pre><code class="language-swift">//泛型 Stack（栈型） 结构体
struct Stack&lt;Element&gt; {
    var items = [Element]()
    mutating func push(item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
}
</code></pre>

<p>使用占位类型<code>Element</code>，这个类型参数包裹在紧随结构体名的一对尖括号里（<code>&lt;Element&gt;</code>）,类型参数用来初始化数组,用来作为<code>push</code><code>pop</code>方法的参数</p>

<p><code>Stack</code>是泛型类型,可以创建任意有效类型栈<br/>
可以通过在尖括号写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例</p>

<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push(&quot;uno&quot;)
stackOfStrings.push(&quot;dos&quot;)
let fromTheTop = stackOfStrings.pop()
</code></pre>

<h2 id="toc_4">扩展泛型类型</h2>

<p>在扩展泛型类型时，不需要在扩展的定义中提供类型参数列表。可以在扩展中直接使用原始类型参数列表,并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<pre><code class="language-swift">//扩展泛型类型增加只读的计算属性
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>

<p>返回`<code>item</code>数组的最后一个元素</p>

<p>扩展中直接使用了已有的类型参数<code>Element</code></p>

<h2 id="toc_5">类型约束</h2>

<p>给泛型函数和泛型类型添加一个特定的约束，可以指定一个类型参数必须继承自指定类，或者符合协议或协议组合</p>

<p>例如:<code>Dictionary</code>类型约束了字典中的键必须是可哈希的（符合<code>Hashable协议</code>），也就是必须有唯一的方法表示她，才能根据键进行判断</p>

<h3 id="toc_6">类型约束语法</h3>

<p>在类型参数名后放置类型或协议名用冒号隔开来进行约束，</p>

<pre><code class="language-swift">//类型约束的泛型函数
func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
</code></pre>

<p>约束T必须是SomeClass的子类，要求U必须遵循SomeProtocol的</p>

<h3 id="toc_7">类型约束实践</h3>

<p>我们新建一个泛型函数来从实现从数组中查找特定元素的功能;</p>

<pre><code class="language-swift">//从数组中查找特定自字符串的非泛型函数
func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}


//泛型类型
func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
        return index
        }
    }
    return nil
}
</code></pre>

<p>上面的泛型函数，是无法通过编译的，因为不是任何类型都可以用<code>==</code>进行比较<br/>
Swift定义了一个<code>Equatable</code>协议,所有遵守改协议的类型都必须实现<code>==或!=</code>，从而对该类型任意值进行比较</p>

<pre><code class="language-swift">//此时泛型函数可以成功编译了
func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>

<h2 id="toc_8">关联类型</h2>

<p>定义协议时，声明一个或者多个<strong>关联类型</strong>作为协议的一部分</p>

<p><strong>关联类型</strong>为协议中的的某个类型提供占位名(别名)，而其实际类型在协议被采纳时才会被指定</p>

<p>用<code>associatedtype</code>关键字指定<strong>关联类型</strong></p>

<pre><code class="language-swift">protocol Container {
    associatedtype ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>

<p>在协议中声明了一个关联类型<code>ItemType</code>,来保证在不知道容器中元素的具体类型情况下行为能够正确执行</p>

<pre><code class="language-swift">//定义类型遵循Contain协议
Struct IntStack: Container {
    // IntStack 的原始实现部分
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // Container 协议的实现部分
    typealias ItemType = Int//可以省略，swift会根据协议的实现推断出类型
        mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}

</code></pre>

<p>在实现协议时需要用<code>typealias ItemType = Int</code>来转换协议中的关联类型<br/>
当然，这个是可以省略的，Swift可以根据方法推断出<code>ItemType</code>类型</p>

<h3 id="toc_9">扩展存在的类型来指定关联类型</h3>

<p>对于Contain协议，Swift中的Array已经默认提供了协议中要求，因此我们只需要声明Array遵循该协议就可以扩展<code>Array</code></p>

<pre><code class="language-Swift">//我们只需要扩展Array来使其遵循该协议即可
extension Array: Container {}
</code></pre>

<h2 id="toc_10">泛型Where语句</h2>

<p><strong>泛型Where语句</strong>用于为关联类型定义约束，比如要求其必须遵循特定协议，以及特定类型参数和关联类型必须相同</p>

<p>在函数体或者类型的大括号前添加<code>Where</code>子句</p>

<pre><code class="language-swift">func allItemsMatch&lt;C1: Container, C2: Container&gt;
(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {
        // 检查两个容器含有相同数量的元素
        if someContainer.count != anotherContainer.count {
            return false
        }
        // 检查每一对元素是否相等
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
            return false
        }
    }
    // 所有元素都匹配，返回 true
    return true
}
</code></pre>

<p>用<code>类型约束</code>约束类型参数:C1、C2必须符合<code>Contain</code>协议<br/>
用<code>泛型Where语句</code>约束关联类型:C1和C2必须类型相同,并且C1符合<code>Equatable</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协议]]></title>
    <link href="https://acefish.github.io/15047511695312.html"/>
    <updated>2017-09-07T10:26:09+08:00</updated>
    <id>https://acefish.github.io/15047511695312.html</id>
    <content type="html"><![CDATA[
<p>类和结构体、枚举都可以遵循协议,并为协议定义的这些要求提供实现<br/>
除了遵循协议的类型必须实现外还可以对协议进行扩展，通过扩展来实现一部分要求或者添加附加功能</p>

<h2 id="toc_0">协议语法</h2>

<p>协议的定义:</p>

<pre><code class="language-swift">protocol SomeProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<p>自定义类型遵循某个协议,定义类型时,可以在类型名称后加上协议名称,中间用<code>:</code>分割,多个协议之间用<code>,</code>分割</p>

<pre><code class="language-swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 这里是结构体的定义部分
}
</code></pre>

<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>

<pre><code class="language-swift">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 这里是类的定义部分
}
</code></pre>

<h2 id="toc_1">属性要求</h2>

<p>协议可以指定遵循协议的类型提供特定名称或属性的实例属性或类型属性。它只指定类型名称和属性而不能指定属性是存储型的还是计算型的,此外，还可以指定属性是可读的还是可写的</p>

<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的</p>

<p>协议总是用<code>var</code>关键字来声明变量属性，在类型声明后加上<code>{ set get }</code>来表示属性是可读可写的，可读属性则用<code>{ get }</code>来表示</p>

<pre><code class="language-swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>在协议中定义类型属性时，使用<code>static</code>关键字作为前缀。当类类型遵循协议时,除了<code>static</code>关键字,还可以使用<code>class</code>关键字声明类型属性:</p>

<pre><code class="language-swift">protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>

<h2 id="toc_2">方法要求</h2>

<p>遵循协议的类型实现某些指定的实例方法或类方法</p>

<ul>
<li>方法像普通方法一样放在协议的定义中,但是不需要大括号和方法体</li>
<li>与普通方法类似可以在方法中提供可变参数,但是不能为参数提供默认值</li>
<li>在协议中定义类方法时，总是使用<code>static</code>关键字为前缀.当类类型遵循协议时，除了<code>static</code>关键字，还可以使用<code>class</code>关键字作为前缀</li>
</ul>

<pre><code class="language-swift">protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<pre><code class="language-swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
</code></pre>

<h2 id="toc_3">Mutating方法要求</h2>

<p>如果在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加<code>mutating</code>关键字,使得结构体和枚举能够遵循此协议并满足方法要求</p>

<blockquote>
<p>在实现协议的<code>mutating</code>方法时，若是类类型则不用写<code>mutating</code>关键字，而若是结构体或枚举必须写<code>mutating</code>关键字</p>
</blockquote>

<pre><code class="language-swift">protocol Togglable {
    mutating func toggle()
}

//定义在两种状态间切换的枚举
enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
</code></pre>

<h2 id="toc_4">构造器要求</h2>

<p><strong>协议可以要求遵循协议的类型实现指定的构造器</strong></p>

<pre><code class="language-swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h3 id="toc_5">构造器要求在类中的实现</h3>

<p>遵循协议的类实现构造器.不论指定构造器或者便利构造器都必须在实现加上<code>required</code>修饰符</p>

<pre><code class="language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<p>使用<code>required</code>修饰符可以确保所有子类也必须提供此构造器实现，即符合协议</p>

<p>注意:</p>

<blockquote>
<p>如果类被标记为<code>final</code>，就不需要在协议构造器中使用<code>required</code>修饰符,因为<code>final</code>类不会有子类</p>
</blockquote>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求,那么重写上需要同时加上<code>required</code>和<code>override</code>修饰符</p>

<pre><code class="language-swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // 这里是构造器的实现部分
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为遵循协议，需要加上 required
    // 因为继承自父类，需要加上 override
    required override init() {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<h3 id="toc_6">可失败构造器要求</h3>

<p>协议还可以为遵循协议的类型定义可失败构造器要求</p>

<p>遵循协议的类型可以通过可失败构造器<code>（init?）</code>或非可失败构造器<code>（init）</code>来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器<code>（init</code>或隐式解包可失败构造器<code>（init!）</code>来满足</p>

<h2 id="toc_7">协议作为类型</h2>

<p>协议可以作为成熟的类型来使用:</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>

<p>协议作为一种类型,因此与它类型的命名写法相同 应该使用驼峰写法</p>

<pre><code class="language-swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>类<code>Dice</code>中含有属性<code>generator</code>为<code>RandomNumberGenerator</code>协议类型,因此遵循了<code>RandomNumberGenerator</code>协议类型的实例都可以赋值给<code>generator</code></p>

<p>在类中有<code>roll</code>的实例方法,调用<code>generator</code>的<code>random()</code>方法来生成一个<code>[0.0,1.0)</code>区间内的随机数</p>

<h2 id="toc_8">委托（代理）模式</h2>

<hr/>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例.<br/>
委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。<br/>
委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型</p>

<hr/>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>我们可以通过扩展代码来为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中相应要求</p>

<blockquote>
<p>通过扩展使已有类型遵循并符合协议时,该类型的所有实例也会获得协议中定义的各项功能</p>
</blockquote>

<pre><code class="language-swift">protocol TextRepresentable {
    var textualDescription: String { get }
}

extension Dice: TextRepresentable {
    var textualDescription: String {
        return &quot;A \(sides)-sided dice&quot;
    }
}
</code></pre>

<p>扩展来遵循并符合协议与原始定义中效果相同</p>

<h2 id="toc_10">通过扩展遵循协议</h2>

<pre><code class="language-swift">struct Hamster {
    var name: String
    var textualDescription: String {
        return &quot;A hamster named \(name)&quot;
    }
}

extension Hamster: TextRepresentable {}
</code></pre>

<h2 id="toc_11">协议类型的集合</h2>

<p>协议类型可以在数组或字典这样的集合使用</p>

<p><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></p>

<h2 id="toc_12">协议的继承</h2>

<p>协议可以继承一个或多个其他协议,可以在继承协议基础上增加新的要求.协议继承与发与类相似,多个协议用逗号分割：</p>

<pre><code class="language-swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<h2 id="toc_13">类类型专属协议</h2>

<p>在协议的继承列表中，通过添加<code>class</code>关键字来限制协议只能被类类型遵循，而值类型如枚举和结构体不能遵循该协议</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<p><code>class</code>关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前</p>

<h2 id="toc_14">协议合成</h2>

<p>同时遵循多个协议时,可以将多个协议采用<code>SomeProtocol &amp; AnotherProtocol</code>的格式进行组合,即<strong>协议合成</strong></p>

<pre><code class="language-swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}

func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)
}

let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
wishHappyBirthday(to: birthdayPerson)// “Happy birthday Malcolm - you&#39;re 21!”
</code></pre>

<blockquote>
<p>协议合成并不是生成一个新的、永久的协议</p>
</blockquote>

<h2 id="toc_15">检查协议一致性</h2>

<p>使用<code>is</code>和<code>as</code>检查协议的一致性,即是否符合某协议，并且可以转换到指定的协议类型,与类型检查和转换用法相同:</p>

<ul>
<li><code>is</code>用来检查实例是否符合某个协议，若符合则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>as?</code>返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回<code>nil</code></li>
<li><code>as!</code>将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误</li>
</ul>

<pre><code class="language-swift">protocol HasArea {
    var area: Double { get }
}

for object in objects {
    if let objectWithArea = object as? HasArea {
        print(&quot;Area is \(objectWithArea.area)&quot;)
    } else {
        print(&quot;Something that doesn&#39;t have an area&quot;)
    }
}
</code></pre>

<p>判断元素是否符合<code>HasArea</code>协议后将<code>as?</code>操作符通过可选绑定，绑定到<code>objectWithArea</code>常量上进行访问</p>

<blockquote>
<p>在数据中的元素类型并不会因为强转而丢失类型信息,只是在被赋值为<code>objectWithArea</code>时，被视为<code>HasArea</code>类型，因此只有<code>area</code>属性可以被访问</p>
</blockquote>

<h2 id="toc_16">可选的协议要求</h2>

<p>协议可以被定义为可选的，用<code>option</code>关键字作为前缀来标记可选要求<br/>
可选要求用在你需要和<code>Objective-C</code>打交道的代码中<br/>
协议和可选要求都必须带上<code>@objc</code>属性<br/>
标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议</p>

<p>当使用可选要求时，协议中的可选的方法或属性会自动变成可选的（函数的话整个函数类型是可选的而不是函数的返回值）</p>

<pre><code class="language-swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code class="language-swift">class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
    //此处无法确定是否存在dataSource 以及 datasource是否遵循了协议 因此需要两层的可选链式调用
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>

<p>通过可选链式调用可选协议</p>

<p><code>CounterDataSource</code>的简单实现</p>

<pre><code class="language-swift">//继承自OC的NSObject
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

//@objc类
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>

<h2 id="toc_17">协议扩展</h2>

<p>通过扩展来为遵循协议的类型提供属性、方法以及下标的&quot;实现&quot;.这样可以基于协议本身实现这些功能,而不需要给每个遵循协议的类型进行重复的实现或者使用全局函数</p>

<pre><code class="language-swift">//定义一个协议
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
//为协议进行协议扩展
extension RandomNumberGenerator {
    func randomBool() -&gt; Bool {
        return random() &gt; 0.5
    }
}
</code></pre>

<p>所有遵循该协议的类型 都能获得扩展所增加的方法实现</p>

<h3 id="toc_18">提供默认实现</h3>

<p>可以通过协议扩展来为协议中的的要求提供默认实现，如果遵循该协议的类型提供了自己的实现,那么自定义实现会代替扩展中的默认实现</p>

<h3 id="toc_19">为协议扩展添加限制条件</h3>

<p>在协议扩展的时候条件一些限制条件,只有遵循协议的类型满足这些条件的时候才能获取协议扩展提供的默认实现</p>

<p>将这些限制条件写在协议名字之后,并且使用<code>where</code>字句描述</p>

<pre><code class="language-swift">/**
扩展CollectionType协议,但是只适用于集合中的元素遵循`TextRepresentable`协议的情况
*/
extension CollectionType where Generator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return &quot;[&quot; + itemsAsText.joinWithSeparator(&quot;, &quot;) + &quot;]&quot;
    }
}
</code></pre>

<p>因此需要一个集合类型的遵循CollectionType协议,而且其中的每个元素都遵循TextRepresentable协议<br/>
这样的话这个集合就默认有扩展协议的默认实现</p>

<blockquote>
<p>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展]]></title>
    <link href="https://acefish.github.io/15042587690391.html"/>
    <updated>2017-09-01T17:39:29+08:00</updated>
    <id>https://acefish.github.io/15042587690391.html</id>
    <content type="html"><![CDATA[
<p><strong>扩展</strong>就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能</p>

<blockquote>
<p>类似OC中的分类功能,但是Swift中的分类没有名字</p>
</blockquote>

<p><strong>Swift中的扩展可功能</strong>:</p>

<ul>
<li>添加计算型属性和计算类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议
还可以对协议进行扩展、提供协议要求的实现，添加额外的功能，让符合协议的类型拥有这些功能</li>
</ul>

<blockquote>
<p>扩展只能添加新的功能不能重写已有功能</p>
</blockquote>

<h2 id="toc_0">扩展语法</h2>

<p>用关键字<code>extension</code>声明扩展:</p>

<pre><code class="language-swift">extension SomeType {
    // 为 SomeType 添加的新功能写到这里
}
</code></pre>

<p>扩展一个已有类型,使其采纳一个或多个协议</p>

<pre><code class="language-swift">extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>

<blockquote>
<p>扩展一个已有实例的新功能,那么新功能对该类型所有实例都可用，不论创建时间</p>
</blockquote>

<h2 id="toc_1">计算型属性</h2>

<pre><code class="language-swift">extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print(&quot;One inch is \(oneInch) meters&quot;)
    // 打印 “One inch is 0.0254 meters”
let threeFeet = 3.ft
print(&quot;Three feet is \(threeFeet) meters&quot;)
    // 打印 “Three feet is 0.914399970739201 meters”
</code></pre>

<p>扩展<code>Double</code>类型,增加计算型属性,实现距离转换<br/>
上面的属性是只读的计算型属性,省略了<code>get</code>关键字</p>

<blockquote>
<p>可以增加新的计算型属性,但是不能增加存储型属性，也不能为已有属性添加属性观察器</p>
</blockquote>

<h2 id="toc_2">构造器</h2>

<p>扩展可以为已有类型添加新的构造器。<br/>
扩展能为类添加新的便利构造器,但是不能为类添加新的指定构造器或者析构器</p>

<blockquote>
<p>如果使用扩展为一个“值类型”添加构造器,同时该值类型的原始实现没有定义定制构造器,且所有存储属性提供了默认值,我们可以在扩展的构造器中调用默认构造器和逐一成员构造器(当原始实现中有定制的构造器,就不能调用了)</p>
</blockquote>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>因为<code>Rect</code>没有指定构造器,存储属性也都有默认值,因此获得一个逐一成员构造器和默认构造器，</p>

<pre><code class="language-swift">extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        //调用结构体的逐一成员构造器
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<h2 id="toc_3">方法</h2>

<p>为已有类型添加新的实例方法和类型方法</p>

<pre><code class="language-swift">extension Int {
    func repetitions(task: () -&gt; Void) {
        for _ in 0..&lt;self {
            task()
        }
    }
}
//为Int类型添加一个名为`repetitions`的实例方法
//这个方法接受一个`()-&gt;Void`类型的单参数，没有参数也没有返回值的函数
</code></pre>

<h3 id="toc_4">可变实例方法</h3>

<p>扩展中添加的实例方法也可以修改该实例本身，对于值类型即结构体或者枚举修改<code>self</code>或其属性的方法就必须将该实例方法标注为<code>mutating</code>(类似原始实现)</p>

<pre><code class="language-swift">extension Int {
    mutating func square() {
        self = self * self
    }
}
</code></pre>

<h2 id="toc_5">下标</h2>

<p>扩展为已有类型添加下标.</p>

<pre><code class="language-swift">extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
        for _ in 0..&lt;digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// 返回 5
746381295[1]
// 返回 9
//取的下标越界时自动用0补充
746381295[9]
// 返回 0，即等同于：
0746381295[9]
</code></pre>

<p>上面的例子为<code>Int</code>增加下标方法，<code>[n]</code>返回十进制数字从右向左数的第<code>n</code>个数字</p>

<h2 id="toc_6">嵌套类型</h2>

<p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型:</p>

<pre><code class="language-swift">extension Int {
    enum Kind {
    case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
</code></pre>

<p>为<code>Int</code>添加了一个嵌套枚举,来表明特定整数的类型，即正数、负数或零</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌套类型]]></title>
    <link href="https://acefish.github.io/15042543172572.html"/>
    <updated>2017-09-01T16:25:17+08:00</updated>
    <id>https://acefish.github.io/15042543172572.html</id>
    <content type="html"><![CDATA[
<p><strong>嵌套类型:</strong>在支持的类型中定义嵌套的枚举、类和结构体</p>

<p>要在一个类型中嵌套另一个类型,将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套</p>

<h2 id="toc_0">嵌套类型实践</h2>

<pre><code class="language-swift">struct BlackjackCard {
    //嵌套的 Suit 枚举//牌的花色
    enum Suit: Character {
        case Spades = &quot;块&quot;, Hearts = &quot;心&quot;, Diamonds = &quot;*&quot;, Clubs = &quot;额&quot;
    }
    //嵌套的 Rank 枚举
    enum Rank: Int {
        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
        case Jack, Queen, King, Ace
        struct Values {//用于反应Ace有两种值，而其他只有一个
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
                case .Ace:
                    return Values(first: 1, second: 11)
                case .Jack, .Queen, .King:
                    return Values(first: 10, second: nil)
                default:
                    return Values(first: self.rawValue, second: nil)
            }
        }
    }
    // BlackjackCard 的属性和方法
    let rank: Rank, suit: Suit
    var description: String {
        var output = &quot;suit is \(suit.rawValue),&quot;
        output += &quot; value is \(rank.values.first)&quot;
        if let second = rank.values.second {
            output += &quot; or \(second)&quot;
        }
        return output
    }
}
</code></pre>

<p><code>BlackjackCard</code>结构体有默认的成员构造器,可以用默认构造器去初始化常量:</p>

<pre><code class="language-swift">/**
尽管Rank和Suit嵌套在BlackjackCard中,类型可以从上下文推断出来,
因此可以用`.Ace 和.Spades`引用枚举实例
*/
let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)
// 打印 “theAceOfSpades: suit is ?, value is 1 or 11”
</code></pre>

<h2 id="toc_1">引用嵌套类型</h2>

<p>在嵌套类型的类型名前加上外部类型的类型名作为前缀:</p>

<pre><code class="language-swift">let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
//红心符号
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型转换]]></title>
    <link href="https://acefish.github.io/15037348375137.html"/>
    <updated>2017-08-26T16:07:17+08:00</updated>
    <id>https://acefish.github.io/15037348375137.html</id>
    <content type="html"><![CDATA[
<p>在<code>Swift</code>中通过<code>is</code>和<code>as</code>操作符来实现<strong>类型转换</strong>，可以来检查值的类型或者转换类型<br/>
可以用它检查一个类型是否实现了某个协议</p>

<h2 id="toc_0">定义一个类层次作为例子</h2>

<p>在数组中存了一个父类的两个子类的实例</p>

<blockquote>
<p>在数组中存在两种子类类型,会推断这个数组为共同的父类类型<br/>
此时虽然数组中存的是子类类型实例,但是迭代的话取出的实例会为父类类型，此时我们需要判断和转换类型</p>
</blockquote>

<h2 id="toc_1">检查类型</h2>

<p>用类型检查操作符<code>is</code> 检查实例是否属于特定子类型，返回<code>bool</code>值</p>

<pre><code class="language-swift">for item in library {
    if item is Movie { //判断实例是否为 Movie类型
        movieCount += 1
    } else if item is Song { //判断实例是否为 Song类型
        songCount += 1
    }
}
</code></pre>

<h2 id="toc_2">向下转型</h2>

<p>当某类型的实例属于一个子类,可以用<code>as?</code>或者<code>as!</code>将其向下转换位子类类型</p>

<p>因为向下转型可能失败，因此提供<code>as?</code>和<code>as!</code>(带上强制解包)，当不确定是否成功时用<code>as?</code> 确定一定成功时<code>as!</code></p>

<pre><code class="language-swift">for item in library {
    if let movie = item as? Movie {
        print(&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    } else if let song = item as? Song {
        print(&quot;Song: &#39;\(song.name)&#39;, by \(song.artist)&quot;)
    }
}
</code></pre>

<p><code>if let movie = item as? Movie</code>尝试将<code>item</code>转为<code>Movie</code>类型。若成功，设置一个新的临时常量<code>movie</code>来存储返回的可选<code>Movie</code>中的值</p>

<h2 id="toc_3">Any和AnyObject的类型转换</h2>

<p>不确定类型的表达方式:<br/>
<code>Any</code>可以表示任何类型，包括函数类型。<br/>
<code>AnyObject</code>可以表示任何类类型的实例</p>

<p>建议只在确定需要使用时才使用<code>Any</code>和<code>AnyObject</code></p>

<pre><code class="language-swift">var things = [Any]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append(&quot;hello&quot;)
things.append((3.0, 5.0))
things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;))
things.append({ (name: String) -&gt; String in &quot;Hello, \(name)&quot; })
</code></pre>

<p>然后我们可以在<code>switch</code>表达式的</p>

<pre><code class="language-swift">for thing in things {
    switch thing {
    case 0 as Int:
        print(&quot;zero as an Int&quot;)
    case 0 as Double:
        print(&quot;zero as a Double&quot;)
    case let someInt as Int:
        print(&quot;an integer value of \(someInt)&quot;)
    case let someDouble as Double where someDouble &gt; 0:
        print(&quot;a positive double value of \(someDouble)&quot;)
    case is Double:
        print(&quot;some other double value that I don&#39;t want to print&quot;)
    case let someString as String:
        print(&quot;a string value of \&quot;\(someString)\&quot;&quot;)
    case let (x, y) as (Double, Double):
        print(&quot;an (x, y) point at \(x), \(y)&quot;)
    case let movie as Movie:
        print(&quot;a movie called &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    case let stringConverter as String -&gt; String:
        print(stringConverter(&quot;Michael&quot;))
    default:
        print(&quot;something else&quot;)
    }
}
// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of &quot;hello&quot;
// an (x, y) point at 3.0, 5.0
// a movie called &#39;Ghostbusters&#39;, dir. Ivan Reitman
// Hello, Michael
</code></pre>

<blockquote>
<p><code>Any</code>是可以表示所有类型的值,包括可选类型,当你在用<code>Any</code>类型来表示一个可选值时,会给出警告，此时可以用<code>as</code>操作符显示转换为<code>Any</code></p>
</blockquote>

<pre><code>let optionalNumber: Int? = 3
things.append(optionalNumber) // 会有警告
things.append(optionalNumber as Any) // 没有警告
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[错误处理]]></title>
    <link href="https://acefish.github.io/15034731740974.html"/>
    <updated>2017-08-23T15:26:14+08:00</updated>
    <id>https://acefish.github.io/15034731740974.html</id>
    <content type="html"><![CDATA[
<p><strong>错误处理</strong>就是响应错误以及从错误中回复的过程</p>

<p><code>Swift</code>提供了运行时对可恢复错误的抛出、捕获、传递和操作等的支持<br/>
通常用来区分失败情况,让程序解决并处理某些错误，把解决不了的错误报告给用户</p>

<h2 id="toc_0">表示并抛出错误</h2>

<p><code>Swift</code>中 错误用符合<code>Error</code>协议的类型值来表示，这个空协议表明该类型可以用于错误处理</p>

<p>通常用枚举类型来构建一组相关的错误状态,枚举的关联值可以提供错误状态的额外信息</p>

<p>使用关键字<code>throw</code>关键字来抛出一个错误，表示有意外发生</p>

<pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection //选择无效
    case insufficientFunds(coinsNeeded: Int) //金额不足
    case outOfStock //缺货
}

throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre>

<h2 id="toc_1">处理错误</h2>

<p><code>Swift</code>中有<code>4</code>种处理错误的方式<br/>
1.把函数抛出的错误传递给调用此函数的代码<br/>
2.用<code>do-catch</code>语句处理错误<br/>
3.将错误作为可选类型处理<br/>
4.断言此错误根本不会发生</p>

<p>我们在调用一个能抛出错误的函数、方法或者构造器之前，用<code>try</code>关键字或者<code>try?</code><code>try!</code>这种变体关键字</p>

<blockquote>
<p>与其他语言的<code>try</code>，<code>catch</code>和<code>throw</code>不同的是<code>swift</code>的错误挫力不涉及解除调用栈,因此其性能特性是可以和<code>return</code>语句相媲美的</p>
</blockquote>

<h3 id="toc_2">用throwing函数传递错误</h3>

<p>在函数声明的参数列表后加上<code>throws</code>关键字，表明可以抛出错误，这个函数就称为<code>throwing</code>函数<br/>
如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面</p>

<pre><code class="language-swift">func canThrowErrors() throws -&gt; String
func cannotThrowErrors() -&gt; String
</code></pre>

<p><strong><code>throwing</code>函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</strong></p>

<blockquote>
<p>对于<code>throwing</code>函数可以传递错误,非<code>throwing</code>函数抛出的错误只能在函数内部处理</p>
</blockquote>

<pre><code class="language-swift">struct Item {
    var price: Int
    var count: Int
}
class VendingMachine {
    var inventory = [
                     &quot;Candy Bar&quot;: Item(price: 12, count: 7),
                     &quot;Chips&quot;: Item(price: 10, count: 4),
                     &quot;Pretzels&quot;: Item(price: 7, count: 11)
                     ]
    var coinsDeposited = 0
    func dispenseSnack(snack: String) {
        print(&quot;Dispensing \(snack)&quot;)
    }
    //throwing函数 会抛出VendingMachineError错误
    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.InvalidSelection
        }
        guard item.count &gt; 0 else {
            throw VendingMachineError.OutOfStock
        }
        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }
        coinsDeposited -= item.price
        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem
        print(&quot;Dispensing \(name)&quot;)
    }
}
</code></pre>

<p>使用了<code>guard</code>语句来提前退出方法，因为<code>throw</code>语句会立即退出方法，保证只有在满足所有条件时才成功卖出商品</p>

<p><code>vend(itemNamed:)</code>会传递它抛出的所有错误,因此在跳用这个方法时，要么直接处理这些错误(<code>do-catch</code>语句,<code>try?</code>或<code>try!</code>)，要么将错误继续传递下去</p>

<pre><code class="language-swift">let favoriteSnacks = [
    &quot;Alice&quot;: &quot;Chips&quot;,
    &quot;Bob&quot;: &quot;Licorice&quot;,
    &quot;Eve&quot;: &quot;Pretzels&quot;,
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;
    try vendingMachine.vend(itemNamed: snackName)
}
//传似抛出的错误
</code></pre>

<p><code>buyFavoriteSnack</code>方法会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法尝试购买,通过在<code>vend(itemNamed:)</code>方法前加<code>try</code>关键字</p>

<p><code>throwing</code>构造器和<code>throwing</code>一样可以传递错误</p>

<pre><code class="language-swift">struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
</code></pre>

<h3 id="toc_3">用Do-Catch处理错误</h3>

<p><strong><code>do-catch</code>语句运行一段<code>闭包</code>代码来处理错误</strong></p>

<p>在<code>do</code>语句抛出一个错误,与<code>catch</code>中的字句匹配</p>

<pre><code class="language-swift">do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</code></pre>

<p><code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误.如果<code>catch</code>没有指定错误模式，那就可以匹配任何错误，并且把错误绑定到名字为<code>error</code>的局部变量</p>

<p><code>catch</code>不必处理抛出的所有错误,错误可以传递到周围,但是必须被处理，可以使外围的<code>do-catch</code>语句 或者是一个<code>throwing</code>函数进行处理</p>

<p>注意:<br/>
在<code>do</code>语句中的<code>try</code>如果有抛出错误就立刻执行<code>catch</code>语句,并判断这个错误是否要被继续传递下去,否则执行<code>do</code>子句中余下的语句</p>

<h3 id="toc_4">将错误转换成可选值</h3>

<p>通过<code>try?</code>将错误转换为一个可选值,如果表达式有错误抛出,那么表达式的值就为<code>nil</code></p>

<pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()
//等效于
let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>

<p>此时不论<code>someThrowingFunction()</code>返回值是什么类型,x，y就是该返回值类型的可选类型</p>

<h3 id="toc_5">禁用错误传递</h3>

<p>当我们确定知道某个<code>throwing</code>函数在运行时是不会抛出错误的,那么可以用<code>tr<br/>
y!</code>来禁用错误传递，它会将调用包装在一个不会有错误抛出的运行时断言中</p>

<h2 id="toc_6">指定清理操作</h2>

<p><code>defer</code>语句在即将离开当前代码块时执行一系列语句，来执行一些必要的清理工作，而不管你是由于哪种方式离开代码块</p>

<ul>
<li><code>defer</code>语句将代码执行延迟到当前作用域退出之前。</li>
<li>该语句由<code>defer</code>关键字和要延时执行的语句组成(延迟执行的语句不能包含任何控制转移语句，或是抛出一个错误)。</li>
<li>延时执行的操作会按照他们被指定时的顺序的相反顺序执行(第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行)</li>
</ul>

<pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // 处理文件。
        }
        // close(file) 会在这里被调用，即作用域的最后。
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可选链式调用]]></title>
    <link href="https://acefish.github.io/15031302948355.html"/>
    <updated>2017-08-19T16:11:34+08:00</updated>
    <id>https://acefish.github.io/15031302948355.html</id>
    <content type="html"><![CDATA[
<p><strong>可选链式调用</strong>是在当前值可能为<code>nil</code>的可选值上请求和调用属性、方法以及下标的方法。如果可选值不为空,调用成功,否则如果可选值为<code>nil</code>，那么调用将返回<code>nil</code>。多个调用可以结合为一个调用链,若任何一个节点为<code>nil</code>。整个调用链都会失败</p>

<h2 id="toc_0">可选链式调用代替强制展开</h2>

<p>在想调用的属性、方法、下标的可选值后加上<code>?</code>来定义一个可选链。</p>

<blockquote>
<p>很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误</p>
</blockquote>

<p>可选链式调用,不论调用的属性、方法及下标返回值的类型,返回结果都是具有相同类型的可选值,可以利用这个可选返回值来判断链式调用是否成功,有值则返回成功，<code>nil</code>表示调用失败</p>

<pre><code class="language-swift">class Person {
    var residence: Residence?
}
class Residence {
    var numberOfRooms = 1
}
let john = Person()
</code></pre>

<p>我们直接<code>let roomCount = john.residence!.numberOfRooms</code>因为<code>residence</code>为<code>nil</code>强制展开的话是会触发运行时错误的</p>

<p>这时我们可以采用可选链式调用来访问<code>numberOfRooms</code>用<code>?</code>代替<code>!</code></p>

<pre><code class="language-swift">if let roomCount = john.residence?.numberOfRooms {
    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)
} else {
    print(&quot;Unable to retrieve the number of rooms.&quot;)
}
</code></pre>

<p><strong>添加问号之后，Swift 就会在<code>residence</code>不为<code>nil</code>的情况下访问<code>numberOfRooms</code></strong></p>

<p>即使<code>numberOfRooms</code>是非可选类型<code>Int</code>，只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回<code>Int?</code>而不是<code>Int</code></p>

<h2 id="toc_1">为可选链式调用定义模型类</h2>

<h2 id="toc_2">通过可选链式调用访问属性</h2>

<p>通过可选链式调用<strong>访问可能不存在实例的属性</strong>:</p>

<pre><code class="language-swift">//john.residence实例可能为nil
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)
} else {
    print(&quot;Unable to retrieve the number of rooms.&quot;)
}
</code></pre>

<p>通过可选链式调用<strong>设置属性值</strong></p>

<pre><code class="language-swift">//john.residence实例可能为nil
let someAddress = Address()
john.residence?.address = someAddress
</code></pre>

<p>对于这种可选链式调用的赋值,如果<code>john.residence</code>为<code>nil</code>，获取<code>address</code>属性失败，那么右侧的代码是不会被执行的</p>

<h2 id="toc_3">通过可选链式调用调用方法</h2>

<p>对于<code>Residence</code>类中定义的方法</p>

<pre><code class="language-swift">func printNumberOfRooms() {
    print(&quot;The number of rooms is \(numberOfRooms)&quot;)
}
</code></pre>

<p>这个方法没有返回值,那就是具有隐式的返回值<code>Void</code><br/>
那么如果用可选链式调用这个方法，返回值就为<code>Void?</code></p>

<pre><code class="language-swift">//john.residence 为Residence类 可能为nil的实例
if john.residence?.printNumberOfRooms() != nil {
    print(&quot;It was possible to print the number of rooms.&quot;)
} else {
    print(&quot;It was not possible to print the number of rooms.&quot;)
}
//可以根据返回值是否为nil 判断调用是否成功
</code></pre>

<p>对实例中的属性赋值 也会返回一个可选类型</p>

<pre><code class="language-swift">if (john.residence?.address = someAddress) != nil {
print(&quot;It was possible to set the address.&quot;)
} else {
print(&quot;It was not possible to set the address.&quot;)
}
</code></pre>

<h2 id="toc_4">通过可选链式调用访问下标</h2>

<p>可以在一个可选值上访问下标,判断下标是否成功</p>

<pre><code class="language-swift">//john.residence可能为nil
if let firstRoomName = john.residence?[0].name {
    print(&quot;The first room name is \(firstRoomName).&quot;)
} else {
    print(&quot;Unable to retrieve the first room name.&quot;)
}
</code></pre>

<blockquote>
<p>注意:下标调用的时候将问号放在下标方括号的前面而不是后面</p>
</blockquote>

<pre><code class="language-swift">john.residence?[0] = Room(name: &quot;Bathroom&quot;)
</code></pre>

<p><code>john.residence</code>为nil时，赋值仍然会失败</p>

<h3 id="toc_5">访问可选类型的下标</h3>

<p>如果下标返回可选类型值,可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用</p>

<pre><code class="language-swift">var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]
testScores[&quot;Dave&quot;]?[0] = 91
testScores[&quot;Bev&quot;]?[0] += 1
testScores[&quot;Brian&quot;]?[0] = 72
</code></pre>

<p>定义一个字典,包含两个键值对，因为字典下标返回的是可选类型值,对于<code>testScores[&quot;Brian&quot;]</code>因为字典中没有这个键，所以返回为<code>nil</code>，调用失败</p>

<h2 id="toc_6">连接多层可选链式调用</h2>

<p>可以连接多个可选链式调用在更深模型层级中访问属性、方法、下标，但是是不会增加返回值的可选层级的</p>

<ul>
<li>通过可选链式调用访问一个 Int 值，将会返回 Int? ，无论使用了多少层可选链式调用</li>
<li>通过可选链式调用访问 Int? 值，依旧会返回 Int? 值，并不会返回 Int??</li>
</ul>

<pre><code class="language-swift">if let johnsStreet = john.residence?.address?.street {
    print(&quot;John&#39;s street name is \(johnsStreet).&quot;)
} else {
    print(&quot;Unable to retrieve the address.&quot;)
}
</code></pre>

<p><code>john.residence.address</code>为<code>nil</code>因此调用失败<br/>
尽管<code>street</code>属性为<code>String？</code>  返回值仍然为<code>String?</code></p>

<h2 id="toc_7">在方法的可选返回值上进行可选链式调用</h2>

<pre><code class="language-swift">if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print(&quot;John&#39;s building identifier is \(buildingIdentifier).&quot;)
}
</code></pre>

<p>在可选值的基础上调用<code>buildingIdentifier()</code>方法  返回<code>String?</code>类型值</p>

<pre><code class="language-swift">if let beginsWithThe =
john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) {
    if beginsWithThe {
        print(&quot;John&#39;s building identifier begins with \&quot;The\&quot;.&quot;)
    } else {
        print(&quot;John&#39;s building identifier does not begin with \&quot;The\&quot;.&quot;)
    }
}
</code></pre>

<p>在方法的返回值基础上进行可选链式调用 </p>

<blockquote>
<p>在方法的圆括号后面加上问号即可</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动引用计数]]></title>
    <link href="https://acefish.github.io/15028525854956.html"/>
    <updated>2017-08-16T11:03:05+08:00</updated>
    <id>https://acefish.github.io/15028525854956.html</id>
    <content type="html"><![CDATA[
<p>与<code>OC</code>相同 <code>Swift</code>使用自动引用计数(ARC)来跟踪和管理应用程序内存</p>

<h2 id="toc_0">工作机制</h2>

<p>创建类的实例时,<code>ARC</code>会分配一块内存来存储实例信息.不再使用该实例,ARC将其释放.当是实例被释放后，其方法或属性均不能被访问或调用。<br/>
因此，为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>

<h2 id="toc_1">循环强引用</h2>

<p>如果两个类实例互相引用,那么类实例的强引用数永远不能变为0，这就是<strong>循环强引用</strong></p>

<h2 id="toc_2">解决循环强引用方法</h2>

<p>解决办法: <strong>弱引用</strong> <strong>无主引用</strong></p>

<p>将循环引用中一个实例对另外的实例不保持强引用</p>

<p>当其他的实例有更短的生命周期时,使用弱引用，即其 实例 析构在先时; 当其他实例有相同或者更长的声明周期时,请使用无主引用</p>

<h3 id="toc_3">弱引用</h3>

<p>弱引用不会对其引用的实例保持强引用，因而不会阻止<code>ARC</code>销毁被引用的实例。</p>

<p>声明属性或变量时,在前面加上<code>weak</code>关键字表明是个弱引用</p>

<p><code>ARC</code>会在引用的实例被销毁后自动将其赋值为<code>nil</code>.并且弱引用可以允许它们的值运行时赋值为<code>nil</code>，所以会被定义为可选类型变量而不是常量</p>

<p>弱引用为可选类型变量,可以通过检查是否为nil,防止访问已经销毁的实例的引用</p>

<blockquote>
<p>在<code>ARC</code>设置弱引用为<code>nil</code>时,属性观察不会被触发</p>
</blockquote>

<pre><code class="language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}

var john: Person?
var unit4A: Apartment?
john = Person(name: &quot;John Appleseed&quot;)
unit4A = Apartment(unit: &quot;4A&quot;)
john!.apartment = unit4A
unit4A!.tenant = john
//因为Apartment 中 的 tenant 属性为弱引用,因此即使这样也不会产生循环引用

john = nil
// 打印 “John Appleseed is being deinitialized”

unit4A = nil
// 打印 “Apartment 4A is being deinitialized”

</code></pre>

<p>变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息</p>

<h3 id="toc_4">无主引用</h3>

<p>与弱引用类似,无主引用不会保持住引用的实例<br/>
与弱引用不同,<strong>无主引用用在与其他实例有相同或者更长声明周期时使用</strong><br/>
在属性前加<code>unowned</code>关键字进行声明</p>

<p>无主引用为非可选类型,因此<code>ARC</code>无法在实例被销毁后将无主引用设置为<code>nil</code></p>

<p><em>注意</em>:</p>

<blockquote>
<p>使用无主引用，必须<strong>保证引用始终指向一个未销毁的实例</strong><br/>
试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误</p>
</blockquote>

<p>举个栗子:<br/>
<code>Customer</code>客户和<code>CreditCard</code>银行卡之间的关系,两个类都将另外一个类的实例作为自身属性,关系是客户可能没有银行卡,但是银行卡一定有客户,因此将银行卡的<code>customer</code>设置为无主引用</p>

<pre><code class="language-swift">
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64 //确保在32、64位机器上均可以保存16位的卡号
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}


var john: Customer?
john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)

john = nil
// 打印 “John Appleseed is being deinitialized”
// 打印 ”Card #1234567890123456 is being deinitialized”

</code></pre>

<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对 <code>Customer</code>实例的无主引用</p>

<blockquote>
<p>对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过 <code>unowned(unsafe)</code>来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作</p>
</blockquote>

<h3 id="toc_5">无主引用以及隐式解析可选属性</h3>

<pre><code class="language-swift">class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>

<p>我们在<code>Country</code>的<code>capitalCity</code>属性声明为<code>City!</code>隐式解析可选类型的属性,表明像其他可选类型一样，默认值为<code>nil</code>，但是不需要展开他的值就能访问</p>

<p>因为<code>capitalCity</code>的默认值为默认为<code>nil</code>，因此在构造country时,当name赋值以后,初始化就完成了,此时我们就能把这个初始化的<code>country</code>实例传递给<code>City</code>来构造City实例</p>

<h2 id="toc_6">闭包引起的循环强引用</h2>

<p>闭包和类 类似,都是引用类型,因此,将闭包赋值为某属性时,是将这个闭包的引用赋值给属性,因此当闭包体中访问实例的某个属性时,就会造成循环引用</p>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<blockquote>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为<code>HTML</code>输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>

<p><strong>闭包捕获列表</strong>解决闭包引起的循环引用</p>

<p>对于一个类的闭包属性,想要改变这个属性的行为,可以通过给这个属性再赋值一个闭包</p>

<p><code>HTMLElement</code>有类和作为<code>asHTML</code>默认值的闭包之间的循环强引用</p>

<p>注意:<br/>
虽然闭包中多次使用<code>self</code>，但是它只捕获<code>HTMLElement</code>实例的一个强引用</p>

<p>此时<code>HTMLElement</code>实例和它的闭包是不会被销毁和释放的</p>

<h2 id="toc_7">解决闭包引起的循环强引用</h2>

<p>在定义闭包时同时定义<strong>捕获列表</strong>作为闭包的一部分，捕获列表定义了闭包体内捕获一个或多个引用类型的规则.声明捕获的引用为弱引用或者无主引用,而不是强引用</p>

<blockquote>
<p><code>Swift</code>规定:在闭包中使用<code>self</code>的成员，要使用<code>self.someProperty</code>或者<code>self.someMethod()</code>，而不是使用<code>someProperty</code>或<code>someMethod()</code></p>
</blockquote>

<h3 id="toc_8">定义捕获列表</h3>

<p>捕获列表由一对元素组成,一个是<code>weak</code>或<code>unowned</code>关键字,另一个是类实例的引用如<code>self</code>或初始化的变量.在方括号中用逗号隔开</p>

<pre><code class="language-swift">//如果闭包有参数列表和返回类型，把捕获列表放在它们前面
lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // 这里是闭包的函数体
}

/**
如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，
那么可以把捕获列表和关键字 in 放在闭包最开始的地方
*/

lazy var someClosure: Void -&gt; String = {
    [unowned self, weak delegate = self.delegate!] in
    // 这里是闭包的函数体
}

</code></pre>

<h3 id="toc_9">弱引用和无主引用</h3>

<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为<code>无主引用</code>。(即被捕获的引用不会变为nil使用无主引用)<br/>
在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>，弱引用总是可选类型,在引用的实例被销毁后自动置为<code>nil</code></p>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<p>在<code>asHTML</code>闭包中多了一个捕获列表，<code>[unowned self]</code>将self声明为无主引用<br/>
这时候没有了循环引用,我们就可以销毁<code>HTMLElement</code>实例了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[析构过程]]></title>
    <link href="https://acefish.github.io/15025006795297.html"/>
    <updated>2017-08-12T09:17:59+08:00</updated>
    <id>https://acefish.github.io/15025006795297.html</id>
    <content type="html"><![CDATA[
<p>只适用类类型,当类的实例被释放时,析构器会被立即调用。<br/>
<code>deinit</code>关键字标示析构器</p>

<h2 id="toc_0">析构过程原理</h2>

<p>自动释放不需要的实例来释放资源,通过自动引用计数来管理内存。实例被释放时会自动清理,但是使用自己的资源需要进行额外的清理(比如自己打开一个文件管理类，需要在类被释放前手动关闭该文件).</p>

<p>在类的定义中,每个类最多只能有一个析构器,不带任何参数</p>

<pre><code class="language-swift">deinit {
    // 执行析构过程
}
</code></pre>

<p>析构器在实例被释放前被调用,不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器<br/>
实现的最后，父类的析构器会被自动调用。</p>

<p>直到实例的析构器被调用后，实例才会被释放,所以析构器可以访问实例的所有属性，并且可以根据那些属<br/>
性可以修改它的行为(比如查找一个需要被关闭的文件)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构造过程]]></title>
    <link href="https://acefish.github.io/15020961612430.html"/>
    <updated>2017-08-07T16:56:01+08:00</updated>
    <id>https://acefish.github.io/15020961612430.html</id>
    <content type="html"><![CDATA[
<p>在类、结构体、枚举实例可用前必须执行<strong>构造过程</strong>，用来设置存储属性的初始值和其他的设置或初始化任务</p>

<p>通过定义<strong>构造器</strong>来实现构造过程，构造器是用来创建特定类型新实例的特殊方法。</p>

<blockquote>
<p>与OC不同,swift的构造器无序返回值,只需保证实例在第一次使用前完成正确的初始化</p>
</blockquote>

<p><strong>类的实例</strong>也可以通过定义<strong>析构器</strong>在实例释放之前执行特定的清除工作</p>

<h2 id="toc_0">存储属性的初始化赋值</h2>

<p>类和结构体在创建实例时,存储属性必须有合适的值<br/>
可以在构造器中为存储型属性赋值,也可以在定义属性值时设置默认值,这两种方法设置存储属性值时,值是被直接设置的,不会触发任何属性观察者</p>

<h3 id="toc_1">构造器</h3>

<pre><code class="language-swift">//最简单形式
init() {
    // 在此处执行构造过程
}
</code></pre>

<h3 id="toc_2">默认属性值</h3>

<pre><code class="language-swift">struct Fahrenheit {
    var temperature = 32.0
}
</code></pre>

<h2 id="toc_3">自定义构造过程</h2>

<h3 id="toc_4">构造参数</h3>

<p>自定义构造过程，在定义中提供<strong>构造参数</strong></p>

<pre><code class="language-swift">struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0
</code></pre>

<h3 id="toc_5">参数的内部名称和外部名称</h3>

<p>构造器并没有可区分的名字,都为<code>init</code>，因此需要构造器中的参数名和类型来确定应该被调用的构造器,因此外部名称很重要</p>

<pre><code class="language-swift">struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red = red
        self.green = green
        self.blue = blue
    }
    init(white: Double) {
        red = white
        green = white
        blue = white
    }
}

let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)

//只要构造器定义了外部名称就必须使用,否则报错
let veryGreen = Color(0.0, 1.0, 0.0)//报编译时错误，需要外部名称
</code></pre>

<h3 id="toc_6">不带外部名的构造器参数</h3>

<p>使用下划线来<code>_</code>来不为构造器某个参数提供外部名称</p>

<pre><code class="language-swift">struct Celsius {
    var temperatureInCelsius: Double
    init(_ celsius: Double){
        temperatureInCelsius = celsius
    }
}

let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius 为 37.0
</code></pre>

<p>此时构造器意图明确 可以不需要外部参数名称</p>

<h3 id="toc_7">可选属性类型</h3>

<p>在类型中包含一个逻辑上允许为空的存储型属性,要将其定义为<code>可选类型</code>,可选类型属性在初始化时自动初始化为<code>nil</code></p>

<pre><code class="language-swift">class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: &quot;Do you like cheese?&quot;)
cheeseQuestion.ask()
// 打印 &quot;Do you like cheese?&quot;
cheeseQuestion.response = &quot;Yes, I do like cheese.&quot;
</code></pre>

<p>定义一个可选类型<code>response</code>因为答案在问题之前是无法确定,所以设为<code>String?</code>类型，在实例初始化是,自动赋值为<code>nil</code></p>

<h3 id="toc_8">构造过程中常量属性的修改</h3>

<p>在构造过程中任意时间点都可以给常量属性指定值,直到构造过程结束为一个确定的值,一旦常量属性赋值就永不能更改</p>

<blockquote>
<p>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>

<pre><code class="language-swift">class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
</code></pre>

<h2 id="toc_9">默认构造器</h2>

<p>如果结构体或者类的所有属性都有默认值,那么<code>Swift</code>会提供一个默认构造器,将所有值设置为默认值</p>

<pre><code class="language-swift">class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</code></pre>

<h3 id="toc_10">结构体的逐一成员构造器</h3>

<p>在结构体中,如果没有提供自定义构造器，会自动获得逐一成员构造器</p>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>

<h2 id="toc_11"><strong>值类型</strong>的构造器代理</h2>

<p>构造器可以通过调用其他构造器来完成实例的部分构造过程,即<strong>构造器代理</strong></p>

<p>对于值类型不支持继承,所以构造代理只能代理自己的其他构造器,对于类类型可以继承,需要保证其所有继承的存储型属性在构造时也能正确的初始化</p>

<p>值类型,可以使用也只能用<code>self.init</code>在自定义构造器中引用同类型的其他构造器</p>

<p>值类型定义一个自定义构造器,将无法访问默认构造器(结构体也无法访问逐一构造器),防止在给值类型增加一个复杂的自定义构造器后仍然有人使用自动生成的构造器</p>

<blockquote>
<p>可以通过将自定义的构造器写在扩展中,而不是将值类型写在原始定义中,来使可以通过默认构造器，逐一成员构造器,以及自定义构造器来创建实例</p>
</blockquote>

<h2 id="toc_12">类的继承和构造过程</h2>

<p>类里面的所有存储属性,包括所有继承自父类的属性，都必须在构造过程中设置初始值</p>

<p>类类型的两种构造器:  <strong>指定构造器</strong> <strong>便利构造器</strong></p>

<h3 id="toc_13">指定构造器和便利构造器</h3>

<p>指定构造器初始化类中提供的所有属性,并根据父类链向上条用父类构造器实现父类的初始化<br/>
每个类都必须至少有一个指定构造器,可以通过继承父类的指定构造器来满足条件;</p>

<p>便利构造器是次要、辅助的构造器，定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>

<h3 id="toc_14">指定构造器、便利构造器语法</h3>

<p>类的指定构造器语法与值类型简单构造器相同:</p>

<pre><code class="language-swift">init(parameters) {
    statements
}
</code></pre>

<p>便利构造器在<code>init</code>关键字前加<code>convenience</code>关键字</p>

<pre><code class="language-swift">convenience init(parameters) {
    statements
}
</code></pre>

<h3 id="toc_15">类的构造器代理规则</h3>

<p>构造器之间代理调用限制:</p>

<ol>
<li>指定构造器必须调用父类的指定构造器</li>
<li>便利构造器必须调用同类中定义的其它构造器</li>
<li>便利构造器必须最终导致一个指定构造器被调用</li>
</ol>

<h3 id="toc_16">两段式构造过程</h3>

<p>构造过程的两个阶段:<br/>
第一阶段: 存储属性指定一个初始值<br/>
第二阶段: 进一步定制它们的存储型属性</p>

<p>可以防止属性值在初始化前被访问和被另外的构造器意外赋其他值</p>

<p>两段式构造过程的构造流程:</p>

<p>阶段1:</p>

<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化，阶段1结束</li>
</ul>

<p>阶段2：</p>

<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问<code>self</code>、修改它的属性并调用实例方法等等</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用 self</li>
</ul>

<h3 id="toc_17">构造器的继承和重写</h3>

<p>与<code>OC</code>不同,<strong><code>swift</code>的子类默认情况下不继承父类构造器</strong>，以防止父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例</p>

<p>要在子类中提供和父类相同指定构造器时,需要重写父类的这个指定构造器,因此必须在子类构造器前加上<code>override</code>修饰符，即使重写的是系统提供的默认构造器,也需要带上<code>override</code></p>

<blockquote>
<p>重写一个父类的指定构造器时，你总是需要写<code>override</code>修饰符，即使你的子类将父类的指定构造器重写为了便利构造器</p>
</blockquote>

<p>而在子类中写一个和父类相同的便利构造器,因为子类不能直接调用父类的便利构造器,因此并未对其进行重写，也不需要加上<code>override</code>前缀</p>

<pre><code class="language-swift">class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return &quot;\(numberOfWheels) wheel(s)&quot;
    }
}
</code></pre>

<p>因为存储属性有默认值,因此会自动获得一个默认构造器</p>

<pre><code class="language-swift">class Bicycle: Vehicle {
    override init() {
        super.init()//可以确保继承的属性 numberOfWheels 能被 Vehicle 类初始化
        numberOfWheels = 2
    }
}
//子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。
</code></pre>

<h3 id="toc_18">构造器的自动继承</h3>

<p>默认子类不继承父类构造器,但是如果满足特定条件是可以被自动继承的</p>

<p>如果为<strong>子类引用的新属性都提供了默认值</strong>:</p>

<ol>
<li>如果子类没有定义任何指定构造器,将自动继承<strong>所有父类</strong>的指定构造器</li>
<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则1继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器</li>
</ol>

<h3 id="toc_19">指定构造器和便利构造器实践</h3>

<pre><code class="language-swift">class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: &quot;[Unnamed]&quot;)
    }
}

let namedMeat = Food(name: &quot;Bacon&quot;)
// namedMeat 的名字是 &quot;Bacon”
let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
</code></pre>

<pre><code class="language-swift">class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    //便利构造器重写了父类的指定构造器
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
let oneMysteryItem = RecipeIngredient() //会继承父类的便利构造器
let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)
let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)
</code></pre>

<pre><code class="language-swift">class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = &quot;\(quantity) x \(name)&quot;
        output += purchased ? &quot; ?&quot; : &quot; ?&quot;
        return output
    }
}
/**
    子类引用的属性都提供了默认值,并且没有自定义构造器,将自动继承所有父类中指定和便利
    构造器
*/
</code></pre>

<h2 id="toc_20">可失败构造器</h2>

<p>如果类、结构体、枚举类型对象在构造时可能会失败,则为其定义一个<strong>可失败构造器</strong></p>

<p>可失败构造器通过在<code>init</code>关键字后添加<code>?</code></p>

<p>注意:<br/>
可失败构造器的参数名和参数类型不能与其他非可失败构造器参数名及参数类型相同</p>

<p>可失败构造器创建自身类型的可选类型对象，构造器并不支持返回值,我们在构造器方法中通过<code>return nil</code>来表示构造失败，</p>

<pre><code class="language-swift">struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}

let anonymousCreature = Animal(species: &quot;&quot;)
// anonymousCreature 的类型是 Animal?, 而不是 Animal
if anonymousCreature == nil {
    print(&quot;The anonymous creature could not be initialized&quot;)
}
// 打印 &quot;The anonymous creature could not be initialized&quot;
</code></pre>

<h3 id="toc_21">枚举类型的可失败构造器</h3>

<p>通过提供的参数来获取特定的枚举成员,如果参数无法匹配任何枚举成员,则构造失败</p>

<pre><code class="language-swift">enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case &quot;K&quot;:
            self = .Kelvin
        case &quot;C&quot;:
            self = .Celsius
        case &quot;F&quot;:
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
</code></pre>

<h3 id="toc_22">带原始值的枚举类型可失败构造器</h3>

<p>带原始值的枚举类型会自带可失败构造器 <code>init?(rawValue:)</code>，参数<code>rawvalue</code>的和枚举类型原始值类型相同,如果能和枚举成员原始值匹配则构造响应枚举成员,否则构造失败</p>

<pre><code class="language-swift">enum TemperatureUnit: Character {
    case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;
}
</code></pre>

<h3 id="toc_23">构造失败的传递</h3>

<p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器，也能向上代理到父类可失败构造器,如果在代理的其他可失败构造器触发构造失败，构造过程终止,接下来构造代码不执行</p>

<pre><code class="language-swift">class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity &lt; 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
//尝试用空name初始化CarItem导致父类构造过程失败
if let oneUnnamed = CartItem(name: &quot;&quot;, quantity: 1) {
    print(&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;)
} else {
    print(&quot;Unable to initialize one unnamed product&quot;)
}
// 打印 &quot;Unable to initialize one unnamed product”

</code></pre>

<h3 id="toc_24">可失败构造器重写</h3>

<p>可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器,但是不能用可失败构造器重写非可失败构造器</p>

<pre><code class="language-swift">class Document {
    var name: String?
    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
    init() {}
    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
    init?(name: String) {
        self.name = name
        if name.isEmpty { return nil }
    }
}

class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = &quot;[Untitled]&quot;
    }
    //用非可失败构造器 init(name:) 重写了父类的可失败构造器 init?(name:)
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = &quot;[Untitled]&quot;
        } else {
            self.name = name
        }
    }
}

//或者可以写为

class UntitledDocument: Document {
    override init() {
    //通过强制解包调用父类的可失败构造器
        super.init(name: &quot;[Untitled]&quot;)!
    }
}
</code></pre>

<h3 id="toc_25">可失败构造器 init!</h3>

<p>可以通过在<code>init</code>后加上<code>!</code>定义一个可失败构造器，会构造一个对应类型的隐式解包可选类型对象</p>

<p>可以在<code>init?</code>中代理到<code>init!</code>，反之亦然。你也可以用<code>init?</code>重写<code>init!</code>，反之亦然。你还可以用 <code>init</code>代理到<code>init!</code>，不过，一旦<code>init!</code>构造失败，则会触发一个断言</p>

<h2 id="toc_26">必要构造器</h2>

<p>类的构造器前添加<code>required</code>修饰符表明所有该类的<code>子类</code>都必须实现该构造器</p>

<pre><code class="language-swift">class SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加<code>required</code>修饰符,不需要添加<code>override</code>修饰符</p>

<pre><code class="language-swift">class SomeSubclass: SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>注意：<br/>
<strong>如果在子类继承的构造器能满足必要构造器的要求,则无须在子类中显式提供必要构造器的实现</strong></p>

<h2 id="toc_27">用闭包或函数设置属性默认值</h2>

<p>使用闭包或全局函数为村塾属性提供默认值,当该类型实例被创建，对应闭包或函数会被调用,他们的返回值会作为这个属性的默认值</p>

<pre><code class="language-swift">class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
    }()
}
</code></pre>

<p>闭包结尾的必须需要一对空的<code>小括号</code>.表明<code>swift</code>立即执行闭包，将闭包的返回值赋值给属性，如果没有括号就相当于将闭包作为值赋值给属性</p>

<blockquote>
<p>在使用闭包来初始化属性时,在闭包被执行时，实例其他部分还没有被初始化,因此不能再闭包中访问其他属性，即使有默认值。也不能隐式使用<code>self</code>或者调用任何实例方法</p>
</blockquote>

<p>闭包初始化存储属性<br/>
```swift<br/>
struct Checkerboard {<br/>
//设置100个bool颜色的数组<br/>
    let boardColors: [Bool] = {<br/>
        var temporaryBoard = <a href="">Bool</a><br/>
        var isBlack = false<br/>
        for i in 1...8 {<br/>
            for j in 1...8 {<br/>
                temporaryBoard.append(isBlack)<br/>
                isBlack = !isBlack<br/>
            }<br/>
            isBlack = !isBlack<br/>
        }<br/>
        return temporaryBoard<br/>
    }()</p>

<pre><code>//返回某一行或列的颜色
func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
    return boardColors[(row * 8) + column]
}
</code></pre>

<p>}</p>

<p>let board = Checkerboard()<br/>
print(board.squareIsBlackAtRow(0, column: 1))<br/>
// 打印 &quot;true&quot;<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[继承]]></title>
    <link href="https://acefish.github.io/15018175799489.html"/>
    <updated>2017-08-04T11:32:59+08:00</updated>
    <id>https://acefish.github.io/15018175799489.html</id>
    <content type="html"><![CDATA[
<p>类可以继承父类的方法、属性和其他特征</p>

<p>类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。</p>

<p>可以为类中继承的属性添加属性观察器</p>

<h2 id="toc_0">定义一个基类</h2>

<p>不继承于其它类的类,称之为基类</p>

<p>注意:</p>

<blockquote>
<p><code>Swift</code>中类并不是从一个通用类继承而来.如果没有为定义的类制定一个超类的话,这个类自动成为一个基类</p>
</blockquote>

<p>创建一个<code>Vehicle</code>的基类，来描述通用车辆</p>

<pre><code class="language-swift">class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return &quot;traveling at \(currentSpeed) miles per hour&quot;
    }
    func makeNoise() {
        // 什么也不做-因为车辆不一定会有噪音
    }
}
</code></pre>

<h2 id="toc_1">子类生成</h2>

<pre><code class="language-swift">//定义一个自行车Bicycle继承自Vehicle
class Bicycle: Vehicle {
    var hasBasket = false
}
</code></pre>

<p>除了继承自父类的方法、属性外，还定义了一个默认值为<code>false</code>的存储属性<code>hasBasket</code></p>

<pre><code class="language-swift">let bicycle = Bicycle()
bicycle.hasBasket = true
//修改继承的属性
bicycle.currentSpeed = 15.0
print(&quot;Bicycle: \(bicycle.description)&quot;)
// 打印 &quot;Bicycle: traveling at 15.0 miles per hour&quot;
</code></pre>

<h2 id="toc_2">重写</h2>

<p>为继承来的实例方法、类方法、实例属性、下标提供自己的实现,即为<strong>重写</strong></p>

<p>需要在重写的定义前加上 <code>override</code>关键字表明重写,否则即为错误的提供了相同的定义</p>

<h3 id="toc_3">访问父类的方法、属性和下标</h3>

<p>通过<code>super</code>前缀来访问父类版本中的方法、属性或下标</p>

<ul>
<li>在方法 someMethod() 的重写实现中，可以通过 super.someMethod() 来调用超类版本的 someMethod() 方法</li>
<li>在属性 someProperty 的 getter 或 setter 的重写实现中，可以通过 super.someProperty 来访问超类版本的someProperty 属性</li>
<li>在下标的重写实现中，可以通过 super[someIndex] 来访问超类版本中的相同下标</li>
</ul>

<h3 id="toc_4">重写方法</h3>

<pre><code class="language-swift">class Train: Vehicle {
    override func makeNoise() {
        print(&quot;Choo Choo&quot;)
    }
}
</code></pre>

<h3 id="toc_5">重写属性</h3>

<p>重写继承来的实例或者类型属性来提供自己定制的<code>getter</code>或者<code>setter</code>或添加属性观察器来观察属性值的改变</p>

<h4 id="toc_6">重写属性的setter和getter</h4>

<p>子类并不知道继承来的属性是存储型还是计算型,重写时要提供属性名称和类型来让编译器去查找父类同名同类型的属性</p>

<p>可以把继承的只读属性重写为可读写,但是没有办法把可读写的重写为只读属性</p>

<blockquote>
<p>如果你在重写属性中提供了<code>setter</code>，那么你也一定要提供<code>getter</code>。如果你不想在重写版本中的<br/>
<code>getter</code>里修改继承来的属性值，你可以直接通过<code>super.someProperty</code>来返回继承来的值</p>
</blockquote>

<pre><code class="language-swift">class Car: Vehicle {
    var gear = 1
    //重写description属性
    override var description: String {
        return super.description + &quot; in gear \(gear)&quot;
    }
}

let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print(&quot;Car: \(car.description)&quot;)//返回自定义描述
// 打印 &quot;Car: traveling at 25.0 miles per hour in gear 3&quot;
</code></pre>

<h4 id="toc_7">重写属性观察器</h4>

<p>注意:<br/>
1. 不能为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器,因为它们不能被设置<br/>
2. 不能同时提供重写的<code>setter</code>和重写的属性观察器。因为此时我们可以直接在setter中观察值的变化</p>

<pre><code class="language-swift">class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1(后向下取得最接近的整数值在加1)
        }
    }
}
</code></pre>

<p>为属性<code>currentSpeed</code>添加观察器，设置速度时就会自动选择合适的档位</p>

<h2 id="toc_8">防止重写</h2>

<p>通过把方法、属性或下标 前加关键字<code>final</code>来防止被重写,例如:<code>final var</code> ， <code>final func</code> ， <code>final class func</code> ，以及 <code>final subscript</code></p>

<p>通过在<code>class</code>前添加关键字<code>final</code>表示这个类是不可被继承的</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[下标]]></title>
    <link href="https://acefish.github.io/15017615739867.html"/>
    <updated>2017-08-03T19:59:33+08:00</updated>
    <id>https://acefish.github.io/15017615739867.html</id>
    <content type="html"><![CDATA[
<p>下标可以定义在类、结构体和枚举中，用于访问集合、列表或序列中的元素</p>

<p>一个类型可以定义多个下标.通过不同索引类型进行重载.下标不限于一维</p>

<h2 id="toc_0">下标语法</h2>

<p>通过在实例名称后的方括号中传入一个或多个索引值来对实例进行存取</p>

<p>定义下标使用<code>subscript</code>关键字,指定一个或者多个输入参数和返回类型<br/>
下标可以设置为读写或者只读,通过是<code>getter</code>或者<code>setter</code>实现</p>

<pre><code class="language-swift">subscript(index: Int) -&gt; Int {
    get {
        // 返回一个适当的 Int 类型的值
    }
    set(newValue) {
        // 执行适当的赋值操作
    }
}
</code></pre>

<p>可以不指定<code>setter</code>的参数,默认提供<code>newValue</code></p>

<pre><code class="language-swift">struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
print(&quot;six times three is \(threeTimesTable[6])&quot;)
// 打印 &quot;six times three is 18&quot;
</code></pre>

<p>定义一个数学公式结构体,只读的下标语法</p>

<h2 id="toc_1">下标用法</h2>

<pre><code class="language-swift">//字典的下标语法
var numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]
numberOfLegs[&quot;bird&quot;] = 2
</code></pre>

<h2 id="toc_2">下标选项</h2>

<p>下标可以使用变量参数和可变参数,但不能使用输入输出参数,也不能给参数设置默认值</p>

<p>下标的重载:<br/>
类和结构体可以根据自身需要提供多个下标实现,通过入参和类型进行区分</p>

<pre><code class="language-swift">struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        //通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            //断言语句
            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)
            return grid[(row * columns) + column]
        }
        set {
            //断言语句
            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)
            grid[(row * columns) + column] = newValue
        }
    }
}
</code></pre>

<pre><code class="language-swift">var matrix = Matrix(rows: 2, columns: 2)
//下标入参用逗号进行分割
matrix[0, 1] = 1.5 //将下标为(0,1)位置设置为1.5
</code></pre>

<p>通过断言,检查下标入参<code>row</code>和<code>colum</code>的值是否有效.定义方法<code>indexIsValidForRow(_:column:)</code>检查入参<code>row</code>和<code>columu</code>是否越界,断言会在下标月结</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法]]></title>
    <link href="https://acefish.github.io/15017296324997.html"/>
    <updated>2017-08-03T11:07:12+08:00</updated>
    <id>https://acefish.github.io/15017296324997.html</id>
    <content type="html"><![CDATA[
<p><code>类、结构体、枚举</code>都可以定义实例方法，实例方法为给定类型实例封装了具体的任务和功能</p>

<p><code>类、结构体、枚举</code>也可定义类型方法,类型方法与类型本身关联（与OC中类似）</p>

<h2 id="toc_0">实例方法</h2>

<p>实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。<br/>
<strong>实例方法的语法与函数完全一致</strong></p>

<p>实例方法能够隐式访问它所属类型的所有的其他实例方法和属性</p>

<pre><code class="language-swift">class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}

let counter = Counter()
// 初始计数值是0
counter.increment()
// 计数值现在是1
counter.increment(by: 5)
// 计数值现在是6
counter.reset()
// 计数值现在是0
</code></pre>

<h3 id="toc_1">self属性</h3>

<p>与OC类似,<code>self</code>等同于该类型的实例本身</p>

<pre><code class="language-swift">//所以我们可以这么写
func increment() {
    self.count += 1
}
</code></pre>

<p>其实没必要写<code>self</code>，使用已知的属性名或者方法名 <code>swift</code>会假定你使用的是当前实例属性或者方法</p>

<p>我们使用的主要场景:<br/>
实例方法的某个<code>参数名称</code>与实例的某个<code>属性名称</code>相同的时候,此时优先使用参数名,因此我们通过<code>self</code>属性来进行区分使用属性</p>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOfX(_ x: Double) -&gt; Bool {
        return self.x &gt; x//用self来区分属性
    }
}

let somePoint = Point(x: 4.0, y: 5.0)

if somePoint.isToTheRightOfX(1.0) {
    print(&quot;This point is to the right of the line where x == 1.0&quot;)
}
// 打印 &quot;This point is to the right of the line where x == 1.0&quot;
</code></pre>

<h3 id="toc_2">实例方法中修改值类型</h3>

<p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改</p>

<p>我们可以通过给这个实例方法选择<code>可变(mutating)</code>行为，就可以在方法内部修改改变它的属性;这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的<code>self</code>属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例</p>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveByX(2.0, y: 3.0)
print(&quot;The point is now at (\(somePoint.x), \(somePoint.y))&quot;)
// 打印 &quot;The point is now at (3.0, 4.0)&quot;
</code></pre>

<p>注意:<br/>
不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性</p>

<h3 id="toc_3">在可变方法中给self赋值</h3>

<p>可以在可变方法中给隐含属性<code>self</code>赋予一个新的实例</p>

<pre><code class="language-swift">struct Point1 {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point1(x: x + deltaX, y: y + deltaY)
    }
}
</code></pre>

<p>创建一个新的结构体实例赋值给self，替换现在的实例</p>

<p>枚举的可变方法，定义了一个三态开关状态枚举,通过调用<code>next()</code>进行切换状态</p>

<pre><code class="language-swift">enum TriStateSwitch {
    case Off, Low, High
    mutating func next() {
        switch self {
        case .Off:
            self = .Low
        case .Low:
            self = .High
        case .High:
            self = .Off
        }
    }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight 现在等于 .High
ovenLight.next()
// ovenLight 现在等于 .Off
</code></pre>

<h2 id="toc_4">类型方法</h2>

<p>定义在类型本身上的方法,即为类型方法<br/>
通过在方法<code>func</code>前加关键字<code>static</code>，来指定类型方法,通过加关键字<code>class</code>来实现子类重写父类的方法实现</p>

<blockquote>
<p>在<code>oc</code>中只能为类定义类型方法,但是在<code>swift</code>中可以为类,结构体,枚举定义类方法</p>
</blockquote>

<p>类型方法在类型上通过点语法调用<br/>
在类型方法中,<code>self</code>指向类型本身,同样的可以用其来区分同样的类型属性和类型方法参数</p>

<p>在类型方法体中可以调用本类中类型属性或的其他类型方法,调用是可以直接通过类型方法名称或者类型属性名称进行调用,而不用在前面添加类型名称</p>

<pre><code class="language-swift">//检测玩家等级的结构体
struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1
    static func unlock(_ level: Int) {
        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func isUnlocked(_ level: Int) -&gt; Bool {
        return level &lt;= highestUnlockedLevel
    }
    @discardableResult //
    mutating func advance(to level: Int) -&gt; Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
</code></pre>

<pre><code class="language-swift">//玩家类
class Player {
    var tracker = LevelTracker()
    let playerName: String
    func complete(level: Int) {
        LevelTracker.unlock(level + 1)
        tracker.advance(to: level + 1)
    }
    init(name: String) {
        playerName = name
    }
}
</code></pre>

<pre><code class="language-swift">var player = Player(name: &quot;Argyrios&quot;)
player.complete(level: 1)
print(&quot;highest unlocked level is now \(LevelTracker.highestUnlockedLevel)&quot;)
// 打印 &quot;highest unlocked level is now 2&quot;

player = Player(name: &quot;Beto&quot;)
if player.tracker.advance(to: 6) {
print(&quot;player is now on level 6&quot;)
} else {
print(&quot;level 6 has not yet been unlocked&quot;)
}
// 打印 &quot;level 6 has not yet been unlocked&quot;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性]]></title>
    <link href="https://acefish.github.io/15015839505859.html"/>
    <updated>2017-08-01T18:39:10+08:00</updated>
    <id>https://acefish.github.io/15015839505859.html</id>
    <content type="html"><![CDATA[
<p>属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>

<p>属性也可以直接作用于类型本身，这种属性称为类型属性。</p>

<p>可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作.可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>

<h2 id="toc_0">存储属性</h2>

<p>存储属性就是存储在特定类或结构体实例里的一个常量或变量,可以为变量或者常量<br/>
可以在定义存储属性时指定默认值，也可在构造过程中设置或修改存储属性值,甚至修改常量存储属性值</p>

<pre><code class="language-swift">struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
rangeOfThreeItems.firstValue = 6
</code></pre>

<p>定义一个结构体,包含<code>firstValue</code>变量存储属性,和<code>length</code>常量存储属性。<code>length</code>在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值</p>

<h3 id="toc_1">常量结构体的存储属性</h3>

<p>若结构体声明为常量,则无法修改实例的任何属性,即使为变量属性:</p>

<pre><code class="language-swift">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// 该区间表示整数0，1，2，3
rangeOfFourItems.firstValue = 6//报错不可修改
// 尽管 firstValue 是个变量属性，这里还是会报错
</code></pre>

<p>这是由于结构体为值类型,值类型为常量则所有属性也变为常量</p>

<p>对于引用类型的类来说,将引用类型赋值给一个常量，仍然可以修改实例的变量属性</p>

<h3 id="toc_2">延迟存储属性</h3>

<p><strong>延迟属性</strong>第一次调用时才会结算其初始化值的属性<br/>
在属性声明前加<code>lazy</code>来标示一个延迟存储属性</p>

<blockquote>
<p>必须将延迟存储属性声明成<code>变量</code>（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而<strong>常量属性在构造过程完成之前必须要有初始值</strong>，因此无法声明成延迟属性。</p>
</blockquote>

<pre><code class="language-swift">class DataImporter {
    /*
    DataImporter 是一个负责将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */
    var fileName = &quot;data.txt&quot;
    // 这里会提供数据导入功能
}
class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // 这里会提供数据管理功能
}
</code></pre>

<pre><code class="language-swift">let manager = DataManager()
manager.data.append(&quot;Some data&quot;)
//此时实例的import属性还没创建
</code></pre>

<pre><code class="language-swift">print(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 &quot;data.txt”
</code></pre>

<p><strong>如果一个被标记为<code>lazy</code>的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次</strong></p>

<h3 id="toc_3">存储属性和实例变量</h3>

<p>与OC不同<code>Swift</code>没有属性对应的实例变量，因此没有办法直接访问属性的后端存储，方便统一访问方式<br/>
使属性的全部信息包括<code>命名、类型和内存管理特征</code>都在一个地方定义</p>

<h2 id="toc_4">计算属性</h2>

<p>计算属性不存储值而是提供一个<code>getter</code>和一个可选的<code>setter</code>,来间接获取和设置其他属性或变量的值</p>

<blockquote>
<p>必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的</p>
</blockquote>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
                  size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)
</code></pre>

<p>可以通过<code>square.center</code>访问计算属性<code>center</code> 会调用<code>getter</code>计算新的值返回<br/>
<code>center</code>可以设置一个新值,会调用<code>setter</code>来修改<code>origin</code>来移动正方形</p>

<h3 id="toc_5">简化setter声明</h3>

<p>如果计算属性的<code>setter</code>没有定义表示新值,就可以使用默认名称<code>newValue</code></p>

<pre><code class="language-swift">struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
</code></pre>

<h3 id="toc_6">只读的计算属性</h3>

<p>只有<code>getter</code>没有<code>setter</code>的计算属性就是只读计算属性，可以访问值,不能设置新值</p>

<pre><code class="language-swift">struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
</code></pre>

<p>只读属性可以省略掉 <code>get</code>关键字和花括号</p>

<h2 id="toc_7">属性观察器</h2>

<p><strong>属性观察器</strong>监控和响应属性值变化，每次属性被设置时会调用属性观察器</p>

<p>为<code>除了延迟属性</code>外其他存储属性添加属性观察器，对于继承的存储属性和计算属性,通过重写的方式来添加属性观察器<br/>
对于非继承的计算属性没必要添加属性观察器，我们可以通过<code>setter</code>方法直接监控</p>

<p>属性观察期器:<br/>
* <code>willSet</code>在新值被设置前调用<br/>
* <code>didSet</code>在新值被设置之后调用</p>

<p><code>willSet</code>观察器会将新的属性值作为常量参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名<br/>
称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>

<p><code>didSet</code>观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。如果<br/>
在<code>didSet</code>方法中再次对该属性赋值，那么新值会覆盖旧的值</p>

<blockquote>
<p>父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>
</blockquote>

<pre><code class="language-swift">class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)
        }
        didSet {
            if totalSteps &gt; oldValue {
                print(&quot;Added \(totalSteps - oldValue) steps&quot;)
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
</code></pre>

<p>注意:<br/>
在willSet或者didSet方法中设置属性值是不会触发的属性观察器方法  </p>

<blockquote>
<p>如果将属性通过<code>in-out</code>方式传入函数，<code>willSet</code>和<code>didSet</code>也会调用。这是因为<code>in-out</code>参数采用了拷入拷出模式：即在函数内部使用的是参数的<code>copy</code>，函数结束后，又对参数重新赋值。</p>
</blockquote>

<h2 id="toc_8">全局变量和局部变量</h2>

<p>全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<p><strong>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量</strong></p>

<p>我们之前用的变量都是存储型变量,跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入</p>

<p>我们可以在全局或局部范围为存储型变量定义观察器</p>

<p>在全局或局部范围都可以定义计算型变量。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样</p>

<p><strong>注意:</strong><br/>
1. 全局的常量或变量都是延迟计算，类似<code>延迟属性</code>但是不需要<code>lazy</code>声明<br/>
2. 局部的常量或变量从不延迟计算</p>

<h2 id="toc_9">类型属性</h2>

<p>可以为类型本身定义属性</p>

<p>类型属性用于定义某个类型所有实例共享的数据</p>

<p>类型属性也可以有 存储型的常量或变量 计算型的只能为变量</p>

<p>注意:</p>

<blockquote>
<p>存储型类型属性必须指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值</p>

<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用<code>lazy</code>修饰符。</p>
</blockquote>

<h3 id="toc_10">类型属性语法</h3>

<p>在<code>OC</code>中,在类中关联的静态变量和常量是作为全局静态变量定义</p>

<p>在<code>Swift</code>中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，作用范围就在类型支持的范围内</p>

<p>使用<code>static</code>来定义类型属性。<br/>
在为类定义计算型类型属性时，可以改用关键字<code>class</code>来支持子类对父类的实现进行重写</p>

<pre><code class="language-swift">//结构体
struct SomeStructure {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 1
    }
}
//枚举
enum SomeEnumeration {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 6
    }
}
//类
class SomeClass {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 27
    }
    //子类对父类的实现进行重写
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}

</code></pre>

<h3 id="toc_11">获取和设置类型属性值</h3>

<p>类型属性通过点运算符通过类型本身来访问</p>

<pre><code class="language-swift">print(SomeStructure.storedTypeProperty)
    // 打印 &quot;Some value.&quot;
SomeStructure.storedTypeProperty = &quot;Another value.&quot;
print(SomeStructure.storedTypeProperty)
    // 打印 &quot;Another value.”
print(SomeEnumeration.computedTypeProperty)
    // 打印 &quot;6&quot;
print(SomeClass.computedTypeProperty)
    // 打印 &quot;27&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类和结构体]]></title>
    <link href="https://acefish.github.io/15005513837564.html"/>
    <updated>2017-07-20T19:49:43+08:00</updated>
    <id>https://acefish.github.io/15005513837564.html</id>
    <content type="html"><![CDATA[
<p>可以使用完全相同的语法规则来为<code>类</code>和<code>结构体</code>定义属性(<code>常量</code>、<code>变量</code>)和添加方法，从而扩展类和结构体的功能</p>

<p>与其他编程语言不同,<code>swift</code>不要求为自定义类和结构创建独立的接口和实现文件.所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口</p>

<h2 id="toc_0">类和结构体对比</h2>

<blockquote>
<p>类通过引用计数进行多次引用,结构体通过复制的方式在代码中传递,不使用引用计数</p>
</blockquote>

<h3 id="toc_1">定义语法</h3>

<p>通过关键之<code>class</code>和<code>struct</code>来分别标识类和结构体</p>

<blockquote>
<p>类和结构体名使用首字母大写的方式进行命名</p>
</blockquote>

<pre><code class="language-swift">//定义一个结构体 描述显示器屏幕分辨率
struct Resolution {
    var width = 0
    var height = 0
    //当这两个属性被初始化为整数 0 的时候，它们会被推断为 Int 类型。
}

//定义一个类 描述视频显示器的特定模式
//四个变量存储属性
class VideoMode {
    var resolution = Resolution()//分辨率 结构体
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
</code></pre>

<p><code>存储属性</code>是被<code>捆绑</code>和<code>存储</code>在类或结构体中的常量或变量。</p>

<h3 id="toc_2">类和结构体实例</h3>

<p>初始化结构体或类的实例</p>

<pre><code class="language-swift">let someResolution = Resolution()
let someVideoMode = VideoMode()
</code></pre>

<p>通过这种方式创建类或者结构体实例,属性都会被初始化为默认值.</p>

<h3 id="toc_3">属性访问</h3>

<p>通过点语法访问实例属性。</p>

<pre><code class="language-swift">//访问结构体属性
print(&quot;The width of someResolution is \(someResolution.width)&quot;)
// 打印 &quot;The width of someResolution is 0&quot;

//访问变量属性
someVideoMode.resolution.width = 1280
print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)
// 打印 &quot;The width of someVideoMode is now 1280&quot;
</code></pre>

<blockquote>
<p>在OC中是不能直接设置结构体子属性值，swift中可以直接设置比如<code>resolution.width</code>属性值,在oc中我们需要给整个结构体<code>resolution</code>设置新值</p>
</blockquote>

<h3 id="toc_4">结构体类型成员逐一构造器</h3>

<p>对于<strong>结构体</strong><br/>
所有结构体都有一个自动生成的<strong>成员逐一构造器</strong>，用来初始化新结构体成员的属性</p>

<pre><code class="language-swift">//通过属性名称
let vga = Resolution(width:640, height: 480)
</code></pre>

<p>类是没有这个成员构造器的</p>

<h2 id="toc_5">结构体和枚举时值类型</h2>

<p><strong>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝</strong></p>

<p>实际上,在<code>Swift</code>中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是<strong>以结构体的形式所实现</strong></p>

<p>在<code>swift</code>中,所有结构体和枚举类型都是值类型。因此,它们的实例以及实例中包含的值类型属性,在传递时都会被复制</p>

<pre><code class="language-swift">let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
cinema.width = 2048
print(&quot;cinema is now \(cinema.width) pixels wide&quot;)// &quot;cinema is now 2048 pixels wide&quot;
print(&quot;hd is still \(hd.width) pixels wide&quot;)//&quot;hd is still 1920 pixels wide&quot;
</code></pre>

<p>在对结构体进行赋值的时候,进行了拷贝,cinema和hd是完全不同的两个实例,因此改变了cinema的宽对hd没有影响</p>

<p>枚举也是值类型,遵循相同的行为准则</p>

<h2 id="toc_6">类是引用类型</h2>

<p>与值类型不同,引用类型在传递时,值不会被拷贝.因此，<strong>引用的是已存在的实例本身而不是其拷贝</strong>。</p>

<pre><code class="language-swift">let tenEighty = VideoMode()
tenEighty.frameRate = 25.0

let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
print(&quot;The frameRate property of tenEighty is now \(tenEighty.frameRate)&quot;)//30.0
</code></pre>

<p>类是引用类型，所以<code>tenEight</code>和<code>alsoTenEight</code>实际上引用的是相同的<code>VideoMode</code>实例<br/>
注意:<br/>
虽然<code>alsoTenEighty</code>为常量但是仍然可以改变<code>alsoTenEighty.frameRate</code>因为这两个常量的值并未改变,这个常量的值存储的并不是<code>ViewMode</code>的实例,而是对其的引用.</p>

<h3 id="toc_7">恒等运算符</h3>

<p>等价于 <code>===</code>  不等价于 <code>!==</code> 用来检测两个变量或常量是否引用同一个实例</p>

<p><code>===</code>与<code>==</code>的不同:<br/>
“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。<br/>
“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准</p>

<h3 id="toc_8">指针</h3>

<p>一个引用实例的<code>swift</code>常量或者变量,与C指针类似,但是并不直接指向某个内存地址,也不需要用<code>*</code>表明在创建引用.</p>

<h2 id="toc_9">类和结构体的选择</h2>

<h2 id="toc_10">字符串、数组、字典类型的赋值和复制行为</h2>

<p>因为<code>swift</code>中很多基本类型,<code>String</code>，<code>Array</code>和<code>Dictionary</code>类型均以结构体的形式实现，赋值给新的常量变量或者传入函数方法中的时候会被拷贝</p>

<blockquote>
<p>在OC中<code>NSString</code>，<code>NSArray</code>和<code>NSDictionary</code>是以类的形式实现,不会发生值拷贝而是传递引用</p>

<p>Swift会在绝对必要时才执行实际拷贝,确保性能最优,因此我们没有必要回避赋值来增加性能</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[枚举]]></title>
    <link href="https://acefish.github.io/15003778819226.html"/>
    <updated>2017-07-18T19:38:01+08:00</updated>
    <id>https://acefish.github.io/15003778819226.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>与C语言不同，<code>Swift</code>中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p></li>
<li><p>枚举成员可以指定任意类型的关联值存储到枚举成员中</p></li>
<li><p>在 Swift 中，<strong>枚举类型</strong>是一等（first-class）类型。采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p></li>
</ol>

<h2 id="toc_0">枚举语法</h2>

<p>用<code>enum</code>关键字来创建枚举</p>

<pre><code class="language-swift">enum CompassPoint {
    case north
    case south
    case east
    case west
}

//多个成员可以在同一行 用 , 隔开
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>我们使用<code>case</code>来定义一个新的枚举成员值</p>

<blockquote>
<p>与OC不同,Swift枚举成员不会再创建时被赋予一个默认的整型值。这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的<code>CompassPoint</code>类型</p>
</blockquote>

<p>在<code>Swift</code>中每个枚举定义了一个全新的类型，与Swift中的其他类型一样,名字以大写字母开头</p>

<pre><code class="language-swift">var directionToHead = CompassPoint.west
//此时directionToHead类型可以被推断出来,我们可以直接使用 . 语法将其设置为另一个枚举值
directionToHead = .east
</code></pre>

<p>当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名。</p>

<h2 id="toc_1">用switch语句匹配枚举值</h2>

<p>在判断一个枚举类型值时,<code>switch</code>必须穷举所有情况，如果不需要匹配每个成员可以使用<code>default</code>分支</p>

<pre><code class="language-swift">let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print(&quot;Mostly harmless&quot;)
default:
    print(&quot;Not a safe place for humans&quot;)
}
// 打印 &quot;Mostly harmless”
</code></pre>

<h2 id="toc_2">关联值</h2>

<p>可以使用<code>Swift</code>的枚举来<strong>存储任意类型的关联值</strong>,枚举成员的关联值类型可以不同(关联值)</p>

<pre><code class="language-swift">enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
</code></pre>

<p>定义一个枚举类型,一个成员值是具有 <code>(Int，Int，Int，Int)</code>类型关联值的 upc，另一个是<code>String</code>类型关联值的qrcode</p>

<pre><code class="language-swift">//给其赋值关联的元组值
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
//赋值新的枚举关联字符串
productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)
//productBarcode同一时间只能存储这两个值中的一个
</code></pre>

<pre><code class="language-swift">switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case .qrCode(let productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 打印 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<p>我们可以提取出来关联值作为常量或变量</p>

<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>：</p>

<pre><code class="language-swift">switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case let .qrCode(productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 输出 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<h2 id="toc_3">原始值</h2>

<p>枚举成员可以被<strong>默认值（称为原始值）预填充</strong>，这些原始值的类型必须相同。</p>

<pre><code class="language-swift">enum ASCIIControlCharacter: Character {
    case tab = &quot;\t&quot;
    case lineFeed = &quot;\n&quot;
    case carriageReturn = &quot;\r&quot;
}
</code></pre>

<p>枚举类型<code>ASCIIControlCharacter</code>的原始值类型被定义为<code>Character</code><br/>
每个原始值在枚举声明中必须是唯一的。</p>

<blockquote>
<p>注意原始值与关联值的不同，原始值是在定义枚举是预先填充的值，对于特定的枚举成员其原始值不变<br/>
关联值是创建一个基于枚举成员的常量或变量时才设置的值,枚举成员的关联值可以变化</p>
</blockquote>

<h3 id="toc_4">原始值的隐式赋值</h3>

<p>当原始值为整数或者字符串类型的枚举时,Swift会自动为每个枚举成员设置原始值;</p>

<ol>
<li><p>原始值为整形枚举</p>

<pre><code class="language-swift">enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0</p></li>
<li><p>原始值为字符串类型</p>

<pre><code class="language-swift">enum CompassPoint: String {
    case north, south, east, west
}
//CompassPoint.south 拥有隐式原始值 south
</code></pre>

<p>使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称</p></li>
</ol>

<p>使用枚举成员的<code>rawValue</code>属性可以访问枚举成员初始值</p>

<pre><code class="language-swift">let earthsOrder = Planet.earth.rawValue
    // earthsOrder 值为 3
let sunsetDirection = CompassPoint.west.rawValue
    // sunsetDirection 值为 &quot;west&quot;
</code></pre>

<h3 id="toc_5">原始值初始化枚举实例</h3>

<p>定义枚举时使用原始值,会获得一个初始化方法,有一个<code>rawValue</code>类型为原始值类型的参数，返回一个枚举类型或为<code>nil</code></p>

<pre><code class="language-swift">let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet 类型为 Planet? 值为 Planet.uranus
//因为不一定都能找到匹配的行星  返回的是可选类型
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print(&quot;Mostly harmless&quot;)
    default:
        print(&quot;Not a safe place for humans&quot;)
    }
} else {
    print(&quot;There isn&#39;t a planet at position \(positionToFind)&quot;)
}
//找不到11代表的行星
</code></pre>

<h2 id="toc_6">递归枚举</h2>

<p>是一种枚举类型  有一个或多个成员使用该枚举类型实例作为关联值</p>

<p>可以在枚举成员前加<code>indirect</code>表示该成员可递归, 或者在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归</p>

<pre><code class="language-swift">enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}

indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}

//递归枚举使用
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

//递归函数中使用递归枚举
func evaluate(_ expression: ArithmeticExpression) -&gt; Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}
print(evaluate(product))//18
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包]]></title>
    <link href="https://acefish.github.io/14993105877642.html"/>
    <updated>2017-07-06T11:09:47+08:00</updated>
    <id>https://acefish.github.io/14993105877642.html</id>
    <content type="html"><![CDATA[
<p>闭包是自包含的函数代码块,可以在代码中被传递和使用</p>

<p><strong>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</strong></p>

<blockquote>
<p><code>Swift</code>中的闭包与<code>C</code>和<code>Objective-C</code>中的代码块（<code>blocks</code>）以及其他一些编程语言中的匿名函数比较相似<br/>
在函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包</p>
</blockquote>

<p>闭包的形式：</p>

<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>

<p>闭包可以进行一定语法优化，常见优化:</p>

<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回<code>单表达式</code>闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>

<h2 id="toc_0">闭包表达式</h2>

<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。</p>

<h3 id="toc_1">sorted方法</h3>

<p><code>Swift</code>的<code>sorted(by:)</code>方法根据提供的排序的闭包函数.将数组排序后返回一个同样大小排序后的数组,原数组不变</p>

<p><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code><br/>
对于数组这个用于排序的闭包函数类型为<code>(String, String) -&gt; Bool</code>通过返回bool值决定第一个参数在前还是在后</p>

<pre><code class="language-swift">func backward(_ s1: String, _ s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversedNames = names.sorted(by: backward)
// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]
</code></pre>

<p>为了写<code>return s1 &gt; s2</code>这么简单的表达式却需要写函数太过繁琐,我们可以使用闭包表达式语法</p>

<h3 id="toc_2">闭包表达式语法</h3>

<pre><code class="language-swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>闭包表达式参数 可以是<code>in-out</code>参数，但不能设定默认值。可以使用可变参数但是要放到参数最后</p>

<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。（<code>in</code>前为闭包定义,后为闭包函数体）</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<h3 id="toc_3">根据上下文推断类型</h3>

<p>因为这个闭包函数的作为方法参数传入,因此其类型已经确定为<code>(String, String) -&gt; Bool</code>,因此我们可以省略这些类型声明,因为可以被正确推断出来</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
//我们将闭包作为函数或方法的参数时,其类型总是可以推断出来的
//推荐完整格式闭包,增加代码可读性
</code></pre>

<h3 id="toc_4">单表达式闭包隐式返回</h3>

<p>如果闭包内只有一行单一表达式,并且明确了需要的返回类型,可以省略<code>return</code>关键字</p>

<pre><code class="language-swift">//
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<h3 id="toc_5">参数名称缩写</h3>

<p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数</p>

<p>如果使用参数名称缩写,那么在闭包定义中也可以省略参数列表,对应的参数名称缩写的类型也可以推断出来,这样的话<code>in</code>关键字也可以省略</p>

<pre><code class="language-swift">//此时闭包表达式只剩下闭包函数体
reversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<h3 id="toc_6">运算符方法</h3>

<p><code>Swift</code>的<code>String</code>类型定义了关于大于号<code>（ &gt; ）</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断出你想使用大于号的字符串函数实现：</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: &gt;)
</code></pre>

<h2 id="toc_7">尾随闭包</h2>

<p>如果要将一个很长的闭包作为函数最后一个参数,为了增强代码的可读性,我们可以使用<code>尾随闭包</code>的方式来调用函数</p>

<pre><code class="language-swift">func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
    // 函数体部分
}
// 以下是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure(closure: {
    // 闭包主体部分
})
// 以下是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
    // 闭包主体部分
}

reversedNames = names.sorted() { $0 &gt; $1 }
//如果闭包函数是函数的唯一参数我们还可以省略（）
reversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<pre><code class="language-swift">//举栗子
let strings = numbers.map {
    (number) -&gt; String in
    var number = number
    var output = &quot;&quot;
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number &gt; 0
    return output
}
// strings 常量被推断为字符串类型数组，即 [String]
// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]
</code></pre>

<h2 id="toc_8">值捕获</h2>

<p>闭包可以在被定义的上下文捕获常量或变量</p>

<p>最简单的捕获值的闭包形式是嵌套函数</p>

<pre><code class="language-swift">func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementer() -&gt; Int {
        runningTotal += amount
    return runningTotal
    }
    return incrementer
}
</code></pre>

<p><code>makeIncrementer</code>的返回类型是<code>() -&gt; Int</code>说明要返回一个函数<br/>
对于嵌套函数<code>incrementer()</code>并没有参数，而是捕获了<code>runningTotal</code>和<code>amount</code>变量的引用.捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>

<blockquote>
<p>如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。 Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>

<pre><code class="language-swift">let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()// 返回的值为10
incrementByTen()// 返回的值为20
incrementByTen()// 返回的值为30
</code></pre>

<p>这个常量函数每次调用都会将<code>runningTotal</code>变量增加<code>10</code></p>

<h2 id="toc_9">闭包是引用类型</h2>

<p><code>函数</code>和<code>闭包</code>都是引用类型，因此我们设置的常量或者变量是设置的对应函数或闭包的引用，而不是闭包内容本身</p>

<blockquote>
</blockquote>

<h2 id="toc_10">逃逸闭包</h2>

<p>将闭包作为参数传递到另一个函数中,但是这个闭包在函数返回后才执行,则这个闭包从函数中<code>逃逸</code>，我们可以通过在函数名之前标注<code>@escaping</code>表示这个闭包允许<code>逃逸</code></p>

<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中,此时必须闭包是可逃逸的否则函数的作用域结束，这个外部变量保存的闭包。。。会导致编译错误</p>

<p>逃逸闭包我们常用于在一个函数需要异步执行操作,通常会让函数返回,在异步操作完成后再调用执行这个闭包,因为闭包需要在函数返回之后被调用,所以需要逃逸闭包</p>

<pre><code class="language-swift">var completionHandlers: [() -&gt; Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {
    completionHandlers.append(completionHandler)
}

func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {
    closure()
}
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
let instance = SomeClass()
instance.doSomething()
print(instance.x)
// 打印出 &quot;200&quot;
completionHandlers.first?()
print(instance.x)
</code></pre>

<h2 id="toc_11">自动闭包</h2>

<p>一种自动创建的闭包，用于包装传递给函数作为参数的表达式。不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这样帮我们省略掉花括号,用一个普通表达式代替显式的闭包</p>

<p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受自动闭包作为它的<code>condition</code>参数和 <code>message</code>参数；它的<code>condition</code>参数仅会在<code>debug</code>模式下被求值，它的<code>message</code>参数仅当 <code>condition</code>参数为<code>false</code>时被计算求值。</p>

<p><strong>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。</strong></p>

<pre><code class="language-swift">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
//未使用自动闭包
func serve(customer customerProvider: () -&gt; String) {
    print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: { customersInLine.remove(at: 0) } )
// 打印出 &quot;Now serving Alex!&quot;

//使用自动闭包
func serve(customer customerProvider: @autoclosure () -&gt; String) {
print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: customersInLine.remove(at: 0))
</code></pre>

<blockquote>
<p>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟<br/>
执行的</p>
</blockquote>

<pre><code class="language-swift">//可以通过同时加上@autoclosure @escaping 自动闭包可以“逃逸”
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {
    customerProviders.append(customerProvider)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSNotification]]></title>
    <link href="https://acefish.github.io/14988080333726.html"/>
    <updated>2017-06-30T15:33:53+08:00</updated>
    <id>https://acefish.github.io/14988080333726.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">notification的使用</h2>

<h3 id="toc_1">注册观察者</h3>

<p><code>- (void)addObserver:(id)notificationObserver selector:(SEL)notificationSelector name:(NSString *)notificationName object:(id)notificationSender<br/>
</code><br/>
注意:</p>

<ol>
<li><code>notificationObserver</code>不能为nil</li>
<li><code>notification Selector</code>回调方法有且只有一个参数(<code>NSNotification</code>对象)</li>
<li>如果<code>notificationName</code>为<code>nil</code>，则会接收所有的通知(如果<code>notificationSender</code>不为空，则接收所有来自于<code>notificationSender</code>的所有通知)</li>
<li>如果<code>notificationSender</code>为<code>nil</code>，则会接收所有<code>notificationName</code>定义的通知；否则，接收由<code>notificationSender</code>发送的通知</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的</li>
</ol>

<h3 id="toc_2">post通知</h3>

<pre><code class="language-objc">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;First&quot; object:@&quot;博客园-Fly_Elephant&quot;];
-(void)notificationFirst:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
}
//名称:First----对象:博客园-Fly_Elephant

[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;Second&quot; object:@&quot;http://www.cnblogs.com/xiaofeixiang&quot; userInfo:dict];
-(void)notificationSecond:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSDictionary  *dict=[notification userInfo];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
    NSLog(@&quot;获取的值:%@&quot;,[dict objectForKey:@&quot;key&quot;]);
}
//名称:Second----对象:http://www.cnblogs.com/xiaofeixiang
//获取的值:keso
</code></pre>

<h2 id="toc_3">通知原理</h2>

<p>单例的方式创建一个<code>NSNotificationCenter</code>对象<br/>
对象注册观察者时 将注册的<code>name</code> <code>selector</code> <code>object</code> 作为一个模型 添加到一个数组中</p>

<p>post时根据名字和object 找到数组中注册的对象 执行通知的方法</p>

<h2 id="toc_4">多线程</h2>

<p>在多线程应用中，<code>Notification</code>在哪个线程中<code>post</code>，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。<br/>
也就是说，<code>Notification</code>的发送与接收处理都是在同一个线程中.</p>

<h2 id="toc_5">通告队列 NSNotificationQueue</h2>

<p><code>NSNotificationQueue</code> 作用是充当通告中心(<code>NSNotificationCenter</code>)的缓冲区,以FIFO的顺序进行维护。当一个通告上升到队列最前时，就将他发送给通告中心，通告中心随后将它派发给所有注册为观察者的对象</p>

<p>参考<a href="http://www.jianshu.com/p/b4835026e8e9">NSNotification&amp;NSNotificationCenter(实现原理,多线程,内存管理角度)</a><br/>
参考<a href="http://www.cnblogs.com/heyonggang/p/3681689.html">iOS NSNotification的使用</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数 Functions]]></title>
    <link href="https://acefish.github.io/14986177362678.html"/>
    <updated>2017-06-28T10:42:16+08:00</updated>
    <id>https://acefish.github.io/14986177362678.html</id>
    <content type="html"><![CDATA[
<p>在<code>Swift</code>中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型。可以把函数类型当做任何其他<br/>
普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数<br/>
的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>

<h2 id="toc_0">函数的定义与调用</h2>

<pre><code class="language-swift">func greet(person: String) -&gt; String {
    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;
    return greeting
}
</code></pre>

<p>定义一个函数,以<code>func</code>为前缀，定义了一个输入参数一个叫<code>person</code>的<code>String</code>值，用<code>-&gt;</code>来指定函数返回类型一个<code>String</code>类型返回值</p>

<blockquote>
<p><code>print(_:separator:terminator:)</code>这个函数第一个参数为<code>_</code>即并没有设置标签,其他参数设置了标签并且有默认值因此是可选的 </p>
</blockquote>

<h2 id="toc_1">函数参数与返回值</h2>

<p>在函数参数名称为<code>_</code>即不设置名称 </p>

<h3 id="toc_2">无参函数</h3>

<pre><code class="language-swift">func sayHelloWorld() -&gt; String {
    return &quot;hello, world&quot;
}
print(sayHelloWorld())
// 打印 &quot;hello, world&quot;
</code></pre>

<p><strong>注意:</strong><br/>
即使这个函数没有参数,但是定义中在函数名后还是<strong>需要一对圆括号</strong>。当被调用时，也需要<strong>在函数名后写一对圆括号</strong>与C语言函数相同</p>

<h3 id="toc_3">多参函数</h3>

<pre><code class="language-swift">func greet(person: String, alreadyGreeted: Bool) -&gt; String {
    if alreadyGreeted {
        return greetAgain(person: person)
    } else {
        return greet(person: person)
    }
}
print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))
// 打印 &quot;Hello again, Tim!&quot;
</code></pre>

<p>传递多个参数,之前用<code>,</code>隔开,这个函数与前面函数虽然名称相同 但是参数不同因此是不同的两个函数</p>

<blockquote>
<p>重载:指两个函数的函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同<br/>
OC不完全支持重载,即OC支持参数个数不同的函数重载,Swift是完全支持重载的</p>
</blockquote>

<h3 id="toc_4">无返回值函数</h3>

<pre><code class="language-swift">func greet(person: String) {
    print(&quot;Hello, \(person)!&quot;)
}
greet(person: &quot;Dave&quot;)
// 打印 &quot;Hello, Dave!&quot;
</code></pre>

<blockquote>
<p>虽然没有定义返回值,其实返回了一个特殊的<code>Void</code>值,这是<strong>一个空的元组</strong>，没有任何元素,可以写为()</p>
</blockquote>

<h3 id="toc_5">多重返回值函数</h3>

<p>我们可以用元组让多个值作为一个复合值从函数中返回</p>

<pre><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
// 打印 &quot;min is -6 and max is 109&quot;
</code></pre>

<blockquote>
<p>我们在返回元组时不需要给元组命名，因为它们的名字在函数返回类型中就已经确定了</p>
</blockquote>

<h3 id="toc_6">可选元组返回值</h3>

<p>如果函数返回的元组类型有可能整个元组都“没有值”,可以使用可选元组返回类型来说明元组可能为<code>nil</code></p>

<blockquote>
<p>注意 可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
</blockquote>

<p>对于上面的数组我们添加一个空数组检查,当传入的数组为空时返回<code>nil</code>:</p>

<pre><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

//用可选类型绑定来检查函数返回的是一个存在的元组还是一个nil
if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
}
// 打印 &quot;min is -6 and max is 109&quot;

</code></pre>

<h2 id="toc_7">函数参数标签和参数名称</h2>

<p>每个函数参数都有一个<code>参数标签</code>以及一个<code>参数名称</code>.<br/>
<code>参数标签</code>在调用函数的时候使用:调用时需要将函数的参数标签写在对应参数前<br/>
<code>参数名称</code>在函数的实现中使用。默认,函数参数使用参数名称来作为参数标签</p>

<h3 id="toc_8">指定参数标签</h3>

<p>在参数名称前指定它的参数标签，中间以空格分隔:</p>

<pre><code class="language-swift">//参数标签使函数在调用时更有表达力,保持可读性
//argumentLabel参数标签  parameterName参数名称
func someFunction(argumentLabel parameterName: Int) {
    // 在函数体内，parameterName 代表参数值
}
func greet(person: String, from hometown: String) -&gt; String {
    return &quot;Hello \(person)! Glad you could visit from \(hometown).&quot;
}
print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))
</code></pre>

<h3 id="toc_9">忽略参数标签</h3>

<p>我们用下划线来忽略 不设置参数标签</p>

<pre><code class="language-swift">func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值
}
someFunction(1, secondParameterName: 2)
</code></pre>

<blockquote>
<p>如果一个参数有标签,那么在调用时必须使用标签来标记这个参数</p>
</blockquote>

<h3 id="toc_10">默认参数值</h3>

<p>可以在函数体重通过给参数赋值来为任意一个参数定义默认值. 如果定义了默认值，可以在调用这个函数时忽略这个参数:</p>

<pre><code class="language-swift">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    // 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault = 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12
</code></pre>

<p>我们通常将不带默认值的参数放在函数参数列表最前。因为一般没有默认值参数更重要，将不带默认值的参<br/>
数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更<br/>
为清晰。</p>

<h3 id="toc_11">可变参数</h3>

<p>通过在变量类型名后加上<code>...</code>的方式来定义可变参数<br/>
可变参数可以接受零个或多个值,我们用其来指定函数传入不确定数量的输入值</p>

<p>我们在函数体中将可变参数传入值变为数组来使用</p>

<pre><code class="language-swift">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// 返回 3.0, 是这 5 个数的平均数。
arithmeticMean(3, 8.25, 18.75)
// 返回 10.0, 是这 3 个数的平均数。
</code></pre>

<blockquote>
<p>一个函数最多只能有一个可变参数</p>
</blockquote>

<h3 id="toc_12">输入输出参数</h3>

<p>参考<a href="http://www.csdn.net/article/2015-01-20/2823635-swift-pointer">Swift中的指针操作及使用</a></p>

<p>函数参数默认为常量,因此在函数体中修改会导致编译错误。如果想要在函数中修改某个参数值,并且这些修改在函数调用后仍然有效，那么需要把这个参数定义为输入输出参数</p>

<p>在参数定义前加上<code>inout</code>关键字来定以输入输出参数，这个值被函数修改然后被传出函数替换原来的值.</p>

<p>只能传递变量给输入输出参数,不能传入常量或字面量，调用时当传入的参数作为输入输出参数时,需要在参数名前加<code>&amp;</code>表示这个值可被修改</p>

<blockquote>
<p>输入输出参数不能有默认值，而且可变参数不能用<code>inout</code>标记</p>
</blockquote>

<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)
// 打印 &quot;someInt is now 107, and anotherInt is now 3&quot;
</code></pre>

<p><strong>可以参考C语言中函数的 指针参数</strong></p>

<h2 id="toc_13">函数类型</h2>

<p>每个函数都有 由<code>函数的参数类型</code>和<code>返回类型</code> 组成<code>函数类型</code></p>

<pre><code class="language-swift">func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    return a + b
}
</code></pre>

<p>函数类型为<code>(Int, Int) -&gt; Int</code></p>

<pre><code class="language-swift">func printHelloWorld() {
    print(&quot;hello, world&quot;)
}
</code></pre>

<p>函数类型为<code>() -&gt; Void</code></p>

<h3 id="toc_14">函数类型的使用</h3>

<p>在<code>Swift</code>中使用函数类型和使用其他类型一样。</p>

<pre><code class="language-swift">var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</code></pre>

<p>定义一个类型是‘一个有两个Int型的参数并返回一个Int型的值的<code>mathFunction</code>变量，指向<code>addTwoInts</code>函数</p>

<p>函数类型与其他类型一样可以通过赋值让<code>Swift</code>推断其函数类型</p>

<h3 id="toc_15">函数类型作为参数类型</h3>

<pre><code class="language-swift">func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print(&quot;Result: \(mathFunction(a, b))&quot;)
}

//调用
printMathResult({ (a, b) -&gt; Int in
    return a*b
}, 10, 20)
</code></pre>

<p><code>printMathResult(_:_:_:)</code>函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得<code>printMathResult(_:_:_:)</code>能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>

<h3 id="toc_16">函数类型作为返回类型</h3>

<p>我们可以将函数类型作为另一个函数的返回类型</p>

<pre><code class="language-swift">func stepForward(_ input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(_ input: Int) -&gt; Int {
    return input - 1
}

func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    return backward ? stepBackward : stepForward
}

//执行
var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
// moveNearerToZero 现在指向 stepBackward() 函数。
</code></pre>

<p>上面例子获取一个整形接近0应该用的函数</p>

<pre><code class="language-swift">print(&quot;Counting to zero:&quot;)
// Counting to zero:
while currentValue != 0 {
    print(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// 3...
// 2...
// 1...
// zero!
</code></pre>

<h2 id="toc_17">嵌套函数</h2>

<p>前面定义的所有函数都为<code>全局函数</code><br/>
我们可以把函数定义在其他函数中,这就是<code>嵌套函数</code><br/>
默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>

<blockquote>
<p>OC中是不支持在一个函数中定义另外一个函数</p>
</blockquote>

<p>我们用返回嵌套方式重写<code>chooseStepFunction(backward:)</code>函数</p>

<pre><code class="language-swift">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    //我们在函数中定义另外函数
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    //返回嵌套函数
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
while currentValue != 0 {
print(&quot;\(currentValue)... &quot;)
currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// -4...
// -3...
// -2...
// -1...
// zero!
</code></pre>

]]></content>
  </entry>
  
</feed>
