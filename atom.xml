<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2018-07-24T10:48:41+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[面对对象高级编程]]></title>
    <link href="https://acefish.github.io/15324890369623.html"/>
    <updated>2018-07-25T11:23:56+08:00</updated>
    <id>https://acefish.github.io/15324890369623.html</id>
    <content type="html"><![CDATA[
<p>对于python这种动态语言,我们可以在创建了class实例之后，给其绑定属性甚至绑定方法</p>

<pre><code class="language-python">class My_TestClass(object):
    &quot;&quot;&quot;docstring for My_TestClass&quot;&quot;&quot;
    pass

test1=My_TestClass()
test1.name=&quot;liyuyuan&quot; # 给实例绑定对象

def set_name(self, name):
    self.name=name

from types import MethodType
test1.set_name=MethodType(set_name, test1) #实例对象绑定方法
test1.set_name(&quot;lyy&quot;)
print(test1.name)  # lyy
</code></pre>

<blockquote>
<p>给一个实例对象绑定的方法，对另外的实例对象是不起作用的，应该给<code>class</code>绑定方法<br/>
动态语言允许我们在程序运行过程中动态给<code>class</code>增加功能</p>
</blockquote>

<pre><code class="language-python">My_TestClass.set_name=set_name
test2=My_TestClass()
test2.set_name(&quot;wtt&quot;)
print(test2.name) # wtt
</code></pre>

<h2 id="toc_0"><strong>slots</strong></h2>

<p>通过<code>__slots__</code>来对实例的属性进行限制能添加的属性</p>

<pre><code class="language-python">class My_Slots_Class(object):
    &quot;&quot;&quot;docstring for My_Slots_Class&quot;&quot;&quot;
    __slots__=(&quot;name&quot;, &quot;score&quot;)
    # def __init__(self, age): #不能有 name、score外的其他属性
    #   self.age=age
    pass
        

slot1=My_Slots_Class()
slot1.age=10 #AttributeError: &#39;My_Slots_Class&#39; object has no attribute &#39;age&#39;
</code></pre>

<blockquote>
<p><code>__slots__</code>定义属性仅对当前类实例起作用,对继承的子类是不起作用的，可以在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
</blockquote>

<pre><code class="language-python">class My_Slots_Subclass(My_Slots_Class):
    &quot;&quot;&quot;docstring for My_Slots_Subclass&quot;&quot;&quot;
    __slots__=(&quot;age&quot;)
    pass
#此时允许的属性为子类的__slots__加上父类的__slots__
slot2=My_Slots_Subclass()
slot2.age=22
slot2.ttt=10  #AttributeError: &#39;My_Slots_Subclass&#39; object has no attribute &#39;ttt&#39;
</code></pre>

<h2 id="toc_1">@property</h2>

<p>python内置的<code>@property</code>装饰器就负责把一个方法变为属性调用</p>

<pre><code class="language-python">class My_Property_Class(object):
    @property
    def age(self):
        print(&quot;获取age&quot;,self._age)
        return self._age

    @age.setter
    def age(self, age):
       #可以在此处检查传入参数处理
        print(&quot;设置age&quot;,age)
        self._age=age

property1=My_Property_Class()
property1.age=10 #设置age 10
property1.age # 获取age 10
</code></pre>

<p>如果我们只定义<code>@property</code>那么该属性就是只读的</p>

<h2 id="toc_2">多继承</h2>

<p>python中支持多继承,一个子类可以同时获得多个父类的所有功能</p>

<h3 id="toc_3">MixIn</h3>

<p>一般设计为单继承,但是当需要额外功能时可以用过多继承实现,这就是<br/>
<code>MixIn</code></p>

<h2 id="toc_4">定制类</h2>

<p>类似<code>__slots__</code>限制类的属性<br/>
<code>__len__()</code>方法让class能作用域<code>len()</code>函数</p>

<h3 id="toc_5"><strong>str</strong></h3>

<p><code>__str__()</code> 对于打印出来的对象信息修改<br/>
<code>__repr__()</code>对程序员看到的对象信息修改</p>

<pre><code class="language-python">class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return &#39;Student object (name: %s)&#39; % self.name
            __repr__ = __str__ #经常把两个写作相同
...
print(Student(&#39;Michael&#39;)) #Student object (name: Michael)
#当开发者在命令行直接输入对象 会打印对象信息，这是调用的是__repr__()
</code></pre>

<h3 id="toc_6"><strong>iter</strong></h3>

<p>如果类需要被<code>for...in</code>循环,必须实现<code>__iter__()</code>方法,返回一个可迭代对象，然后调用对象的<code>__next__()</code>方法获取循环下一个值,直到遇到<code>StopIteration</code>错误退出循环</p>

<blockquote>
<p>学习迭代器一章知道,调用iter()方法转为迭代器,然后调用next方法获取下一个值,其内部实现就是<code>__iter__()</code>和<code>__next__()</code></p>
</blockquote>

<pre><code class="language-python">
class My_Iter_Class(object):
    &quot;&quot;&quot;docstring for My_Iter_Class&quot;&quot;&quot;
    def __init__(self):
        self.a=0
    def __iter__(self):
        return self

    def __next__(self):
        self.a+=1
        while self.a&gt;10:
            raise StopIteration()
        print(self.a)


for x in My_Iter_Class():
    pass


</code></pre>

<h3 id="toc_7"><strong>getitem</strong></h3>

<p>对于实现了<code>__iter__()</code>和<code>__next__()</code>可以用for遍历,但是并不能像list一样取某个下标或者进行切片操作,这时需要实现<code>__getitem__()</code>方法</p>

<pre><code class="language-python">class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        #判断是否为切片对象
        if isinstance(n, slice): # n是切片  
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre>

<blockquote>
<p>在<code>__getitem__()</code>方法中，需要判断是取下标索引传入参数为<code>int</code>，还是传入的为切片<code>slice</code>进行切片操作<br/>
上面对切片操作并不完善，比如对于负数的处理</p>
</blockquote>

<p><strong>对应于__getitem__()还有__setitem__()来对类进行赋值 <strong>delitem</strong>()删除某个元素</strong></p>

<h3 id="toc_8"><strong>getattr</strong></h3>

<p>当我们调用类中不存在的属性或方法时时，Python解释器会试图调用<code>__getattr__(self, &#39;attr&#39;)</code>来获得属性或方法，我们就可以通过这个方法来返回对应不存在属性值或方法</p>

<blockquote>
<p>如果我们实现了这个方法,默认返回是<code>None</code>无法提示用户该属性不存在,我们可以返回一个<code>raise AttributeError</code>错误</p>
</blockquote>

<h3 id="toc_9"><strong>call</strong></h3>

<p>当我们在类内部实现<code>__call__()</code>方法后,我们就可以直接对实例进行调用</p>

<pre><code class="language-python">class My_Call_Class(object):
    def __call__(self):
        print(&quot;调用自身call&quot;)

obj1=My_Call_Class()
obj1() # 调用自身call

#判断一个对象是否可调用
if callable(obj1): #True
    print(&quot;可调用&quot;)  #可调用

</code></pre>

<blockquote>
<p>对于可直接调用对象，可以将其看做函数,可以传参数</p>
</blockquote>

<h2 id="toc_10">枚举类</h2>

<p>Python为定义大量常量的枚举 提供了<code>Enum</code>类</p>

<p>使用Enum实现一个简单的枚举</p>

<pre><code class="language-python">Month = Enum(&quot;Month&quot;, (&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;))
print(Month.Jan) # Month.Jan
print(Month.Mar.value) # 3

# __members__返回所有成员的name-&gt;value的map
for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)
</code></pre>

<p>对于某些情况我们可能需要自定义枚举,可以从<code>Enum</code>派生出自定义类</p>

<pre><code class="language-python">class WeekDay(Enum):
    Sun=7
    Mon=1
    Tue=2
    Wed=3
    Thu=4
    Fri=5
    Sat=6

print(WeekDay.Sun) #WeekDay.Sun
print(WeekDay.Fri.value) #5

for name, member in WeekDay.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)
</code></pre>

<p><code>Enum</code>可以把相关常量定义在一个不可变<code>class</code>中,成员之间可以直接比较</p>

<h2 id="toc_11">元类</h2>

<p><strong>动态语言和静态语言最大的不同就是,函数和类的定义不是编译时定义的而是运行时动态创建的</strong></p>

<p>当python解释器载入模块时，就会依次执行该模块中的所有语句</p>

<p><code>class</code>的定义是在运行时动态创建的，创建<code>class</code>的方法就是使用<code>type()</code>函数</p>

<p>利用<code>type</code>函数创建一个class</p>

<pre><code class="language-python">def hello_func(self, name=&quot;world&quot;):
    print(&quot;hello, &quot;, name)

#用type创建Hello class
Hello_Class=type(&quot;Hello&quot;, (object,), dict(hello=hello_func))

h1= Hello_Class()
h1.hello() # hello,  world
</code></pre>

<p>用type定义的类与class定义的完全相同,python解释器遇到class定义类也是仅仅扫描一下后调用<code>type()</code>方法来定义类</p>

<blockquote>
<p>当前执行的模块名字为__main__</p>
</blockquote>

<h3 id="toc_12">metaclass</h3>

<p><code>metaclass</code>允许我们创建或者修改类</p>

<p><code>metaclass</code>是类的模板，所以必须从<code>type</code>类型派生</p>

<p>该节不常用,自行参考<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000">廖雪峰的python学习元类</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面对对象编程]]></title>
    <link href="https://acefish.github.io/15324145349319.html"/>
    <updated>2018-07-24T14:42:14+08:00</updated>
    <id>https://acefish.github.io/15324145349319.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类和实例</h2>

<p><code>class</code>关键字定义类<br/>
类名通常首字母大写</p>

<pre><code class="language-python">class My_Class_Student(object):
    &quot;&quot;&quot;docstring for My_Class_Student&quot;&quot;&quot;
    def __init__(self, name):
        super(My_Class_Student, self).__init__()
        self.name = name
        
lyy=My_Class_Student(&quot;liyuyuan&quot;)

print(lyy)
print(lyy.name) # liyuyuan
</code></pre>

<p><code>__init__</code>方法定义初始化对象时必须要传入的参数,比如上面student初始化时必须传入name</p>

<p>在类中定义的函数，第一个参数永远是实例变量<code>self</code>，调用时不用传递该参数</p>

<h3 id="toc_1">数据封装</h3>

<p>使用类中定义的方法来实现数据封装</p>

<pre><code class="language-python">class My_Class_Student(object):
    &quot;&quot;&quot;docstring for My_Class_Student&quot;&quot;&quot;
    def __init__(self, name):
        super(My_Class_Student, self).__init__()
        self.name = name
    def print_name(self):
        print(self.name)
        
lyy=My_Class_Student(&quot;liyuyuan&quot;)

print(lyy)
print(lyy.name) # liyuyuan
lyy.print_name() #liyuyuan

</code></pre>

<h2 id="toc_2">访问限制</h2>

<p>让内部属性不被外部访问，可以再属性名称前加双下划线<code>__</code>，在python中，以<code>__</code>开头的变量名就为私有变量,外部不能访问（只能为<code>__</code>不能<code>_</code>）</p>

<pre><code class="language-python">class My_Class_Student(object):
    &quot;&quot;&quot;docstring for My_Class_Student&quot;&quot;&quot;
    def __init__(self, name):
        super(My_Class_Student, self).__init__()
        self.__name = name
    def print_name(self):
        print(self.__name)
        
lyy=My_Class_Student(&quot;liyuyuan&quot;)

print(lyy.__name) # AttributeError:&#39;My_Class_Student&#39; object has no attribute &#39;__name&#39;
lyy.print_name() #liyuyuan
</code></pre>

<blockquote>
<p>变量名为<code>__xxx__</code>是特殊变量，外部可以直接访问的</p>

<p>对于单下划线开头的变量,虽然可以访问,但是约定俗成不要访问,当做私有变量</p>

<p>对于<code>__</code>开头的变量，其实python是将其改名为<code>_classname__变量名</code>，我们也可以通过其进行访问，不建议</p>
</blockquote>

<h2 id="toc_3">继承和多态</h2>

<h3 id="toc_4">继承</h3>

<pre><code class="language-python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)

#继承了Animal 就自带了run方法
class Dog(Animal):
    pass

#重写父类继承的方法
class Cat(Animal):
    def run(self):
        print(&#39;Cat is running...&#39;)
    
</code></pre>

<h3 id="toc_5">多态</h3>

<p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p>

<pre><code class="language-python">b = Animal() # b是Animal类型
isinstance(b, Animal)  #True
</code></pre>

<blockquote>
<p>对于静态语言(java等),需要传入的必须是Animal类型或者其子类,否则无法调用其方法</p>

<p>对于python等动态语言,没有类型检查,只需要保证其有执行的方法就行了，就可以执行<br/>
这就是鸭子类型</p>
</blockquote>

<h2 id="toc_6">获取对象信息</h2>

<h3 id="toc_7">type()</h3>

<p>用<code>type()</code>来获取对象类型</p>

<pre><code class="language-python">if type(&quot;name&quot;) == type(&quot;dd&quot;):
    print(&quot;类型相同+&quot;,type(&quot;name&quot;)) # 类型相同+ &lt;class &#39;str&#39;&gt;
</code></pre>

<h3 id="toc_8">isinstance()</h3>

<p>对于继承关系来说,<code>type()</code>并不好用,我们可以使用<code>isinstance()</code>函数来判断<code>class</code>类型<br/>
<code>isinstance()</code>对于该类型以及父类继承链 均返回<code>True</code></p>

<pre><code class="language-python">#用type() 判断的基本类型 也可以用isinstance判断
isinstance(123, int) # True


# 判断是否为某些类型的一种
 isinstance([1, 2, 3], (list, tuple))  #True

</code></pre>

<h3 id="toc_9">dir() getattr() setattr() hasattr()</h3>

<p>用<code>dir()</code>来获得对象的所有属性和方法</p>

<p><code>hasattr()</code>判断该对象是否有此属性<br/>
<code>setattr()</code>设置一个属性<br/>
<code>getattr()</code>获取该属性的值 ，当试图获取不存在的属性，会抛出<code>AttributeError</code>错误</p>

<h2 id="toc_10">实例属性和类属性</h2>

<p>对于类属性,直接在<code>class</code>定义</p>

<pre><code class="language-python">class My_Student_Class(object):
    &quot;&quot;&quot;docstring for My_Student_Class&quot;&quot;&quot;
    name=&quot;My_Student_Class&quot; #在类中直接定义的类属性

stu1=My_Student_Class()
# 因为对象没有name属性,因此继续查找class的name属性
print(stu1.name) # My_Student_Class
print(My_Student_Class.name) #My_Student_Class
stu1.name=&quot;liyuyuan&quot;
print(stu1.name,&quot;  &quot;,My_Student_Class.name) #  liyuyuan    My_Student_Class
del stu1.name #删除实例的name属性
print(stu1.name) # My_Student_Class
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模块]]></title>
    <link href="https://acefish.github.io/15324005146874.html"/>
    <updated>2018-07-24T10:48:34+08:00</updated>
    <id>https://acefish.github.io/15324005146874.html</id>
    <content type="html"><![CDATA[
<p>在python中一个.py文件就称为一个模块</p>

<p>使用模块不仅可以增加代码的维护性和复用性,还可以避免函数名和变量名冲突,相同名字的函数和变量可以存在不同模块中</p>

<p>为了避免模块名冲突,<code>Python</code>引入了按照目录组织模块的方法:<strong>包</strong>,只要我们的报名不与别人冲突,那么所有模块就不会冲突</p>

<blockquote>
<p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是mycompany。</p>
</blockquote>

<p><img src="media/15324005146874/15324024289634.jpg" alt="" style="width:587px;"/></p>

<ol>
<li>文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。</li>
<li>mycompany.web也是一个模块</li>
</ol>

<h2 id="toc_0">使用模块</h2>

<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&quot;这是一个测试模块&quot; #任何模块的第一个字符串都会被视为模块的注释

__author__=&quot;ACEfish&quot;


import sys #导入模块

def test():
    args = sys.argv #sys模块有一个argv变量，用list存储了命令行的所有参数
    if len(args)==1:
        print(&quot;只有一个参数&quot;,args[0])
    elif len(args)==2:
        print(&quot;两个参数&quot;,args[0],args[1])
    else :
        print(&quot;too many params!&quot;)


if __name__ == &quot;__main__&quot;: #当我们在命令行执行该文件时，会把一个特殊变量__name__置为__main__,而如果在其他地方导入该hello模块时，if判断将失败因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
    test()
else:
    print(&quot;不执行测试模块&quot;)
</code></pre>

<blockquote>
<p>当我们在命令行执行该文件时，会把一个特殊变量__name__置为__main__,而如果在其他地方导入该hello模块时，if判断将失败因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
</blockquote>

<h3 id="toc_1">作用域</h3>

<p><code>python</code>中并没有绝对的限制<code>private</code>函数或变量,因此：</p>

<ol>
<li>正常的函数和变量名是公开的</li>
<li>类似<code>__xxx__</code>是特殊变量，可以被直接引用，但是有特殊用途,例如: <code>__author__</code> <code>__name__</code></li>
<li>类似<code>_xxx</code>或者<code>__xxx</code>是非公开的，不应该被引用</li>
</ol>

<h2 id="toc_2">第三方模块</h2>

<h3 id="toc_3">模块搜索路径</h3>

<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p>

<p><strong>默认情况下，<code>Python解释器</code>会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：</strong></p>

<pre><code class="language-python">import sys
sys.path
</code></pre>

<p>如果我们要添加自己的搜索目录，有两种方法：</p>

<ol>
<li>直接修改<code>sys.path</code>，添加要搜索的目录</li>
<li>设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数式编程]]></title>
    <link href="https://acefish.github.io/15320795459657.html"/>
    <updated>2018-07-20T17:39:05+08:00</updated>
    <id>https://acefish.github.io/15320795459657.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">高阶函数</h2>

<ol>
<li><p>变量可以指向函数</p>
<pre><code class="language-python">print(abs(-10)) # 10
abs_func=abs<br/>
print(abs_func(-10)) # 10
</code></pre></li>
<li><p>函数名也是变量<br/>
例如 <code>abs</code>就是一个指向获取绝对值的函数，我们可以试着将<code>abs</code>指向其它对象,这时<code>abs</code>也就无法完成获取绝对值</p></li>
<li><p>传入参数<br/>
函数可以接收另外一个函数作为参数</p>
<pre><code class="language-python">def my_funcparam_func(x, y, f):
   return f(x)+f(y)<br/>
print(my_funcparam_func(10,-10,abs))  #20
</code></pre></li>
</ol>

<h3 id="toc_1">map/reduce</h3>

<ol>
<li><p>map用法<br/>
map将传入的参数依次作用域每个元素，将结果作为<code>Iterator</code>返回</p>
<pre><code class="language-python">r1=map(my_func_xx,[1,2,3,4,5])
list1=list(r1) #因为返回的时Iterator惰性序列,使用list将整个序列计算返回list<br/>
print(list1)  # [1, 4, 9, 16, 25]
</code></pre></li>
<li><p>reduce用法<br/>
<code>reduce</code>把一个函数作用在一个序列上,这个函数接收两个参数，将结果继续和下一个元素做累计运算</p>
<pre><code class="language-python">from functools import reduce
def my_func_add(x, y):<br/>
    return x+y<br/>
list2=reduce(my_func_add,[1,2,3,4])<br/>
print(list2) #10
</code></pre>
<h3 id="toc_2">filter</h3></li>
</ol>

<p><code>filter</code>将传入函数依次作用于每个元素,然后根据返回值为<code>True</code>或者<code>False</code>，决定保留或者丢弃该元素</p>

<pre><code class="language-python">    def my_is_odd(x):
        return x%2==0
    #返回的还是Iterator的惰性序列
    list3=list(filter(my_is_odd, [1,2,4,5,6]))
    print(list3)  #[2, 4, 6]
</code></pre>

<h3 id="toc_3">排序</h3>

<p><code>sorted</code>函数</p>

<pre><code class="language-python">list4=[1, 2,-4,0,-3]
#直接用sorted函数排序
sorted(list4) # [-4, -3, 0, 1, 2]
sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;]) #[&#39;Credit&#39;, &#39;Zoo&#39;, &#39;about&#39;, &#39;bob&#39;]
#用关键字排序
sorted(list4, key=abs) #[0, 1, 2, -3, -4]
#反向排序 
sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)

</code></pre>

<p>默认对字符串的排序,按照ASCII码大小比较,<br/>
<code>key</code>指定的函数作用域list的每个元素.并根据返回结果进行排序</p>

<h2 id="toc_4">返回函数</h2>

<p>函数作为结果值进行返回</p>

<pre><code class="language-python">def my_lazy_sum(*args):
    def my_sum():
        sum=0
        for x in args:
            sum+=x
        return sum
    return my_sum

my_f=my_lazy_sum(1,2,3,4)
my_f() #10

</code></pre>

<p>在函数内部又定义了函数,内部函数可以引用外部函数的参数和局部变量,当外部函数返回内部函数时,参数和变量都保存在返回的函数中，这就是<code>闭包</code></p>

<h3 id="toc_5">闭包</h3>

<p>注意:返回的函数并不会立即执行，而是直到调用才执行,因此函数内用到的变量是执行时的变量值,为了避免:<strong>返回函数时，不要饮用任何循环变量或后续会变化的变量</strong></p>

<h2 id="toc_6">匿名函数</h2>

<p><code>lambda</code>关键字表示匿名函数，冒号前为函数参数<br/>
匿名函数也可以作为返回值</p>

<pre><code class="language-python">my_f2=lambda x: x*x
print(my_f2(2)) #4
</code></pre>

<h2 id="toc_7">装饰器</h2>

<p>函数有<code>__name__</code>属性，可以拿到函数的名字</p>

<pre><code class="language-python">def my_func_now(x):
    return x*3

name=my_func_now.__name__
print(name) #my_func_now
</code></pre>

<p>定义一个装饰器decorator</p>

<pre><code class="language-python">def my_custom_decorator(func):
    def my_wrapper(*args, **kw):
        print(&quot;call %s()&quot;%func.__name__)
        return func(*args, **kw)
    return my_wrapper
</code></pre>

<p>用装饰器装饰一个函数</p>

<pre><code class="language-python">@my_custom_decorator #相当于执行了my_log=my_custom_decorator(my_log)
def my_log():
    print(&quot;my_log_func&quot;)

my_log() 
#call my_log()
# my_log_func
</code></pre>

<p>在执行<code>my_log</code>函数不仅会执行函数本身，还会运行装饰器的<code>my_wrapper</code>函数</p>

<p><code>decorator</code>还可以传入参数，就需要更复杂的3层嵌套</p>

<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
    
@log(&#39;execute&#39;) #3层嵌套相当于:  now = log(&#39;execute&#39;)(now)
def now():
    print(&#39;2015-3-25&#39;)
#execute now():
#2015-3-25
</code></pre>

<blockquote>
<p>当需要在装饰器中获取到真正执行的函数名称时,我们可以使用<code>Python</code>内置的<code>functools.wraps</code></p>
</blockquote>

<pre><code class="language-python">import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__) #此时获取到的name为装饰的函数名称，而不是wrapper
        return func(*args, **kw)
    return wrapper
</code></pre>

<h2 id="toc_8">偏函数</h2>

<p>使用<code>functools.partial</code>将函数的某些参数固定住（设置默认值）,返回一个新的函数</p>

<pre><code class="language-python">import functools

int2=functools.partial(int, base=2)
print(int2(&quot;100&quot;))  #4
</code></pre>

<p>实际<code>functools.partial</code>接受三个参数:函数对象、<code>*args</code>、<code>**kw</code>,会将<code>*args</code>参数部分自动加到函数对象的左边,而将<code>**kw</code>一部分自动加到右边</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高级特性]]></title>
    <link href="https://acefish.github.io/15319012648780.html"/>
    <updated>2018-07-18T16:07:44+08:00</updated>
    <id>https://acefish.github.io/15319012648780.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">切片</h2>

<p>list的切片</p>

<pre><code class="language-python">listTest = list(range(100))

listTest[:10]  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
listTest[:10:2] #[0, 2, 4, 6, 8]
listTest[-10:] # [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
listTest[:] # 拷贝一个新的list 相当于深拷贝
</code></pre>

<p>元组:<br/>
元组的切片结果 仍为不可变的元组</p>

<pre><code class="language-python">(0, 1, 2, 3, 4, 5)[:3] #(0, 1, 2)
</code></pre>

<p>字符串也可看做一种list，可执行切片</p>

<pre><code class="language-python">&#39;ABCDEFG&#39;[:3] #&#39;ABC&#39;
&#39;ABCDEFG&#39;[::2] #&#39;ACEG&#39;
</code></pre>

<h2 id="toc_1">迭代</h2>

<pre><code class="language-python">#遍历dict
for key in dict2: #遍历所有键
for key in dict2.values(): #遍历所有值
for key in dict2.items(): #遍历所有键值对，返回为元组
    print(key)
</code></pre>

<p>当遍历时需要下标时,用enumerate()方法可以获取索引</p>

<pre><code class="language-python">for x, value in enumerate(dict2):
    print(x, value)
</code></pre>

<h2 id="toc_2">列表生成器</h2>

<pre><code class="language-python">L1=list(range(1,11))
print(L1) #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
L2=[x*x for x in L1]
print(L2) #[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
L3=[x*x for x in L1 if x%2 == 0]
print(L3) # [4, 16, 36, 64, 100]
L4=[str(x1)+str(x2) for x1 in list(range(3)) for x2 in list(range(3,6))]
print(L4) # [&#39;03&#39;, &#39;04&#39;, &#39;05&#39;, &#39;13&#39;, &#39;14&#39;, &#39;15&#39;, &#39;23&#39;, &#39;24&#39;, &#39;25&#39;]
</code></pre>

<h2 id="toc_3">生成器 generator</h2>

<p>在列表中一遍循环一边计算的机制,称为生成器：<code>generator</code></p>

<p>创建生成器:</p>

<ol>
<li><p>方法一: 通过将列表生成器的<code>[]</code>改为<code>()</code></p>
<pre><code class="language-python"> LI1=list(range(1,5))
LI2=(x*x for x in LI1)<br/>
#通过next()方法来获取生成器中的下一个值 直到最后一个元素抛出错误<br/>
print(next(LI2))<br/>
print(next(LI2))<br/>
print(next(LI2))<br/>
print(next(LI2))<br/>
print(next(LI2)) # 抛出 StopIteration错误<br/>
# 通过next()方法太麻烦,我们应该用 for 循环 不用关心StopIteration错误<br/>
for x in LI2:<br/>
    print(x)<br/>
# 1<br/>
# 4<br/>
# 9<br/>
# 16
</code></pre></li>
<li><p>方法二: 函数中包含<code>yield</code>关键字,为一个generator函数<br/>
generator函数在遇到yield关键字时会中断，返回yeild后的值,next之后会继续执行,直到没有yeild就会报错<br/>
当然也可以通过<code>for</code>循环来获取</p>
<pre><code class="language-python">def my_generatorFuc():
    print(&quot;step1&quot;)<br/>
    yield (1)<br/>
    print(&quot;step2&quot;)<br/>
    yield (5)<br/>
    print(&quot;step3&quot;)<br/>
    yield(10)<br/>
    return 100
</code></pre></li>
</ol>

<blockquote>
<p>采用<code>next()</code>可以当遇到<code>StopIteration</code>错误可以获取到<code>generator</code>函数的<code>return</code>值,返回值包含在<code>StopIteration</code>的<code>value</code>中<br/>
采用<code>for</code>循环获取不到函数的返回值,因此需要捕获<code>StopIteration</code>错误</p>
</blockquote>

<h2 id="toc_4">迭代器</h2>

<p> 对于可以用for循环的对象称为可迭代对象:<code>Iterable</code><br/>
 目前常用的可迭代对象有:<br/>
 1. list、tuple、dict、set、str<br/>
 2. generator:生成器和带<code>yield</code>的generator函数<br/>
 <br/>
 可以被next()函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code><br/>
 生成器都是迭代器,但是list、tuple、dict、set、str等是可迭代对象但不是迭代器<br/>
 </p>

<blockquote>
<p><code>Iterator</code>对象表示的是一个数据流，是一个惰性序列,不能事先知道序列长度，只能通过需要是<code>next()</code>计算下一个序列值</p>

<p><code>for</code>循环本质上是通过不停调用<code>next()</code>来实现的</p>

<p>list、tuple、dict、set、str等可迭代对象可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象</p>
</blockquote>

<pre><code class="language-python">it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre>

<p> <br/>
 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数]]></title>
    <link href="https://acefish.github.io/15318121291068.html"/>
    <updated>2018-07-17T15:22:09+08:00</updated>
    <id>https://acefish.github.io/15318121291068.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常用函数</h2>

<h3 id="toc_1">类型转换</h3>

<pre><code class="language-python">int(&#39;123&#39;)
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float(&#39;12.34&#39;)
12.34
&gt;&gt;&gt; str(1.23)
&#39;1.23&#39;
&gt;&gt;&gt; str(100)
&#39;100&#39;
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(&#39;&#39;)
False
</code></pre>

<h2 id="toc_2">定义函数</h2>

<pre><code class="language-python">def my_abs(x):
    # 检查参数类型 
    if not isinstance(x, (int, float)):
       # 当参数类型错误时  抛出错误
        raise TypeError(&quot;bad operate Params type&quot;)

    if x&gt;0:
        return x
    else:
        return -x

print(my_abs(&quot;-333&quot;)) #TypeError: bad operate Params type
</code></pre>

<p>定义一个空函数</p>

<pre><code class="language-python">def nop():
    pass
# pass用作占位符 
</code></pre>

<p>返回多个返回值<br/>
返回的其实为单一一个值，一个<code>元组</code>,我们通过多个变量接收一个元组,按位置赋值</p>

<pre><code class="language-python">import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

x, y = move(100, 100, 60, math.pi / 6)
print(x, y)
151.96152422706632 70.0
</code></pre>

<blockquote>
<p>若函数结束时没有<code>return</code>语句，就自动添加 <code>return None</code></p>
</blockquote>

<h2 id="toc_3">函数参数</h2>

<p>python的函数定义简单,灵活度很大.除了正常的必选参数外,还能使用默认参数、可变参数、关键字参数。</p>

<p><strong>参数组合</strong></p>

<blockquote>
<p>在Python中，可以使用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，但是参数的定义顺序必须是:<code>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</code></p>
</blockquote>

<pre><code class="language-python">def f1(a, b, c=0, *args, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)

def f2(a, b, c=0, *, d, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)
</code></pre>

<h3 id="toc_4">默认参数</h3>

<p>必选参数在前,默认参数在后</p>

<pre><code class="language-python">def my_power(x, n=2):
    total = 1
    for s in range(1,n+1):
        total = total*x
    return total

print(my_power(2))  # 4
</code></pre>

<p><strong>定义默认参数时: 默认参数必须指向不变对象,否则可变对象会成为函数内静态变量会在多次调用时变化，影响函数调用结果</strong></p>

<blockquote>
<p>使用默认参数即可省略参数，降低调用难度</p>
</blockquote>

<h3 id="toc_5">可变参数</h3>

<p>当不确定参数的个数时,可以使用可变参数，可以传入任意个参数,包括0个参数</p>

<pre><code class="language-python">def my_sum(*numbers):
    sum=0
    for x in numbers:
        sum += x

    return sum

print(my_sum(1,2,3,4)) # 10
numbers = [1,2,3,4,5]
#通过给list 或者 tuple前加*  将其元素变为可变参数
print(my_sum(*numbers)) #15 
</code></pre>

<p>传入的可变参数在函数内部封装为一个元组</p>

<h3 id="toc_6">关键字参数</h3>

<p>可以传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动封装为dict</p>

<pre><code class="language-python">def my_personFuc(name, age, **kw):
    print(&quot;name:&quot;, name, &quot;age:&quot;, age, kw)

my_personFuc(&quot;lyy&quot;, 24, city=&quot;luoyang&quot;) #name: lyy age: 24 {&#39;city&#39;: &#39;luoyang&#39;}
my_personFuc(&quot;wt&quot;, 20) # name: wt age: 20 {}

kwDict={&quot;city&quot;:&quot;beijing&quot;}
# 解构字典
my_personFuc(&quot;yt&quot;, &quot;25&quot;, **kwDict) # name: yt age: 25 {&#39;city&#39;: &#39;beijing&#39;}
</code></pre>

<blockquote>
<p>对于关键字参数，对于直接传入的参数，采用<code>=</code>而且<code>key</code>不能为str类似的字符串</p>
</blockquote>

<h3 id="toc_7">命名关键字参数</h3>

<pre><code class="language-python">#命名需要关键字 * ，在 * 之后的为命名关键字参数，
def my_keyPerson(name, age, *, city, job):
    print(name, age, city, job)

#命名关键字必须传入参数名 否则会报错 
my_keyPerson(&quot;lyy&quot;, 24, city=&quot;luoyang&quot;, job=&quot;iOS&quot;) # lyy 24 luoyang iOS

# 可以为可变参数隔开
def my_keyPerson1(name, age, *args, city, job):
    print(name, age, args, city, job)

# 明明关键字可以有缺省值,这样调用时候可以不传入city参数
def my_keyPerson2(name, age, *, city=&#39;Beijing&#39;, job):
    print(name, age, city, job)

</code></pre>

<h2 id="toc_8">递归函数</h2>

<p>解决递归调用栈溢出的方法是通过<code>尾递归优化</code>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。<br/>
<code>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</code>。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况</p>

<pre><code class="language-python"># 递归函数
def fact(n):
    if n==1:
        return 1
    return n + fact(n - 1)

print(fact(10))  # 55
# 栈溢出
print(fact(1000))  #RecursionError: maximum recursion depth exceeded in comparison

#尾递归优化后
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
</code></pre>

<blockquote>
<p>目前包括Python在内的编程语言都没有做尾递归优化,因此类似上面的尾递归优化之后仍会导致栈溢出</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语句]]></title>
    <link href="https://acefish.github.io/15317414032911.html"/>
    <updated>2018-07-16T19:43:23+08:00</updated>
    <id>https://acefish.github.io/15317414032911.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">list</h2>

<pre><code class="language-python">
list1=[1, 2, 3]

print(len(list1)) #长度 3
print(&quot;第一个元素:%s&quot; % (list1[0])) #从0开始获取第一个元素 1
print(&quot;最后一个元素:%s&quot; % (list1[-1])) #从-1开始获取最后一个元素 3

list1.append(4) #追加元素到末尾
print(&quot;m末尾追加元素：%s&quot;%(list1[-1]))  # 4

list1.insert(1, 1) #向索引1插入1
print(list1)  # [1, 1, 2, 3, 4]

list1.pop() #删除末尾元素
print(list1)  # [1, 1, 2, 3]

list1.pop(1) #删除指定索引位置元素
print(list1)  # [1, 2, 3]

list1[1] = 1 #替换元素
print(list1)  # [1, 1, 3]

list1[2] = &quot;第3个元素&quot;  #list中的数据类型可以不同
list1.append(False)
list1.append([5,6])
print(list1)  # [1, 1, &#39;第3个元素&#39;, False, [5, 6]]
</code></pre>

<h2 id="toc_1">tuple</h2>

<pre><code class="language-python">tuple1=(1,) #定义只有一个元素的元组 不能使用 tuple1=(1)这样定义为1这个数
print(tuple1) # (1,)
#tuple一经定义便不能修改，不过不变的是每个元素的指向,而可以修改器内指针元素指向的对象
tuple2=() # 定义一个空元组
</code></pre>

<blockquote>
<p>因为tuple与list相比不能修改,所以更安全，尽量使用元组</p>
</blockquote>

<h2 id="toc_2">条件语句</h2>

<pre><code class="language-python">if len(tuple2)==0:
    print(&quot;空元组&quot;)
elif len(tuple2)&gt;0:   # else if的缩写
    print(&quot;非空数组&quot;)
else:
    print(&quot;无效&quot;)
</code></pre>

<blockquote>
<p>对于判断条件中的非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code></p>
</blockquote>

<h2 id="toc_3">input</h2>

<pre><code class="language-python">birth=input(&quot;birth:&quot;)
birth=int(birth)
if birth &gt; 25:
    print(&quot;人到中年，身不由己&quot;)
else:
    print(&quot;你还年轻&quot;)
</code></pre>

<blockquote>
<p>input默认导入的为一个字符串 因此需要转换类型为int才能进行与数字进行比较</p>
</blockquote>

<h2 id="toc_4">for循环</h2>

<pre><code class="language-python">for x in list1: #遍历列表
    print(x)

for x in range(1,10): 
    print(x)
</code></pre>

<h2 id="toc_5">break continue</h2>

<p><code>break</code>用于提前退出循环<br/>
<code>continue</code>用于跳过当前这次循环</p>

<pre><code class="language-python">for x in range(1,10):
    if x==5:
        break
    print(x)
    
    for x in range(1,10):
    if x==5:
        continue
    print(x)
</code></pre>

<blockquote>
<p>不要滥用break和continue，容易逻辑分差太多而出错</p>
</blockquote>

<h2 id="toc_6">dict</h2>

<pre><code class="language-python">dict1={&quot;lyy&quot;:25, &quot;wtt&quot;:20}
dict1[None] = 10
dict1[&#39;Adam&#39;] = 67
print(dict1[None]) # 10
print(dict1) #{&#39;lyy&#39;: 25, &#39;wtt&#39;: 20, None: 10, &#39;Adam&#39;: 67}

#判断key是否存在  key in dict
if &quot;lyy&quot; in dict1:
    print(dict1[&quot;lyy&quot;])   #25

print(dict1.get(&quot;eee&quot;, &quot;placehoder&quot;)) #placehoder  获取key如果没有就返回None或自指定的value

dict1.pop(&quot;lyy&quot;)  #pop删除指定键
if &quot;lyy&quot; in dict1:
    print(dict1[&quot;lyy&quot;])
else:
    print(&quot;lyy不存在&quot;)  #不存在
    

dict1[(1,)] = &quot;name&quot;  #用元组作为key
print(dict1[(1,)])  #name
#虽然元组也是不可变对象 但是元素不能为list等可变对象
dict1[(1,[1,2])] = &quot;name&quot;  #报错  unhashable type: &#39;list&#39;
</code></pre>

<p><code>dict</code>的<code>key</code>必须为不可变对象,例如字符串，整数等，而list是可变的不能作为key</p>

<blockquote>
<p>和list比较，dict有以下几个特点：<br/>
查找和插入的速度极快，不会随着key的增加而变慢；<br/>
需要占用大量的内存，内存浪费多。<br/>
而list相反：<br/>
查找和插入的时间随着元素的增加而增加；<br/>
占用空间小，浪费内存很少。</p>
</blockquote>

<p>补充知识:</p>

<p><strong>dict()</strong>函数 用于创建一个字典,返回一个字典</p>

<pre><code class="language-python">class dict(**kwarg)  # **kwargs -- 关键字
class dict(mapping, **kwarg)  # mapping -- 元素的容器
class dict(iterable, **kwarg) # iterable -- 可迭代对象


dict()                        # 创建空字典
{}
dict(a=&#39;a&#39;, b=&#39;b&#39;, t=&#39;t&#39;)     # 传入关键字
{&#39;a&#39;: &#39;a&#39;, &#39;b&#39;: &#39;b&#39;, &#39;t&#39;: &#39;t&#39;}
dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))   # 映射函数方式来构造字典
{&#39;three&#39;: 3, &#39;two&#39;: 2, &#39;one&#39;: 1} 
dict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])    # 可迭代对象方式来构造字典
{&#39;three&#39;: 3, &#39;two&#39;: 2, &#39;one&#39;: 1}
</code></pre>

<h2 id="toc_7">Set</h2>

<p><code>set</code>中不能元素不能重复,因此只能为不可变对象</p>

<p>要创建<code>set</code>需要用<code>list</code>作为输入集合</p>

<pre><code class="language-python">set1 = set([1, &quot;name&quot;, 1])
print(set1)  # {1, &#39;name&#39;}
set1.add(&quot;1&quot;)
set1.add(1)
print(set1)  # {1, &#39;1&#39;, &#39;name&#39;}
set1.remove(1)
print(set1)  # {&#39;1&#39;, &#39;name&#39;}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python基础]]></title>
    <link href="https://acefish.github.io/15317258769792.html"/>
    <updated>2018-07-16T15:24:36+08:00</updated>
    <id>https://acefish.github.io/15317258769792.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">数据类型</h2>

<h3 id="toc_1">字符串</h3>

<p><strong>字符串是不可变的</strong></p>

<ol>
<li>用<code>&#39;</code>或者<code>&quot;</code>括起来的文本</li>
<li>可以通过 <code>\</code>转义字符来在文本中转义,进行<code>\n</code>换行 <code>\t</code>制表</li>
<li>可以通过在文本前加<code>r</code>表示文本不转义</li>
<li>用三个单引号<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的文本可以在内部直接换行而不需要<code>\n</code></li>
</ol>

<pre><code class="language-python">print(&quot;hello, world&quot;)
print(&quot;I\&#39;m OK!&quot;)
print(&quot;\t文本&quot;)
print(r&#39;&#39;&#39;\\line1
line2
line3aaaa&#39;&#39;&#39;)
</code></pre>

<h3 id="toc_2">布尔</h3>

<p><code>True</code>  真<br/>
<code>False</code> 假</p>

<p>布尔运算<br/>
<code>and</code>  与<br/>
<code>or</code>   或<br/>
<code>not</code>  非</p>

<h3 id="toc_3">空值</h3>

<p><code>None</code>表示空值</p>

<h2 id="toc_4">变量</h2>

<p>定义变量<br/>
<code>a=1</code></p>

<blockquote>
<p>python是动态语言 因此可以将同步类型的变量赋值给同一变量</p>
</blockquote>

<pre><code class="language-python">a=False
a=&quot;aa&quot;
print(a)
</code></pre>

<h2 id="toc_5">常量</h2>

<p>在python中常用全大写的变量名来表示常量</p>

<blockquote>
<p>python中除法<code>/</code>的结果为浮点数(即使整除),  <code>//</code>为地板除，两个除法的结果仍为整数</p>
</blockquote>

<pre><code class="language-python">print(10/3)   3.3333333333333335
print(10//3)   3
print(9/3)    3.0
print(9//3)   3
print(12.7//5.1)   2.0
print(1.2/3)    0.39999999999999997
</code></pre>

<h2 id="toc_6">编码</h2>

<p>在python3中字符串以Unicode编码，</p>

<p>可以通过<code>ord()</code>函数获取字符的整数表示<br/>
可以通过<code>chr()</code>函数将编码转为对应字符</p>

<pre><code class="language-python">print(ord(&quot;😱&quot;)) //128561
print(chr(128561)) //😱
//当知道字符的整数编码,可以用16进制来写str
print(&#39;\u4e2d\u6587&#39;) //中文
</code></pre>

<p>Python对bytes类型的数据用带<code>b</code>前缀的单引号或双引号表示:</p>

<pre><code class="language-python">x = b&#39;ABC&#39;
</code></pre>

<blockquote>
<p>python的字符串<code>str</code>在内存中以Unicode表示,当在网上传输或者保存磁盘时,需要将其转为以字节为单位的<code>bytes</code>使用<code>encode()</code>,而当从网络或磁盘读取数据读到的是<code>bytes</code>,将butes转为str，使用<code>decode()</code>方法</p>
</blockquote>

<p>可以通过<code>encode()</code>方法将<code>str</code>编码为指定的<code>bytes</code></p>

<pre><code class="language-python">print(&quot;中文&quot;.encode(&quot;utf-8&quot;))  # b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
print(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;))  #中文

#如果bytes中存在一小部分无效字节,可以添加errors=&#39;ignore&#39;来忽略错误的字节
b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)  #中
</code></pre>

<p><code>len()</code>函数用来计算<code>str</code>字符串的字符数,对于<code>bytes</code>则计算其字节数:</p>

<pre><code class="language-python">&gt;&gt;&gt; len(b&#39;ABC&#39;)
3
&gt;&gt;&gt; len(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
6
&gt;&gt;&gt; len(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
</code></pre>

<blockquote>
<p>为避免乱码,请坚持使用UTF-8编码进行转换,因此对于python的源码文件,指定其为UTF-8编码保存,并通过<code># -*- coding: utf-8 -*-</code>告诉编译器按照UTF-8读取源码</p>
</blockquote>

<p><strong><code># -*- coding: utf-8 -*-</code></strong></p>

<h2 id="toc_7">格式化</h2>

<pre><code class="language-python"># 格式化
print(&quot;这是字符串的%s格式化&quot; % (&quot;栗豫塬&quot;))
print(&quot;my name is %s age is %d height %.2f&quot; % (&quot;栗豫塬&quot;, 24, 17.0))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stack Navigation]]></title>
    <link href="https://acefish.github.io/15312926184354.html"/>
    <updated>2018-07-11T15:03:38+08:00</updated>
    <id>https://acefish.github.io/15312926184354.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">navigationOptions</h3>

<p>title: 导航栏的标题</p>

<p>header: 导航栏设置对象</p>

<p>headerTitle: 导航栏的标题, 可以是字符串也可以是个组件<br/>
headerBackTitle: 左上角的返回键文字, 默认是上一个页面的title，设置这个属性会覆盖掉title的值<br/>
headerRight: 导航栏右按钮<br/>
headerLeft: 导航栏左按钮<br/>
headerStyle: 导航栏的style<br/>
headerTitleStyle: 导航栏的title的style<br/>
headerTintColor: 返回按钮的颜色<br/>
headerPressColorAndroid ：按压返回按钮显示的颜色 安卓系统 &gt;= 5.0才有效。<br/>
gesturesEnabled ：是否允许右滑返回，在iOS上默认为true，在Android上默认为false</p>

<h3 id="toc_1">StackNavigatorConfig</h3>

<ul>
<li>initialRouteName: 设置默认的页面组件，必须是上面已注册的页面组件</li>
<li>initialRouteParams: 初始路由的参数</li>
<li>navigationOptions: 屏幕导航的默认选项</li>
<li>paths: RouteConfigs里面路径设置的映射</li>
<li>mode: 页面切换模式:
<ul>
<li>card: 普通app常用的左右切换</li>
<li>modal: 上下切换</li>
</ul></li>
<li>headerMode: 导航栏的显示模式:
<ul>
<li>float: 无透明效果, 默认</li>
<li>screen: 有渐变透明效果, 如微信QQ的一样</li>
<li>none: 隐藏导航栏</li>
</ul></li>
<li>cardStyle: 样式</li>
<li>onTransitionStart: 页面切换开始时的回调函数</li>
<li>onTransitionEnd: 页面切换结束时的回调函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[混合开发(OC)]]></title>
    <link href="https://acefish.github.io/15304988629042.html"/>
    <updated>2018-07-02T10:34:22+08:00</updated>
    <id>https://acefish.github.io/15304988629042.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">声明类 实现协议</h2>

<p>需要实现了<code>RCTBridgeModule</code>协议类,<br/>
导入<code>#import &lt;React/RCTBridgeModule.h&gt;</code></p>

<p>实现协议需要包含这个宏，可以添加参数作为访问此模块的名字 通常不指定默认使用类名<br/>
<code>RCT_EXPORT_MODULE();</code></p>

<h2 id="toc_1">声明原生方法给js调用</h2>

<p>声明需要提供给<code>React Native</code>组件调用的方法，即导出的方法<br/>
<code>RCT_EXPORT_METHOD()</code></p>

<pre><code class="language-javascript">//在OC中
RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
{
  RCTLogInfo(@&quot;Pretending to create an event %@ at %@&quot;, name, location);
}
//在js中这样调用
import { NativeModules } from &#39;react-native&#39;;
var CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent(&#39;Birthday Party&#39;, &#39;4 Privet Drive, Surrey&#39;);
</code></pre>

<p>通常我们将多个参数使用一个字典进行存放</p>

<pre><code class="language-javascript">#import &lt;React/RCTConvert.h&gt;

RCT_EXPORT_METHOD(addEvent:(NSString *)name details:(NSDictionary *)details)
{
  NSString *location = [RCTConvert NSString:details[@&quot;location&quot;]];
  NSDate *time = [RCTConvert NSDate:details[@&quot;time&quot;]];
  ...
}

CalendarManager.addEvent(&#39;Birthday Party&#39;, {
  location: &#39;4 Privet Drive, Surrey&#39;,
  time: date.toTime(),
  description: &#39;...&#39;
})
</code></pre>

<h3 id="toc_2">声明回调函数</h3>

<pre><code class="language-javascript">
//原生
//原生模块通常只应调用回调函数一次。但是，它可以保存callback并在将来调用
RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
{
  NSArray *events = ...
  callback(@[[NSNull null], events]);
}

//js调用
CalendarManager.findEvents((error, events) =&gt; {
  if (error) {
    console.error(error);
  } else {
    this.setState({events: events});
  }
})

//采用promise

//原生
RCT_REMAP_METHOD(findEvents,
                 resolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject)
{
  NSArray *events = ...
  if (events) {
    resolve(events);
  } else {
    reject(error);
  }
}
//js调用
async function updateEvents() {
  try {
    var events = await CalendarManager.findEvents();
    this.setState({ events });
  } catch (e) {
    console.error(e);
  }
}

updateEvents();

</code></pre>

<h2 id="toc_3">多线程</h2>

<p>生模块不应对自己被调用时所处的线程做任何假设。React Native在一个独立的串行GCD队列中调用原生模块的方法，但这属于实现的细节，并且可能会在将来的版本中改变。通过实现方法<code>- (dispatch_queue_t)methodQueue</code>，原生模块可以指定自己想在哪个队列中被执行。</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code></pre>

<p>如果一个操作需要花费很长时间，原生模块不应该阻塞住，而是应当声明一个用于执行操作的独立队列</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_queue_create(&quot;com.facebook.React.AsyncLocalStorageQueue&quot;, DISPATCH_QUEUE_SERIAL);
}
</code></pre>

<blockquote>
<p>在模块之间共享分发队列<br/>
methodQueue方法会在模块被初始化的时候被执行一次，然后会被React Native的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p>
</blockquote>

<h2 id="toc_4">导出常量</h2>

<pre><code class="language-objectivec">- (NSDictionary *)constantsToExport
{
  return @{ @&quot;firstDayOfTheWeek&quot;: @&quot;Monday&quot; };
}
</code></pre>

<h2 id="toc_5">给JS发送事件</h2>

<p>继承<code>RCTEventEmitter</code>，实现<code>suppportEvents</code>方法并调用<code>self sendEventWithName:</code></p>

<pre><code class="language-objectivec">#import &lt;React/RCTEventEmitter.h&gt;

- (NSArray&lt;NSString *&gt; *)supportedEvents
{
  return @[@&quot;EventReminder&quot;];
}

- (void)calendarEventReminderReceived:(NSNotification *)notification
{
  NSString *eventName = notification.userInfo[@&quot;name&quot;];
  [self sendEventWithName:@&quot;EventReminder&quot; body:@{@&quot;name&quot;: eventName}];
}

</code></pre>

<p>JavaScript代码可以创建一个包含你的模块的NativeEventEmitter实例来订阅这些事件。</p>

<pre><code class="language-javascript">import { NativeEventEmitter, NativeModules } from &#39;react-native&#39;;
const { CalendarManager } = NativeModules;

const calendarManagerEmitter = new NativeEventEmitter(CalendarManager);

const subscription = calendarManagerEmitter.addListener(
  &#39;EventReminder&#39;,
  (reminder) =&gt; console.log(reminder.name)
);
...
// 别忘了取消订阅，通常在componentWillUnmount生命周期方法中实现。
subscription.remove();
</code></pre>

<h2 id="toc_6">原生UI</h2>

<p>原生视图需要被一个RCTViewManager来管理和创建。本质上都是单例 - React Native只会为每个管理器创建一个实例。它们创建原生的视图并提供给<code>RCTUIManager</code>，<code>RCTUIManager</code>则会反过来委托它们在需要的时候去设置和更新视图的属性。RCTViewManager还会代理视图的所有委托，并给JavaScript发回对应的事件</p>

<ol>
<li>创建<code>RCTViewManager</code>的子类</li>
<li>添加<code>RCT_EXPORT_MODULE()</code>标记宏</li>
<li><p>实现<code>-(UIView *)view</code>方法</p></li>
<li><p>在js代码中将视图变为可用的React组件</p></li>
</ol>

<pre><code class="language-javascript">// MapView.js
var { requireNativeComponent } = require(&#39;react-native&#39;);

// requireNativeComponent 自动把这个组件提供给 &quot;RNTMapManager&quot;
module.exports = requireNativeComponent(&#39;RNTMap&#39;, null);
</code></pre>

<h3 id="toc_7">声明属性</h3>

<pre><code class="language-objectivec">//声明属性
RCT_EXPORT_VIEW_PROPERTY(pitchEnabled, BOOL)

//设置属性之后，在js中可以直接设置
&lt;MapView pitchEnabled={false} /&gt;

//比较复杂的属性
RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RNTMap)
{
  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组件属性一]]></title>
    <link href="https://acefish.github.io/15293961047296.html"/>
    <updated>2018-06-19T16:15:04+08:00</updated>
    <id>https://acefish.github.io/15293961047296.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">View</h2>

<h3 id="toc_1">颜色与边框</h3>

<ol>
<li>backgroundColor: 背景颜色</li>
<li>opacity: 0~1透明度</li>
<li><p>borderStyle: 边框风格</p>
<ul>
<li>solid: default 实线边框</li>
<li>dotted: 点状边框</li>
<li>dashed: 虚线边框</li>
</ul></li>
<li><p>borderColor: 边框颜色,可以单独定义上下左右</p></li>
<li><p>borderRadius: 定义圆角边框,可单独定义四个角</p></li>
</ol>

<blockquote>
<p>大部分组件继承了View的属性</p>
</blockquote>

<h3 id="toc_2">视觉效果</h3>

<h4 id="toc_3">阴影</h4>

<ol>
<li>shadowColor</li>
<li>shadowOffset</li>
<li>shadowOpacity</li>
<li>shadowRadius</li>
</ol>

<h4 id="toc_4">overflow</h4>

<p>取值为 visible和hidden(默认),定义子组件产出父组件部分的是否显示，当设置为visible时，仅对ios平台有效,显示超出父组件部分</p>

<h4 id="toc_5">elevation</h4>

<p>Android平台特有效果,在组件周围渲染阴影</p>

<h3 id="toc_6">变形</h3>

<p>利用<code>transform</code>设置组件的变形,包括<code>translate</code>平移,<code>scale</code>缩放,<code>rotate</code>旋转,<code>skew</code>倾斜</p>

<pre><code class="language-javascript">const styles = StyleSheet.create({
    view1Style: {
        ....
        transform: [{scale:2}, {rotateZ:&quot;45deg&quot;}]
    }
})
//Xdeg 表示角度 取值0-360
</code></pre>

<h3 id="toc_7">回调函数</h3>

<p>回调函数命名 onB 即B事件发生的回调函数</p>

<h4 id="toc_8">onLayOut</h4>

<p>当View组件被加载或者改变布局时</p>

<h4 id="toc_9">onTouchStart、onTouchMove、onTouchEnd</h4>

<p>开始触摸事件、触摸点移动事件、触摸结束事件<br/>
三个回调函数带一个event参数,</p>

<pre><code class="language-javascript">//Event结构有用对象
{
 timeStamp: aNumber, //时间戳
 nativeEvent: {
    locationX: aNumber,
    locationY: aNumber,
 }
}
</code></pre>

<pre><code class="language-javascript">//示例 demo
constructor(props) {
        super(props)
        this._onTouchStart = this._onTouchStart.bind(this)
    }

    _onTouchStart(event) {
        console.log( event.nativeEvent.locationX)
    }

    render() {
        return(
            &lt;View style={styles.containStyle}&gt;
                &lt;View style={styles.view1Style} onTouchStart={this._onTouchStart}&gt;

                &lt;/View&gt;
            &lt;/View&gt;
        )
    }
</code></pre>

<h4 id="toc_10">removeClippedSubviews</h4>

<p>布尔属性，与性能有关的，属性为true将允许释放不在显示范围内的子组件，需要将overflow设置为hidden才会生效</p>

<h3 id="toc_11">onLayOut</h3>

<p>应用通过<code>Dimension</code>获取屏幕宽高，Dimensions.get(&#39;window&#39;).width/height,获取到的宽和高是实时屏幕的宽和高,当横置时宽大于高</p>

<h3 id="toc_12">pointEvents</h3>

<p>在RN中 触摸事件总是传递给最上层的组件，当被遮盖的组件需要向银行触摸事件，就需要从View继承的<code>pointEvents</code></p>

<p>可以取值为<code>none</code> <code>box-none</code> <code>box-only</code> <code>auto</code></p>

<p><strong>none:</strong> 发生在本组件和子组件的触摸事件交给本组件的父组件处理<br/>
<strong>box-none:</strong> 本组件显示范围内，非子组件显示范围内的时间交给本组件父组件处理,子组件显示范围交给子组件处理<br/>
<strong>box-only:</strong> 本组件显示范围内的所有触摸事件都交给本组件处理<br/>
<strong>auto:</strong> 视组件不同而不同 不是所有组件都支持box-none和box-only</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[补充]]></title>
    <link href="https://acefish.github.io/15290351401483.html"/>
    <updated>2018-06-15T11:59:00+08:00</updated>
    <id>https://acefish.github.io/15290351401483.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">当安装了第三方库之后 需要重新yarn安装依赖</h3>

<p><code>yarn install</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象]]></title>
    <link href="https://acefish.github.io/15289781671435.html"/>
    <updated>2018-06-14T20:09:27+08:00</updated>
    <id>https://acefish.github.io/15289781671435.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">JS创建对象以及对象属性的几种方式</h2>

<h3 id="toc_1">1.创建直接的对象</h3>

<pre><code class="language-javascript">person=new Object();
person.firstname=&quot;Bill&quot;;
person.lastname=&quot;Gates&quot;;
person.age=56;
person.eyecolor=&quot;blue&quot;;
</code></pre>

<h3 id="toc_2">2.替代语法(使用对象 literals)</h3>

<pre><code class="language-javascript">person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,age:50,eyecolor:&quot;blue&quot;};

</code></pre>

<h3 id="toc_3">3.函数对象构造器</h3>

<pre><code class="language-javascript">function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}
</code></pre>

<h3 id="toc_4">4.使用class</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[导航页面]]></title>
    <link href="https://acefish.github.io/15289587744708.html"/>
    <updated>2018-06-14T14:46:14+08:00</updated>
    <id>https://acefish.github.io/15289587744708.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">适配不同平台</h3>

<ol>
<li><p>文件适配</p>
<p>通过命名文件后缀为 <code>.android.js</code> 和 <code>.ios.js</code>文件 RN会根据不同平台加载不同文件</p></li>
<li><p>平台检测</p></li>
</ol>

<pre><code class="language-javascript">import {
    Platform

} from &#39;react-native&#39;
if(Platform.OS === &quot;android&quot;) {
//安卓代码
} else  {
//iOS代码
}
</code></pre>

<h3 id="toc_1">监测android物理后退按钮时间</h3>

<pre><code class="language-javascript">//对于android 点击后退按钮 如果当前有后退视图就后退 并返回true 否则返回false标识后退事件没被处理 传递给操作系统 就退出应用
    handleBackAndroid() {
        if (this.navigator.getCurrentRoutes().length &gt; 1) {
            this.navigator.pop()
            return true
        } else  {
            return false
        }
    }
    //组件挂接到当前页面
    componentDidMount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.addListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }
    //组件挂接到当前页面
    componentWillUnmount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.removeListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }

</code></pre>

<p>可以使用<code>BackAndroid</code>的<code>addEventListener</code>函数挂接多个监听器,当返回键按下，最后的的最先执行 如果返回false会接下来执行倒数第二个 所有的都执行完 才会交给安卓操作系统</p>

<p><code>BackAndroid.exitApp();</code>可以 直接退出应用</p>

<h3 id="toc_2">颜色</h3>

<ol>
<li><code>rgba(52, 52, 52, 0.5)</code></li>
<li><code>0xF5FCFF01</code></li>
<li><code>#F5FCFF</code></li>
<li><code>rgb(245, 255, 255)</code></li>
<li><code>hsl(360, 100%, 100%)</code></li>
<li><code>hsla(360, 100%, l00%, 1.0)</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[状态机]]></title>
    <link href="https://acefish.github.io/15288713693530.html"/>
    <updated>2018-06-13T14:29:29+08:00</updated>
    <id>https://acefish.github.io/15288713693530.html</id>
    <content type="html"><![CDATA[
<p>ReactNative 将UI视作一个状态机,每个UI场景就是状态机的一个状态</p>

<blockquote>
<p>不要在状态机变量中存放于显示无关的变量,会导致务必要渲染UI</p>
</blockquote>

<h2 id="toc_0">State</h2>

<blockquote>
<p>尽可能让自定义的组件成为无状态组件<br/>
好的reactnative设计思路:创建多个只负责渲染数据的无状态组件，将他们封装在一个有状态的reactnative组件中,有状态的组件封装了UI交互的逻辑，而无状态的组件负责渲染UI界面。</p>
</blockquote>

<pre><code class="language-javascrip">constructor(props) {
        super(props)
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    updateNum(newText) {
        this.setState((state) =&gt; {
            return {input: newText}
        });
    }

    updatePWD(newText) {
        this.setState(() =&gt; {
            return {
                inputPWD : newText
            }
        })
    }
</code></pre>

<p>通过this.state.状态机变量名 访问状态机变量</p>

<p>我们需要将状态机变量看做 <strong>不可变常量</strong>，不能直接改变状态机变量，只能通过<strong>setState</strong>函数</p>

<h2 id="toc_1">渲染</h2>

<p>setState函数原型：<code>setState(oldState, callback)</code> 第二个参数为回调函数,会在setState完成并且重新渲染完成(如果需要的话)后被调用</p>

<p>如果setState函数将传入函数的返回值与当前状态机相比没有任何修改或增加,将不会进行渲染</p>

<p>改变状态机变量后 所有与状态机变量值有关系的组件都会被刷新。</p>

<blockquote>
<p>当修改组件的状态机变量值后，ReactNative会在考虑清楚如何高效的渲染UI后,执行SetState的箭头函数来渲染组件,因此setState是异步执行的函数</p>

<p>当子组件需要渲染时,那么该子组件的各个生命周期的函数都会按声明周期调用 这就是渲染高效的原因</p>
</blockquote>

<h3 id="toc_2">判断是否渲染</h3>

<pre><code class="language-javascript">//判断是否渲染，实现这个函数后,会在重新渲染组件前，调用这个函数，返回false就放弃渲染组件
shouldComponentUpdate() {
        if (this.state.input.length &lt; 3) {
            return true;
        }
        return false;
    }
</code></pre>

<h3 id="toc_3">强制渲染</h3>

<p><code>forceUpdate(callback)</code> <br/>
当UI的可变数据来源为属性和状态之外获取时,可以使用这个函数要求重新渲染，这会导致所有级别的UI都重新读取、计算、渲染。</p>

<blockquote>
<p>这个渲染过程不会调用<code>shouldComponentUpdate</code><br/>
可以通过回调函数,在执行结束后调用<br/>
尽量避免使用</p>
</blockquote>

<h3 id="toc_4">render渲染过程</h3>

<p>RN通过<code>render</code>实现重新渲染。原型为<code>ReactComponent render()</code><br/>
任何组件都必须有这个函数 也必须只能返回一个可渲染组件<br/>
通过修改属性或者状态机变量来触发render的重新渲染，而不是直接调用这个函数</p>

<h3 id="toc_5">简洁写法</h3>

<pre><code class="language-javascript">    //简洁写法1（通过指定参数名称与状态机变量名称相同 省略）
    updateNum(input) {
        this.setState(() =&gt; {
            return {input}
        })
    }
    
    //简洁写法2（省略箭头函数）
    updateNum(input) {
        this.setState( {input})
    }
 ```

## 成员变量

```javascript
    constructor(props) {
        super(props)
        this.myProperty1 = &quot;test&quot;
        this.myProperty2 = true
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    //就可以在组件中使用myProperty1  myProperty2 这两个成员变量
</code></pre>

<p>组件可以有静态变量、静态成员函数，直接用<code>类名.</code>调用</p>

<h3 id="toc_6">回调函数绑定</h3>

<pre><code class="language-javascript">//在constuctor函数中
this.updateNum = this.updateNum.bind(this)
</code></pre>

<p>绑定操作是为了让回调函数能正确解析出this，否则this.updateNum函数被执行时,指向另外对象而不是该组建类的实例</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flex]]></title>
    <link href="https://acefish.github.io/15287061850668.html"/>
    <updated>2018-06-11T16:36:25+08:00</updated>
    <id>https://acefish.github.io/15287061850668.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基本概念</h2>

<p>采用Flex布局的元素，称为容器，它的所有子元素 自动成为容器成员<br/>
<img src="media/15287061850668/15287068668255.png" alt=""/></p>

<h2 id="toc_1">容器属性</h2>

<pre><code class="language-text">flex-direction
flex-warp
flex-flow
justify-content
align-items
align-content
</code></pre>

<h3 id="toc_2">flex-direction</h3>

<p>决定主轴的方向 </p>

<ul>
<li>row:default 主轴为水平方向，起点在左端</li>
<li>row-reverse: 主轴为水平 起点在右端</li>
<li>column: 主轴为垂直方向，起点在上</li>
<li>colum-reverse:主轴为垂直方向 起点在下</li>
</ul>

<h3 id="toc_3">flex-warp</h3>

<p>当一条轴线放不下的情况 如何换行</p>

<ul>
<li>nowarp: default 不换行</li>
<li>wrap: 换行 第一行在上方</li>
<li>warp-reverse:换行，第一行在下方</li>
</ul>

<h3 id="toc_4">flex-flow</h3>

<p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>

<h3 id="toc_5">justify-content</h3>

<p>项目在主轴上的对齐方式</p>

<ul>
<li>flex-start: 左对齐</li>
<li>flex-end: 右对齐</li>
<li>center: 居中</li>
<li>space-between: 两端对齐，项目之间间隔相等</li>
<li>space-around: 每个项目两侧间隔相等</li>
</ul>

<h3 id="toc_6">align-items属性</h3>

<p>align-items属性定义项目在交叉轴上如何对齐</p>

<ul>
<li>flex-start: 交叉轴的起点对齐</li>
<li>flex-end: 交叉轴的终点对齐</li>
<li>center: 交叉轴的中间对齐</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
<li>strech: default 项目未设置高度或者设为auto，将默认占满整个容器</li>
</ul>

<h3 id="toc_7">align-content</h3>

<p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>

<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch：default 轴线占满整个交叉轴。</li>
</ul>

<h2 id="toc_8">项目属性</h2>

<pre><code class="language-text">order
flex-grow
flex-shrink
flex-basis
flex
align-self
</code></pre>

<h3 id="toc_9">order属性</h3>

<p>定义项目的排列顺序 数值越小 越靠前 默认为NO</p>

<h3 id="toc_10">flex-grow</h3>

<p>定义项目的放大比例 默认为0，即 如果存在剩余空间 也不放大<br/>
如果所有项目的<code>flex-grow</code>属性都为1，它们将等分剩余空间,如果属性为2，其它项目为1，则前者占据的剩余空间比其它多一倍</p>

<h3 id="toc_11">flex-shrink</h3>

<p>定义项目的缩小比例 默认为1 即如果空间不足 该项目将缩小<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小<br/>
负值无效</p>

<h3 id="toc_12">flex-basis</h3>

<p>定义在分配多余空间之前，项目占据的主轴空间， 根据这个值计算是否有剩余空间，默认值为<code>auto</code>即项目的本来大小</p>

<h3 id="toc_13">flex</h3>

<p>flex属性是flex-shrink、flex-grow、flex-basis的简写，默认值是0，1，auto，后两个属性是可选的<br/>
该属性有两个快捷值：auto（1 1 auto） 和none（0 0 auto）</p>

<h3 id="toc_14">align-self</h3>

<p>允许单个项目与其它项目有不一样的对齐方式，可覆盖<code>align-items</code>属性 默认值为<code>auto</code>表示继承父元素的<code>align-items</code>属性,如果没有父属性则等同于<code>stretch</code></p>

<h1 id="toc_15">ReactNative Flex</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git]]></title>
    <link href="https://acefish.github.io/15284514278903.html"/>
    <updated>2018-06-08T17:50:27+08:00</updated>
    <id>https://acefish.github.io/15284514278903.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text">git show 命令可以查看很多信息 分支 标签 commitId

</code></pre>

<h3 id="toc_0">log</h3>

<blockquote>
<p>git log 的节点只与当前分支相关的节点,包括创建此分支之前继承的节点 和 之后自己提交的 以及作为当前分支与其他分支合并的log</p>
</blockquote>

<pre><code class="language-text">git log --graph  可以看到分支合并图
git log --graph --pretty=oneline --abbrev-commit 以图形化方式更好的展示分支合并状况
</code></pre>

<h3 id="toc_1">diff</h3>

<pre><code class="language-text">git diff 工作区与缓存区比较
git diff --cache 缓存区与HEAD比较
git diff HEAD 工作区与当前分支对比
git diff branchName 当前分支与某分支对比
git diff commitId 工作区与某次提交对比
</code></pre>

<h3 id="toc_2">回退</h3>

<pre><code class="language-text">git checkout -- fileName 将工作区文件撤销修改至与暂存区一致

git reset HEAD fileName 将暂存区的修改撤销掉 重新放回工作区(HEAD表示最新版本)

git reset commitId 回退版本

</code></pre>

<h3 id="toc_3">删除</h3>

<pre><code class="language-text"> git rm filename 将暂存区和工作区的文件一起删除
 git rm --cache filename 将暂存区的文件删除但是保留工作区文件
</code></pre>

<h3 id="toc_4">分支</h3>

<blockquote>
<p>不同分支共享工作区和暂存区,但是版本库是不一样的 ，因此不同分支下的文件是工作区 暂存区可各自的版本库文件总和 可能文件不同</p>
</blockquote>

<pre><code class="language-text">git checkout -b newBranchName 创建分支并且切换分支 相当于 git branch branchName +  git checkout branchName
git branch branchName 创建分支
git checkout branchName 切换分支为当前分支
git branch -d branchName 删除分支
git merge branchName 将其他分支合并到当前分支
git merge -m &quot;commitInfo&quot; branchName 合并分支 当不为快速合并时 新建commitInfo的提交
git merge --no-ff -m &quot;commitInfo&quot; branchName 禁用快速合并
</code></pre>

<h4 id="toc_5">快速合并</h4>

<p>如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作；git 不创建任何新的提交(commit),只是将当前分支指向合并进来的分支。 否则合并会新建一个提交来合并分支</p>

<h3 id="toc_6">stash</h3>

<pre><code class="language-text">git stash 将工作去和缓存区文件stash起来

 git stash list 查看stash内容的列表
 
 git stash apply stash@\{0\}  恢复暂存 不删除stash内容(如果不指定节点 默认最后stash的一个)
 
 git stash drop stash@\{0\} 删除stash内容(如果不指定节点 默认最后stash的一个)
 
git stash pop stash@\{0\} 恢复暂存 并且删除stash内容(如果不指定节点 默认最后stash的一个)
</code></pre>

<h3 id="toc_7">remote</h3>

<pre><code class="language-text">git remote -v 查看远程信息

git branch -r 查看远程分支信息

git checkout -b branchName origin/branchName  创建远程的branchName分支到本地


</code></pre>

<pre><code class="language-text">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 将本地分支推送到远程分支 如果没有这个远程分支就新建远程分支

git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果没有本地分支 就创建本地分支

</code></pre>

<pre><code class="language-text">
git push origin branchName 将本地分支推送到远程分支 如果分支不存在 就会新建

git push origin :branchName 删除指定远程分支 等同于 git push origin --delete master

git push origin 将当前分支 推送到远程分支

git push -u origin master 使用-u选项指定一个默认主机，这样以后就可以不加任何参数使用git push

git push -f origin branchName -f表示覆盖远程分支 相当于先删除远程分支在新建

</code></pre>

<pre><code class="language-text">git pull origin remoteBranch  remoteBranch与当前分支合并

git branch --set-upstream-to=origin/branchName branchName 指定本地分支与远程分支的连接，建立追踪关系后 就可以直接 git pull origin 省略远程分支名字 如果只有一个追踪分支 origin也可以省略 

</code></pre>

<h3 id="toc_8">变基</h3>

<p>git rebase </p>

<h3 id="toc_9">标签</h3>

<p>标签也是版本库的快照</p>

<pre><code class="language-text">git tag tagName 打标签 默认打在最新提交commit
git tag tagName commitId 给commit打上标签
git tag -a tagName -m &quot;tag说明文字&quot; commitId 给tag加说明文字 -a为标签名 -m为说明文字
git tag 查看所有标签
git show tagName 查看标签信息(git show命令还可以查看其它很多信息)
git tag -d tagName 删除本地标签

//推送标签
git push origin refs/tags/源标签名:refs/tags/目的标签名 

git push origin tagname 推送标签到远程
git push origin --tags 推送所有标签

删除远程标签
git tag -d tagname //先删除本地标签
git push origin :refs/tags/tagname

</code></pre>

<h3 id="toc_10">补充</h3>

<h4 id="toc_11">ignore</h4>

<p>git check-ignore -v 文件名 查看ignore文件写的有什么问题</p>

<h4 id="toc_12">alias</h4>

<pre><code class="language-text">git config --global alias.st status //st代表status
git config --global alias.co checkout //co 代表 checkout
git config --global alias.ci commit //ci代表commit
git config --global alias.br branch //br代表branch
git config --global alias.last &#39;log -1&#39; //git last代表 git log -l 最后一次提交信息
git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; //修改git lg 为一种好看的格式
</code></pre>

<h3 id="toc_13">搭建自定义Git仓库</h3>

<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 与 ECMAScript 区别]]></title>
    <link href="https://acefish.github.io/15266103811219.html"/>
    <updated>2018-05-18T10:26:21+08:00</updated>
    <id>https://acefish.github.io/15266103811219.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础名词</h2>

<p>ECMA 为科学技术制定标准的组织</p>

<p>ECMA-262 目前脚本语言的规范</p>

<p>ECMAScript是定义在ECMA-262中定义的标准,用于创建通用目的脚本语言</p>

<p>JavaScript 通用目的的脚本语言，遵循ECMAScript规范</p>

<p>JavaScript引擎 能够理解和执行JavaScript代码的程序或解释器</p>

<p>JavaScript运行时 js代码运行所在环境,为js引擎所解释。运行时提供js可以运行和操作的宿主对象，js代码被引擎传递,被解析和理解之后,运行时的实体或系统将执行解释行为。例如：浏览器的宿主环境提供的对象视窗或文档等WebAPIs 服务器的宿主环境Node.js，即文件系统、处理和请求等</p>

<p>ECMAScript 6  是ECMA的第6个版本,对规范有显著改变(同名的ES2015)</p>

<p>Babel 将ES6代码转换为ES5的转译器(目前主流js引擎都支持ES6 但不一定支持ES6)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[# iOS编译过程]]></title>
    <link href="https://acefish.github.io/15266103180287.html"/>
    <updated>2018-05-18T10:25:18+08:00</updated>
    <id>https://acefish.github.io/15266103180287.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">大致过程</h2>

<blockquote>
<p>如果有工程依赖的第三方依赖库,会首先build依赖库target,然后build主target</p>
</blockquote>

<p>大致流程:</p>

<ul>
<li><p>compile各个.m文件<br/>
<code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch x86_64 -W -c path/main.m -o path/main.o</code></p>
<ul>
<li>-x 表示编译语言</li>
<li>-arch 表示编译的架构</li>
<li>-W表示各种编译警告</li>
<li>-c 表示进行预处理，编译，汇编过程</li>
<li>-o 输出结果</li>
</ul></li>
<li><p>Copy静态资源(包括img, string, font等)<br/>
//copy图片到app<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copypng <br/>
-compress -strip-PNG-text path/MaskView/MaskView/en.lproj/icons.png path/MaskView.app/en.lproj/icons.png</code></p></li>
<li><p>compile xib文件<br/>
编译xib，生成nib文件<br/>
 <code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool</code></p></li>
<li><p>compile storyboard文件<br/>
编译storyBoard,生成.storyBoard，其包内容为nib+plist<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool</code></p></li>
<li><p>compile asset catalogs<br/>
生成Asset.car文件<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/actool</code></p></li>
<li><p>process info.plist<br/>
处理info.plist<br/>
<code>builtin-infoPlistUtility</code></p></li>
<li><p>link storyboards<br/>
链接storyboard<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool</code></p></li>
<li><p>run custom script<br/>
执行脚本<br/>
<code>/bin/sh</code></p></li>
<li><p>touch app</p>
<p><code>/usr/bin/touch</code></p></li>
<li><p>sign app<br/>
对app进行签名<br/>
<code>/usr/bin/codesign</code></p></li>
<li><p>validate app<br/>
校验app<br/>
<code>builtin-validationUtility</code></p></li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用宏定义]]></title>
    <link href="https://acefish.github.io/15260169489026.html"/>
    <updated>2018-05-11T13:35:48+08:00</updated>
    <id>https://acefish.github.io/15260169489026.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">#ifdef <strong>OBJC</strong>宏定义</h2>

<p><img src="media/15260169489026/15260169903529.jpg" alt=""/></p>

]]></content>
  </entry>
  
</feed>
