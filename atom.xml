<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2018-05-02T11:28:32+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[全民认证]]></title>
    <link href="https://acefish.github.io/15252210899371.html"/>
    <updated>2018-05-02T08:31:29+08:00</updated>
    <id>https://acefish.github.io/15252210899371.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">联系我们</h2>

<h3 id="toc_1">联系电话</h3>

<p>+86 15538868997</p>

<h3 id="toc_2">电子邮箱</h3>

<p><a href="mailto:fish_lyy@sina.com">fish_lyy@sina.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS基础使用]]></title>
    <link href="https://acefish.github.io/15205769334278.html"/>
    <updated>2018-03-09T14:28:53+08:00</updated>
    <id>https://acefish.github.io/15205769334278.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础语法</h2>

<ol>
<li>JS忽略出现的空格、制表符、空格</li>
<li>JS中分号是可选的，如果一行只有一句代码，是可以忽略这个分号的</li>
<li>JS是区分大小写的</li>
<li><p>JS中单行注释用<code>//</code> 多行注释用<code>/*...*/</code> JS可以识别<code>html</code>注释的开始部分<code>&lt;!--</code>但不能识别html注释的结尾部分<code>--&gt;</code></p>

<pre><code class="language-javascript">//对于js代码我们可以这样写，在不支持js的浏览器中节省我们的代码
&lt;!--
  var1 = 10
//--&gt;
</code></pre></li>
</ol>

<h2 id="toc_1">不支持js的警告信息</h2>

<pre><code class="language-javascript">&lt;html&gt;
    &lt;body&gt;

    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
    &lt;!--
       document.write(&quot;Hello World!&quot;)
    //--&gt;
    &lt;/script&gt;


    &lt;noscript&gt;
    //对于不支持或者没开启js功能的浏览器会在屏幕上显示这航信息
      Sorry...JavaScript is needed to go ahead.
    &lt;/noscript&gt;
    &lt;/body&gt;
    &lt;/html&gt;

</code></pre>

<h2 id="toc_2">JS代码位置</h2>

<ol>
<li><code>HTML</code>网页的<head>...<head></li>
<li><code>HTML</code>网页的<body>...<body></li>
<li><code>HTML</code>网页的<body>...<body>和<head>...<head></li>
<li>外部文件.js文件,并引用在<head>...<head>中</li>
</ol>

<pre><code class="language-javascript">&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;filename.js&quot; &gt;&lt;/script&gt;
    &lt;/head&gt;
</code></pre>

<h2 id="toc_3">JS变量</h2>

<p>1.数据类型有<br/>
    1). 数值类型(未区分整数和浮点数，均用64位浮点格式表示)<br/>
    2). 字符串类型<br/>
    3). 布尔类型  true 或者 false<br/>
2. 使用<code>var</code>声明变量 必须先声明在使用<br/>
3. JS变量是对大小写敏感的</p>

<h2 id="toc_4">运算符</h2>

<ol>
<li>算术运算符 +、-、*、/、%、++、--</li>
<li>比较运算符 ==、!=、&gt;、&lt;、&gt;=、&lt;=</li>
<li>逻辑运算符 &amp;&amp;、||、！</li>
<li>位运算符 &amp;、|、<sup>、~、&lt;&lt;、&gt;&gt;(按最高位进行补位)、&gt;&gt;&gt;(左边补零移位)</sup></li>
<li>赋值运算符：=、+=、-=、*=、/=、%=</li>
<li>条件运算符： ？:</li>
<li>typeof运算符：返回类型的字符串</li>
</ol>

<h2 id="toc_5">If...Else</h2>

<pre><code class="language-javascript"> &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    var book = &quot;maths&quot;;
    if( book == &quot;history&quot; ){
       document.write(&quot;&lt;b&gt;History Book&lt;/b&gt;&quot;);
    }else if( book == &quot;maths&quot; ){
       document.write(&quot;&lt;b&gt;Maths Book&lt;/b&gt;&quot;);
    }else if( book == &quot;economics&quot; ){
       document.write(&quot;&lt;b&gt;Economics Book&lt;/b&gt;&quot;);
    }else{
      document.write(&quot;&lt;b&gt;Unknown Book&lt;/b&gt;&quot;);
    }
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h2 id="toc_6">Switch Case</h2>

<pre><code class="language-javascript">
switch (expression)
    {
      case condition 1: statement(s)
    break;
      case condition 2: statement(s)
    break;
       ...
      case condition n: statement(s)
    break;
      default: statement(s)
    } 
</code></pre>

<h2 id="toc_7">while循环</h2>

<pre><code class="language-javascript">while(expression){  
        statement  
    }
    
    do{  
        statement  
    }while(expression);  
    
</code></pre>

<h2 id="toc_8">for循环</h2>

<pre><code class="language-javascript">for(initialize;test condition;iteration statement)  
    {  
        statement;  
    }
</code></pre>

<h2 id="toc_9">for in循环</h2>

<pre><code class="language-javascript"> for (variablename in object){  
        statement
    } 
</code></pre>

<p>将对象的属性作为参数变量来实现循环</p>

<h2 id="toc_10">循环控制</h2>

<h3 id="toc_11">break</h3>

<p>提前结束整个循环</p>

<h3 id="toc_12">continue</h3>

<p>立即开始下次循环</p>

<h3 id="toc_13">使用标签来控制流</h3>

<p>一个标签可以被用于 break , continue 语句去更精确地控制流<br/>
在js1.2之后,标签是一个标识符后跟一个冒号,应用于声明或代码块。</p>

<blockquote>
<p>continue或break语句以及其标签的名字之间不允许有换行符。标签名称和其后循环体之间也不应有任何其他语句</p>
</blockquote>

<pre><code class="language-javascript">  &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    document.write(&quot;Entering the loop!&lt;br /&gt; &quot;);
    outerloop:   // This is the label name
    for (vari = 0; i&lt; 5; i++)
    {
    document.write(&quot;Outerloop: &quot; + i + &quot;&lt;br /&gt;&quot;);
    innerloop:
    for (var j = 0; j &lt; 5; j++)
    {
    if (j &gt;  3 ) break ; // Quit the innermost loop
    if (i == 2) break innerloop; // Do the same thing
    if (i == 4) break outerloop; // Quit the outer loop
    document.write(&quot;Innerloop: &quot; + j + &quot;  &lt;br /&gt;&quot;);
       }
    }
    document.write(&quot;Exiting the loop!&lt;br /&gt; &quot;);
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h2 id="toc_14">函数</h2>

<h3 id="toc_15">定义函数</h3>

<p>使用函数关键字<code>function</code></p>

<pre><code class="language-javascript">//定义函数
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function functionname(parameter-list)
    {
        statements
    }
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h3 id="toc_16">调用函数</h3>

<pre><code class="language-javascript">  &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    sayHello();
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h3 id="toc_17">函数参数</h3>

<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function sayHello(name, age)
    {
       alert( name + &quot; is &quot; + age + &quot; years old.&quot;);
    }
    //--&gt;
    &lt;/script&gt;
    
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    sayHello(&#39;Zara&#39;, 7 );
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h3 id="toc_18">return 语句</h3>

<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function concatenate(first, last)
    {
       var full;

       full = first + last;
       return  full;
    }
    //--&gt;
    &lt;/script&gt;
    
     &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
       var result;
       result = concatenate(&#39;Zara&#39;, &#39;Ali&#39;);
       alert(result );
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h2 id="toc_19">事件</h2>

<h3 id="toc_20">onclick事件类型</h3>

<p>当用户点击鼠标左按钮</p>

<pre><code class="language-javascript">&lt;html&gt;
    &lt;head&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function sayHello() {
       alert(&quot;Hello World&quot;)
    }
    //--&gt;
    &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;input type=&quot;button&quot; onclick=&quot;sayHello()&quot; value=&quot;Say Hello&quot; /&gt;
    &lt;/body&gt;
    &lt;/html&gt;  
</code></pre>

<h3 id="toc_21">onsubmit事件类型</h3>

<p>尝试提交一个表单，可以用此事件类型进行表单验证，</p>

<pre><code class="language-javascript">
&lt;html&gt;
    &lt;head&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function validation() {
       all validation goes here
       .........
       return either true or false
    }
    //--&gt;
    &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    //当表单中加上 onsubmit=&quot;return false&quot; 可以阻止表单提交
    &lt;form method=&quot;POST&quot; action=&quot;t.cgi&quot; onsubmit=&quot;return validate()&quot;&gt;
    .......
    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
    &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;  
</code></pre>

<h3 id="toc_22">onmouseover 和 onmouseout</h3>

<p>onmouseover 事件发生时,当你把你的鼠标在任何元素上时， onmouseover 事件发生。当你把鼠标从该元素移开时，onmouseout 事件发生</p>

<h2 id="toc_23">Cookies</h2>

<p><a href="http://wiki.jikexueyuan.com/project/javascript/cookies.html">参考资料</a></p>

<h3 id="toc_24">写入cookies</h3>

<p><code>document.cookie = &quot;key1=value;key2=value2;expires=date&quot;;</code></p>

<pre><code class="language-javascript">//写入cookie
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function WriteCookie()
{
   if( document.myform.customer.value == &quot;&quot; ){
      alert(&quot;Enter some value!&quot;);
      return;
   }

   cookievalue= escape(document.myform.customer.value) + &quot;;&quot;;
   document.cookie=&quot;name=&quot; + cookievalue;
   alert(&quot;Setting Cookies : &quot; + &quot;name=&quot; + cookievalue );
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;myform&quot; action=&quot;&quot;&gt;
Enter name: &lt;input type=&quot;text&quot; name=&quot;customer&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;Set Cookie&quot; onclick=&quot;WriteCookie();&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="toc_25">读取cookies</h3>

<p>document.cookie 对象的值就是 Cookie 的属性值,document.cookie 字符串会保存一系列用分号分开的 name = value 键值对</p>

<pre><code class="language-javascript">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function ReadCookie()
{
   var allcookies = document.cookie;
   alert(&quot;All Cookies : &quot; + allcookies );

   // Get all the cookies pairs in an array
   cookiearray  = allcookies.split(&#39;;&#39;);

   // Now take key value pair out of this array
   for(var i=0; i&lt;cookiearray.length; i++){
      name = cookiearray[i].split(&#39;=&#39;)[0];
      value = cookiearray[i].split(&#39;=&#39;)[1];
      alert(&quot;Key is : &quot; + name + &quot; and Value is : &quot; + value);
   }
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;myform&quot; action=&quot;&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;Get Cookie&quot; onclick=&quot;ReadCookie()&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>

<h3 id="toc_26">设置cookies有效日期</h3>

<pre><code class="language-javascript">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function WriteCookie()
{
   var now = new Date();
   now.setMonth( now.getMonth() + 1 ); 
   cookievalue = escape(document.myform.customer.value) + &quot;;&quot;
   document.cookie=&quot;name=&quot; + cookievalue;
   document.cookie = &quot;expires=&quot; + now.toUTCString() + &quot;;&quot;
   alert(&quot;Setting Cookies : &quot; + &quot;name=&quot; + cookievalue );
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;formname&quot; action=&quot;&quot;&gt;
Enter name: &lt;input type=&quot;text&quot; name=&quot;customer&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;Set Cookie&quot; onclick=&quot;WriteCookie()&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="toc_27">删除cookies</h3>

<p>删除一个 Cookie，从而下次尝试读取 Cookie 信息时会返回一个空值，可以设置 Cookie 的有效生存时间为过去的某个时间的即可。</p>

<pre><code class="language-javascript">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function WriteCookie()
{
   var now = new Date();
   now.setMonth( now.getMonth() - 1 ); 
   cookievalue = escape(document.myform.customer.value) + &quot;;&quot;
   document.cookie=&quot;name=&quot; + cookievalue;
   document.cookie = &quot;expires=&quot; + now.toUTCString() + &quot;;&quot;
   alert(&quot;Setting Cookies : &quot; + &quot;name=&quot; + cookievalue );
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;formname&quot; action=&quot;&quot;&gt;
Enter name: &lt;input type=&quot;text&quot; name=&quot;customer&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;Set Cookie&quot; onclick=&quot;WriteCookie()&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS11]]></title>
    <link href="https://acefish.github.io/15143731430102.html"/>
    <updated>2017-12-27T19:12:23+08:00</updated>
    <id>https://acefish.github.io/15143731430102.html</id>
    <content type="html"><![CDATA[
<p><code>estimatedRowHeight</code>是一个预估高度，iOS11之前是为0，在iOS11下，这个值默认为44。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UISearchBar UISearchController UITextField]]></title>
    <link href="https://acefish.github.io/15124643482351.html"/>
    <updated>2017-12-05T16:59:08+08:00</updated>
    <id>https://acefish.github.io/15124643482351.html</id>
    <content type="html"><![CDATA[
<p>1.用searchBar的搜索框的话 取消按钮会在键盘消失即searchBar失去第一响应者时变为不可点击状态 需要再次点击取消按钮或者搜索框使其成为第一响应者才能点击取消按钮</p>

<p>2.UIsearchController<br/>
点击出现搜索结果控制器的动画不收控制,依赖于当前searchBar位置与self.view相对，对于tabbleView的headView的searchBar，其tableView的y为0,并且不能用自动布局</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战:ARKit捕捉平面]]></title>
    <link href="https://acefish.github.io/15082392311480.html"/>
    <updated>2017-10-17T19:20:31+08:00</updated>
    <id>https://acefish.github.io/15082392311480.html</id>
    <content type="html"><![CDATA[
<p>当捕捉到一个平面锚点<code>ARPlaneAnchor</code>会添加到当前场景中，我们可以通过监听<code>ARSCNView</code>代理来获取这个平面锚点</p>

<pre><code class="language-objc">//添加节点时候调用（当开启平地捕捉模式之后，如果捕捉到平地，ARKit会自动添加一个平地节点）
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor
{
    if ([anchor isMemberOfClass:[ARPlaneAnchor class]]) {
        NSLog(@&quot;捕捉到平地&quot;);
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARCamera]]></title>
    <link href="https://acefish.github.io/15082385455420.html"/>
    <updated>2017-10-17T19:09:05+08:00</updated>
    <id>https://acefish.github.io/15082385455420.html</id>
    <content type="html"><![CDATA[
<p><code>ARCamera</code>是一个相机,连接虚拟场景与现实场景的枢纽</p>

<p>它的API大致只需要了解即可,ARKit会默认帮我们进行配置好</p>

<h2 id="toc_0">API</h2>

<pre><code class="language-objc">/**
 4x4矩阵表示相机位置，同ARAnchor
 */
@property (nonatomic, readonly) matrix_float4x4 transform;

/**
相机方向（旋转）的矢量欧拉角
分别是x/y/z
 */
@property (nonatomic, readonly) vector_float3 eulerAngles;

/**
 相机追踪状态（在下方会有枚举值介绍）
 */
@property (nonatomic, readonly) ARTrackingState trackingState NS_REFINED_FOR_SWIFT;

/**
追踪运动类型
 */
@property (nonatomic, readonly) ARTrackingStateReason trackingStateReason NS_REFINED_FOR_SWIFT;

/**
相机内参矩阵
3x3矩阵
 fx 0   px
 0  fy  py
 0  0   1
 */
@property (nonatomic, readonly) matrix_float3x3 intrinsics;

/**
摄像头分辨率
 */
@property (nonatomic, readonly) CGSize imageResolution;

/**
投影矩阵
*/
@property (nonatomic, readonly) matrix_float4x4 projectionMatrix;

/**
创建相机投影矩阵
 */
- (matrix_float4x4)projectionMatrixWithViewportSize:(CGSize)viewportSize orientation:(UIInterfaceOrientation)orientation zNear:(CGFloat)zNear zFar:(CGFloat)zFar;

@end

//相机追踪状态枚举
typedef NS_ENUM(NSInteger, ARTrackingState) {

    /** 不被允许 */
    ARTrackingStateNotAvailable,

    /** 被限制 限值原因ARTrackingStateReason */
    ARTrackingStateLimited,

    /** 正常. */
    ARTrackingStateNormal,
} NS_REFINED_FOR_SWIFT;

/**
 追踪运动类型
 */
API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(macos, watchos, tvos)
typedef NS_ENUM(NSInteger, ARTrackingStateReason) {
    /** 无. */
    ARTrackingStateReasonNone,
    
    /** 初始化追踪 */
    ARTrackingStateReasonInitializing,

    /** 过度运动. */
    ARTrackingStateReasonExcessiveMotion,

    /** 未找到可见特征 缺少纹理 */
    ARTrackingStateReasonInsufficientFeatures,
} NS_REFINED_FOR_SWIFT;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARSession]]></title>
    <link href="https://acefish.github.io/15082349866219.html"/>
    <updated>2017-10-17T18:09:46+08:00</updated>
    <id>https://acefish.github.io/15082349866219.html</id>
    <content type="html"><![CDATA[
<p><code>ARSession</code>是连接底层与AR视图的桥梁，<code>ARCNView</code>内部所有的代理方法都是ARSession提供的</p>

<p><img src="media/15082349866219/15082365566677.png" alt=""/></p>

<h2 id="toc_0">获取相机位置的方法</h2>

<ol>
<li>实时不断的获取相机位置,然后由<code>ARSession</code>告知用户</li>
</ol>

<p>//获取相机位置<br/>
<code>- (void)session:(ARSession *)session didUpdateFrame:(ARFrame *)frame</code></p>

<ol>
<li>用户想要时主动去获取,通过其<code>currentFrame</code>属性获取</li>
</ol>

<h2 id="toc_1">API</h2>

<pre><code class="language-objc">/**
 代理
 */
@property (nonatomic, weak) id &lt;ARSessionDelegate&gt; delegate;

/**
指定代理执行的线程（主线程不会有延迟，子线程会有延迟），不指定的话默认主线程
 */
@property (nonatomic, strong, nullable) dispatch_queue_t delegateQueue;

/**
相机当前的位置（是由会话追踪配置计算出来的）
 */
@property (nonatomic, copy, nullable, readonly) ARFrame *currentFrame;

/**
 会话追踪配置
 */
@property (nonatomic, copy, nullable, readonly) ARSessionConfiguration *configuration;

/**
运行会话（这行代码就是开启AR的关键所在）
 */
- (void)runWithConfiguration:(ARSessionConfiguration *)configuration NS_SWIFT_UNAVAILABLE(&quot;Use run(_:options:)&quot;);

/**
运行会话，只是多了一个参数ARSessionRunOptions：作用就是会话断开重连时的行为。
ARSessionRunOptionResetTracking：表示重置追踪  
ARSessionRunOptionRemoveExistingAnchors：移除现有锚点
 */
- (void)runWithConfiguration:(ARSessionConfiguration *)configuration options:(ARSessionRunOptions)options NS_SWIFT_NAME(run(_:options:));

/**
暂停会话
 */
- (void)pause;

/**
添加锚点
 */
- (void)addAnchor:(ARAnchor *)anchor NS_SWIFT_NAME(add(anchor:));

/**
移除锚点
 */
- (void)removeAnchor:(ARAnchor *)anchor NS_SWIFT_NAME(remove(anchor:));

@end

//session代理分类两部分，一个是观察者（KVO） 一个是委托者（代理）
#pragma mark - ARSessionObserver


//session KVO观察者
@protocol ARSessionObserver &lt;NSObject&gt;

@optional

/**
 session失败
 */
- (void)session:(ARSession *)session didFailWithError:(NSError *)error;

/**
相机改变追踪状态
 */
- (void)session:(ARSession *)session cameraDidChangeTrackingState:(ARCamera *)camera;

/**
 session意外断开（如果开启ARSession之后，APP退到后台就有可能导致会话断开）
 */
- (void)sessionWasInterrupted:(ARSession *)session;

/**
session会话断开恢复（短时间退到后台再进入APP会自动恢复）
 */
- (void)sessionInterruptionEnded:(ARSession *)session;

@end

#pragma mark - ARSessionDelegate



@protocol ARSessionDelegate &lt;ARSessionObserver&gt;

@optional

/**
 更新相机位置
 */
- (void)session:(ARSession *)session didUpdateFrame:(ARFrame *)frame;

/**
添加锚点
 */
- (void)session:(ARSession *)session didAddAnchors:(NSArray&lt;ARAnchor*&gt;*)anchors;

/**
刷新锚点
 */
- (void)session:(ARSession *)session didUpdateAnchors:(NSArray&lt;ARAnchor*&gt;*)anchors;

/**
移除锚点
 */
- (void)session:(ARSession *)session didRemoveAnchors:(NSArray&lt;ARAnchor*&gt;*)anchors;

@end

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARSCNView]]></title>
    <link href="https://acefish.github.io/15082316038998.html"/>
    <updated>2017-10-17T17:13:23+08:00</updated>
    <id>https://acefish.github.io/15082316038998.html</id>
    <content type="html"><![CDATA[
<p>用于3DAR场景的视图</p>

<ul>
<li>在视图中渲染设备摄像头的实时视频流，并就其设置为 3D 场景的背景</li>
<li>ARKit 的 3D 坐标系会匹配 SceneKit 的 3D 坐标系，所以此视图渲染的对象会自动匹配增强后的 ARKit 世界视图</li>
<li>自动移动虚拟 SceneKit 3D 摄像头来匹配 ARKit 追踪到的 3D 位置，所以不需要再写代码连接 ARKit 移动事件与 SceneKit 3D 渲染</li>
</ul>

<pre><code class="language-objc">/**
代理
 */
@property (nonatomic, weak, nullable) id&lt;ARSCNViewDelegate&gt; delegate;

/**
AR会话
 */
@property (nonatomic, strong) ARSession *session;

/**
场景
 */
@property(nonatomic, strong) SCNScene *scene;

/**
是否自动适应灯光
 */
@property(nonatomic) BOOL automaticallyUpdatesLighting;

/**
返回对应节点的锚点，节点是一个3D虚拟物体，它的坐标是虚拟场景中的坐标，而锚点ARAnchor是ARKit中现实世界的坐标。
 */
- (nullable ARAnchor *)anchorForNode:(SCNNode *)node;

/**
返回对应锚点的物体
 */
- (nullable SCNNode *)nodeForAnchor:(ARAnchor *)anchor;

/**
根据2D坐标点搜索3D模型，这个方法通常用于，当我们在手机屏幕点击某一个点的时候，可以捕捉到这一个点所在的3D模型的位置，至于为什么是一个数组非常好理解。手机屏幕一个是长方形，这是一个二维空间。而相机捕捉到的是一个由这个二维空间射出去的长方体，我们点击屏幕一个点可以理解为在这个长方体的边缘射出一条线，这一条线上可能会有多个3D物体模型
point：2D坐标点（手机屏幕某一点）
ARHitTestResultType：捕捉类型  点还是面
(NSArray&lt;ARHitTestResult *&gt; *)：追踪结果数组  详情见本章节ARHitTestResult类介绍
数组的结果排序是由近到远
 */
- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;

@end

//代理
#pragma mark - ARSCNViewDelegate


//代理的内部实现了SCNSceneRendererDelegate：scenekit代理 和ARSessionObserver：ARSession监听（KVO机制）
@protocol ARSCNViewDelegate &lt;SCNSceneRendererDelegate, ARSessionObserver&gt;
@optional

/**
自定义节点的锚点
 */
- (nullable SCNNode *)renderer:(id &lt;SCNSceneRenderer&gt;)renderer nodeForAnchor:(ARAnchor *)anchor;

/**
当添加节点是会调用，我们可以通过这个代理方法得知我们添加一个虚拟物体到AR场景下的锚点（AR现实世界中的坐标）
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

/**
将要刷新节点
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer willUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

/**
 已经刷新节点
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

/**
 移除节点
 */
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didRemoveNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARKit框架API简介]]></title>
    <link href="https://acefish.github.io/15082286345415.html"/>
    <updated>2017-10-17T16:23:54+08:00</updated>
    <id>https://acefish.github.io/15082286345415.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ARAnchor</h2>

<p>物体的3D锚点,表示物体在3D空间的位置和方向</p>

<pre><code class="language-objc">/**
 标识符
 */
@property (nonatomic, readonly) NSUUID *identifier;

/**
 锚点的旋转变换矩阵，定义了锚点的旋转、位置、缩放。是一个4x4的矩阵（读者可以自行科普什么叫4x4矩阵）
 */
@property (nonatomic, readonly) matrix_float4x4 transform;

/**
 构造方法,一般我们无需构造。因为添加一个3D物体时ARKit会有代理告知我们物体的锚点
 */
- (instancetype)initWithTransform:(matrix_float4x4)transform;
</code></pre>

<h2 id="toc_1">ARFrame</h2>

<p>主要用于追踪相机的当前状态,包括位置、图像帧以及时间等参数</p>

<pre><code class="language-objc">/**
时间戳.
 */
@property (nonatomic, readonly) NSTimeInterval timestamp;

/**
 缓冲区图像帧
 */
@property (nonatomic, readonly) CVPixelBufferRef capturedImage;

/**
相机（表示这个ARFrame是哪一个相机的，iPhone7plus有两个摄像机）
 */
@property (nonatomic, copy, readonly) ARCamera *camera;

/**
 返回当前相机捕捉到的锚点数据（当一个3D虚拟模型加入到ARKit中时，锚点值得就是这个模型在AR中的位置）
 */
@property (nonatomic, copy, readonly) NSArray&lt;ARAnchor *&gt; *anchors;

/**
灯光（指的是灯光强度 一般是0-2000，系统默认1000）
 */
@property (nonatomic, copy, nullable, readonly) ARLightEstimate *lightEstimate;

/**
特征点（捕捉平地或者人脸的，比较苹果有自带的人脸识别功能）
 */
@property (nonatomic, nullable, readonly) ARPointCloud *rawFeaturePoints;

/**
根据2D坐标点搜索3D模型，这个方法通常用于，当我们在手机屏幕点击某一个点的时候，可以捕捉到这一个点所在的3D模型的位置，至于为什么是一个数组非常好理解。手机屏幕一个是长方形，这是一个二维空间。而相机捕捉到的是一个由这个二维空间射出去的长方体，我们点击屏幕一个点可以理解为在这个长方体的边缘射出一条线，这一条线上可能会有多个3D物体模型
point：2D坐标点（手机屏幕某一点）
ARHitTestResultType：捕捉类型  点还是面
(NSArray&lt;ARHitTestResult *&gt; *)：追踪结果数组  详情见本章节ARHitTestResult类介绍

 */
- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;

/**
相机窗口的的坐标变换（可用于相机横竖屏的旋转适配）
 */
- (CGAffineTransform)displayTransformWithViewportSize:(CGSize)viewportSize orientation:(UIInterfaceOrientation)orientation;
</code></pre>

<h2 id="toc_2">ARHitTestResult</h2>

<p>点击的回调结果,通常用于获取ARKit的捕捉结果，获取物体到相机的距离/位置、方向等</p>

<pre><code class="language-swift">//捕捉类型枚举
typedef NS_OPTIONS(NSUInteger, ARHitTestResultType) {
    /** 点. */
    ARHitTestResultTypeFeaturePoint              = (1 &lt;&lt; 0),

    /** 水平面 y为0. */
    ARHitTestResultTypeEstimatedHorizontalPlane  = (1 &lt;&lt; 1),

    /** 已结存在的平面. */
    ARHitTestResultTypeExistingPlane             = (1 &lt;&lt; 3),

    /** 已结存在的锚点和平面. */
    ARHitTestResultTypeExistingPlaneUsingExtent  = (1 &lt;&lt; 4),
} NS_SWIFT_NAME(ARHitTestResult.ResultType);

/**
捕捉类型
 */
@property (nonatomic, readonly) ARHitTestResultType type;

/**
 3D虚拟物体与相机的距离（单位：米）
 */
@property (nonatomic, readonly) CGFloat distance;

/**
本地坐标矩阵（世界坐标指的是相机为场景原点的坐标，而每一个3D物体自身有一个场景，本地坐标就是相对于这个场景的坐标）类似于frame和bounds的区别
 */
@property (nonatomic, readonly) matrix_float4x4 localTransform;

/**
世界坐标矩阵
 */
@property (nonatomic, readonly) matrix_float4x4 worldTransform;

/**
 锚点（3D虚拟物体，在虚拟世界有一个位置，这个位置参数是SceneKit中的SCNVector3：三维矢量），而锚点anchor是这个物体在AR现实场景中的位置，是一个4x4的矩阵
 */
@property (nonatomic, strong, nullable, readonly) ARAnchor *anchor;

</code></pre>

<h2 id="toc_3">ARLightEstimate</h2>

<p>灯光效果</p>

<pre><code class="language-swift">/**
灯光强度  范围0-2000 默认1000
 */
@property (nonatomic, readonly) CGFloat ambientIntensity;

</code></pre>

<h2 id="toc_4">ARPlaneAnchor</h2>

<p>平面锚点,是<code>ARAnchor</code>的子类,<code>ARKit</code>可以自动识别平面并且添加一个锚点到场景中</p>

<p>所有被检测到的表面都会关联到一个<code>ARPlaneAnchor</code>对象，并可进一步使用提供物体到镜头的距离、位置和方向的<code>ARHitTestResult</code>进行描述。<code>ARPlaneAnchor</code>是<code>ARAnchor</code>的一个子类实例，可添加到AR场景中，实现在场景中放置虚拟物体。</p>

<pre><code class="language-swift">/**
平面类型，目前只有一个，就是水平面
 */
@property (nonatomic, readonly) ARPlaneAnchorAlignment alignment;

/**
3轴矢量结构体，表示平地的中心点  x/y/z
 */
@property (nonatomic, readonly) vector_float3 center;

/**
3轴矢量结构体，表示平地的大小（宽度和高度）  x/y/z
 */
@property (nonatomic, readonly) vector_float3 extent;
</code></pre>

<h2 id="toc_5">ARPointCloud</h2>

<p>点状渲染云 主要用于渲染场景</p>

<pre><code class="language-objc">/**
 点的数量
 */
@property (nonatomic, readonly) NSUInteger count;

/**
每一个点的位置的集合（结构体带*表示的是结构体数组）
 */
@property (nonatomic, readonly) const vector_float3 *points;
</code></pre>

<h2 id="toc_6">ARConfiguration</h2>

<p>会话追踪配置，主要就是追踪相机的位置</p>

<blockquote>
<p>子类ARWorldTrackingConfiguration</p>
</blockquote>

<pre><code class="language-objc">/**
当前设备是否支持，一般A9芯片以下设备不支持
 */
@property(class, nonatomic, readonly) BOOL isSupported;

/**
会话的对齐方式，这里的对其指的是3D世界的坐标。枚举值见下方
 */
@property (nonatomic, readwrite) ARWorldAlignment worldAlignment;

typedef NS_ENUM(NSInteger, ARWorldAlignment) {
    ARWorldAlignmentGravity,//相机位置
    ARWorldAlignmentGravityAndHeading,//相机位置及方向
    ARWorldAlignmentCamera//相机方向
} 

/**
是否需要自适应灯光效果，默认是YES
 */
@property (nonatomic, readwrite, getter=isLightEstimationEnabled) BOOL lightEstimationEnabled;

@end


//世界会话追踪配置，苹果建议我们使用这个类，这个子类只有一个属性，也就是可以帮助我们追踪相机捕捉到的平地
@interface ARWorldTrackingSessionConfiguration : ARSessionConfiguration

/**
侦查类型。枚举值见下方（默认侦查平地）
 */
@property (nonatomic, readwrite) ARPlaneDetection planeDetection;
</code></pre>

<h2 id="toc_7">ARError</h2>

<p>描述ARKit中的错误信息</p>

<pre><code class="language-swift">//作用域，一般会表示是哪一个类出现问题
NSString *const ARErrorDomain;
typedef NS_ERROR_ENUM(ARErrorDomain, ARErrorCode) {
    /** Unsupported session configuration. */
    ARErrorCodeUnsupportedConfiguration   = 100,//不支持会话追踪配置，由于A9芯片以下的机型会报错

    /** A sensor required to run the session is not available. */
    ARErrorCodeSensorUnavailable          = 101,//失活状态

    /** A sensor failed to provide the required input. */
    ARErrorCodeSensorFailed               = 102,//传感器故障

    /** World tracking has encountered a fatal error. */
    ARErrorCodeWorldTrackingFailed        = 200,//追踪失败
};

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SceneKit]]></title>
    <link href="https://acefish.github.io/15077240642559.html"/>
    <updated>2017-10-11T20:14:24+08:00</updated>
    <id>https://acefish.github.io/15077240642559.html</id>
    <content type="html"><![CDATA[
<p>我们通过<code>ARKit</code>的相机(<code>ARCamera</code>)捕获现实世界图像,利用<code>SceneKit</code>来在图像中展示3D模型</p>

<h2 id="toc_0">SceneKit中常用类及作用</h2>

<ul>
<li><strong>ARCamera</strong>:用于捕获摄像头画面</li>
<li><strong>ARSCNView</strong>:视图类用于展示由摄像头捕捉到的现实世界3D场景,继承自<code>SceneKit</code>中的<code>SCNView</code>用于展示3D场景,<code>SCNView</code>继承自<code>UIView</code>视图</li>
<li><strong>ARSession</strong>: 会话,搭建3D场景</li>
<li><strong>ARKit</strong>:用于将现实世界转为3D场景</li>
<li><strong>SceneKit</strong>:用于将虚拟物体构建在3D场景中</li>
<li><strong>SCNNode</strong>:每个虚拟物体都是一个节点,其作为主节点构成了<code>SCNScene</code>场景,无数个场景构成3D世界</li>
</ul>

<h3 id="toc_1">ARSession</h3>

<p>通过<code>ARSession</code>来沟通<code>ARSCNView</code>和<code>ARCamera</code></p>

<p>我们需要给ARSession会话指定一个<code>会话追踪设置</code>(<code>ARConfiguration</code>),用其来追踪相机在3D世界的位置特征和场景</p>

<p>苹果建议使用<code>ARWorldTrackingConfiguration</code>，该类只支持A9之后芯片</p>

<h4 id="toc_2">ARWorldTrackingConfiguration与ARFrame</h4>

<p><code>ARWorldTrackingConfiguration</code>得到手机在世界中的位置数据交给<code>ARSession</code>，而相机在的位置数据即<strong>ARFrame</strong></p>

<blockquote>
<p>用ARSession的currentFrame属性来获取当前位置信息</p>
</blockquote>

<p><img src="media/15077240642559/15078865839013.png" alt=""/></p>

<p><code>ARConfiguration</code>捕捉相机3D位置的意义就在于能够在添加3D物体模型的时候计算出3D物体模型相对于相机的真实的矩阵位置</p>

<p><code>ARKit API</code>支持两种主配置，即只追踪设备定位的<code>ARConfiguration</code>，以及进一步追踪设备位置并检测真实世界表面<code>ARWorldTrackingConfiguration</code>。</p>

<h2 id="toc_3">ARKit实战</h2>

<p>完整的ARKit环境必须需要:<br/>
ARSCNView、ARSession、ARSessionConfiguration</p>

<p>1.初始化 搭建AR环境</p>

<p>2.开启AR扫描</p>

<blockquote>
<p>苹果推荐将开启的代码写到<code>viewWillAppear</code>而不是<code>viewDidLoad</code></p>
</blockquote>

<p>3.进行自定制操作</p>

<blockquote>
<p>默认情况下，节点<code>SCNNode</code>的x/y/z位置是(0,0,0),也就是摄像头所在的位置，每一个<code>ARSession</code>在启动时，摄像头的位置就是3D世界的原点，而且这个原点不再随着摄像头的移动而改变，是第一次就永久固定的</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARKit]]></title>
    <link href="https://acefish.github.io/15077234771115.html"/>
    <updated>2017-10-11T20:04:37+08:00</updated>
    <id>https://acefish.github.io/15077234771115.html</id>
    <content type="html"><![CDATA[
<p>AR即虚拟现实增强技术</p>

<p><code>ARKit</code>是基于苹果的游戏引擎3D(SceneKit)和2D的(SpriktKit)</p>

<p>注意:需要A9处理器的的iOS11以上的系统</p>

<p>增强现实的目标是往真实世界中的特定点插入虚拟内容，并且在真实世界中移动时还能对此虚拟内容保持追踪。ARKit 的基本流程包括从 iOS 设备摄像头中读取视频帧，对每一帧的图片进行处理并获得特征点。特征有很多很多，但我们需要从图片中找出能在多个帧中都被追踪到的特征。特征可能是物体的某个角，或是有纹理的织物的某条边等等。有很多种方式可以生成这些特征，可以在网上了解更多（例如搜索 SIFT）但目前我们只需知道，每张图片里会产生多个唯一标识的特征就足够了。</p>

<p>获得某张图片的特征后，就可以从多个帧中追踪这些特征，随着用户在世界中移动，就可以利用相应的特征点来估算 3D 世界信息，例如当前摄像头的位置和特征的位置。用户移动地越多，就会获得越多的特征，并优化这些估算的 3D 世界信息。</p>

<p>至于平面检测，就是在获得一定数量的 3D 特征点后，尝试在这些点中安装一些平面，然后根据尺度、方向和位置找出最匹配的那个。ARKit 会不断分析 3D 特征点并在代码中报告找到的平面。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高级运算符]]></title>
    <link href="https://acefish.github.io/15059300219793.html"/>
    <updated>2017-09-21T01:53:41+08:00</updated>
    <id>https://acefish.github.io/15059300219793.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">位运算符</h2>

<p><code>Swift</code>支持C语言中全部位运算符</p>

<h3 id="toc_1">按位取反运算符 <code>~</code></h3>

<pre><code class="language-swift">let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits // 等于 0b11110000
</code></pre>

<h3 id="toc_2">按位与运算符 <code>&amp;</code></h3>

<h3 id="toc_3">按位或运算符 <code>|</code></h3>

<p>两个数的对应位中有任意一个为1时，返回的对应位就为1</p>

<h3 id="toc_4">按位异或运算符 <code>^</code></h3>

<p>当两个数对应位不相同时，返回1</p>

<h3 id="toc_5">按位移位运算符</h3>

<p>左移<code>&lt;&lt;</code>  右移<code>&gt;&gt;</code></p>

<p>无符号整数的移位运算是:<br/>
<strong>逻辑移位</strong>:对于移除整型存储范围的位都会被舍弃</p>

<pre><code class="language-swift">let pink: UInt32 = 0xCC6699
let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16 // redComponent 是 0xCC，即 204
let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102
let blueComponent = pink &amp; 0x0000FF // blueComponent 是 0x99，即 153
</code></pre>

<p>有符号整数的移位运算:<br/>
<strong>算术移位</strong>:当对整数进行按位右移时，对于移位产生的空白位使用符号位进行填充（逻辑移位中为0填充）,左移规则与逻辑移位相同</p>

<h2 id="toc_6">溢出运算符</h2>

<p><code>Swift</code>中的运算符默认不会溢出,溢出会被捕获并且报告为错误。</p>

<pre><code class="language-swift">var potentialOverflow = Int16.max
// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数
potentialOverflow += 1
// 这里会报错
</code></pre>

<p>我们可以选在数值溢出时采用阶段处理，而不报错：采用已出运算符(以&amp;开头)</p>

<p><code>&amp;+</code> <code>&amp;-</code> <code>&amp;*</code></p>

<blockquote>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
</blockquote>

<h2 id="toc_7">优先级和结合性</h2>

<p>注意:<br/>
<code>Swift</code>中的优先级与C语言中完全不一致</p>

<h2 id="toc_8">运算符函数</h2>

<p><em>类和结构体</em>可以为现有的运算符提供自定义实现--&gt;<strong>运算符重载</strong></p>

<pre><code class="language-swift">struct Vector2D {
    var x = 0.0, y = 0.0
}
extension Vector2D {
    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y + right.y)
    }
}
</code></pre>

<p>对于结构体<code>Vector2.0</code>，运算符函数被定义为类方法,名字与要重载的<code>+</code>一致</p>

<p>因为加法运算并不是一个向量必须的功能，因此这个类被定义在扩展而不是原结构体声明中</p>

<p>这个函数被定义为全局的,因此任意<code>Vector2D</code>示例都可以使用这个运算符:</p>

<pre><code class="language-swift">let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)
</code></pre>

<h3 id="toc_9">前缀和后缀运算符</h3>

<p>不仅加法似的中缀运算符,类和结构体也可以提供单目运算符实现</p>

<pre><code class="language-swift">extension Vector2D {
//prefix表明是前缀运算符的实现
    static prefix func - (vector: Vector2D) -&gt; Vector2D {
        return Vector2D(x: -vector.x, y: -vector.y)
    }
}

let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例
let alsoPositive = -negative
// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例
</code></pre>

<p>实现单目运算符需要用<code>prefix</code>或者<code>postfix</code>来指明前缀后后缀</p>

<h3 id="toc_10">复合赋值运算符</h3>

<p>对于复合赋值运算符例如:<code>+=</code> <code>-=</code><br/>
需要在实现时将做参数设置为<code>inout</code>类型，这样参数值可以在函数中被修改</p>

<pre><code class="language-swift">extension Vector2D {
    static func += (left: inout Vector2D, right: Vector2D) {
        left = left + right
    }
}
</code></pre>

<blockquote>
<p>不能对默认的赋值运算符<code>=</code>进行重载。只能重载组合赋值运算符，也无法对三目运算符进行重载</p>
</blockquote>

<h3 id="toc_11">等价运算符</h3>

<p>通过对自定义类或结构体进行<code>==</code>或<code>!=</code>运算符实现来判断其是否“相等”</p>

<pre><code class="language-swift">//实现方法与中缀运算符相同
extension Vector2D {
    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {
        return (left.x == right.x) &amp;&amp; (left.y == right.y)
    }
    static func != (left: Vector2D, right: Vector2D) -&gt; Bool {
        return !(left == right)
    }
}
</code></pre>

<h2 id="toc_12">自定义运算符</h2>

<p>除了实现标准运算符外还可以声明和实现<strong>自定义的运算符</strong></p>

<p>新的运算符要使用<code>operator</code>关键字在全局作用域内进行定义，同时还要指定<code>prefix</code>、<code>infix</code>或者<code>postfix</code>修饰符：</p>

<pre><code class="language-swift">prefix operator +++ {}
//定义了+++的前缀运算符  全局作用域
//这个运算符现在没有任何意义
</code></pre>

<p>我们针对<code>Vector2D</code>结构体来实现<code>+++</code>运算符</p>

<pre><code class="language-swift">extension Vector2D {
    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {
        vector += vector
        return vector
    }
}
//我们将+++实现为前面重载的运算符+=自身的值
</code></pre>

<h3 id="toc_13">自定义中缀运算符优先级</h3>

<p>每个自定义中缀运算符都属于某个优先级组。这个优先级组指定了这个运算符和其他中缀运算符的优先级和结合性</p>

<pre><code class="language-swift">//自定义中缀运算符+- 属于AdditionPrecedence优先组
infix operator +-: AdditionPrecedence

extension Vector2D {
    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
        return Vector2D(x: left.x + right.x, y: left.y - right.y)
    }
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)
</code></pre>

<p><code>AdditionPrecedence</code>优先组为<code>+</code><code>-</code>等默认的优先级组</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[访问控制]]></title>
    <link href="https://acefish.github.io/15057532270985.html"/>
    <updated>2017-09-19T00:47:07+08:00</updated>
    <id>https://acefish.github.io/15057532270985.html</id>
    <content type="html"><![CDATA[
<p><strong>访问控制：限定其他源文件或者模块代码对你的代码的访问级别</strong></p>

<ul>
<li>明确的给单个类型(类,结构体,枚举)设置访问级别</li>
<li>给类型的属性、方法、构造器、下标等设置访问级别</li>
<li>限定协议在一定范围使用，包括协议中的全局变量、常亮、函数</li>
</ul>

<p><code>Swift</code>有显式提供多种访问级别，也有为场景提供了默认的访问级别</p>

<h2 id="toc_0">模块和源文件</h2>

<p><strong><code>Swift</code>中的访问控制基于模块和源文件</strong></p>

<p><mark>模块</mark>指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用<code>import</code>关键字导入另外一个模块。<br/>
在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。</p>

<p><mark>源文件</mark>就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>

<h2 id="toc_1">访问级别</h2>

<p><code>Swift</code>提供了5种访问级别</p>

<ul>
<li><strong>开放访问和公开访问</strong>(open、public):可以访问同一模块源文件中的任何实体，在模块外也可以导入该模块来访问源文件中的所有实体。我们通常将框架中的某个借口可以被任何使用时,设置为此级别</li>
<li><strong>内部访问</strong>(internal)：可以访问同一模块源文件的任何实体，但是不能从外部访问该模块源文件中的实体。用于某借口只在应用程序或者内部使用时</li>
<li><strong>文件私有访问限制</strong>(filepart)：限值实体只能被所定义的<em>文件</em>内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
<li><strong>私有访问限值</strong>(private)： 限值实体只能在所定义的<em>作用域</em>使用,需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>
</ul>

<p>开放权限由上向下变小，开放访问级别最高,私有访问级别最低</p>

<blockquote>
<p>访问级别可以看做这块代码的作用范围</p>
</blockquote>

<p>开放访问和公开访问区别:(开放访问只作用于类类型和类的成员)</p>

<ul>
<li>公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。</li>
<li>公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。</li>
<li>开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</li>
<li>开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</li>
<li>把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</li>
</ul>

<h3 id="toc_2">访问级别基本原则</h3>

<p><strong>基本原则：不可以在某个实体中定义访问级别更低（限制更多）的实体</strong></p>

<h3 id="toc_3">默认访问级别</h3>

<p>如果不为代码中的实体指定访问级别,默认为<code>internal</code>级别。因此大多数情况下我们不需要显示指定实体的访问级别</p>

<h3 id="toc_4">单目标应用程序的访问级别</h3>

<p>对于单目标应用程序,应用的所有功能都为该应用进行服务而不需要提供给其他应用或者模块进行使用,因此使用默认的<code>internal</code>即可。也可以使用文件私有访问或者私有访问级别来进行一些功能的实现细节的隐藏</p>

<h3 id="toc_5">框架访问级别</h3>

<p>在开发框架时需要将对外的接口定义为开放访问或者公开访问级别，即API<br/>
此时仍会使用默认的内部访问级别，但是对于需要开发的API可以指定为开放访问或者公开访问级别</p>

<h3 id="toc_6">单元测试目标的访问级别</h3>

<p>当我们用单元测试目标去访问程序代码，为了访问那些非公开访问或者开发访问代码,可以在导入的应用程序模块的语句前使用<code>@testable</code>特性，然后在允许测试的编译设置<code>（Build Options -&gt; Enable Testability）</code>下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p>

<h2 id="toc_7">访问控制语法</h2>

<pre><code class="language-swift">//声明实体访问级别
public class SomePublicClass {}
internal class SomeInternalClass {}
fileprivate class SomeFilePrivateClass {}
private class SomePrivateClass {}
public var somePublicVariable = 0
internal let someInternalConstant = 0
fileprivate func someFilePrivateFunction() {}
private func somePrivateFunction() {}
//默认为内部访问级别
class SomeInternalClass {} // 隐式内部访问级别
var someInternalConstant = 0 // 隐式内部访问级别
</code></pre>

<h2 id="toc_8">自定义类型</h2>

<p>在自定义类型时指定访问的级别，然后这个类型就在访问级别限制范围内进行使用</p>

<p>定义的类型访问级别会影响到类型成员(属性、方法、构造器、下标)的默认访问级别。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。</p>

<blockquote>
<p>必须显式指定才能将成员设置为公开访问类型，避免不消息暴露内部使用接口</p>
</blockquote>

<h3 id="toc_9">元组类型</h3>

<p>定义的一个元组的访问级别由元组中访问级别最严格的类型决定，其访问级别是在使用时自动推断出的无法明确指定</p>

<h3 id="toc_10">函数类型</h3>

<p>函数的访问类型也由参数或者返回类型的访问级别决定,但是我们可以明确<em>指定函数的访问级别</em>来符合函数定义或者环境默认访问级别</p>

<pre><code class="language-swift">//定义一个全局函数
func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // 此处是函数实现部分
}
/**
    这样是无法通过编译的,这个函数返回了一个元组,元组中包含了两个自定义类，根据元组访问
    级别,元组为privite的，因此函数也为private访问级别，因此并不是默认的internal级
    别，因此需要用private修饰符明确指出函数访问级别
*/

private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // 此处是函数实现部分
}
</code></pre>

<h3 id="toc_11">枚举类型</h3>

<p>枚举成员的访问级别与枚举类型相同，不能单独指定</p>

<h4 id="toc_12">原始值和关联值</h4>

<p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。</p>

<h3 id="toc_13">嵌套类型</h3>

<p>如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>

<h2 id="toc_14">子类</h2>

<p><strong>子类的访问级别也不能高于父类</strong></p>

<p>可以通过重写为继承来的类成员(方法、属性、下标、构造器等)提供更高的访问级别</p>

<pre><code class="language-swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {}
}
//类B继承自A，重写了类A中的方法将访问级别指定为更高的访问级别
</code></pre>

<pre><code class="language-swift">public class A {
    private func someMethod() {}
}
internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
//子类中访问父类中级别更低成员（保证操作在相应访问级别的限值范围内）
</code></pre>

<h3 id="toc_15">常亮、变量、属性、下标</h3>

<p>常量、变量、属性不能有比类型（成员的定义类型）更高的访问级别，下标也不能有比索引类型或返回类型更高的访问级别</p>

<h3 id="toc_16">Getter和Setter</h3>

<p>常量、变量、属性、下标的<code>Getters</code>和<code>Setters</code>的访问级别和它们所属类型的访问级别相同</p>

<p><code>Setter</code>的访问级别可以低于<code>Getter</code>的访问级别，来控制其读写权限。可以通过添加<code>fileprivate(set)</code>、<code>private(set)</code>、<code>internal(set)</code>来为写入指定更低权限</p>

<blockquote>
<p>适用于存储型和计算型属性,对于存储性属性也会隐式创建setter和getter方法的</p>
</blockquote>

<pre><code class="language-swift">struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = &quot;&quot; {
        didSet {
            numberOfEdits += 1
        }
    }
}
//结构体类型和valew属性为默认的interal级别
//numberOfEdits的set定义为private级别,因此只能在定义该结构体的源文件中进行赋值，而访问仍为在该模块可访问的internal级别
</code></pre>

<p>此时我们在其它源文件中可以访问但是不能修改结构体的<code>numberOfEdits</code>属性</p>

<h2 id="toc_17">构造器</h2>

<p><strong>我们自定义的构造器的访问级别可以等于或低于该类型的访问级别</strong>，但是对于<code>必要构造器</code>访问级别必须和所属类型访问级别相同</p>

<h3 id="toc_18">默认构造器</h3>

<p>对于swift为结构体和类提供的默认构造器,访问级别与类型相同(当类型为public时，默认构造器的访问级别为internal)</p>

<h3 id="toc_19">结构体默认的成员逐一构造器</h3>

<p>如果结构体中任意存储型属性的访问级别为<code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是<code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>

<h2 id="toc_20">协议</h2>

<p>在定义协议时指定协议的访问级别,限值协议只能在指定范围被遵循<br/>
<strong>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别</strong></p>

<blockquote>
<p>不同于类型，对于public的协议其要求也是public级别的</p>
</blockquote>

<h3 id="toc_21">协议继承</h3>

<p>继承的新协议其访问级别不能高于被继承的协议</p>

<h3 id="toc_22">协议的一致性</h3>

<p><strong>类型可以采纳比自身访问级别更低的协议</strong><br/>
例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。</p>

<p>注意:<br/>
1. 采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别<br/>
2. 遵循协议后，要确保协议的要求的实现访问级别不能低于协议的访问级别</p>

<h2 id="toc_23">扩展</h2>

<ol>
<li>可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别</li>
<li>可以明确指定扩展的访问级别，从而给扩展中成员一个新的访问级别,但是新的默认访问级别仍会被单独指定的级别覆盖</li>
</ol>

<h3 id="toc_24">通过扩展添加协议一致性</h3>

<p>通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>

<h2 id="toc_25">泛型</h2>

<p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>

<h2 id="toc_26">类型别名</h2>

<p>每个类型别名都会被当做不同类型处理</p>

<p>类型别名的访问级别不可高于其表示的类型的访问级别</p>

<blockquote>
<p>这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况__</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[泛型]]></title>
    <link href="https://acefish.github.io/15052932669633.html"/>
    <updated>2017-09-13T17:01:06+08:00</updated>
    <id>https://acefish.github.io/15052932669633.html</id>
    <content type="html"><![CDATA[
<p><strong>泛型:</strong>根据自定义的需求，编写适用于任意类型，灵活可用的函数和类型</p>

<h2 id="toc_0">泛型函数</h2>

<p>泛型函数适用与任何类型</p>

<pre><code class="language-swift">func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>

<p>函数的泛型版本:<br/>
1）使用占位类型名来代替实际类型名(这里用字母<code>T</code>表示),这里并没有指明T必须是什么类型,而是a与b类型相同,在实际调用时才根据传入类型决定<code>T</code>所代表的类型<br/>
2）在函数名后有<code>&lt;T&gt;</code>，声明了<code>T</code>是函数内定义的占位类型名<br/>
因此，函数<code>swapTwoInts(_:_:)</code>可以接受任意相同类型的参数</p>

<h2 id="toc_1">类型参数</h2>

<p>类型参数指定并命名一个占位类型,紧随在函数名后,用尖括号括起来(如:<code>&lt;T&gt;</code>),也可以提供多个参数用逗号隔开</p>

<p>可以用指定的类型参数作为函数的参数类型或返回类型，</p>

<h2 id="toc_2">命名类型参数</h2>

<p>我们可以使用有意义的单词来表明类型参数和泛型函数关系,当没有联系时,通常使用单个字母来命名</p>

<p><strong>使用大写字母开头的驼峰命名法来为类型参数命名</strong></p>

<h2 id="toc_3">泛型类型</h2>

<p><strong>泛型类型：</strong>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型,类型于<code>Array</code>和<code>Dictionary</code></p>

<pre><code class="language-swift">//泛型 Stack（栈型） 结构体
struct Stack&lt;Element&gt; {
    var items = [Element]()
    mutating func push(item: Element) {
        items.append(item)
    }
    mutating func pop() -&gt; Element {
        return items.removeLast()
    }
}
</code></pre>

<p>使用占位类型<code>Element</code>，这个类型参数包裹在紧随结构体名的一对尖括号里（<code>&lt;Element&gt;</code>）,类型参数用来初始化数组,用来作为<code>push</code><code>pop</code>方法的参数</p>

<p><code>Stack</code>是泛型类型,可以创建任意有效类型栈<br/>
可以通过在尖括号写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例</p>

<pre><code class="language-swift">var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push(&quot;uno&quot;)
stackOfStrings.push(&quot;dos&quot;)
let fromTheTop = stackOfStrings.pop()
</code></pre>

<h2 id="toc_4">扩展泛型类型</h2>

<p>在扩展泛型类型时，不需要在扩展的定义中提供类型参数列表。可以在扩展中直接使用原始类型参数列表,并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<pre><code class="language-swift">//扩展泛型类型增加只读的计算属性
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</code></pre>

<p>返回`<code>item</code>数组的最后一个元素</p>

<p>扩展中直接使用了已有的类型参数<code>Element</code></p>

<h2 id="toc_5">类型约束</h2>

<p>给泛型函数和泛型类型添加一个特定的约束，可以指定一个类型参数必须继承自指定类，或者符合协议或协议组合</p>

<p>例如:<code>Dictionary</code>类型约束了字典中的键必须是可哈希的（符合<code>Hashable协议</code>），也就是必须有唯一的方法表示她，才能根据键进行判断</p>

<h3 id="toc_6">类型约束语法</h3>

<p>在类型参数名后放置类型或协议名用冒号隔开来进行约束，</p>

<pre><code class="language-swift">//类型约束的泛型函数
func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
</code></pre>

<p>约束T必须是SomeClass的子类，要求U必须遵循SomeProtocol的</p>

<h3 id="toc_7">类型约束实践</h3>

<p>我们新建一个泛型函数来从实现从数组中查找特定元素的功能;</p>

<pre><code class="language-swift">//从数组中查找特定自字符串的非泛型函数
func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}


//泛型类型
func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
        return index
        }
    }
    return nil
}
</code></pre>

<p>上面的泛型函数，是无法通过编译的，因为不是任何类型都可以用<code>==</code>进行比较<br/>
Swift定义了一个<code>Equatable</code>协议,所有遵守改协议的类型都必须实现<code>==或!=</code>，从而对该类型任意值进行比较</p>

<pre><code class="language-swift">//此时泛型函数可以成功编译了
func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>

<h2 id="toc_8">关联类型</h2>

<p>定义协议时，声明一个或者多个<strong>关联类型</strong>作为协议的一部分</p>

<p><strong>关联类型</strong>为协议中的的某个类型提供占位名(别名)，而其实际类型在协议被采纳时才会被指定</p>

<p>用<code>associatedtype</code>关键字指定<strong>关联类型</strong></p>

<pre><code class="language-swift">protocol Container {
    associatedtype ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>

<p>在协议中声明了一个关联类型<code>ItemType</code>,来保证在不知道容器中元素的具体类型情况下行为能够正确执行</p>

<pre><code class="language-swift">//定义类型遵循Contain协议
Struct IntStack: Container {
    // IntStack 的原始实现部分
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // Container 协议的实现部分
    typealias ItemType = Int//可以省略，swift会根据协议的实现推断出类型
        mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}

</code></pre>

<p>在实现协议时需要用<code>typealias ItemType = Int</code>来转换协议中的关联类型<br/>
当然，这个是可以省略的，Swift可以根据方法推断出<code>ItemType</code>类型</p>

<h3 id="toc_9">扩展存在的类型来指定关联类型</h3>

<p>对于Contain协议，Swift中的Array已经默认提供了协议中要求，因此我们只需要声明Array遵循该协议就可以扩展<code>Array</code></p>

<pre><code class="language-Swift">//我们只需要扩展Array来使其遵循该协议即可
extension Array: Container {}
</code></pre>

<h2 id="toc_10">泛型Where语句</h2>

<p><strong>泛型Where语句</strong>用于为关联类型定义约束，比如要求其必须遵循特定协议，以及特定类型参数和关联类型必须相同</p>

<p>在函数体或者类型的大括号前添加<code>Where</code>子句</p>

<pre><code class="language-swift">func allItemsMatch&lt;C1: Container, C2: Container&gt;
(_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {
        // 检查两个容器含有相同数量的元素
        if someContainer.count != anotherContainer.count {
            return false
        }
        // 检查每一对元素是否相等
        for i in 0..&lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
            return false
        }
    }
    // 所有元素都匹配，返回 true
    return true
}
</code></pre>

<p>用<code>类型约束</code>约束类型参数:C1、C2必须符合<code>Contain</code>协议<br/>
用<code>泛型Where语句</code>约束关联类型:C1和C2必须类型相同,并且C1符合<code>Equatable</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[协议]]></title>
    <link href="https://acefish.github.io/15047511695312.html"/>
    <updated>2017-09-07T10:26:09+08:00</updated>
    <id>https://acefish.github.io/15047511695312.html</id>
    <content type="html"><![CDATA[
<p>类和结构体、枚举都可以遵循协议,并为协议定义的这些要求提供实现<br/>
除了遵循协议的类型必须实现外还可以对协议进行扩展，通过扩展来实现一部分要求或者添加附加功能</p>

<h2 id="toc_0">协议语法</h2>

<p>协议的定义:</p>

<pre><code class="language-swift">protocol SomeProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<p>自定义类型遵循某个协议,定义类型时,可以在类型名称后加上协议名称,中间用<code>:</code>分割,多个协议之间用<code>,</code>分割</p>

<pre><code class="language-swift">struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 这里是结构体的定义部分
}
</code></pre>

<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>

<pre><code class="language-swift">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 这里是类的定义部分
}
</code></pre>

<h2 id="toc_1">属性要求</h2>

<p>协议可以指定遵循协议的类型提供特定名称或属性的实例属性或类型属性。它只指定类型名称和属性而不能指定属性是存储型的还是计算型的,此外，还可以指定属性是可读的还是可写的</p>

<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的</p>

<p>协议总是用<code>var</code>关键字来声明变量属性，在类型声明后加上<code>{ set get }</code>来表示属性是可读可写的，可读属性则用<code>{ get }</code>来表示</p>

<pre><code class="language-swift">protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>

<p>在协议中定义类型属性时，使用<code>static</code>关键字作为前缀。当类类型遵循协议时,除了<code>static</code>关键字,还可以使用<code>class</code>关键字声明类型属性:</p>

<pre><code class="language-swift">protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</code></pre>

<h2 id="toc_2">方法要求</h2>

<p>遵循协议的类型实现某些指定的实例方法或类方法</p>

<ul>
<li>方法像普通方法一样放在协议的定义中,但是不需要大括号和方法体</li>
<li>与普通方法类似可以在方法中提供可变参数,但是不能为参数提供默认值</li>
<li>在协议中定义类方法时，总是使用<code>static</code>关键字为前缀.当类类型遵循协议时，除了<code>static</code>关键字，还可以使用<code>class</code>关键字作为前缀</li>
</ul>

<pre><code class="language-swift">protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>

<pre><code class="language-swift">class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
</code></pre>

<h2 id="toc_3">Mutating方法要求</h2>

<p>如果在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加<code>mutating</code>关键字,使得结构体和枚举能够遵循此协议并满足方法要求</p>

<blockquote>
<p>在实现协议的<code>mutating</code>方法时，若是类类型则不用写<code>mutating</code>关键字，而若是结构体或枚举必须写<code>mutating</code>关键字</p>
</blockquote>

<pre><code class="language-swift">protocol Togglable {
    mutating func toggle()
}

//定义在两种状态间切换的枚举
enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
</code></pre>

<h2 id="toc_4">构造器要求</h2>

<p><strong>协议可以要求遵循协议的类型实现指定的构造器</strong></p>

<pre><code class="language-swift">protocol SomeProtocol {
    init(someParameter: Int)
}
</code></pre>

<h3 id="toc_5">构造器要求在类中的实现</h3>

<p>遵循协议的类实现构造器.不论指定构造器或者便利构造器都必须在实现加上<code>required</code>修饰符</p>

<pre><code class="language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<p>使用<code>required</code>修饰符可以确保所有子类也必须提供此构造器实现，即符合协议</p>

<p>注意:</p>

<blockquote>
<p>如果类被标记为<code>final</code>，就不需要在协议构造器中使用<code>required</code>修饰符,因为<code>final</code>类不会有子类</p>
</blockquote>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求,那么重写上需要同时加上<code>required</code>和<code>override</code>修饰符</p>

<pre><code class="language-swift">protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // 这里是构造器的实现部分
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为遵循协议，需要加上 required
    // 因为继承自父类，需要加上 override
    required override init() {
        // 这里是构造器的实现部分
    }
}
</code></pre>

<h3 id="toc_6">可失败构造器要求</h3>

<p>协议还可以为遵循协议的类型定义可失败构造器要求</p>

<p>遵循协议的类型可以通过可失败构造器<code>（init?）</code>或非可失败构造器<code>（init）</code>来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器<code>（init</code>或隐式解包可失败构造器<code>（init!）</code>来满足</p>

<h2 id="toc_7">协议作为类型</h2>

<p>协议可以作为成熟的类型来使用:</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>

<p>协议作为一种类型,因此与它类型的命名写法相同 应该使用驼峰写法</p>

<pre><code class="language-swift">class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
</code></pre>

<p>类<code>Dice</code>中含有属性<code>generator</code>为<code>RandomNumberGenerator</code>协议类型,因此遵循了<code>RandomNumberGenerator</code>协议类型的实例都可以赋值给<code>generator</code></p>

<p>在类中有<code>roll</code>的实例方法,调用<code>generator</code>的<code>random()</code>方法来生成一个<code>[0.0,1.0)</code>区间内的随机数</p>

<h2 id="toc_8">委托（代理）模式</h2>

<hr/>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例.<br/>
委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。<br/>
委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型</p>

<hr/>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>我们可以通过扩展代码来为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中相应要求</p>

<blockquote>
<p>通过扩展使已有类型遵循并符合协议时,该类型的所有实例也会获得协议中定义的各项功能</p>
</blockquote>

<pre><code class="language-swift">protocol TextRepresentable {
    var textualDescription: String { get }
}

extension Dice: TextRepresentable {
    var textualDescription: String {
        return &quot;A \(sides)-sided dice&quot;
    }
}
</code></pre>

<p>扩展来遵循并符合协议与原始定义中效果相同</p>

<h2 id="toc_10">通过扩展遵循协议</h2>

<pre><code class="language-swift">struct Hamster {
    var name: String
    var textualDescription: String {
        return &quot;A hamster named \(name)&quot;
    }
}

extension Hamster: TextRepresentable {}
</code></pre>

<h2 id="toc_11">协议类型的集合</h2>

<p>协议类型可以在数组或字典这样的集合使用</p>

<p><code>let things: [TextRepresentable] = [game, d12, simonTheHamster]</code></p>

<h2 id="toc_12">协议的继承</h2>

<p>协议可以继承一个或多个其他协议,可以在继承协议基础上增加新的要求.协议继承与发与类相似,多个协议用逗号分割：</p>

<pre><code class="language-swift">protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 这里是协议的定义部分
}
</code></pre>

<h2 id="toc_13">类类型专属协议</h2>

<p>在协议的继承列表中，通过添加<code>class</code>关键字来限制协议只能被类类型遵循，而值类型如枚举和结构体不能遵循该协议</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<p><code>class</code>关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前</p>

<h2 id="toc_14">协议合成</h2>

<p>同时遵循多个协议时,可以将多个协议采用<code>SomeProtocol &amp; AnotherProtocol</code>的格式进行组合,即<strong>协议合成</strong></p>

<pre><code class="language-swift">protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}

func wishHappyBirthday(to celebrator: Named &amp; Aged) {
    print(&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;)
}

let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
wishHappyBirthday(to: birthdayPerson)// “Happy birthday Malcolm - you&#39;re 21!”
</code></pre>

<blockquote>
<p>协议合成并不是生成一个新的、永久的协议</p>
</blockquote>

<h2 id="toc_15">检查协议一致性</h2>

<p>使用<code>is</code>和<code>as</code>检查协议的一致性,即是否符合某协议，并且可以转换到指定的协议类型,与类型检查和转换用法相同:</p>

<ul>
<li><code>is</code>用来检查实例是否符合某个协议，若符合则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>as?</code>返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回<code>nil</code></li>
<li><code>as!</code>将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误</li>
</ul>

<pre><code class="language-swift">protocol HasArea {
    var area: Double { get }
}

for object in objects {
    if let objectWithArea = object as? HasArea {
        print(&quot;Area is \(objectWithArea.area)&quot;)
    } else {
        print(&quot;Something that doesn&#39;t have an area&quot;)
    }
}
</code></pre>

<p>判断元素是否符合<code>HasArea</code>协议后将<code>as?</code>操作符通过可选绑定，绑定到<code>objectWithArea</code>常量上进行访问</p>

<blockquote>
<p>在数据中的元素类型并不会因为强转而丢失类型信息,只是在被赋值为<code>objectWithArea</code>时，被视为<code>HasArea</code>类型，因此只有<code>area</code>属性可以被访问</p>
</blockquote>

<h2 id="toc_16">可选的协议要求</h2>

<p>协议可以被定义为可选的，用<code>option</code>关键字作为前缀来标记可选要求<br/>
可选要求用在你需要和<code>Objective-C</code>打交道的代码中<br/>
协议和可选要求都必须带上<code>@objc</code>属性<br/>
标记<code>@objc</code>特性的协议只能被继承自<code>Objective-C</code>类的类或者<code>@objc</code>类遵循，其他类以及结构体和枚举均不能遵循这种协议</p>

<p>当使用可选要求时，协议中的可选的方法或属性会自动变成可选的（函数的话整个函数类型是可选的而不是函数的返回值）</p>

<pre><code class="language-swift">@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&gt; Int
    optional var fixedIncrement: Int { get }
}
</code></pre>

<pre><code class="language-swift">class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
    //此处无法确定是否存在dataSource 以及 datasource是否遵循了协议 因此需要两层的可选链式调用
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</code></pre>

<p>通过可选链式调用可选协议</p>

<p><code>CounterDataSource</code>的简单实现</p>

<pre><code class="language-swift">//继承自OC的NSObject
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

//@objc类
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func increment(forCount count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>

<h2 id="toc_17">协议扩展</h2>

<p>通过扩展来为遵循协议的类型提供属性、方法以及下标的&quot;实现&quot;.这样可以基于协议本身实现这些功能,而不需要给每个遵循协议的类型进行重复的实现或者使用全局函数</p>

<pre><code class="language-swift">//定义一个协议
protocol RandomNumberGenerator {
    func random() -&gt; Double
}
//为协议进行协议扩展
extension RandomNumberGenerator {
    func randomBool() -&gt; Bool {
        return random() &gt; 0.5
    }
}
</code></pre>

<p>所有遵循该协议的类型 都能获得扩展所增加的方法实现</p>

<h3 id="toc_18">提供默认实现</h3>

<p>可以通过协议扩展来为协议中的的要求提供默认实现，如果遵循该协议的类型提供了自己的实现,那么自定义实现会代替扩展中的默认实现</p>

<h3 id="toc_19">为协议扩展添加限制条件</h3>

<p>在协议扩展的时候条件一些限制条件,只有遵循协议的类型满足这些条件的时候才能获取协议扩展提供的默认实现</p>

<p>将这些限制条件写在协议名字之后,并且使用<code>where</code>字句描述</p>

<pre><code class="language-swift">/**
扩展CollectionType协议,但是只适用于集合中的元素遵循`TextRepresentable`协议的情况
*/
extension CollectionType where Generator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return &quot;[&quot; + itemsAsText.joinWithSeparator(&quot;, &quot;) + &quot;]&quot;
    }
}
</code></pre>

<p>因此需要一个集合类型的遵循CollectionType协议,而且其中的每个元素都遵循TextRepresentable协议<br/>
这样的话这个集合就默认有扩展协议的默认实现</p>

<blockquote>
<p>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展]]></title>
    <link href="https://acefish.github.io/15042587690391.html"/>
    <updated>2017-09-01T17:39:29+08:00</updated>
    <id>https://acefish.github.io/15042587690391.html</id>
    <content type="html"><![CDATA[
<p><strong>扩展</strong>就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能</p>

<blockquote>
<p>类似OC中的分类功能,但是Swift中的分类没有名字</p>
</blockquote>

<p><strong>Swift中的扩展可功能</strong>:</p>

<ul>
<li>添加计算型属性和计算类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议
还可以对协议进行扩展、提供协议要求的实现，添加额外的功能，让符合协议的类型拥有这些功能</li>
</ul>

<blockquote>
<p>扩展只能添加新的功能不能重写已有功能</p>
</blockquote>

<h2 id="toc_0">扩展语法</h2>

<p>用关键字<code>extension</code>声明扩展:</p>

<pre><code class="language-swift">extension SomeType {
    // 为 SomeType 添加的新功能写到这里
}
</code></pre>

<p>扩展一个已有类型,使其采纳一个或多个协议</p>

<pre><code class="language-swift">extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>

<blockquote>
<p>扩展一个已有实例的新功能,那么新功能对该类型所有实例都可用，不论创建时间</p>
</blockquote>

<h2 id="toc_1">计算型属性</h2>

<pre><code class="language-swift">extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print(&quot;One inch is \(oneInch) meters&quot;)
    // 打印 “One inch is 0.0254 meters”
let threeFeet = 3.ft
print(&quot;Three feet is \(threeFeet) meters&quot;)
    // 打印 “Three feet is 0.914399970739201 meters”
</code></pre>

<p>扩展<code>Double</code>类型,增加计算型属性,实现距离转换<br/>
上面的属性是只读的计算型属性,省略了<code>get</code>关键字</p>

<blockquote>
<p>可以增加新的计算型属性,但是不能增加存储型属性，也不能为已有属性添加属性观察器</p>
</blockquote>

<h2 id="toc_2">构造器</h2>

<p>扩展可以为已有类型添加新的构造器。<br/>
扩展能为类添加新的便利构造器,但是不能为类添加新的指定构造器或者析构器</p>

<blockquote>
<p>如果使用扩展为一个“值类型”添加构造器,同时该值类型的原始实现没有定义定制构造器,且所有存储属性提供了默认值,我们可以在扩展的构造器中调用默认构造器和逐一成员构造器(当原始实现中有定制的构造器,就不能调用了)</p>
</blockquote>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>因为<code>Rect</code>没有指定构造器,存储属性也都有默认值,因此获得一个逐一成员构造器和默认构造器，</p>

<pre><code class="language-swift">extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        //调用结构体的逐一成员构造器
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<h2 id="toc_3">方法</h2>

<p>为已有类型添加新的实例方法和类型方法</p>

<pre><code class="language-swift">extension Int {
    func repetitions(task: () -&gt; Void) {
        for _ in 0..&lt;self {
            task()
        }
    }
}
//为Int类型添加一个名为`repetitions`的实例方法
//这个方法接受一个`()-&gt;Void`类型的单参数，没有参数也没有返回值的函数
</code></pre>

<h3 id="toc_4">可变实例方法</h3>

<p>扩展中添加的实例方法也可以修改该实例本身，对于值类型即结构体或者枚举修改<code>self</code>或其属性的方法就必须将该实例方法标注为<code>mutating</code>(类似原始实现)</p>

<pre><code class="language-swift">extension Int {
    mutating func square() {
        self = self * self
    }
}
</code></pre>

<h2 id="toc_5">下标</h2>

<p>扩展为已有类型添加下标.</p>

<pre><code class="language-swift">extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
        for _ in 0..&lt;digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// 返回 5
746381295[1]
// 返回 9
//取的下标越界时自动用0补充
746381295[9]
// 返回 0，即等同于：
0746381295[9]
</code></pre>

<p>上面的例子为<code>Int</code>增加下标方法，<code>[n]</code>返回十进制数字从右向左数的第<code>n</code>个数字</p>

<h2 id="toc_6">嵌套类型</h2>

<p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型:</p>

<pre><code class="language-swift">extension Int {
    enum Kind {
    case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
</code></pre>

<p>为<code>Int</code>添加了一个嵌套枚举,来表明特定整数的类型，即正数、负数或零</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌套类型]]></title>
    <link href="https://acefish.github.io/15042543172572.html"/>
    <updated>2017-09-01T16:25:17+08:00</updated>
    <id>https://acefish.github.io/15042543172572.html</id>
    <content type="html"><![CDATA[
<p><strong>嵌套类型:</strong>在支持的类型中定义嵌套的枚举、类和结构体</p>

<p>要在一个类型中嵌套另一个类型,将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套</p>

<h2 id="toc_0">嵌套类型实践</h2>

<pre><code class="language-swift">struct BlackjackCard {
    //嵌套的 Suit 枚举//牌的花色
    enum Suit: Character {
        case Spades = &quot;块&quot;, Hearts = &quot;心&quot;, Diamonds = &quot;*&quot;, Clubs = &quot;额&quot;
    }
    //嵌套的 Rank 枚举
    enum Rank: Int {
        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
        case Jack, Queen, King, Ace
        struct Values {//用于反应Ace有两种值，而其他只有一个
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
                case .Ace:
                    return Values(first: 1, second: 11)
                case .Jack, .Queen, .King:
                    return Values(first: 10, second: nil)
                default:
                    return Values(first: self.rawValue, second: nil)
            }
        }
    }
    // BlackjackCard 的属性和方法
    let rank: Rank, suit: Suit
    var description: String {
        var output = &quot;suit is \(suit.rawValue),&quot;
        output += &quot; value is \(rank.values.first)&quot;
        if let second = rank.values.second {
            output += &quot; or \(second)&quot;
        }
        return output
    }
}
</code></pre>

<p><code>BlackjackCard</code>结构体有默认的成员构造器,可以用默认构造器去初始化常量:</p>

<pre><code class="language-swift">/**
尽管Rank和Suit嵌套在BlackjackCard中,类型可以从上下文推断出来,
因此可以用`.Ace 和.Spades`引用枚举实例
*/
let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)
// 打印 “theAceOfSpades: suit is ?, value is 1 or 11”
</code></pre>

<h2 id="toc_1">引用嵌套类型</h2>

<p>在嵌套类型的类型名前加上外部类型的类型名作为前缀:</p>

<pre><code class="language-swift">let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
//红心符号
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型转换]]></title>
    <link href="https://acefish.github.io/15037348375137.html"/>
    <updated>2017-08-26T16:07:17+08:00</updated>
    <id>https://acefish.github.io/15037348375137.html</id>
    <content type="html"><![CDATA[
<p>在<code>Swift</code>中通过<code>is</code>和<code>as</code>操作符来实现<strong>类型转换</strong>，可以来检查值的类型或者转换类型<br/>
可以用它检查一个类型是否实现了某个协议</p>

<h2 id="toc_0">定义一个类层次作为例子</h2>

<p>在数组中存了一个父类的两个子类的实例</p>

<blockquote>
<p>在数组中存在两种子类类型,会推断这个数组为共同的父类类型<br/>
此时虽然数组中存的是子类类型实例,但是迭代的话取出的实例会为父类类型，此时我们需要判断和转换类型</p>
</blockquote>

<h2 id="toc_1">检查类型</h2>

<p>用类型检查操作符<code>is</code> 检查实例是否属于特定子类型，返回<code>bool</code>值</p>

<pre><code class="language-swift">for item in library {
    if item is Movie { //判断实例是否为 Movie类型
        movieCount += 1
    } else if item is Song { //判断实例是否为 Song类型
        songCount += 1
    }
}
</code></pre>

<h2 id="toc_2">向下转型</h2>

<p>当某类型的实例属于一个子类,可以用<code>as?</code>或者<code>as!</code>将其向下转换位子类类型</p>

<p>因为向下转型可能失败，因此提供<code>as?</code>和<code>as!</code>(带上强制解包)，当不确定是否成功时用<code>as?</code> 确定一定成功时<code>as!</code></p>

<pre><code class="language-swift">for item in library {
    if let movie = item as? Movie {
        print(&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    } else if let song = item as? Song {
        print(&quot;Song: &#39;\(song.name)&#39;, by \(song.artist)&quot;)
    }
}
</code></pre>

<p><code>if let movie = item as? Movie</code>尝试将<code>item</code>转为<code>Movie</code>类型。若成功，设置一个新的临时常量<code>movie</code>来存储返回的可选<code>Movie</code>中的值</p>

<h2 id="toc_3">Any和AnyObject的类型转换</h2>

<p>不确定类型的表达方式:<br/>
<code>Any</code>可以表示任何类型，包括函数类型。<br/>
<code>AnyObject</code>可以表示任何类类型的实例</p>

<p>建议只在确定需要使用时才使用<code>Any</code>和<code>AnyObject</code></p>

<pre><code class="language-swift">var things = [Any]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append(&quot;hello&quot;)
things.append((3.0, 5.0))
things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;))
things.append({ (name: String) -&gt; String in &quot;Hello, \(name)&quot; })
</code></pre>

<p>然后我们可以在<code>switch</code>表达式的</p>

<pre><code class="language-swift">for thing in things {
    switch thing {
    case 0 as Int:
        print(&quot;zero as an Int&quot;)
    case 0 as Double:
        print(&quot;zero as a Double&quot;)
    case let someInt as Int:
        print(&quot;an integer value of \(someInt)&quot;)
    case let someDouble as Double where someDouble &gt; 0:
        print(&quot;a positive double value of \(someDouble)&quot;)
    case is Double:
        print(&quot;some other double value that I don&#39;t want to print&quot;)
    case let someString as String:
        print(&quot;a string value of \&quot;\(someString)\&quot;&quot;)
    case let (x, y) as (Double, Double):
        print(&quot;an (x, y) point at \(x), \(y)&quot;)
    case let movie as Movie:
        print(&quot;a movie called &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    case let stringConverter as String -&gt; String:
        print(stringConverter(&quot;Michael&quot;))
    default:
        print(&quot;something else&quot;)
    }
}
// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of &quot;hello&quot;
// an (x, y) point at 3.0, 5.0
// a movie called &#39;Ghostbusters&#39;, dir. Ivan Reitman
// Hello, Michael
</code></pre>

<blockquote>
<p><code>Any</code>是可以表示所有类型的值,包括可选类型,当你在用<code>Any</code>类型来表示一个可选值时,会给出警告，此时可以用<code>as</code>操作符显示转换为<code>Any</code></p>
</blockquote>

<pre><code>let optionalNumber: Int? = 3
things.append(optionalNumber) // 会有警告
things.append(optionalNumber as Any) // 没有警告
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[错误处理]]></title>
    <link href="https://acefish.github.io/15034731740974.html"/>
    <updated>2017-08-23T15:26:14+08:00</updated>
    <id>https://acefish.github.io/15034731740974.html</id>
    <content type="html"><![CDATA[
<p><strong>错误处理</strong>就是响应错误以及从错误中回复的过程</p>

<p><code>Swift</code>提供了运行时对可恢复错误的抛出、捕获、传递和操作等的支持<br/>
通常用来区分失败情况,让程序解决并处理某些错误，把解决不了的错误报告给用户</p>

<h2 id="toc_0">表示并抛出错误</h2>

<p><code>Swift</code>中 错误用符合<code>Error</code>协议的类型值来表示，这个空协议表明该类型可以用于错误处理</p>

<p>通常用枚举类型来构建一组相关的错误状态,枚举的关联值可以提供错误状态的额外信息</p>

<p>使用关键字<code>throw</code>关键字来抛出一个错误，表示有意外发生</p>

<pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection //选择无效
    case insufficientFunds(coinsNeeded: Int) //金额不足
    case outOfStock //缺货
}

throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre>

<h2 id="toc_1">处理错误</h2>

<p><code>Swift</code>中有<code>4</code>种处理错误的方式<br/>
1.把函数抛出的错误传递给调用此函数的代码<br/>
2.用<code>do-catch</code>语句处理错误<br/>
3.将错误作为可选类型处理<br/>
4.断言此错误根本不会发生</p>

<p>我们在调用一个能抛出错误的函数、方法或者构造器之前，用<code>try</code>关键字或者<code>try?</code><code>try!</code>这种变体关键字</p>

<blockquote>
<p>与其他语言的<code>try</code>，<code>catch</code>和<code>throw</code>不同的是<code>swift</code>的错误挫力不涉及解除调用栈,因此其性能特性是可以和<code>return</code>语句相媲美的</p>
</blockquote>

<h3 id="toc_2">用throwing函数传递错误</h3>

<p>在函数声明的参数列表后加上<code>throws</code>关键字，表明可以抛出错误，这个函数就称为<code>throwing</code>函数<br/>
如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面</p>

<pre><code class="language-swift">func canThrowErrors() throws -&gt; String
func cannotThrowErrors() -&gt; String
</code></pre>

<p><strong><code>throwing</code>函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</strong></p>

<blockquote>
<p>对于<code>throwing</code>函数可以传递错误,非<code>throwing</code>函数抛出的错误只能在函数内部处理</p>
</blockquote>

<pre><code class="language-swift">struct Item {
    var price: Int
    var count: Int
}
class VendingMachine {
    var inventory = [
                     &quot;Candy Bar&quot;: Item(price: 12, count: 7),
                     &quot;Chips&quot;: Item(price: 10, count: 4),
                     &quot;Pretzels&quot;: Item(price: 7, count: 11)
                     ]
    var coinsDeposited = 0
    func dispenseSnack(snack: String) {
        print(&quot;Dispensing \(snack)&quot;)
    }
    //throwing函数 会抛出VendingMachineError错误
    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.InvalidSelection
        }
        guard item.count &gt; 0 else {
            throw VendingMachineError.OutOfStock
        }
        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }
        coinsDeposited -= item.price
        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem
        print(&quot;Dispensing \(name)&quot;)
    }
}
</code></pre>

<p>使用了<code>guard</code>语句来提前退出方法，因为<code>throw</code>语句会立即退出方法，保证只有在满足所有条件时才成功卖出商品</p>

<p><code>vend(itemNamed:)</code>会传递它抛出的所有错误,因此在跳用这个方法时，要么直接处理这些错误(<code>do-catch</code>语句,<code>try?</code>或<code>try!</code>)，要么将错误继续传递下去</p>

<pre><code class="language-swift">let favoriteSnacks = [
    &quot;Alice&quot;: &quot;Chips&quot;,
    &quot;Bob&quot;: &quot;Licorice&quot;,
    &quot;Eve&quot;: &quot;Pretzels&quot;,
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;
    try vendingMachine.vend(itemNamed: snackName)
}
//传似抛出的错误
</code></pre>

<p><code>buyFavoriteSnack</code>方法会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法尝试购买,通过在<code>vend(itemNamed:)</code>方法前加<code>try</code>关键字</p>

<p><code>throwing</code>构造器和<code>throwing</code>一样可以传递错误</p>

<pre><code class="language-swift">struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
</code></pre>

<h3 id="toc_3">用Do-Catch处理错误</h3>

<p><strong><code>do-catch</code>语句运行一段<code>闭包</code>代码来处理错误</strong></p>

<p>在<code>do</code>语句抛出一个错误,与<code>catch</code>中的字句匹配</p>

<pre><code class="language-swift">do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</code></pre>

<p><code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误.如果<code>catch</code>没有指定错误模式，那就可以匹配任何错误，并且把错误绑定到名字为<code>error</code>的局部变量</p>

<p><code>catch</code>不必处理抛出的所有错误,错误可以传递到周围,但是必须被处理，可以使外围的<code>do-catch</code>语句 或者是一个<code>throwing</code>函数进行处理</p>

<p>注意:<br/>
在<code>do</code>语句中的<code>try</code>如果有抛出错误就立刻执行<code>catch</code>语句,并判断这个错误是否要被继续传递下去,否则执行<code>do</code>子句中余下的语句</p>

<h3 id="toc_4">将错误转换成可选值</h3>

<p>通过<code>try?</code>将错误转换为一个可选值,如果表达式有错误抛出,那么表达式的值就为<code>nil</code></p>

<pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()
//等效于
let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>

<p>此时不论<code>someThrowingFunction()</code>返回值是什么类型,x，y就是该返回值类型的可选类型</p>

<h3 id="toc_5">禁用错误传递</h3>

<p>当我们确定知道某个<code>throwing</code>函数在运行时是不会抛出错误的,那么可以用<code>tr<br/>
y!</code>来禁用错误传递，它会将调用包装在一个不会有错误抛出的运行时断言中</p>

<h2 id="toc_6">指定清理操作</h2>

<p><code>defer</code>语句在即将离开当前代码块时执行一系列语句，来执行一些必要的清理工作，而不管你是由于哪种方式离开代码块</p>

<ul>
<li><code>defer</code>语句将代码执行延迟到当前作用域退出之前。</li>
<li>该语句由<code>defer</code>关键字和要延时执行的语句组成(延迟执行的语句不能包含任何控制转移语句，或是抛出一个错误)。</li>
<li>延时执行的操作会按照他们被指定时的顺序的相反顺序执行(第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行)</li>
</ul>

<pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // 处理文件。
        }
        // close(file) 会在这里被调用，即作用域的最后。
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可选链式调用]]></title>
    <link href="https://acefish.github.io/15031302948355.html"/>
    <updated>2017-08-19T16:11:34+08:00</updated>
    <id>https://acefish.github.io/15031302948355.html</id>
    <content type="html"><![CDATA[
<p><strong>可选链式调用</strong>是在当前值可能为<code>nil</code>的可选值上请求和调用属性、方法以及下标的方法。如果可选值不为空,调用成功,否则如果可选值为<code>nil</code>，那么调用将返回<code>nil</code>。多个调用可以结合为一个调用链,若任何一个节点为<code>nil</code>。整个调用链都会失败</p>

<h2 id="toc_0">可选链式调用代替强制展开</h2>

<p>在想调用的属性、方法、下标的可选值后加上<code>?</code>来定义一个可选链。</p>

<blockquote>
<p>很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误</p>
</blockquote>

<p>可选链式调用,不论调用的属性、方法及下标返回值的类型,返回结果都是具有相同类型的可选值,可以利用这个可选返回值来判断链式调用是否成功,有值则返回成功，<code>nil</code>表示调用失败</p>

<pre><code class="language-swift">class Person {
    var residence: Residence?
}
class Residence {
    var numberOfRooms = 1
}
let john = Person()
</code></pre>

<p>我们直接<code>let roomCount = john.residence!.numberOfRooms</code>因为<code>residence</code>为<code>nil</code>强制展开的话是会触发运行时错误的</p>

<p>这时我们可以采用可选链式调用来访问<code>numberOfRooms</code>用<code>?</code>代替<code>!</code></p>

<pre><code class="language-swift">if let roomCount = john.residence?.numberOfRooms {
    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)
} else {
    print(&quot;Unable to retrieve the number of rooms.&quot;)
}
</code></pre>

<p><strong>添加问号之后，Swift 就会在<code>residence</code>不为<code>nil</code>的情况下访问<code>numberOfRooms</code></strong></p>

<p>即使<code>numberOfRooms</code>是非可选类型<code>Int</code>，只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回<code>Int?</code>而不是<code>Int</code></p>

<h2 id="toc_1">为可选链式调用定义模型类</h2>

<h2 id="toc_2">通过可选链式调用访问属性</h2>

<p>通过可选链式调用<strong>访问可能不存在实例的属性</strong>:</p>

<pre><code class="language-swift">//john.residence实例可能为nil
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)
} else {
    print(&quot;Unable to retrieve the number of rooms.&quot;)
}
</code></pre>

<p>通过可选链式调用<strong>设置属性值</strong></p>

<pre><code class="language-swift">//john.residence实例可能为nil
let someAddress = Address()
john.residence?.address = someAddress
</code></pre>

<p>对于这种可选链式调用的赋值,如果<code>john.residence</code>为<code>nil</code>，获取<code>address</code>属性失败，那么右侧的代码是不会被执行的</p>

<h2 id="toc_3">通过可选链式调用调用方法</h2>

<p>对于<code>Residence</code>类中定义的方法</p>

<pre><code class="language-swift">func printNumberOfRooms() {
    print(&quot;The number of rooms is \(numberOfRooms)&quot;)
}
</code></pre>

<p>这个方法没有返回值,那就是具有隐式的返回值<code>Void</code><br/>
那么如果用可选链式调用这个方法，返回值就为<code>Void?</code></p>

<pre><code class="language-swift">//john.residence 为Residence类 可能为nil的实例
if john.residence?.printNumberOfRooms() != nil {
    print(&quot;It was possible to print the number of rooms.&quot;)
} else {
    print(&quot;It was not possible to print the number of rooms.&quot;)
}
//可以根据返回值是否为nil 判断调用是否成功
</code></pre>

<p>对实例中的属性赋值 也会返回一个可选类型</p>

<pre><code class="language-swift">if (john.residence?.address = someAddress) != nil {
print(&quot;It was possible to set the address.&quot;)
} else {
print(&quot;It was not possible to set the address.&quot;)
}
</code></pre>

<h2 id="toc_4">通过可选链式调用访问下标</h2>

<p>可以在一个可选值上访问下标,判断下标是否成功</p>

<pre><code class="language-swift">//john.residence可能为nil
if let firstRoomName = john.residence?[0].name {
    print(&quot;The first room name is \(firstRoomName).&quot;)
} else {
    print(&quot;Unable to retrieve the first room name.&quot;)
}
</code></pre>

<blockquote>
<p>注意:下标调用的时候将问号放在下标方括号的前面而不是后面</p>
</blockquote>

<pre><code class="language-swift">john.residence?[0] = Room(name: &quot;Bathroom&quot;)
</code></pre>

<p><code>john.residence</code>为nil时，赋值仍然会失败</p>

<h3 id="toc_5">访问可选类型的下标</h3>

<p>如果下标返回可选类型值,可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用</p>

<pre><code class="language-swift">var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]
testScores[&quot;Dave&quot;]?[0] = 91
testScores[&quot;Bev&quot;]?[0] += 1
testScores[&quot;Brian&quot;]?[0] = 72
</code></pre>

<p>定义一个字典,包含两个键值对，因为字典下标返回的是可选类型值,对于<code>testScores[&quot;Brian&quot;]</code>因为字典中没有这个键，所以返回为<code>nil</code>，调用失败</p>

<h2 id="toc_6">连接多层可选链式调用</h2>

<p>可以连接多个可选链式调用在更深模型层级中访问属性、方法、下标，但是是不会增加返回值的可选层级的</p>

<ul>
<li>通过可选链式调用访问一个 Int 值，将会返回 Int? ，无论使用了多少层可选链式调用</li>
<li>通过可选链式调用访问 Int? 值，依旧会返回 Int? 值，并不会返回 Int??</li>
</ul>

<pre><code class="language-swift">if let johnsStreet = john.residence?.address?.street {
    print(&quot;John&#39;s street name is \(johnsStreet).&quot;)
} else {
    print(&quot;Unable to retrieve the address.&quot;)
}
</code></pre>

<p><code>john.residence.address</code>为<code>nil</code>因此调用失败<br/>
尽管<code>street</code>属性为<code>String？</code>  返回值仍然为<code>String?</code></p>

<h2 id="toc_7">在方法的可选返回值上进行可选链式调用</h2>

<pre><code class="language-swift">if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print(&quot;John&#39;s building identifier is \(buildingIdentifier).&quot;)
}
</code></pre>

<p>在可选值的基础上调用<code>buildingIdentifier()</code>方法  返回<code>String?</code>类型值</p>

<pre><code class="language-swift">if let beginsWithThe =
john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) {
    if beginsWithThe {
        print(&quot;John&#39;s building identifier begins with \&quot;The\&quot;.&quot;)
    } else {
        print(&quot;John&#39;s building identifier does not begin with \&quot;The\&quot;.&quot;)
    }
}
</code></pre>

<p>在方法的返回值基础上进行可选链式调用 </p>

<blockquote>
<p>在方法的圆括号后面加上问号即可</p>
</blockquote>

]]></content>
  </entry>
  
</feed>
