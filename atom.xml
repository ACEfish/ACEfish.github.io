<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[栗豫塬的博客]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2017-08-11T14:23:41+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[析构过程]]></title>
    <link href="https://acefish.github.io/15025006795297.html"/>
    <updated>2017-08-12T09:17:59+08:00</updated>
    <id>https://acefish.github.io/15025006795297.html</id>
    <content type="html"><![CDATA[
<p>只适用类类型,当类的实例被释放时,析构器会被立即调用。<br/>
<code>deinit</code>关键字标示析构器</p>

<h2 id="toc_0">析构过程原理</h2>

<p>自动释放不需要的实例来释放资源,通过自动引用计数来管理内存。实例被释放时会自动清理,但是使用自己的资源需要进行额外的清理(比如自己打开一个文件管理类，需要在类被释放前手动关闭该文件).</p>

<p>在类的定义中,每个类最多只能有一个析构器,不带任何参数</p>

<pre><code class="language-swift">deinit {
    // 执行析构过程
}
</code></pre>

<p>析构器在实例被释放前被调用,不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器<br/>
实现的最后，父类的析构器会被自动调用。</p>

<p>直到实例的析构器被调用后，实例才会被释放,所以析构器可以访问实例的所有属性，并且可以根据那些属<br/>
性可以修改它的行为(比如查找一个需要被关闭的文件)</p>

<h2 id="toc_1">自动引用计数</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构造过程]]></title>
    <link href="https://acefish.github.io/15020961612430.html"/>
    <updated>2017-08-07T16:56:01+08:00</updated>
    <id>https://acefish.github.io/15020961612430.html</id>
    <content type="html"><![CDATA[
<p>在类、结构体、枚举实例可用前必须执行<strong>构造过程</strong>，用来设置存储属性的初始值和其他的设置或初始化任务</p>

<p>通过定义<strong>构造器</strong>来实现构造过程，构造器是用来创建特定类型新实例的特殊方法。</p>

<blockquote>
<p>与OC不同,swift的构造器无序返回值,只需保证实例在第一次使用前完成正确的初始化</p>
</blockquote>

<p><strong>类的实例</strong>也可以通过定义<strong>析构器</strong>在实例释放之前执行特定的清除工作</p>

<h2 id="toc_0">存储属性的初始化赋值</h2>

<p>类和结构体在创建实例时,存储属性必须有合适的值<br/>
可以在构造器中为存储型属性赋值,也可以在定义属性值时设置默认值,这两种方法设置存储属性值时,值是被直接设置的,不会触发任何属性观察者</p>

<h3 id="toc_1">构造器</h3>

<pre><code class="language-swift">//最简单形式
init() {
    // 在此处执行构造过程
}
</code></pre>

<h3 id="toc_2">默认属性值</h3>

<pre><code class="language-swift">struct Fahrenheit {
    var temperature = 32.0
}
</code></pre>

<h2 id="toc_3">自定义构造过程</h2>

<h3 id="toc_4">构造参数</h3>

<p>自定义构造过程，在定义中提供<strong>构造参数</strong></p>

<pre><code class="language-swift">struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0
</code></pre>

<h3 id="toc_5">参数的内部名称和外部名称</h3>

<p>构造器并没有可区分的名字,都为<code>init</code>，因此需要构造器中的参数名和类型来确定应该被调用的构造器,因此外部名称很重要</p>

<pre><code class="language-swift">struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red = red
        self.green = green
        self.blue = blue
    }
    init(white: Double) {
        red = white
        green = white
        blue = white
    }
}

let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)

//只要构造器定义了外部名称就必须使用,否则报错
let veryGreen = Color(0.0, 1.0, 0.0)//报编译时错误，需要外部名称
</code></pre>

<h3 id="toc_6">不带外部名的构造器参数</h3>

<p>使用下划线来<code>_</code>来不为构造器某个参数提供外部名称</p>

<pre><code class="language-swift">struct Celsius {
    var temperatureInCelsius: Double
    init(_ celsius: Double){
        temperatureInCelsius = celsius
    }
}

let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius 为 37.0
</code></pre>

<p>此时构造器意图明确 可以不需要外部参数名称</p>

<h3 id="toc_7">可选属性类型</h3>

<p>在类型中包含一个逻辑上允许为空的存储型属性,要将其定义为<code>可选类型</code>,可选类型属性在初始化时自动初始化为<code>nil</code></p>

<pre><code class="language-swift">class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: &quot;Do you like cheese?&quot;)
cheeseQuestion.ask()
// 打印 &quot;Do you like cheese?&quot;
cheeseQuestion.response = &quot;Yes, I do like cheese.&quot;
</code></pre>

<p>定义一个可选类型<code>response</code>因为答案在问题之前是无法确定,所以设为<code>String?</code>类型，在实例初始化是,自动赋值为<code>nil</code></p>

<h3 id="toc_8">构造过程中常量属性的修改</h3>

<p>在构造过程中任意时间点都可以给常量属性指定值,直到构造过程结束为一个确定的值,一旦常量属性赋值就永不能更改</p>

<blockquote>
<p>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>

<pre><code class="language-swift">class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
</code></pre>

<h2 id="toc_9">默认构造器</h2>

<p>如果结构体或者类的所有属性都有默认值,那么<code>Swift</code>会提供一个默认构造器,将所有值设置为默认值</p>

<pre><code class="language-swift">class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</code></pre>

<h3 id="toc_10">结构体的逐一成员构造器</h3>

<p>在结构体中,如果没有提供自定义构造器，会自动获得逐一成员构造器</p>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>

<h2 id="toc_11"><strong>值类型</strong>的构造器代理</h2>

<p>构造器可以通过调用其他构造器来完成实例的部分构造过程,即<strong>构造器代理</strong></p>

<p>对于值类型不支持继承,所以构造代理只能代理自己的其他构造器,对于类类型可以继承,需要保证其所有继承的存储型属性在构造时也能正确的初始化</p>

<p>值类型,可以使用也只能用<code>self.init</code>在自定义构造器中引用同类型的其他构造器</p>

<p>值类型定义一个自定义构造器,将无法访问默认构造器(结构体也无法访问逐一构造器),防止在给值类型增加一个复杂的自定义构造器后仍然有人使用自动生成的构造器</p>

<blockquote>
<p>可以通过将自定义的构造器写在扩展中,而不是将值类型写在原始定义中,来使可以通过默认构造器，逐一成员构造器,以及自定义构造器来创建实例</p>
</blockquote>

<h2 id="toc_12">类的继承和构造过程</h2>

<p>类里面的所有存储属性,包括所有继承自父类的属性，都必须在构造过程中设置初始值</p>

<p>类类型的两种构造器:  <strong>指定构造器</strong> <strong>便利构造器</strong></p>

<h3 id="toc_13">指定构造器和便利构造器</h3>

<p>指定构造器初始化类中提供的所有属性,并根据父类链向上条用父类构造器实现父类的初始化<br/>
每个类都必须至少有一个指定构造器,可以通过继承父类的指定构造器来满足条件;</p>

<p>便利构造器是次要、辅助的构造器，定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>

<h3 id="toc_14">指定构造器、便利构造器语法</h3>

<p>类的指定构造器语法与值类型简单构造器相同:</p>

<pre><code class="language-swift">init(parameters) {
    statements
}
</code></pre>

<p>便利构造器在<code>init</code>关键字前加<code>convenience</code>关键字</p>

<pre><code class="language-swift">convenience init(parameters) {
    statements
}
</code></pre>

<h3 id="toc_15">类的构造器代理规则</h3>

<p>构造器之间代理调用限制:</p>

<ol>
<li>指定构造器必须调用父类的指定构造器</li>
<li>便利构造器必须调用同类中定义的其它构造器</li>
<li>便利构造器必须最终导致一个指定构造器被调用</li>
</ol>

<h3 id="toc_16">两段式构造过程</h3>

<p>构造过程的两个阶段:<br/>
第一阶段: 存储属性指定一个初始值<br/>
第二阶段: 进一步定制它们的存储型属性</p>

<p>可以防止属性值在初始化前被访问和被另外的构造器意外赋其他值</p>

<p>两段式构造过程的构造流程:</p>

<p>阶段1:</p>

<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化，阶段1结束</li>
</ul>

<p>阶段2：</p>

<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问<code>self</code>、修改它的属性并调用实例方法等等</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用 self</li>
</ul>

<h3 id="toc_17">构造器的继承和重写</h3>

<p>与<code>OC</code>不同,<code>swift</code>的子类默认情况下不继承父类构造器，以防止父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例</p>

<p>要在子类中提供和父类相同指定构造器时,需要重写父类的这个指定构造器,因此必须在子类构造器前加上<code>override</code>修饰符，即使重写的是系统提供的默认构造器,也需要带上<code>override</code></p>

<blockquote>
<p>重写一个父类的指定构造器时，你总是需要写<code>override</code>修饰符，即使你的子类将父类的指定构造器重写为了便利构造器</p>
</blockquote>

<p>而在子类中写一个和父类相同的便利构造器,因为子类不能直接调用父类的便利构造器,因此并未对其进行重写，也不需要加上<code>override</code>前缀</p>

<pre><code class="language-swift">class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return &quot;\(numberOfWheels) wheel(s)&quot;
    }
}
</code></pre>

<p>因为存储属性有默认值,因此会自动获得一个默认构造器</p>

<pre><code class="language-swift">class Bicycle: Vehicle {
    override init() {
        super.init()//可以确保继承的属性 numberOfWheels 能被 Vehicle 类初始化
        numberOfWheels = 2
    }
}
//子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。
</code></pre>

<h3 id="toc_18">构造器的自动继承</h3>

<p>默认子类不继承父类构造器,但是如果满足特定条件是可以被自动继承的</p>

<p>如果为<strong>子类引用的新属性都提供了默认值</strong>:</p>

<ol>
<li>如果子类没有定义任何指定构造器,将自动继承<strong>所有父类</strong>的指定构造器</li>
<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则1继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器</li>
</ol>

<h3 id="toc_19">指定构造器和便利构造器实践</h3>

<pre><code class="language-swift">class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: &quot;[Unnamed]&quot;)
    }
}

let namedMeat = Food(name: &quot;Bacon&quot;)
// namedMeat 的名字是 &quot;Bacon”
let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
</code></pre>

<pre><code class="language-swift">class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    //便利构造器重写了父类的指定构造器
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
let oneMysteryItem = RecipeIngredient() //会继承父类的便利构造器
let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)
let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)
</code></pre>

<pre><code class="language-swift">class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = &quot;\(quantity) x \(name)&quot;
        output += purchased ? &quot; ?&quot; : &quot; ?&quot;
        return output
    }
}
/**
    子类引用的属性都提供了默认值,并且没有自定义构造器,将自动继承所有父类中指定和便利
    构造器
*/
</code></pre>

<h2 id="toc_20">可失败构造器</h2>

<p>如果类、结构体、枚举类型对象在构造时可能会失败,则为其定义一个<strong>可失败构造器</strong></p>

<p>可失败构造器通过在<code>init</code>关键字后添加<code>?</code></p>

<p>注意:<br/>
可失败构造器的参数名和参数类型不能与其他非可失败构造器参数名及参数类型相同</p>

<p>可失败构造器创建自身类型的可选类型对象，构造器并不支持返回值,我们在构造器方法中通过<code>return nil</code>来表示构造失败，</p>

<pre><code class="language-swift">struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}

let anonymousCreature = Animal(species: &quot;&quot;)
// anonymousCreature 的类型是 Animal?, 而不是 Animal
if anonymousCreature == nil {
    print(&quot;The anonymous creature could not be initialized&quot;)
}
// 打印 &quot;The anonymous creature could not be initialized&quot;
</code></pre>

<h3 id="toc_21">枚举类型的可失败构造器</h3>

<p>通过提供的参数来获取特定的枚举成员,如果参数无法匹配任何枚举成员,则构造失败</p>

<pre><code class="language-swift">enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case &quot;K&quot;:
            self = .Kelvin
        case &quot;C&quot;:
            self = .Celsius
        case &quot;F&quot;:
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
</code></pre>

<h3 id="toc_22">带原始值的枚举类型可失败构造器</h3>

<p>带原始值的枚举类型会自带可失败构造器 <code>init?(rawValue:)</code>，参数<code>rawvalue</code>的和枚举类型原始值类型相同,如果能和枚举成员原始值匹配则构造响应枚举成员,否则构造失败</p>

<pre><code class="language-swift">enum TemperatureUnit: Character {
    case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;
}
</code></pre>

<h3 id="toc_23">构造失败的传递</h3>

<p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器，也能向上代理到父类可失败构造器,如果在代理的其他可失败构造器触发构造失败，构造过程终止,接下来构造代码不执行</p>

<pre><code class="language-swift">class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity &lt; 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
//尝试用空name初始化CarItem导致父类构造过程失败
if let oneUnnamed = CartItem(name: &quot;&quot;, quantity: 1) {
    print(&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;)
} else {
    print(&quot;Unable to initialize one unnamed product&quot;)
}
// 打印 &quot;Unable to initialize one unnamed product”

</code></pre>

<h3 id="toc_24">可失败构造器重写</h3>

<p>可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器,但是不能用可失败构造器重写非可失败构造器</p>

<pre><code class="language-swift">class Document {
    var name: String?
    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
    init() {}
    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
    init?(name: String) {
        self.name = name
        if name.isEmpty { return nil }
    }
}

class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = &quot;[Untitled]&quot;
    }
    //用非可失败构造器 init(name:) 重写了父类的可失败构造器 init?(name:)
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = &quot;[Untitled]&quot;
        } else {
            self.name = name
        }
    }
}

//或者可以写为

class UntitledDocument: Document {
    override init() {
    //通过强制解包调用父类的可失败构造器
        super.init(name: &quot;[Untitled]&quot;)!
    }
}
</code></pre>

<h3 id="toc_25">可失败构造器 init!</h3>

<p>可以通过在<code>init</code>后加上<code>!</code>定义一个可失败构造器，会构造一个对应类型的隐式解包可选类型对象</p>

<p>可以在<code>init?</code>中代理到<code>init!</code>，反之亦然。你也可以用<code>init?</code>重写<code>init!</code>，反之亦然。你还可以用 <code>init</code>代理到<code>init!</code>，不过，一旦<code>init!</code>构造失败，则会触发一个断言</p>

<h2 id="toc_26">必要构造器</h2>

<p>类的构造器前添加<code>required</code>修饰符表明所有该类的<code>子类</code>都必须实现该构造器</p>

<pre><code class="language-swift">class SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加<code>required</code>修饰符,不需要添加<code>override</code>修饰符</p>

<pre><code class="language-swift">class SomeSubclass: SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>注意：<br/>
<strong>如果在子类继承的构造器能满足必要构造器的要求,则无须在子类中显式提供必要构造器的实现</strong></p>

<h2 id="toc_27">用闭包或函数设置属性默认值</h2>

<p>使用闭包或全局函数为村塾属性提供默认值,当该类型实例被创建，对应闭包或函数会被调用,他们的返回值会作为这个属性的默认值</p>

<pre><code class="language-swift">class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
    }()
}
</code></pre>

<p>闭包结尾的必须需要一对空的<code>小括号</code>.表明<code>swift</code>立即执行闭包，将闭包的返回值赋值给属性，如果没有括号就相当于将闭包作为值赋值给属性</p>

<blockquote>
<p>在使用闭包来初始化属性时,在闭包被执行时，实例其他部分还没有被初始化,因此不能再闭包中访问其他属性，即使有默认值。也不能隐式使用<code>self</code>或者调用任何实例方法</p>
</blockquote>

<p>闭包初始化存储属性<br/>
```swift<br/>
struct Checkerboard {<br/>
//设置100个bool颜色的数组<br/>
    let boardColors: [Bool] = {<br/>
        var temporaryBoard = <a href="">Bool</a><br/>
        var isBlack = false<br/>
        for i in 1...8 {<br/>
            for j in 1...8 {<br/>
                temporaryBoard.append(isBlack)<br/>
                isBlack = !isBlack<br/>
            }<br/>
            isBlack = !isBlack<br/>
        }<br/>
        return temporaryBoard<br/>
    }()</p>

<pre><code>//返回某一行或列的颜色
func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
    return boardColors[(row * 8) + column]
}
</code></pre>

<p>}</p>

<p>let board = Checkerboard()<br/>
print(board.squareIsBlackAtRow(0, column: 1))<br/>
// 打印 &quot;true&quot;<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[继承]]></title>
    <link href="https://acefish.github.io/15018175799489.html"/>
    <updated>2017-08-04T11:32:59+08:00</updated>
    <id>https://acefish.github.io/15018175799489.html</id>
    <content type="html"><![CDATA[
<p>类可以继承父类的方法、属性和其他特征</p>

<p>类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。</p>

<p>可以为类中继承的属性添加属性观察器</p>

<h2 id="toc_0">定义一个基类</h2>

<p>不继承于其它类的类,称之为基类</p>

<p>注意:</p>

<blockquote>
<p><code>Swift</code>中类并不是从一个通用类继承而来.如果没有为定义的类制定一个超类的话,这个类自动成为一个基类</p>
</blockquote>

<p>创建一个<code>Vehicle</code>的基类，来描述通用车辆</p>

<pre><code class="language-swift">class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return &quot;traveling at \(currentSpeed) miles per hour&quot;
    }
    func makeNoise() {
        // 什么也不做-因为车辆不一定会有噪音
    }
}
</code></pre>

<h2 id="toc_1">子类生成</h2>

<pre><code class="language-swift">//定义一个自行车Bicycle继承自Vehicle
class Bicycle: Vehicle {
    var hasBasket = false
}
</code></pre>

<p>除了继承自父类的方法、属性外，还定义了一个默认值为<code>false</code>的存储属性<code>hasBasket</code></p>

<pre><code class="language-swift">let bicycle = Bicycle()
bicycle.hasBasket = true
//修改继承的属性
bicycle.currentSpeed = 15.0
print(&quot;Bicycle: \(bicycle.description)&quot;)
// 打印 &quot;Bicycle: traveling at 15.0 miles per hour&quot;
</code></pre>

<h2 id="toc_2">重写</h2>

<p>为继承来的实例方法、类方法、实例属性、下标提供自己的实现,即为<strong>重写</strong></p>

<p>需要在重写的定义前加上 <code>override</code>关键字表明重写,否则即为错误的提供了相同的定义</p>

<h3 id="toc_3">访问父类的方法、属性和下标</h3>

<p>通过<code>super</code>前缀来访问父类版本中的方法、属性或下标</p>

<ul>
<li>在方法 someMethod() 的重写实现中，可以通过 super.someMethod() 来调用超类版本的 someMethod() 方法</li>
<li>在属性 someProperty 的 getter 或 setter 的重写实现中，可以通过 super.someProperty 来访问超类版本的someProperty 属性</li>
<li>在下标的重写实现中，可以通过 super[someIndex] 来访问超类版本中的相同下标</li>
</ul>

<h3 id="toc_4">重写方法</h3>

<pre><code class="language-swift">class Train: Vehicle {
    override func makeNoise() {
        print(&quot;Choo Choo&quot;)
    }
}
</code></pre>

<h3 id="toc_5">重写属性</h3>

<p>重写继承来的实例或者类型属性来提供自己定制的<code>getter</code>或者<code>setter</code>或添加属性观察器来观察属性值的改变</p>

<h4 id="toc_6">重写属性的setter和getter</h4>

<p>子类并不知道继承来的属性是存储型还是计算型,重写时要提供属性名称和类型来让编译器去查找父类同名同类型的属性</p>

<p>可以把继承的只读属性重写为可读写,但是没有办法把可读写的重写为只读属性</p>

<blockquote>
<p>如果你在重写属性中提供了<code>setter</code>，那么你也一定要提供<code>getter</code>。如果你不想在重写版本中的<br/>
<code>getter</code>里修改继承来的属性值，你可以直接通过<code>super.someProperty</code>来返回继承来的值</p>
</blockquote>

<pre><code class="language-swift">class Car: Vehicle {
    var gear = 1
    //重写description属性
    override var description: String {
        return super.description + &quot; in gear \(gear)&quot;
    }
}

let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print(&quot;Car: \(car.description)&quot;)//返回自定义描述
// 打印 &quot;Car: traveling at 25.0 miles per hour in gear 3&quot;
</code></pre>

<h4 id="toc_7">重写属性观察器</h4>

<p>注意:<br/>
1. 不能为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器,因为它们不能被设置<br/>
2. 不能同时提供重写的<code>setter</code>和重写的属性观察器。因为此时我们可以直接在setter中观察值的变化</p>

<pre><code class="language-swift">class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1(后向下取得最接近的整数值在加1)
        }
    }
}
</code></pre>

<p>为属性<code>currentSpeed</code>添加观察器，设置速度时就会自动选择合适的档位</p>

<h2 id="toc_8">防止重写</h2>

<p>通过把方法、属性或下标 前加关键字<code>final</code>来防止被重写,例如:<code>final var</code> ， <code>final func</code> ， <code>final class func</code> ，以及 <code>final subscript</code></p>

<p>通过在<code>class</code>前添加关键字<code>final</code>表示这个类是不可被继承的</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[下标]]></title>
    <link href="https://acefish.github.io/15017615739867.html"/>
    <updated>2017-08-03T19:59:33+08:00</updated>
    <id>https://acefish.github.io/15017615739867.html</id>
    <content type="html"><![CDATA[
<p>下标可以定义在类、结构体和枚举中，用于访问集合、列表或序列中的元素</p>

<p>一个类型可以定义多个下标.通过不同索引类型进行重载.下标不限于一维</p>

<h2 id="toc_0">下标语法</h2>

<p>通过在实例名称后的方括号中传入一个或多个索引值来对实例进行存取</p>

<p>定义下标使用<code>subscript</code>关键字,指定一个或者多个输入参数和返回类型<br/>
下标可以设置为读写或者只读,通过是<code>getter</code>或者<code>setter</code>实现</p>

<pre><code class="language-swift">subscript(index: Int) -&gt; Int {
    get {
        // 返回一个适当的 Int 类型的值
    }
    set(newValue) {
        // 执行适当的赋值操作
    }
}
</code></pre>

<p>可以不指定<code>setter</code>的参数,默认提供<code>newValue</code></p>

<pre><code class="language-swift">struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
print(&quot;six times three is \(threeTimesTable[6])&quot;)
// 打印 &quot;six times three is 18&quot;
</code></pre>

<p>定义一个数学公式结构体,只读的下标语法</p>

<h2 id="toc_1">下标用法</h2>

<pre><code class="language-swift">//字典的下标语法
var numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]
numberOfLegs[&quot;bird&quot;] = 2
</code></pre>

<h2 id="toc_2">下标选项</h2>

<p>下标可以使用变量参数和可变参数,但不能使用输入输出参数,也不能给参数设置默认值</p>

<p>下标的重载:<br/>
类和结构体可以根据自身需要提供多个下标实现,通过入参和类型进行区分</p>

<pre><code class="language-swift">struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        //通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            //断言语句
            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)
            return grid[(row * columns) + column]
        }
        set {
            //断言语句
            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)
            grid[(row * columns) + column] = newValue
        }
    }
}
</code></pre>

<pre><code class="language-swift">var matrix = Matrix(rows: 2, columns: 2)
//下标入参用逗号进行分割
matrix[0, 1] = 1.5 //将下标为(0,1)位置设置为1.5
</code></pre>

<p>通过断言,检查下标入参<code>row</code>和<code>colum</code>的值是否有效.定义方法<code>indexIsValidForRow(_:column:)</code>检查入参<code>row</code>和<code>columu</code>是否越界,断言会在下标月结</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法]]></title>
    <link href="https://acefish.github.io/15017296324997.html"/>
    <updated>2017-08-03T11:07:12+08:00</updated>
    <id>https://acefish.github.io/15017296324997.html</id>
    <content type="html"><![CDATA[
<p><code>类、结构体、枚举</code>都可以定义实例方法，实例方法为给定类型实例封装了具体的任务和功能</p>

<p><code>类、结构体、枚举</code>也可定义类型方法,类型方法与类型本身关联（与OC中类似）</p>

<h2 id="toc_0">实例方法</h2>

<p>实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。<br/>
<strong>实例方法的语法与函数完全一致</strong></p>

<p>实例方法能够隐式访问它所属类型的所有的其他实例方法和属性</p>

<pre><code class="language-swift">class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}

let counter = Counter()
// 初始计数值是0
counter.increment()
// 计数值现在是1
counter.increment(by: 5)
// 计数值现在是6
counter.reset()
// 计数值现在是0
</code></pre>

<h3 id="toc_1">self属性</h3>

<p>与OC类似,<code>self</code>等同于该类型的实例本身</p>

<pre><code class="language-swift">//所以我们可以这么写
func increment() {
    self.count += 1
}
</code></pre>

<p>其实没必要写<code>self</code>，使用已知的属性名或者方法名 <code>swift</code>会假定你使用的是当前实例属性或者方法</p>

<p>我们使用的主要场景:<br/>
实例方法的某个<code>参数名称</code>与实例的某个<code>属性名称</code>相同的时候,此时优先使用参数名,因此我们通过<code>self</code>属性来进行区分使用属性</p>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOfX(_ x: Double) -&gt; Bool {
        return self.x &gt; x//用self来区分属性
    }
}

let somePoint = Point(x: 4.0, y: 5.0)

if somePoint.isToTheRightOfX(1.0) {
    print(&quot;This point is to the right of the line where x == 1.0&quot;)
}
// 打印 &quot;This point is to the right of the line where x == 1.0&quot;
</code></pre>

<h3 id="toc_2">实例方法中修改值类型</h3>

<p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改</p>

<p>我们可以通过给这个实例方法选择<code>可变(mutating)</code>行为，就可以在方法内部修改改变它的属性;这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的<code>self</code>属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例</p>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveByX(2.0, y: 3.0)
print(&quot;The point is now at (\(somePoint.x), \(somePoint.y))&quot;)
// 打印 &quot;The point is now at (3.0, 4.0)&quot;
</code></pre>

<p>注意:<br/>
不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性</p>

<h3 id="toc_3">在可变方法中给self赋值</h3>

<p>可以在可变方法中给隐含属性<code>self</code>赋予一个新的实例</p>

<pre><code class="language-swift">struct Point1 {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point1(x: x + deltaX, y: y + deltaY)
    }
}
</code></pre>

<p>创建一个新的结构体实例赋值给self，替换现在的实例</p>

<p>枚举的可变方法，定义了一个三态开关状态枚举,通过调用<code>next()</code>进行切换状态</p>

<pre><code class="language-swift">enum TriStateSwitch {
    case Off, Low, High
    mutating func next() {
        switch self {
        case .Off:
            self = .Low
        case .Low:
            self = .High
        case .High:
            self = .Off
        }
    }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight 现在等于 .High
ovenLight.next()
// ovenLight 现在等于 .Off
</code></pre>

<h2 id="toc_4">类型方法</h2>

<p>定义在类型本身上的方法,即为类型方法<br/>
通过在方法<code>func</code>前加关键字<code>static</code>，来指定类型方法,通过加关键字<code>class</code>来实现子类重写父类的方法实现</p>

<blockquote>
<p>在<code>oc</code>中只能为类定义类型方法,但是在<code>swift</code>中可以为类,结构体,枚举定义类方法</p>
</blockquote>

<p>类型方法在类型上通过点语法调用<br/>
在类型方法中,<code>self</code>指向类型本身,同样的可以用其来区分同样的类型属性和类型方法参数</p>

<p>在类型方法体中可以调用本类中类型属性或的其他类型方法,调用是可以直接通过类型方法名称或者类型属性名称进行调用,而不用在前面添加类型名称</p>

<pre><code class="language-swift">//检测玩家等级的结构体
struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1
    static func unlock(_ level: Int) {
        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func isUnlocked(_ level: Int) -&gt; Bool {
        return level &lt;= highestUnlockedLevel
    }
    @discardableResult //
    mutating func advance(to level: Int) -&gt; Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
</code></pre>

<pre><code class="language-swift">//玩家类
class Player {
    var tracker = LevelTracker()
    let playerName: String
    func complete(level: Int) {
        LevelTracker.unlock(level + 1)
        tracker.advance(to: level + 1)
    }
    init(name: String) {
        playerName = name
    }
}
</code></pre>

<pre><code class="language-swift">var player = Player(name: &quot;Argyrios&quot;)
player.complete(level: 1)
print(&quot;highest unlocked level is now \(LevelTracker.highestUnlockedLevel)&quot;)
// 打印 &quot;highest unlocked level is now 2&quot;

player = Player(name: &quot;Beto&quot;)
if player.tracker.advance(to: 6) {
print(&quot;player is now on level 6&quot;)
} else {
print(&quot;level 6 has not yet been unlocked&quot;)
}
// 打印 &quot;level 6 has not yet been unlocked&quot;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性]]></title>
    <link href="https://acefish.github.io/15015839505859.html"/>
    <updated>2017-08-01T18:39:10+08:00</updated>
    <id>https://acefish.github.io/15015839505859.html</id>
    <content type="html"><![CDATA[
<p>属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>

<p>属性也可以直接作用于类型本身，这种属性称为类型属性。</p>

<p>可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作.可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>

<h2 id="toc_0">存储属性</h2>

<p>存储属性就是存储在特定类或结构体实例里的一个常量或变量,可以为变量或者常量<br/>
可以在定义存储属性时指定默认值，也可在构造过程中设置或修改存储属性值,甚至修改常量存储属性值</p>

<pre><code class="language-swift">struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
rangeOfThreeItems.firstValue = 6
</code></pre>

<p>定义一个结构体,包含<code>firstValue</code>变量存储属性,和<code>length</code>常量存储属性。<code>length</code>在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值</p>

<h3 id="toc_1">常量结构体的存储属性</h3>

<p>若结构体声明为常量,则无法修改实例的任何属性,即使为变量属性:</p>

<pre><code class="language-swift">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// 该区间表示整数0，1，2，3
rangeOfFourItems.firstValue = 6//报错不可修改
// 尽管 firstValue 是个变量属性，这里还是会报错
</code></pre>

<p>这是由于结构体为值类型,值类型为常量则所有属性也变为常量</p>

<p>对于引用类型的类来说,将引用类型赋值给一个常量，仍然可以修改实例的变量属性</p>

<h3 id="toc_2">延迟存储属性</h3>

<p><strong>延迟属性</strong>第一次调用时才会结算其初始化值的属性<br/>
在属性声明前加<code>lazy</code>来标示一个延迟存储属性</p>

<blockquote>
<p>必须将延迟存储属性声明成<code>变量</code>（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而<strong>常量属性在构造过程完成之前必须要有初始值</strong>，因此无法声明成延迟属性。</p>
</blockquote>

<pre><code class="language-swift">class DataImporter {
    /*
    DataImporter 是一个负责将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */
    var fileName = &quot;data.txt&quot;
    // 这里会提供数据导入功能
}
class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // 这里会提供数据管理功能
}
</code></pre>

<pre><code class="language-swift">let manager = DataManager()
manager.data.append(&quot;Some data&quot;)
//此时实例的import属性还没创建
</code></pre>

<pre><code class="language-swift">print(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 &quot;data.txt”
</code></pre>

<p><strong>如果一个被标记为<code>lazy</code>的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次</strong></p>

<h3 id="toc_3">存储属性和实例变量</h3>

<p>与OC不同<code>Swift</code>没有属性对应的实例变量，因此没有办法直接访问属性的后端存储，方便统一访问方式<br/>
使属性的全部信息包括<code>命名、类型和内存管理特征</code>都在一个地方定义</p>

<h2 id="toc_4">计算属性</h2>

<p>计算属性不存储值而是提供一个<code>getter</code>和一个可选的<code>setter</code>,来间接获取和设置其他属性或变量的值</p>

<blockquote>
<p>必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的</p>
</blockquote>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
                  size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)
</code></pre>

<p>可以通过<code>square.center</code>访问计算属性<code>center</code> 会调用<code>getter</code>计算新的值返回<br/>
<code>center</code>可以设置一个新值,会调用<code>setter</code>来修改<code>origin</code>来移动正方形</p>

<h3 id="toc_5">简化setter声明</h3>

<p>如果计算属性的<code>setter</code>没有定义表示新值,就可以使用默认名称<code>newValue</code></p>

<pre><code class="language-swift">struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
</code></pre>

<h3 id="toc_6">只读的计算属性</h3>

<p>只有<code>getter</code>没有<code>setter</code>的计算属性就是只读计算属性，可以访问值,不能设置新值</p>

<pre><code class="language-swift">struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
</code></pre>

<p>只读属性可以省略掉 <code>get</code>关键字和花括号</p>

<h2 id="toc_7">属性观察器</h2>

<p><strong>属性观察器</strong>监控和响应属性值变化，每次属性被设置时会调用属性观察器</p>

<p>为<code>除了延迟属性</code>外其他存储属性添加属性观察器，对于继承的存储属性和计算属性,通过重写的方式来添加属性观察器<br/>
对于非继承的计算属性没必要添加属性观察器，我们可以通过<code>setter</code>方法直接监控</p>

<p>属性观察期器:<br/>
* <code>willSet</code>在新值被设置前调用<br/>
* <code>didSet</code>在新值被设置之后调用</p>

<p><code>willSet</code>观察器会将新的属性值作为常量参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名<br/>
称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>

<p><code>didSet</code>观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。如果<br/>
在<code>didSet</code>方法中再次对该属性赋值，那么新值会覆盖旧的值</p>

<blockquote>
<p>父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>
</blockquote>

<pre><code class="language-swift">class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)
        }
        didSet {
            if totalSteps &gt; oldValue {
                print(&quot;Added \(totalSteps - oldValue) steps&quot;)
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
</code></pre>

<p>注意:<br/>
在willSet或者didSet方法中设置属性值是不会触发的属性观察器方法  </p>

<blockquote>
<p>如果将属性通过<code>in-out</code>方式传入函数，<code>willSet</code>和<code>didSet</code>也会调用。这是因为<code>in-out</code>参数采用了拷入拷出模式：即在函数内部使用的是参数的<code>copy</code>，函数结束后，又对参数重新赋值。</p>
</blockquote>

<h2 id="toc_8">全局变量和局部变量</h2>

<p>全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<p><strong>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量</strong></p>

<p>我们之前用的变量都是存储型变量,跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入</p>

<p>我们可以在全局或局部范围为存储型变量定义观察器</p>

<p>在全局或局部范围都可以定义计算型变量。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样</p>

<p><strong>注意:</strong><br/>
1. 全局的常量或变量都是延迟计算，类似<code>延迟属性</code>但是不需要<code>lazy</code>声明<br/>
2. 局部的常量或变量从不延迟计算</p>

<h2 id="toc_9">类型属性</h2>

<p>可以为类型本身定义属性</p>

<p>类型属性用于定义某个类型所有实例共享的数据</p>

<p>类型属性也可以有 存储型的常量或变量 计算型的只能为变量</p>

<p>注意:</p>

<blockquote>
<p>存储型类型属性必须指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值</p>

<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用<code>lazy</code>修饰符。</p>
</blockquote>

<h3 id="toc_10">类型属性语法</h3>

<p>在<code>OC</code>中,在类中关联的静态变量和常量是作为全局静态变量定义</p>

<p>在<code>Swift</code>中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，作用范围就在类型支持的范围内</p>

<p>使用<code>static</code>来定义类型属性。<br/>
在为类定义计算型类型属性时，可以改用关键字<code>class</code>来支持子类对父类的实现进行重写</p>

<pre><code class="language-swift">//结构体
struct SomeStructure {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 1
    }
}
//枚举
enum SomeEnumeration {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 6
    }
}
//类
class SomeClass {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 27
    }
    //子类对父类的实现进行重写
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}

</code></pre>

<h3 id="toc_11">获取和设置类型属性值</h3>

<p>类型属性通过点运算符通过类型本身来访问</p>

<pre><code class="language-swift">print(SomeStructure.storedTypeProperty)
    // 打印 &quot;Some value.&quot;
SomeStructure.storedTypeProperty = &quot;Another value.&quot;
print(SomeStructure.storedTypeProperty)
    // 打印 &quot;Another value.”
print(SomeEnumeration.computedTypeProperty)
    // 打印 &quot;6&quot;
print(SomeClass.computedTypeProperty)
    // 打印 &quot;27&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类和结构体]]></title>
    <link href="https://acefish.github.io/15005513837564.html"/>
    <updated>2017-07-20T19:49:43+08:00</updated>
    <id>https://acefish.github.io/15005513837564.html</id>
    <content type="html"><![CDATA[
<p>可以使用完全相同的语法规则来为<code>类</code>和<code>结构体</code>定义属性(<code>常量</code>、<code>变量</code>)和添加方法，从而扩展类和结构体的功能</p>

<p>与其他编程语言不同,<code>swift</code>不要求为自定义类和结构创建独立的接口和实现文件.所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口</p>

<h2 id="toc_0">类和结构体对比</h2>

<blockquote>
<p>类通过引用计数进行多次引用,结构体通过复制的方式在代码中传递,不使用引用计数</p>
</blockquote>

<h3 id="toc_1">定义语法</h3>

<p>通过关键之<code>class</code>和<code>struct</code>来分别标识类和结构体</p>

<blockquote>
<p>类和结构体名使用首字母大写的方式进行命名</p>
</blockquote>

<pre><code class="language-swift">//定义一个结构体 描述显示器屏幕分辨率
struct Resolution {
    var width = 0
    var height = 0
    //当这两个属性被初始化为整数 0 的时候，它们会被推断为 Int 类型。
}

//定义一个类 描述视频显示器的特定模式
//四个变量存储属性
class VideoMode {
    var resolution = Resolution()//分辨率 结构体
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
</code></pre>

<p><code>存储属性</code>是被<code>捆绑</code>和<code>存储</code>在类或结构体中的常量或变量。</p>

<h3 id="toc_2">类和结构体实例</h3>

<p>初始化结构体或类的实例</p>

<pre><code class="language-swift">let someResolution = Resolution()
let someVideoMode = VideoMode()
</code></pre>

<p>通过这种方式创建类或者结构体实例,属性都会被初始化为默认值.</p>

<h3 id="toc_3">属性访问</h3>

<p>通过点语法访问实例属性。</p>

<pre><code class="language-swift">//访问结构体属性
print(&quot;The width of someResolution is \(someResolution.width)&quot;)
// 打印 &quot;The width of someResolution is 0&quot;

//访问变量属性
someVideoMode.resolution.width = 1280
print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)
// 打印 &quot;The width of someVideoMode is now 1280&quot;
</code></pre>

<blockquote>
<p>在OC中是不能直接设置结构体子属性值，swift中可以直接设置比如<code>resolution.width</code>属性值,在oc中我们需要给整个结构体<code>resolution</code>设置新值</p>
</blockquote>

<h3 id="toc_4">结构体类型成员逐一构造器</h3>

<p>对于<strong>结构体</strong><br/>
所有结构体都有一个自动生成的<strong>成员逐一构造器</strong>，用来初始化新结构体成员的属性</p>

<pre><code class="language-swift">//通过属性名称
let vga = Resolution(width:640, height: 480)
</code></pre>

<p>类是没有这个成员构造器的</p>

<h2 id="toc_5">结构体和枚举时值类型</h2>

<p><strong>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝</strong></p>

<p>实际上,在<code>Swift</code>中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是<strong>以结构体的形式所实现</strong></p>

<p>在<code>swift</code>中,所有结构体和枚举类型都是值类型。因此,它们的实例以及实例中包含的值类型属性,在传递时都会被复制</p>

<pre><code class="language-swift">let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
cinema.width = 2048
print(&quot;cinema is now \(cinema.width) pixels wide&quot;)// &quot;cinema is now 2048 pixels wide&quot;
print(&quot;hd is still \(hd.width) pixels wide&quot;)//&quot;hd is still 1920 pixels wide&quot;
</code></pre>

<p>在对结构体进行赋值的时候,进行了拷贝,cinema和hd是完全不同的两个实例,因此改变了cinema的宽对hd没有影响</p>

<p>枚举也是值类型,遵循相同的行为准则</p>

<h2 id="toc_6">类是引用类型</h2>

<p>与值类型不同,引用类型在传递时,值不会被拷贝.因此，<strong>引用的是已存在的实例本身而不是其拷贝</strong>。</p>

<pre><code class="language-swift">let tenEighty = VideoMode()
tenEighty.frameRate = 25.0

let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
print(&quot;The frameRate property of tenEighty is now \(tenEighty.frameRate)&quot;)//30.0
</code></pre>

<p>类是引用类型，所以<code>tenEight</code>和<code>alsoTenEight</code>实际上引用的是相同的<code>VideoMode</code>实例<br/>
注意:<br/>
虽然<code>alsoTenEighty</code>为常量但是仍然可以改变<code>alsoTenEighty.frameRate</code>因为这两个常量的值并未改变,这个常量的值存储的并不是<code>ViewMode</code>的实例,而是对其的引用.</p>

<h3 id="toc_7">恒等运算符</h3>

<p>等价于 <code>===</code>  不等价于 <code>!==</code> 用来检测两个变量或常量是否引用同一个实例</p>

<p><code>===</code>与<code>==</code>的不同:<br/>
“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。<br/>
“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准</p>

<h3 id="toc_8">指针</h3>

<p>一个引用实例的<code>swift</code>常量或者变量,与C指针类似,但是并不直接指向某个内存地址,也不需要用<code>*</code>表明在创建引用.</p>

<h2 id="toc_9">类和结构体的选择</h2>

<h2 id="toc_10">字符串、数组、字典类型的赋值和复制行为</h2>

<p>因为<code>swift</code>中很多基本类型,<code>String</code>，<code>Array</code>和<code>Dictionary</code>类型均以结构体的形式实现，赋值给新的常量变量或者传入函数方法中的时候会被拷贝</p>

<blockquote>
<p>在OC中<code>NSString</code>，<code>NSArray</code>和<code>NSDictionary</code>是以类的形式实现,不会发生值拷贝而是传递引用</p>

<p>Swift会在绝对必要时才执行实际拷贝,确保性能最优,因此我们没有必要回避赋值来增加性能</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[枚举]]></title>
    <link href="https://acefish.github.io/15003778819226.html"/>
    <updated>2017-07-18T19:38:01+08:00</updated>
    <id>https://acefish.github.io/15003778819226.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>与C语言不同，<code>Swift</code>中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p></li>
<li><p>枚举成员可以指定任意类型的关联值存储到枚举成员中</p></li>
<li><p>在 Swift 中，<strong>枚举类型</strong>是一等（first-class）类型。采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p></li>
</ol>

<h2 id="toc_0">枚举语法</h2>

<p>用<code>enum</code>关键字来创建枚举</p>

<pre><code class="language-swift">enum CompassPoint {
    case north
    case south
    case east
    case west
}

//多个成员可以在同一行 用 , 隔开
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>我们使用<code>case</code>来定义一个新的枚举成员值</p>

<blockquote>
<p>与OC不同,Swift枚举成员不会再创建时被赋予一个默认的整型值。这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的<code>CompassPoint</code>类型</p>
</blockquote>

<p>在<code>Swift</code>中每个枚举定义了一个全新的类型，与Swift中的其他类型一样,名字以大写字母开头</p>

<pre><code class="language-swift">var directionToHead = CompassPoint.west
//此时directionToHead类型可以被推断出来,我们可以直接使用 . 语法将其设置为另一个枚举值
directionToHead = .east
</code></pre>

<p>当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名。</p>

<h2 id="toc_1">用switch语句匹配枚举值</h2>

<p>在判断一个枚举类型值时,<code>switch</code>必须穷举所有情况，如果不需要匹配每个成员可以使用<code>default</code>分支</p>

<pre><code class="language-swift">let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print(&quot;Mostly harmless&quot;)
default:
    print(&quot;Not a safe place for humans&quot;)
}
// 打印 &quot;Mostly harmless”
</code></pre>

<h2 id="toc_2">关联值</h2>

<p>可以使用<code>Swift</code>的枚举来<strong>存储任意类型的关联值</strong>,枚举成员的关联值类型可以不同(关联值)</p>

<pre><code class="language-swift">enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
</code></pre>

<p>定义一个枚举类型,一个成员值是具有 <code>(Int，Int，Int，Int)</code>类型关联值的 upc，另一个是<code>String</code>类型关联值的qrcode</p>

<pre><code class="language-swift">//给其赋值关联的元组值
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
//赋值新的枚举关联字符串
productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)
//productBarcode同一时间只能存储这两个值中的一个
</code></pre>

<pre><code class="language-swift">switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case .qrCode(let productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 打印 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<p>我们可以提取出来关联值作为常量或变量</p>

<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>：</p>

<pre><code class="language-swift">switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case let .qrCode(productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 输出 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<h2 id="toc_3">原始值</h2>

<p>枚举成员可以被<strong>默认值（称为原始值）预填充</strong>，这些原始值的类型必须相同。</p>

<pre><code class="language-swift">enum ASCIIControlCharacter: Character {
    case tab = &quot;\t&quot;
    case lineFeed = &quot;\n&quot;
    case carriageReturn = &quot;\r&quot;
}
</code></pre>

<p>枚举类型<code>ASCIIControlCharacter</code>的原始值类型被定义为<code>Character</code><br/>
每个原始值在枚举声明中必须是唯一的。</p>

<blockquote>
<p>注意原始值与关联值的不同，原始值是在定义枚举是预先填充的值，对于特定的枚举成员其原始值不变<br/>
关联值是创建一个基于枚举成员的常量或变量时才设置的值,枚举成员的关联值可以变化</p>
</blockquote>

<h3 id="toc_4">原始值的隐式赋值</h3>

<p>当原始值为整数或者字符串类型的枚举时,Swift会自动为每个枚举成员设置原始值;</p>

<ol>
<li><p>原始值为整形枚举</p>

<pre><code class="language-swift">enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0</p></li>
<li><p>原始值为字符串类型</p>

<pre><code class="language-swift">enum CompassPoint: String {
    case north, south, east, west
}
//CompassPoint.south 拥有隐式原始值 south
</code></pre>

<p>使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称</p></li>
</ol>

<p>使用枚举成员的<code>rawValue</code>属性可以访问枚举成员初始值</p>

<pre><code class="language-swift">let earthsOrder = Planet.earth.rawValue
    // earthsOrder 值为 3
let sunsetDirection = CompassPoint.west.rawValue
    // sunsetDirection 值为 &quot;west&quot;
</code></pre>

<h3 id="toc_5">原始值初始化枚举实例</h3>

<p>定义枚举时使用原始值,会获得一个初始化方法,有一个<code>rawValue</code>类型为原始值类型的参数，返回一个枚举类型或为<code>nil</code></p>

<pre><code class="language-swift">let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet 类型为 Planet? 值为 Planet.uranus
//因为不一定都能找到匹配的行星  返回的是可选类型
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print(&quot;Mostly harmless&quot;)
    default:
        print(&quot;Not a safe place for humans&quot;)
    }
} else {
    print(&quot;There isn&#39;t a planet at position \(positionToFind)&quot;)
}
//找不到11代表的行星
</code></pre>

<h2 id="toc_6">递归枚举</h2>

<p>是一种枚举类型  有一个或多个成员使用该枚举类型实例作为关联值</p>

<p>可以在枚举成员前加<code>indirect</code>表示该成员可递归, 或者在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归</p>

<pre><code class="language-swift">enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}

indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}

//递归枚举使用
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

//递归函数中使用递归枚举
func evaluate(_ expression: ArithmeticExpression) -&gt; Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}
print(evaluate(product))//18
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包]]></title>
    <link href="https://acefish.github.io/14993105877642.html"/>
    <updated>2017-07-06T11:09:47+08:00</updated>
    <id>https://acefish.github.io/14993105877642.html</id>
    <content type="html"><![CDATA[
<p>闭包是自包含的函数代码块,可以在代码中被传递和使用</p>

<p><strong>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</strong></p>

<blockquote>
<p><code>Swift</code>中的闭包与<code>C</code>和<code>Objective-C</code>中的代码块（<code>blocks</code>）以及其他一些编程语言中的匿名函数比较相似<br/>
在函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包</p>
</blockquote>

<p>闭包的形式：</p>

<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>

<p>闭包可以进行一定语法优化，常见优化:</p>

<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回<code>单表达式</code>闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>

<h2 id="toc_0">闭包表达式</h2>

<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。</p>

<h3 id="toc_1">sorted方法</h3>

<p><code>Swift</code>的<code>sorted(by:)</code>方法根据提供的排序的闭包函数.将数组排序后返回一个同样大小排序后的数组,原数组不变</p>

<p><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code><br/>
对于数组这个用于排序的闭包函数类型为<code>(String, String) -&gt; Bool</code>通过返回bool值决定第一个参数在前还是在后</p>

<pre><code class="language-swift">func backward(_ s1: String, _ s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversedNames = names.sorted(by: backward)
// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]
</code></pre>

<p>为了写<code>return s1 &gt; s2</code>这么简单的表达式却需要写函数太过繁琐,我们可以使用闭包表达式语法</p>

<h3 id="toc_2">闭包表达式语法</h3>

<pre><code class="language-swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>闭包表达式参数 可以是<code>in-out</code>参数，但不能设定默认值。可以使用可变参数但是要放到参数最后</p>

<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。（<code>in</code>前为闭包定义,后为闭包函数体）</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<h3 id="toc_3">根据上下文推断类型</h3>

<p>因为这个闭包函数的作为方法参数传入,因此其类型已经确定为<code>(String, String) -&gt; Bool</code>,因此我们可以省略这些类型声明,因为可以被正确推断出来</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
//我们将闭包作为函数或方法的参数时,其类型总是可以推断出来的
//推荐完整格式闭包,增加代码可读性
</code></pre>

<h3 id="toc_4">单表达式闭包隐式返回</h3>

<p>如果闭包内只有一行单一表达式,并且明确了需要的返回类型,可以省略<code>return</code>关键字</p>

<pre><code class="language-swift">//
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<h3 id="toc_5">参数名称缩写</h3>

<p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数</p>

<p>如果使用参数名称缩写,那么在闭包定义中也可以省略参数列表,对应的参数名称缩写的类型也可以推断出来,这样的话<code>in</code>关键字也可以省略</p>

<pre><code class="language-swift">//此时闭包表达式只剩下闭包函数体
reversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<h3 id="toc_6">运算符方法</h3>

<p><code>Swift</code>的<code>String</code>类型定义了关于大于号<code>（ &gt; ）</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断出你想使用大于号的字符串函数实现：</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: &gt;)
</code></pre>

<h2 id="toc_7">尾随闭包</h2>

<p>如果要将一个很长的闭包作为函数最后一个参数,为了增强代码的可读性,我们可以使用<code>尾随闭包</code>的方式来调用函数</p>

<pre><code class="language-swift">func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
    // 函数体部分
}
// 以下是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure(closure: {
    // 闭包主体部分
})
// 以下是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
    // 闭包主体部分
}

reversedNames = names.sorted() { $0 &gt; $1 }
//如果闭包函数是函数的唯一参数我们还可以省略（）
reversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<pre><code class="language-swift">//举栗子
let strings = numbers.map {
    (number) -&gt; String in
    var number = number
    var output = &quot;&quot;
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number &gt; 0
    return output
}
// strings 常量被推断为字符串类型数组，即 [String]
// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]
</code></pre>

<h2 id="toc_8">值捕获</h2>

<p>闭包可以在被定义的上下文捕获常量或变量</p>

<p>最简单的捕获值的闭包形式是嵌套函数</p>

<pre><code class="language-swift">func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementer() -&gt; Int {
        runningTotal += amount
    return runningTotal
    }
    return incrementer
}
</code></pre>

<p><code>makeIncrementer</code>的返回类型是<code>() -&gt; Int</code>说明要返回一个函数<br/>
对于嵌套函数<code>incrementer()</code>并没有参数，而是捕获了<code>runningTotal</code>和<code>amount</code>变量的引用.捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>

<blockquote>
<p>如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。 Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>

<pre><code class="language-swift">let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()// 返回的值为10
incrementByTen()// 返回的值为20
incrementByTen()// 返回的值为30
</code></pre>

<p>这个常量函数每次调用都会将<code>runningTotal</code>变量增加<code>10</code></p>

<h2 id="toc_9">闭包是引用类型</h2>

<p><code>函数</code>和<code>闭包</code>都是引用类型，因此我们设置的常量或者变量是设置的对应函数或闭包的引用，而不是闭包内容本身</p>

<blockquote>
</blockquote>

<h2 id="toc_10">逃逸闭包</h2>

<p>将闭包作为参数传递到另一个函数中,但是这个闭包在函数返回后才执行,则这个闭包从函数中<code>逃逸</code>，我们可以通过在函数名之前标注<code>@escaping</code>表示这个闭包允许<code>逃逸</code></p>

<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中,此时必须闭包是可逃逸的否则函数的作用域结束，这个外部变量保存的闭包。。。会导致编译错误</p>

<p>逃逸闭包我们常用于在一个函数需要异步执行操作,通常会让函数返回,在异步操作完成后再调用执行这个闭包,因为闭包需要在函数返回之后被调用,所以需要逃逸闭包</p>

<pre><code class="language-swift">var completionHandlers: [() -&gt; Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {
    completionHandlers.append(completionHandler)
}

func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {
    closure()
}
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
let instance = SomeClass()
instance.doSomething()
print(instance.x)
// 打印出 &quot;200&quot;
completionHandlers.first?()
print(instance.x)
</code></pre>

<h2 id="toc_11">自动闭包</h2>

<p>一种自动创建的闭包，用于包装传递给函数作为参数的表达式。不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这样帮我们省略掉花括号,用一个普通表达式代替显式的闭包</p>

<p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受自动闭包作为它的<code>condition</code>参数和 <code>message</code>参数；它的<code>condition</code>参数仅会在<code>debug</code>模式下被求值，它的<code>message</code>参数仅当 <code>condition</code>参数为<code>false</code>时被计算求值。</p>

<p><strong>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。</strong></p>

<pre><code class="language-swift">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
//未使用自动闭包
func serve(customer customerProvider: () -&gt; String) {
    print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: { customersInLine.remove(at: 0) } )
// 打印出 &quot;Now serving Alex!&quot;

//使用自动闭包
func serve(customer customerProvider: @autoclosure () -&gt; String) {
print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: customersInLine.remove(at: 0))
</code></pre>

<blockquote>
<p>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟<br/>
执行的</p>
</blockquote>

<pre><code class="language-swift">//可以通过同时加上@autoclosure @escaping 自动闭包可以“逃逸”
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {
    customerProviders.append(customerProvider)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSNotification]]></title>
    <link href="https://acefish.github.io/14988080333726.html"/>
    <updated>2017-06-30T15:33:53+08:00</updated>
    <id>https://acefish.github.io/14988080333726.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">notification的使用</h2>

<h3 id="toc_1">注册观察者</h3>

<p><code>- (void)addObserver:(id)notificationObserver selector:(SEL)notificationSelector name:(NSString *)notificationName object:(id)notificationSender<br/>
</code><br/>
注意:</p>

<ol>
<li><code>notificationObserver</code>不能为nil</li>
<li><code>notification Selector</code>回调方法有且只有一个参数(<code>NSNotification</code>对象)</li>
<li>如果<code>notificationName</code>为<code>nil</code>，则会接收所有的通知(如果<code>notificationSender</code>不为空，则接收所有来自于<code>notificationSender</code>的所有通知)</li>
<li>如果<code>notificationSender</code>为<code>nil</code>，则会接收所有<code>notificationName</code>定义的通知；否则，接收由<code>notificationSender</code>发送的通知</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的</li>
</ol>

<h3 id="toc_2">post通知</h3>

<pre><code class="language-objc">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;First&quot; object:@&quot;博客园-Fly_Elephant&quot;];
-(void)notificationFirst:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
}
//名称:First----对象:博客园-Fly_Elephant

[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;Second&quot; object:@&quot;http://www.cnblogs.com/xiaofeixiang&quot; userInfo:dict];
-(void)notificationSecond:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSDictionary  *dict=[notification userInfo];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
    NSLog(@&quot;获取的值:%@&quot;,[dict objectForKey:@&quot;key&quot;]);
}
//名称:Second----对象:http://www.cnblogs.com/xiaofeixiang
//获取的值:keso
</code></pre>

<h2 id="toc_3">通知原理</h2>

<p>单例的方式创建一个<code>NSNotificationCenter</code>对象<br/>
对象注册观察者时 将注册的<code>name</code> <code>selector</code> <code>object</code> 作为一个模型 添加到一个数组中</p>

<p>post时根据名字和object 找到数组中注册的对象 执行通知的方法</p>

<h2 id="toc_4">多线程</h2>

<p>在多线程应用中，<code>Notification</code>在哪个线程中<code>post</code>，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。<br/>
也就是说，<code>Notification</code>的发送与接收处理都是在同一个线程中.</p>

<h2 id="toc_5">通告队列 NSNotificationQueue</h2>

<p><code>NSNotificationQueue</code> 作用是充当通告中心(<code>NSNotificationCenter</code>)的缓冲区,以FIFO的顺序进行维护。当一个通告上升到队列最前时，就将他发送给通告中心，通告中心随后将它派发给所有注册为观察者的对象</p>

<p>参考<a href="http://www.jianshu.com/p/b4835026e8e9">NSNotification&amp;NSNotificationCenter(实现原理,多线程,内存管理角度)</a><br/>
参考<a href="http://www.cnblogs.com/heyonggang/p/3681689.html">iOS NSNotification的使用</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数 Functions]]></title>
    <link href="https://acefish.github.io/14986177362678.html"/>
    <updated>2017-06-28T10:42:16+08:00</updated>
    <id>https://acefish.github.io/14986177362678.html</id>
    <content type="html"><![CDATA[
<p>在<code>Swift</code>中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型。可以把函数类型当做任何其他<br/>
普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数<br/>
的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>

<h2 id="toc_0">函数的定义与调用</h2>

<pre><code class="language-swift">func greet(person: String) -&gt; String {
    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;
    return greeting
}
</code></pre>

<p>定义一个函数,以<code>func</code>为前缀，定义了一个输入参数一个叫<code>person</code>的<code>String</code>值，用<code>-&gt;</code>来指定函数返回类型一个<code>String</code>类型返回值</p>

<blockquote>
<p><code>print(_:separator:terminator:)</code>这个函数第一个参数为<code>_</code>即并没有设置标签,其他参数设置了标签并且有默认值因此是可选的 </p>
</blockquote>

<h2 id="toc_1">函数参数与返回值</h2>

<p>在函数参数名称为<code>_</code>即不设置名称 </p>

<h3 id="toc_2">无参函数</h3>

<pre><code class="language-swift">func sayHelloWorld() -&gt; String {
    return &quot;hello, world&quot;
}
print(sayHelloWorld())
// 打印 &quot;hello, world&quot;
</code></pre>

<p><strong>注意:</strong><br/>
即使这个函数没有参数,但是定义中在函数名后还是<strong>需要一对圆括号</strong>。当被调用时，也需要<strong>在函数名后写一对圆括号</strong>与C语言函数相同</p>

<h3 id="toc_3">多参函数</h3>

<pre><code class="language-swift">func greet(person: String, alreadyGreeted: Bool) -&gt; String {
    if alreadyGreeted {
        return greetAgain(person: person)
    } else {
        return greet(person: person)
    }
}
print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))
// 打印 &quot;Hello again, Tim!&quot;
</code></pre>

<p>传递多个参数,之前用<code>,</code>隔开,这个函数与前面函数虽然名称相同 但是参数不同因此是不同的两个函数</p>

<blockquote>
<p>重载:指两个函数的函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同<br/>
OC不完全支持重载,即OC支持参数个数不同的函数重载,Swift是完全支持重载的</p>
</blockquote>

<h3 id="toc_4">无返回值函数</h3>

<pre><code class="language-swift">func greet(person: String) {
    print(&quot;Hello, \(person)!&quot;)
}
greet(person: &quot;Dave&quot;)
// 打印 &quot;Hello, Dave!&quot;
</code></pre>

<blockquote>
<p>虽然没有定义返回值,其实返回了一个特殊的<code>Void</code>值,这是<strong>一个空的元组</strong>，没有任何元素,可以写为()</p>
</blockquote>

<h3 id="toc_5">多重返回值函数</h3>

<p>我们可以用元组让多个值作为一个复合值从函数中返回</p>

<pre><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
// 打印 &quot;min is -6 and max is 109&quot;
</code></pre>

<blockquote>
<p>我们在返回元组时不需要给元组命名，因为它们的名字在函数返回类型中就已经确定了</p>
</blockquote>

<h3 id="toc_6">可选元组返回值</h3>

<p>如果函数返回的元组类型有可能整个元组都“没有值”,可以使用可选元组返回类型来说明元组可能为<code>nil</code></p>

<blockquote>
<p>注意 可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
</blockquote>

<p>对于上面的数组我们添加一个空数组检查,当传入的数组为空时返回<code>nil</code>:</p>

<pre><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

//用可选类型绑定来检查函数返回的是一个存在的元组还是一个nil
if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
}
// 打印 &quot;min is -6 and max is 109&quot;

</code></pre>

<h2 id="toc_7">函数参数标签和参数名称</h2>

<p>每个函数参数都有一个<code>参数标签</code>以及一个<code>参数名称</code>.<br/>
<code>参数标签</code>在调用函数的时候使用:调用时需要将函数的参数标签写在对应参数前<br/>
<code>参数名称</code>在函数的实现中使用。默认,函数参数使用参数名称来作为参数标签</p>

<h3 id="toc_8">指定参数标签</h3>

<p>在参数名称前指定它的参数标签，中间以空格分隔:</p>

<pre><code class="language-swift">//参数标签使函数在调用时更有表达力,保持可读性
//argumentLabel参数标签  parameterName参数名称
func someFunction(argumentLabel parameterName: Int) {
    // 在函数体内，parameterName 代表参数值
}
func greet(person: String, from hometown: String) -&gt; String {
    return &quot;Hello \(person)! Glad you could visit from \(hometown).&quot;
}
print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))
</code></pre>

<h3 id="toc_9">忽略参数标签</h3>

<p>我们用下划线来忽略 不设置参数标签</p>

<pre><code class="language-swift">func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值
}
someFunction(1, secondParameterName: 2)
</code></pre>

<blockquote>
<p>如果一个参数有标签,那么在调用时必须使用标签来标记这个参数</p>
</blockquote>

<h3 id="toc_10">默认参数值</h3>

<p>可以在函数体重通过给参数赋值来为任意一个参数定义默认值. 如果定义了默认值，可以在调用这个函数时忽略这个参数:</p>

<pre><code class="language-swift">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    // 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault = 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12
</code></pre>

<p>我们通常将不带默认值的参数放在函数参数列表最前。因为一般没有默认值参数更重要，将不带默认值的参<br/>
数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更<br/>
为清晰。</p>

<h3 id="toc_11">可变参数</h3>

<p>通过在变量类型名后加上<code>...</code>的方式来定义可变参数<br/>
可变参数可以接受零个或多个值,我们用其来指定函数传入不确定数量的输入值</p>

<p>我们在函数体中将可变参数传入值变为数组来使用</p>

<pre><code class="language-swift">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// 返回 3.0, 是这 5 个数的平均数。
arithmeticMean(3, 8.25, 18.75)
// 返回 10.0, 是这 3 个数的平均数。
</code></pre>

<blockquote>
<p>一个函数最多只能有一个可变参数</p>
</blockquote>

<h3 id="toc_12">输入输出参数</h3>

<p>参考<a href="http://www.csdn.net/article/2015-01-20/2823635-swift-pointer">Swift中的指针操作及使用</a></p>

<p>函数参数默认为常量,因此在函数体中修改会导致编译错误。如果想要在函数中修改某个参数值,并且这些修改在函数调用后仍然有效，那么需要把这个参数定义为输入输出参数</p>

<p>在参数定义前加上<code>inout</code>关键字来定以输入输出参数，这个值被函数修改然后被传出函数替换原来的值.</p>

<p>只能传递变量给输入输出参数,不能传入常量或字面量，调用时当传入的参数作为输入输出参数时,需要在参数名前加<code>&amp;</code>表示这个值可被修改</p>

<blockquote>
<p>输入输出参数不能有默认值，而且可变参数不能用<code>inout</code>标记</p>
</blockquote>

<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)
// 打印 &quot;someInt is now 107, and anotherInt is now 3&quot;
</code></pre>

<p><strong>可以参考C语言中函数的 指针参数</strong></p>

<h2 id="toc_13">函数类型</h2>

<p>每个函数都有 由<code>函数的参数类型</code>和<code>返回类型</code> 组成<code>函数类型</code></p>

<pre><code class="language-swift">func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    return a + b
}
</code></pre>

<p>函数类型为<code>(Int, Int) -&gt; Int</code></p>

<pre><code class="language-swift">func printHelloWorld() {
    print(&quot;hello, world&quot;)
}
</code></pre>

<p>函数类型为<code>() -&gt; Void</code></p>

<h3 id="toc_14">函数类型的使用</h3>

<p>在<code>Swift</code>中使用函数类型和使用其他类型一样。</p>

<pre><code class="language-swift">var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</code></pre>

<p>定义一个类型是‘一个有两个Int型的参数并返回一个Int型的值的<code>mathFunction</code>变量，指向<code>addTwoInts</code>函数</p>

<p>函数类型与其他类型一样可以通过赋值让<code>Swift</code>推断其函数类型</p>

<h3 id="toc_15">函数类型作为参数类型</h3>

<pre><code class="language-swift">func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print(&quot;Result: \(mathFunction(a, b))&quot;)
}

//调用
printMathResult({ (a, b) -&gt; Int in
    return a*b
}, 10, 20)
</code></pre>

<p><code>printMathResult(_:_:_:)</code>函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得<code>printMathResult(_:_:_:)</code>能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>

<h3 id="toc_16">函数类型作为返回类型</h3>

<p>我们可以将函数类型作为另一个函数的返回类型</p>

<pre><code class="language-swift">func stepForward(_ input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(_ input: Int) -&gt; Int {
    return input - 1
}

func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    return backward ? stepBackward : stepForward
}

//执行
var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
// moveNearerToZero 现在指向 stepBackward() 函数。
</code></pre>

<p>上面例子获取一个整形接近0应该用的函数</p>

<pre><code class="language-swift">print(&quot;Counting to zero:&quot;)
// Counting to zero:
while currentValue != 0 {
    print(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// 3...
// 2...
// 1...
// zero!
</code></pre>

<h2 id="toc_17">嵌套函数</h2>

<p>前面定义的所有函数都为<code>全局函数</code><br/>
我们可以把函数定义在其他函数中,这就是<code>嵌套函数</code><br/>
默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>

<blockquote>
<p>OC中是不支持在一个函数中定义另外一个函数</p>
</blockquote>

<p>我们用返回嵌套方式重写<code>chooseStepFunction(backward:)</code>函数</p>

<pre><code class="language-swift">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    //我们在函数中定义另外函数
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    //返回嵌套函数
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
while currentValue != 0 {
print(&quot;\(currentValue)... &quot;)
currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// -4...
// -3...
// -2...
// -1...
// zero!
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络通信]]></title>
    <link href="https://acefish.github.io/14982190720101.html"/>
    <updated>2017-06-23T19:57:52+08:00</updated>
    <id>https://acefish.github.io/14982190720101.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">TCP/IP五层模型</h2>

<p><img src="media/14982190720101/14982758829850.jpg" alt=""/><br/>
<code>TCP/IP协议五层模型</code>中的应用层对应<code>网络七层模型</code>中的第五层、第六层和第七层的功能</p>

<ul>
<li>应用层:对应应用程序的通信服务  如HTTP,FTP,NFS,SMTP</li>
<li>传输层:是否选择差错恢复协议还是无差错恢复协议，在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。 如TCP UDP</li>
<li>网络层:主要为数据包寻找路由(路由寻址),为了适应最大传输单元长度(MTU)小于包长度的传输介质，网络层还定义了如何分包 ,路由器</li>
<li>数据链路层:传输有地址的帧 ，以太网交换机等 数据成帧后通过差错控制提供数据帧在信道上无差错的传输</li>
<li>物理层:数据传输的物理媒介</li>
</ul>

<p>应用层用于识别数据内容,通过遵循应用层协议(HTTP、FTP或者我们自己定义的协议等)可以识别数据,使数据有意义</p>

<p>TCP/IP协议还提供一项名为UDP（用户数据报协议)<br/>
TCP：面向连接、传输可靠、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br/>
UDP：面向非连接(是指在正式通信前不必与对方先建立连接，不管对方状态就直接发送)、传输不可靠、用于传输少量数据(数据包模式)、速度快。</p>

<p>//UDP传输层传输的示意图<br/>
<img src="media/14982190720101/14982727461179.png" alt=""/></p>

<p>UDP端口对于基于UDP的通信作为单一消息队列和网络端点来操作，而所有TCP通信的终点都是唯一的连接。每个TCP连接由两个端点唯一识别。由于所有TCP连接由两对 IP 地址和TCP端口唯一识别（每个所连主机都有一个地址/端口对），因此每个TCP服务器端口都能提供对多个连接的共享访问</p>

<h2 id="toc_1">TCP的长连接和短连接</h2>

<p>在利用TCP协议开始通讯前,需要客户端和服务端进行<code>三次握手</code>来建立连接,而在结束通信后需要由<code>四次握手</code>来释放连接</p>

<h3 id="toc_2">TCP短连接&amp;&amp;长连接</h3>

<p>短连接即建立连接后,<code>client</code>向<code>server</code>发送消息,<code>server</code>收到消息回应<code>client</code> 然后完成了一次读写通信后,这时候双方都可以进行<code>close</code>操作,一般由客户端进行断开连接的操作,因此短连接只进行一次传递读写的操作</p>

<p>长连接是在建立连接,进行读写之后并不会主动关闭连接,后续仍然使用这个连接来进行读写</p>

<h3 id="toc_3">维护长连接</h3>

<p>我们在应用中创建一个长连接，这个长连接并没有确切时间限制,而是说这条连接需要时间较长<br/>
通常我们在应用中对网络通信的实时性要求较高,需要及时知道已经断开的连接进行及时处理,因此我们需要手工来进行不断探测</p>

<h4 id="toc_4">1.应用层使用心跳包</h4>

<p>一般在一个心跳间隔,客户端发送一个特定<code>ping</code>消息到服务器,服务器返回消息完成一次心跳交互,等待下一轮.如果客户端没有收到心跳反馈就会关闭掉<code>TCP</code>连接,心跳周期一般设置为几分钟,比如微信为300S</p>

<p>心跳机制可以由客户端和服务器两端都可以发送心跳包，两端也都可以监测, 一般为客户端发送心跳包服务器监测,如果在一个心跳周期没有收到心跳反馈可以断开连接(或者没有收到反馈后再发送几次ping包确定没有收到反馈后即断开连接)  而服务器一般在心跳间隔的1.5周期没有收到客户端的心跳包可以选择断开连接，当然具体情况视应用具体需求而定</p>

<h4 id="toc_5">2.TCP/IP协议层面的心跳机制</h4>

<p><strong>TCP保活功能:</strong><br/>
保活功能<code>主要为服务器</code>应用提供，用来检测客户端主机是否已经崩溃,如果客户端主机已经消失,那么服务器上这个连接就成为了半开放连接,而保活功能就是用来检测这种半开放连接的:<br/>
如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机处于以下4个状态之一：</p>

<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ol>

<p>TCP的心跳机制即为利用上面说的保活功能使两小时后发现TCP连接是否存在,如果想要使时间减少就需要修改内核方面参数,这种方式是很不合适的</p>

<h2 id="toc_6">socket编程</h2>

<p><code>socket</code>也称为<strong>套接字</strong>,用于描述IP地址和端口,实现不同主机间通信,IP地址和端口确定一个socket</p>

<blockquote>
<p>端口:用于区分不同应用服务,比如<code>HTTP</code>或者<code>FTP</code>等,然后可以根据应用协议来解析数据</p>
</blockquote>

<p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层，对<code>TCP/IP</code>进行了封装，这就是<code>Socket编程接口</code>,程序员通过其进行网络开发.</p>

<blockquote>
<p>HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力</p>
</blockquote>

<p><img src="media/14982190720101/14984586168116.jpg" alt=""/></p>

<p>在<code>Internet</code>上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个<code>Socket</code>，并绑定到一个端口上，不同的端口对应于不同的服务。</p>

<p><img src="media/14982190720101/14982205873836.jpg" alt=""/></p>

<h2 id="toc_7">常用应用层协议</h2>

<p><strong>应用层协议 :规定了客户端和服务器之间的数据传输格式</strong></p>

<h3 id="toc_8">1.HTTP</h3>

<h4 id="toc_9">长连接&amp;&amp;短连接</h4>

<p>HTTP为应用层协议,在传输层使用TCP协议，在网络使用IP协议<br/>
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br/>
HTTP的长连接和短连接本质就是TCP的长连接和短连接,http通过tcp三次握手建立连接<br/>
在HTTP/1.0中默认使用短连接，每进行一次HTTP操作就建立一次连接,结束就中断<br/>
从HTTP/1.1开始，默认使用长连接来保持连接特性,使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code>,可以在一次连接中处理多个请求，可以重叠进行<br/>
<code>Keep-Alive</code>并不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如<code>Apache</code>）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<blockquote>
<p>注意:这个alive 和 tcp的alive是不同的</p>
</blockquote>

<h4 id="toc_10">轮询</h4>

<p>分为短轮询和长轮询</p>

<p>短轮询:向服务器发送数据，服务器返回结果,不断的操作就是轮询,缺点是浪费了大量资源<br/>
优点：后端程序编写比较容易。 <br/>
缺点：请求中有大半是无用，浪费带宽和服务器资源。 <br/>
实例：适于小型应用。</p>

<p>长轮询：解决了短轮询的问题,长轮询的操作是:前段发送请求给后端，后台收到请求后并不及时返回,加入后台数据没有更新,就将请求挂起来直到有消息返回才返回响应信息并关闭连接,这样就不会频繁请求堵塞服务器<br/>
优点：在无消息的情况下不会频繁的请求，耗费资源小。 <br/>
缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 <br/>
实例：WebQQ、Hi网页版 <br/>
<img src="media/14982190720101/14985257353004.png" alt=""/></p>

<h3 id="toc_11">2.WebSocket</h3>

<p>在上面介绍的HTTP的轮询方式是非常浪费资源的,因为HTTP的header非常长,我们频繁发送一个很小的数据却占用了大量带宽,因此我们可以用<code>webSocket</code>代替</p>

<p><code>WebSocket</code>是应用层协议，是<code>html5</code>一种新的协议。它<strong>实现了浏览器与服务器全双工通信</strong></p>

<p>WebSocket建立连接过程:<br/>
1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行<br/>
2. TCP连接成功后，浏览器通过<code>HTTP协议</code>向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）<br/>
3. 服务器收到客户端的握手请求后，同样采用<code>HTTP协议</code>回馈数据。<br/>
4. 当收到了连接成功的消息后，通过TCP通道进行传输通信</p>

<blockquote>
<p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的<br/>
<code>WebSocket</code>是一种双向通信协议，在建立连接后，<code>WebSocket</code>服务器和<code>Browser/Client Agent</code>都能主动的向对方发送或接收数据，就像<code>Socket</code>一样;</p>
</blockquote>

<p>存在问题:<br/>
<code>webSockets</code>虽然是实现了长连接，但是如果客户端与服务端长时间没有发送数据，那么网络链路就会认为这个连接已经失效，会自作主张的将其断开，因此需要发送心跳包</p>

<p>iOS端使用webSocket：<br/>
<a href="http://www.cocoachina.com/ios/20161031/17886.html">接入WebSocket记录</a></p>

<h2 id="toc_12">iOS中网络编程</h2>

<h3 id="toc_13">iOS网络层次</h3>

<p>iOS网络编程层次结构分为三层:<br/>
Cocoa层：NSURL，Bonjour，Game Kit，WebKit<br/>
Core Foundation层：基于C的CFNetwork 和 CFNetServices<br/>
OS层:基于C的 BSD socket</p>

<p><code>Bonjour</code>封装了<code>CFNetwork</code>,Bonjour中的<code>NSNetService</code>也有对应底层实现<code>CFNetService</code>，<code>NSInputStream</code>有对应的底层实现<code>CFInputStream</code></p>

<p><code>Bonjour</code>是一种能够自动查询接入网络中的设备或应用程序的协议，抽象ip和port为<code>service</code>，一个应用程序<code>publish</code>一个网络服务<code>service</code>然后网络中的其他程序就能自动发现这个<code>service</code>，从而可以向这个<code>service</code>查询其<code>ip</code>和<code>port</code>，然后通过获得的<code>ip</code>和<code>port</code>建立 <code>socket</code>链接进行通信。通常我们是通过<code>NSNetService</code>和<code>NSNetServiceBrowser</code>来使用 <code>Bonjour</code>的，前者用于建立与发布<code>service</code>，后者用于监听查询网络上的<code>service</code>。<br/>
不多做介绍,深入学习可以参考<a href="http://www.cnblogs.com/kesalin/archive/2011/09/15/cocoa_bonjour.html">深入浅出Cocoa之Bonjour网络编程</a></p>

<h3 id="toc_14">iOS中应用限制</h3>

<p>Apple为了让设备尽量省电，减少不必要的开销，保持系统流畅除了特殊的官方程序外是不会让程序在后台无限执行的,开发者开发的程序收到以下限制:</p>

<p>按下<code>home</code>将应用转为后台运行后,app后台运行时间有限（可以通过<code>backgroundTimeRemaining</code>属性来获取这个可用时间）(<code>拥有180s运行时间可以处理后台操作</code>), 时间结束后我们的程序在程序会进入挂起状态，这种状态下应用不会执行任何代码、关闭定时器、系统会收回给程序分配的<code>socket</code>资源</p>

<p>我们只能通过苹果提供的几种特殊后台方式来进行程序的“后台”工作</p>

<ol>
<li><p>进入后台后前若应用还有未完成任务,可以申请有限时间(最多不超过10分钟)来完成重要任务<br/>
当10分钟到了后会，无论怎么向系统申请继续后台，系统会强制挂起App，挂起所有后台操作、线程，直到用户再次点击App之后才会继续运行。</p>

<pre><code class="language-objc">- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void (^)(void))handler
//返回一个新的后台任务的唯一的标示符，你必须将这个值传给endBackgroundTask:方法来标记任务的结束。如果无法在后台运行这个方法将返回UIBackgroundTaskInvalid。
//handle回调是在时间快到了执行,防申请到的时间片段内，还是没能完成任务的话，做最后的清理和标注工作,如果不传的话，那么结果就是iOS直接kill掉你的APP
</code></pre>

<p>必须在任务执行结束时，调用<code>endBackgroundTask</code>并传递这个标示符，来结束后台任务。</p></li>
<li><p>iOS为特殊任务设计的后台模式</p></li>
</ol>

<p>后台下载任务：<br/>
<code>Background Downloading</code> <strong>后台下载</strong>,必须使用 iOS 指定的机制才可以，那就是 <code>NSURLSession</code></p>

<p>后台运行的特定服务类型<br/>
    <img src="media/14982190720101/14990618979269.jpg" alt=""/></p>

<pre><code>1. 应用在后台播放或者录制音频
2. APP更新GPS信息，通知给用户
3. `voip` 网络电话功能
4. 杂志应用,在后台下载杂志并处理(用通知触发后台下载任务)
5. 一些控制外设的app，需要不停与外设沟通.系统就不会主动关闭 APP 与 外设之间的连接，而是替
    APP 监视这个连接，但有数据过来时，会唤醒 APP 进行处理，每次唤醒 APP 只有 10S 时间
    进行数据处理(不够的话还使用上面的方法申请更多时间)
6. iPhone作为蓝牙中心设备，需要不停更新蓝牙设备
7. iphone作为蓝牙外围设备，需要不停访问其他蓝牙设备数据
8. 需要在后台频繁有规律获取数据,统在你的 APP 进入后台后，会间隔性的给机会将你的 APP 唤醒，
   并回调你的 委托方法`application:performFetchWithCompletionHandler:`
9. App后台关注推送,推送到达时，后台启动app：服务端推送加上键值对content-available = 1的
   话, 手机收到这个通知后，会自动启动 APP 到后台，或 唤醒（依旧保持后台执行），并回调 委托
   方法 application:didReceiveRemoteNotification:fetchCompletionHandler:
</code></pre>

<p>详细设计可参考<a href="http://dxjia.cn/2016/05/26/ios-background-executions/?utm_source=tuicool&amp;utm_medium=referral">iOS 后台任务设计指导</a></p>

<h2 id="toc_15">补充：</h2>

<h3 id="toc_16">WebService</h3>

<p><code>Web Service</code>是一种可以接收从<code>Internet</code>或者<code>Intranet</code>上的其它系统中传递过来的请求，轻量级的独立的通讯技术。<br/>
WebService是一种跨编程语言和跨操作系统平台的远程调用技术</p>

<p>远程调用就是:一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法。 例如百度等把自己的系统服务以<code>webservice</code>服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能</p>

<p>可以从多个角度来理解<code>WebService</code>，从表面上看，<code>WebService</code>就是一个应用程序向外界暴露出一个能通过<code>Web</code>进行调用的<code>API</code>,能用编程的方法通过Web来调用这个应用程序,那么提供这个<code>WebService</code>的应用程序就是服务端。从深层次看，<code>WebService</code>是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在<code>Web</code>上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写<code>WebService</code>，只要我们可以通过<code>WebService</code>标准对这些服务进行查询和访问。</p>

<p>为了分布式应用程序的创建,必须要有一套标准的类型系统,需要标准的描述语言来描述webService让开发者可以获取信息，最后还需要有一个方法对这个<code>WebService</code>进行远程调用即远程调用协议(RPC)，为了达到跨语言跨平台目的这个RPC还需要和平台语言无关</p>

<ol>
<li>XML+XSD
WebService采用HTTP协议传输数据，采用XML格式封装数据，
<code>XSD</code>即 <code>XML Schema</code> 是定义了XML的标准数据类型.WebService平台就是用XSD来作为其数据类型系统的。</li>
<li>SOAP（简单对象访问协议）
WebService采用HTTP协议传输数据，采用XML格式封装数据，并且增加了一些特定的HTTP消息头来说明消息的内容格式，这些特定的HTTP消息头和XML内容格式就是<code>SOAP协议</code>。SOAP提供了标准的RPC方法来调用Web Service。
<code>SOAP协议 = HTTP协议 + XML数据格式</code>
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。</li>
<li>WSDL（Web服务描述语言）
WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么。<code>WSDL</code>文件是一个<code>XML</code>文档，用于描述Web Service及其函数、参数和返回值。
<a href="http://im.intreplus.com/wse/wsesmart.asmx">smartTouch WSDL</a></li>
</ol>

<p><code>WebService</code>服务提供商可以通过两种方式来暴露它的<code>WSDL</code>文件地址：1.注册到<code>UDDI</code>服务器，以便被人查找；2.直接告诉给客户端调用者。</p>

<p><code>WebService</code>的调用有3种方式：<br/>
1)httpget <br/>
2)httppost<br/>
3)httpsoap<br/>
<code>soap</code>的优点是 可以传递结构化的数据，而前两种不行</p>

<p>将数据直接用XML格式封装 因此不用担心编码，大小写等问题,传递数据可以是数组，对象等</p>

<p>但是由于要进行XML解析 因此会导致效率有所降低</p>

<h2 id="toc_17">参考连接:</h2>

<p><a href="http://blog.csdn.net/wwd0501/article/details/54582912">WebSocket介绍，与Socket的区别</a><br/>
<a href="http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html">Web 通信 之 长连接、长轮询</a><br/>
<a href="http://blog.csdn.net/prl18353364833/article/details/51593643">网络七层协议 五层模型</a><br/>
<a href="http://www.jianshu.com/p/49d7997ad3b7">Web Service到底是什么</a><br/>
<a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理</a><br/>
<a href="http://www.jianshu.com/p/121fc5b7f2d3">iOS Background Modes</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[控制流]]></title>
    <link href="https://acefish.github.io/14980952471508.html"/>
    <updated>2017-06-22T09:34:07+08:00</updated>
    <id>https://acefish.github.io/14980952471508.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">For-In循环</h2>

<p>可以用来遍历区间</p>

<pre><code class="language-swift">//遍历一个闭区间
for index in 1...5 {
    print(&quot;(index) times 5 is (index * 5)&quot;)
}
</code></pre>

<p><code>index</code>在每次遍历开始时是会自动赋值的<code>常量</code>,会隐式声明,不用使用关键字<code>let</code>进行声明</p>

<p>有时我们进行遍历,并不关心遍历出的值,只需要遍历的次数,这时候我们可以使用下划线<code>_</code>代替变量名忽略这个值</p>

<pre><code class="language-swift">//求 3的10次方 这时候我们不关心便利出来的值 只关系执行次数
let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
</code></pre>

<p>我们还可以使用<code>for-in</code>遍历 </p>

<ul>
<li>数组所有元素 </li>
<li>遍历一个字典访问键值对,键值对以元组形式返回,可以使用显示的常量名称解读<code>(key, value)</code></li>
<li>字符串中的字符(<code>greeting.characters.indices</code>，返回包含所有字符的range)</li>
</ul>

<h2 id="toc_1">While</h2>

<h3 id="toc_2">While</h3>

<p>循环开始时判断条件是否符合,<code>ture</code>执行循环的语句,<code>false</code>结束循环</p>

<pre><code class="language-swift">while square &lt; finalSquare {
    
}
</code></pre>

<h3 id="toc_3">Repeat-While</h3>

<p>与<code>while</code>的区别就是执行判断条件之前会首先执行一次循环的代码块(类似do-while)</p>

<pre><code class="language-swift">repeat {
    statements
} while condition
</code></pre>

<h2 id="toc_4">条件语句</h2>

<h3 id="toc_5">IF语句</h3>

<pre><code class="language-swift">let temperatureInFahrenheit = 90
if temperatureInFahrenheit &lt;= 32 {
    print(&quot;It&#39;s very cold. Consider wearing a scarf.&quot;)
} else if temperatureInFahrenheit &gt;= 86 {
    print(&quot;It&#39;s really warm. Don&#39;t forget to wear sunscreen.&quot;)
} else {
    print(&quot;It&#39;s not that cold. Wear a t-shirt.&quot;)
}
//也可以不要最后的else语句 这样有可能既不冷也不热,不会触发if和else if 也就不会打印任何消息
</code></pre>

<h3 id="toc_6">switch</h3>

<p>将某个值与一个或多个同类型的值作比较</p>

<pre><code class="language-swift">switch some value to consider {
case value 1:
    respond to value 1
case value 2,
    value 3:
    respond to value 2 or 3
default:
    otherwise, do something else
}
</code></pre>

<p>完备性:<br/>
对于<code>switch</code>语句每个可能的值,需要至少一个<code>case</code>分支与之对应,对于某些没办法用<code>case</code>覆盖所有分支的情况,可以通过在最后加上<code>default</code>分支来涵盖其他没有对应的值</p>

<h4 id="toc_7">隐式break</h4>

<p>与OC中的<code>switch</code>语句不同,即使在<code>case</code>语句后没有break 也在执行<code>case</code>分钟的代码执行完毕后终止<code>switch</code>语句的执行，不会继续执行下一个<code>case</code>分支</p>

<p>注意:<br/>
<code>case</code>分支中都至少包含一条语句</p>

<pre><code class="language-switch">//case分支后至少需要一条语句 下面这种写法是错误的
let anotherCharacter: Character = &quot;a&quot;
switch anotherCharacter {
case &quot;a&quot;: // 无效，这个分支下面没有语句
case &quot;A&quot;:
    print(&quot;The letter A&quot;)
default:
    print(&quot;Not the letter A&quot;)
}
//此时如果想case&quot;a&quot;分支什么都不执行 可以直接执行一条break语句
</code></pre>

<p>此时如果我们想<code>&quot;a&quot;和&quot;A&quot;</code>都执行<code>print(&quot;The letter A&quot;)</code>可以将两个值组合为一个复合匹配</p>

<pre><code class="language-swift">let anotherCharacter: Character = &quot;a&quot;
switch anotherCharacter {
case &quot;a&quot;, &quot;A&quot;:
    print(&quot;The letter A&quot;)
default:
    print(&quot;Not the letter A&quot;)
}
//为了可读性 可以写为多行形式
case &quot;a&quot;,
     &quot;A&quot;
</code></pre>

<h4 id="toc_8">区间匹配</h4>

<p>case分支的匹配模式也可以是一个值的区间</p>

<pre><code class="language-swift">let approximateCount = 62
let countedThings = &quot;moons orbiting Saturn&quot;
var naturalCount: String
switch approximateCount {
case 0:
    naturalCount = &quot;no&quot;
case 1..&lt;5:
    naturalCount = &quot;a few&quot;
case 5..&lt;12:
    naturalCount = &quot;several&quot;
case 12..&lt;100:
    naturalCount = &quot;dozens of&quot;
case 100..&lt;1000:
    naturalCount = &quot;hundreds of&quot;
default:
    naturalCount = &quot;many&quot;
}
print(&quot;There are \(naturalCount) \(countedThings).&quot;)
</code></pre>

<h4 id="toc_9">元组</h4>

<p>可以使用元组在同一个<code>switch</code>语句中测试多个值，元组中的元素可以是值,也可以是区间,也可以使用<code>_</code>(下划线)来匹配所有可能的值</p>

<pre><code class="language-swift">let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print(&quot;(0, 0) is at the origin&quot;)
case (_, 0)://下划线匹配所有值
    print(&quot;(\(somePoint.0), 0) is on the x-axis&quot;)
case (0, _):
    print(&quot;(0, \(somePoint.1)) is on the y-axis&quot;)
case (-2...2, -2...2)://区间匹配
    print(&quot;(\(somePoint.0), \(somePoint.1)) is inside the box&quot;)
default:
    print(&quot;(\(somePoint.0), \(somePoint.1)) is outside of the box&quot;)
}
// 输出 &quot;(1, 1) is inside the box&quot;
//（0,0）虽然符合所有分支模式 但是只有第一个case分支会执行
</code></pre>

<p>注意：</p>

<blockquote>
<p>与OC中的switch不同,swift中的case分支中的值是允许交叉的,即允许多个case匹配同一个值,但是只会执行第一个被匹配的case分支</p>
</blockquote>

<h4 id="toc_10">值绑定</h4>

<p>将匹配的值绑定到一个临时变量或常量,在<strong>case内部使用</strong></p>

<pre><code class="language-swift">let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print(&quot;on the x-axis with an x value of \(x)&quot;)
case (0, let y):
    print(&quot;on the y-axis with a y value of \(y)&quot;)
case let (x, y)://可以匹配所有分支
    print(&quot;somewhere else at (\(x), \(y))&quot;)
}
// 输出 &quot;on the x-axis with an x value of 2&quot;
</code></pre>

<pre><code class="language-swift">let somesPoint = (1, 1)
switch somesPoint {
case (let x, 0):
    print(&quot;X中上\(x)&quot;)
case (0, var y):
    print(&quot;Y中上\(y)&quot;)
case let defaultPint:
    print(defaultPint, defaultPint.0, defaultPint.1)
}
</code></pre>

<h4 id="toc_11">Where</h4>

<p><code>case</code>分支的模式可以使用<code>where</code>语句来判断额外的条件</p>

<pre><code class="language-swift">let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
    case let (x, y) where x == y:
print(&quot;(\(x), \(y)) is on the line x == y&quot;)
    case let (x, y) where x == -y:
print(&quot;(\(x), \(y)) is on the line x == -y&quot;)
    case let (x, y):
print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)
}
// 输出 &quot;(1, -1) is on the line x == -y&quot;
</code></pre>

<h4 id="toc_12">复合匹配</h4>

<p>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个<code>case</code>后面，并且用逗号隔开。此时当<code>case</code>后任意模式匹配时,这个分支就会被匹配</p>

<pre><code class="language-swift">let someCharacter: Character = &quot;e&quot;
switch someCharacter {
case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:
    print(&quot;\(someCharacter) is a vowel&quot;)
    //匹配列表过长 可以分行写
case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,
&quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:
    print(&quot;\(someCharacter) is a consonant&quot;)
default:
    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)
}
// 输出 &quot;e is a vowel&quot;
</code></pre>

<pre><code class="language-swift">let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print(&quot;On an axis, \(distance) from the origin&quot;)
default:
    print(&quot;Not on an axis&quot;)
}
/**
    第一个case分之中,两个模式都值绑定了distance
*/
</code></pre>

<h2 id="toc_13">控制转移</h2>

<p>控制转移语句改变代码执行顺序,实现代码的跳转</p>

<h3 id="toc_14">Continue</h3>

<p>立即停止本次循环开始下次循环</p>

<pre><code class="language-swift">let puzzleInput = &quot;great minds think alike&quot;
var puzzleOutput = &quot;&quot;
for character in puzzleInput.characters {
    switch character {
        case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;:
        continue
    default:
        puzzleOutput.append(character)
    }
}
print(puzzleOutput) // 输出 &quot;grtmndsthnklk&quot;
//这里把continue换位break输出结果是一样的,因为continue会匹配为循环体，而break会匹配为switch语句结束执行,循环体还会继续执行下去
</code></pre>

<h3 id="toc_15">Break</h3>

<p>立刻结束控制流的执行，可以更早结束一个<code>switch</code>代码块或者一个循环体</p>

<h4 id="toc_16">循环中的break</h4>

<p>当在一个循环体中使用<code>break</code>时，会立刻中断该循环体的执行，后跳转到表示循环体结束的大括号<code>( } )</code>后的第一行代码，不会再有循环的代码被执行</p>

<h4 id="toc_17">Switch中的break</h4>

<p>在<code>Switch</code>中使用<code>break</code>时会立刻中断<code>switch</code>代码块的执行,跳转到表示 switch 代码块<br/>
结束的大括号<code>( } )</code>后的第一行代码</p>

<p>我们可以用其去忽略一个或多个分支,因为switch不允许有空分支,我们可以在分支语句中写为break,来立即结束市场代码块的执行</p>

<h3 id="toc_18">贯穿   fallthrough</h3>

<p><code>Swift</code>与C不同,<code>switch</code>不会从上一个<code>case</code>分支落入到下一个<code>case</code>分支中。<br/>
但是如果我们想要与C类似的贯穿的风格就需要加上关键字<code>fallthrough</code></p>

<pre><code class="language-swift">let integerToDescribe = 5
var description = &quot;The number \(integerToDescribe) is&quot;
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += &quot; a prime number&quot;
    fallthrough
case 10:
    description += &quot; , and also&quot;
    fallthrough
default:
    description += &quot; an integer.&quot;
}
print(description)
// 输出 &quot;The number 5 is a prime number, and also an integer.&quot;
</code></pre>

<p>在分支语句加上<code>fallthrough</code>关键字后,在执行完分支语句后会继续执行下面的分支，即贯穿到<code>default</code>分支</p>

<p>注意:<br/>
在加上<code>fallthrough</code>后是不会判断下面的<code>case</code>语句的匹配条件而直接执行其分支中的代码</p>

<blockquote>
<p>在C语言的switch语句中也是如果不加break时,那么执行完一条case语句后会直接执行下一条case分支代码,而不会判断分支条件,直到遇到break或者switch语句结束,这与swift中是一致的</p>
</blockquote>

<h3 id="toc_19">带标签的语句</h3>

<p>当有循环体和条件语句嵌套时,我们想要显式指明用break终止哪个循环体<br/>
当有多个循环体嵌套时,显示指明用continue开始哪个循环体的下次循环</p>

<p>这时候就需要 <strong>标签</strong></p>

<p>声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签,作为这个语句的前导关键字,该标签后面加上一个冒号。<br/>
<code>label name : while condition { statements } //对while循环体的标签</code></p>

<pre><code class="language-swift">gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // 骰子数刚好使玩家移动到最终的方格里，游戏结束。
        break gameLoop
    case let newSquare where newSquare &gt; finalSquare:
        // 骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子
        continue gameLoop
    default:
        // 合法移动，做正常的处理
        square += diceRoll
        square += board[square]
    }
}
print(&quot;Game over!&quot;)
</code></pre>

<p>我们用<code>标签+冒号+while循环</code>来声明循环为<code>gameLoop</code>，然后用<code>break 标签</code>或者<code>continue 标签</code>来避免break switch语句 而直接作用于循环体</p>

<h2 id="toc_20">提前退出  guard</h2>

<p>与<code>if</code>语句类似<code>guard</code>语句的执行取决于其后的一个bool条件,如果为真时直接执行<code>guard</code>语句后的代码,如果为假时执行<code>else</code>中的语句</p>

<p><strong>注意:</strong><br/>
条件不满足会执行<code>else</code>分支上的代码,这个分支这个分支必须转移控制以退出<code>guard</code>语句出现的代码段。可以使用控制转移语句如<code>return</code>, <code>break</code>, <code>continue</code>或者<code>throw</code>做这件事，或者调用一个不返回的方法或函数，例如<code>fatalError()</code>。</p>

<pre><code class="language-swift">func greet(person: [String: String]) {
    guard let name = person[&quot;name&quot;] else {
        return
    }
    print(&quot;Hello \(name)&quot;)
    guard let location = person[&quot;location&quot;] else {
        print(&quot;I hope the weather is nice near you.&quot;)
        return
    }
    print(&quot;I hope the weather is nice in \(location).&quot;)
}
greet(person: [&quot;name&quot;: &quot;John&quot;])
// 输出 &quot;Hello John!&quot;
// 输出 &quot;I hope the weather is nice near you.&quot;
greet(person: [&quot;name&quot;: &quot;Jane&quot;, &quot;location&quot;: &quot;Cupertino&quot;])
// 输出 &quot;Hello Jane!&quot;
// 输出 &quot;I hope the weather is nice in Cupertino.&quot;
</code></pre>

<h2 id="toc_21">检测API的可用性</h2>

<p><code>Swift</code>内置支持检查<code>API</code>可用性，可以确保我们不会在当前机器上使用不可用API，否则会在编译期间报错</p>

<p>为了判断代码在指定部署机器上是否可用,我们在<code>if</code>或<code>guard</code>中使用<code>可用性条件</code>去执行一段代码,在运行时有条件的执行一段代码，来在运行时判断调用的<code>API</code>是否可用</p>

<pre><code class="language-swift">if #available(iOS 10, macOS 10.12, *) {
    // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API
} else {
    // 使用先前版本的 iOS 和 macOS 的 API
}
</code></pre>

<p>最后的 <code>*</code> 是必须的用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。</p>

<p><code>#available()</code>一般使用<strong>平台名字</strong>(iOS,macOS,watchOS,tvOS)以及<strong>版本号</strong>（iOS 10 等）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集合类型]]></title>
    <link href="https://acefish.github.io/14978615246204.html"/>
    <updated>2017-06-19T16:38:44+08:00</updated>
    <id>https://acefish.github.io/14978615246204.html</id>
    <content type="html"><![CDATA[
<p><code>Swift</code>语言提供<code>Arrays</code>(有序数据集)、<code>Sets</code>(无序不重复数据集)和<code>Dictionaries</code>(无序键值对)三种基本的集合类型用来存储集合数据</p>

<p><code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确<br/>
Swift 的Arrays、Sets和Dictionaries类型被实现为<code>泛型集合</code>。</p>

<blockquote>
<p>数组类型<code>Array&lt;Int&gt;</code> 简化形式 <code>[Int]</code><br/>
集合类型<code>Set&lt;Int&gt;</code> 无简化形式<br/>
字典类型<code>Dictionary&lt;Int, String&gt;</code> 简化 <code>[Int: String]</code><br/>
Array继承<code>RangeReplaceableCollection</code>协议 因此可以使用我们前面说的<code>index索引</code>和<code>insert方法</code><br/>
创建空的集合数据 就是 <code>类型()</code></p>
</blockquote>

<h2 id="toc_0">集合可变性</h2>

<p>当集合为变量，集合是可变的,当不需要集合改变时建议创建为不可变的,有利于优化</p>

<h2 id="toc_1">数组Array</h2>

<p>存储同一类型值,可以重复</p>

<h3 id="toc_2">创建空数组</h3>

<pre><code class="language-swift">var someInts = [Int]()//创建空数组
通过构造函数的类型，数组可以推断为[Int]
//创建特定数据类型的空数组
var someInt1 = [[Int]]()//创建类型为整形数组的空数组
</code></pre>

<blockquote>
<p>数组的类型表达为 [Int]  表示一个类型为[Int]的数组</p>
</blockquote>

<pre><code class="language-swift">someInts.append(3)
//可以从上面推断出数组为Int类型数组,因此可以直接创建空数组
someInts = []
//直接创建空数组
</code></pre>

<h3 id="toc_3">带有默认值的数组</h3>

<p>创建特定大小并且所有数据都被默认构造数组方法</p>

<pre><code class="language-swift">var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]
</code></pre>

<h3 id="toc_4">通过两个数组相加创建一个数组</h3>

<p>可以用<code>+</code>将两种相同数据类型数组组合为一个新的数组,新的数组类型与这两个数组类型相同</p>

<h3 id="toc_5">用数组字面量构造数组</h3>

<p>用数组字面量来进行数组构造,这是用一个或者多个数值构造数组</p>

<pre><code class="language-swift">[value 1, value 2, value 3]
// shoppingList 已经被构造并且拥有两个初始项。
var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]
var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;] //可以不用声明类型 可以推断为String类型
</code></pre>

<h3 id="toc_6">访问和修改数组</h3>

<p>1.使用数组的只读<code>count</code>属性来获取数组中数据项数量<br/>
2.用布尔<code>isEmpty</code>检查数组是否为空 即<code>count</code>属性是否为<code>0</code><br/>
3.使用<code>append(_:)</code>方法在数组后添加一个新的数组项</p>

<pre><code class="language-swift">shoppingList.append(&quot;Flour&quot;) //只能添加一项
</code></pre>

<p>4.用加法赋值运算符<code>+=</code>在数组后添加一个或多个相同类型数据项<br/>
<code>shoppingList += [&quot;Chocolate Spread&quot;, &quot;Cheese&quot;, &quot;Butter&quot;]</code><br/>
5.用下标来获取数组中数据项</p>

<pre><code class="language-Swift">var firstItem = shoppingList[0]//获取数组中第一项
</code></pre>

<p>6.用下标改变一个或多个下标索引对应色数据值</p>

<pre><code class="language-Swift">shoppingList[0] = &quot;Six eggs&quot;//

shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]//改变一系列值 即使新数据和原有数据的数量不一致
</code></pre>

<blockquote>
<p>不能用下标访问的形式在数组尾部添加新项</p>
</blockquote>

<p>7.用<code>insert(_:at:)</code>方法在某个索引之前添加新的数据项</p>

<p>8.移除<br/>
使用<code>remove(at:)</code>方法来移除数组中的某一项</p>

<pre><code class="language-swift">//移除下标索引为0的数据项
let mapleSyrup = remove(at: 0)
//返回值 mapleSyrup 等于被移除的数据项值&quot;Maple Syrup&quot;
</code></pre>

<p><code>removeLast()</code>移除数组最后一项(使用这个方法可以避免我们去用count属性获取数组最后一个下标)</p>

<blockquote>
<p>运行期可以自动检查是否发生数组越界</p>
</blockquote>

<h3 id="toc_7">遍历数组</h3>

<p>用<code>for-in</code>进行遍历</p>

<pre><code class="language-swift">for item in shoppingList {
    print(item)//单独的变量或常量可以直接print
}
</code></pre>

<p>如果想要在遍历时获取每个数据项的索引和值,可以用数组的<code>enumerated()</code>，它会返回由索引和数组值组成的元组</p>

<pre><code class="language-swift">for (index, value) in shoppingList.enumerated() {
    print(&quot;Item \(String(index + 1)): \(value)&quot;)
}
/*
    shoppingList.enumerated()返回就是一个sorted后 以元组形式返回
*/
</code></pre>

<blockquote>
<p>数组也继承了<code>collection</code>协议</p>
</blockquote>

<h2 id="toc_8">集合Set</h2>

<p>存储相同类型并且没有确定顺序的值</p>

<h3 id="toc_9">集合类型的哈希值</h3>

<p>一个类型为了存储在集合中，该类型必须是可哈希化的,即该类型必须提供一个方法来计算它的哈希值(哈希值是<code>Int</code>类型的)，相等对象的哈希值必须相同(<code>a==b因此a.hashValue == b.hashValue</code>).</p>

<p>Swift 的所有基本类型(比如<code>String , Int , Double 和 Bool</code>)默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值默认也是可哈希化的。</p>

<blockquote>
<p>为了使我们的自定义类型作为集合或者字典键的类型,需要使你的自定义类型符合<code>Hashable</code>协议.这个协议需要我们提供一个类型为<code>Int</code>的可读属性<code>hashValue</code>.<code>hashValue</code>属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。</p>

<p>因为<code>Hashable</code>协议符合<code>Equatable</code>协议，所以遵循该协议的类型也必须提供一个&quot;是否相等&quot;运算符(<code>==</code>)的实现。<br/>
<code>==</code>的实现必须满足以下三种情况:<br/>
* a == a (自反性)<br/>
* a == b 意味着 b == a (对称性)<br/>
* a == b &amp;&amp; b == c 意味着 a == c (传递性)</p>
</blockquote>

<h3 id="toc_10">集合类型写法/表达</h3>

<p>Swift 中的<code>Set</code>类型被写为 <code>Set&lt;Element&gt;</code>(<code>Element</code>表示<code>Set</code>中允许存储的类型)，它并没有类似数组的简化形式</p>

<h3 id="toc_11">空的集合</h3>

<pre><code class="language-swift">var letters = Set&lt;Character&gt;()
</code></pre>

<pre><code class="language-swift">letters.insert(&quot;a&quot;)//通过这 我们可以推断出为一个Set&lt;Character&gt;类型集合
letters = []//我们可以直接设置其为空的Set  其类型还是Set&lt;Character&gt; 
</code></pre>

<h3 id="toc_12">用数组字面量创建集合</h3>

<pre><code class="language-swift">//有三个初始值
var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>

<p>我们用数组字面量的形式初始化这个<code>Set</code>.我们从数组字面量没有办法推断出为<code>Set</code>类型,因此必须显示声明,但是可以推断出Set中元素类型,因此我们可以简化为</p>

<pre><code class="language-swift">var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
</code></pre>

<h3 id="toc_13">访问和修改一个集合</h3>

<p>1.只读属性<code>count</code>获取集合中个数</p>

<p>2.布尔属性<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为 0</p>

<p>3.<code>insert(_:)</code>方法来添加一个新元素</p>

<pre><code class="language-swift">favoriteGenres.insert(&quot;Jazz&quot;)
/**
    返回一个元组(inserted: Bool, memberAfterInserted: String)
*/
</code></pre>

<p>4.<code>remove(_:)</code>方法去删除一个元素 <code>removeAll()</code>删除所有元素</p>

<p>5.<code>contains(_:)</code>方法去检查<code>Set</code>中是否包含一个特定的值</p>

<pre><code class="language-swift">    if favoriteGenres.contains(&quot;Funk&quot;) {
        print(&quot;I get up on the good foot.&quot;)
    } else {
        print(&quot;It&#39;s too funky in here.&quot;)
    }
</code></pre>

<p>6.用<code>for-in</code>遍历</p>

<pre><code class="language-swift">    for genre in favoriteGenres {
        print(&quot;\(genre)&quot;)
    }
</code></pre>

<p><code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个<code>Set</code>中的值可以使用<code>sorted()</code>方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符<code>&#39;&lt;&#39;</code>对元素进行比较的结果来确定</p>

<pre><code class="language-swift">    for genre in favoriteGenres.sorted() {
        print(&quot;(genre)&quot;)
    }
</code></pre>

<blockquote>
<p>sorted()后返回的是数组<br/>
sorted()返回排序后数组 数据源不变 sort()不返回数组将数据源变为排序后的数组(Set没有这方法,Array有)</p>
</blockquote>

<h2 id="toc_14">集合操作</h2>

<h3 id="toc_15">基本集合操作</h3>

<p>用<code>intersection(_:)</code>计算两个集合相交部分<br/>
用<code>symmetricDifference(_:)</code>计算两个集合中不同部分<br/>
用<code>union(_:)</code>方法合并两个集合<br/>
用<code>subtracting(_:)</code>方法根据在本集合不在另外集合中的部分</p>

<pre><code class="language-swift">let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
oddDigits.union(evenDigits).sort()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
</code></pre>

<h3 id="toc_16">集合成员关系以及相等</h3>

<p>用<code>==</code>判断两个集合是否包含完全相同的值<br/>
用<code>isSubset(of:)</code>判断是不是两外一个集合的子集<br/>
用<code>isSuperset(of:)</code>判断另外一个集合是不是本集合的子集<br/>
用<code>isStrictSubset(of:)</code>或<code>isStrictSuperset(of:)</code>判断一个集合是否是另外一个集合的子集合或<br/>
者父集合并且两个集合并不相等<br/>
用<code>isDisjoint(with:)</code>判断两个集合是否没有交集（没有相同的值）</p>

<pre><code class="language-swift">let houseAnimals: Set = [&quot;?&quot;, &quot;?&quot;]
let farmAnimals: Set = [&quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;]
let cityAnimals: Set = [&quot;?&quot;, &quot;?&quot;]
houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
</code></pre>

<h2 id="toc_17">字典</h2>

<p>存储多个相同类型的值的容器</p>

<h3 id="toc_18">字典类型表达语法</h3>

<p><code>Swift</code>的字典使用<code>Dictionary&lt;Key, Value&gt;</code>定义，<code>Key</code>是键的类型,<code>Value</code>是值所对应的数据类型<br/>
<code>[Key: Value]</code>通常我们使用这种简化形式</p>

<blockquote>
<p>一个字典的 Key 类型必须遵循<code>Hashable</code>协议，就像<code>Set</code>的值类型,因为在字典中键也是唯一的,需要利用哈希值进行判断相等</p>
</blockquote>

<h3 id="toc_19">创建一个空字典</h3>

<pre><code class="language-swift">var namesOfIntegers = [Int: String]()//创建一个[Int: String] 类型的空字典
</code></pre>

<p>如果上下文已经知道类型信息</p>

<pre><code class="language-swift">namesOfIntegers = [:]//创建一个[Int: String] 类型的空字典
</code></pre>

<h3 id="toc_20">用字典字面量创建字典</h3>

<pre><code class="language-swift">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
//因为swift可以推断出为[String : String]类型 因此可以不同显示声明
var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
</code></pre>

<h3 id="toc_21">访问和修改字典</h3>

<p>1.只读属性<code>count</code>来获取字典的数据项数量</p>

<pre><code class="language-swift">print(&quot;The dictionary of airports contains (airports.count) items.&quot;)
// 打印 &quot;The dictionary of airports contains 2 items.&quot;（这个字典有两个数据项）
</code></pre>

<p>2.<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为 0 </p>

<p>3.可以在字典中使用下标语法来添加新的数据项<br/>
4.在字典中使用下标语法来改变特定键对应的值<br/>
<code>swift<br/>
airports[&quot;LHR&quot;] = &quot;London&quot;<br/>
//若不存在键&quot;LHR&quot; 即为添加新的数据项 否则为改变键对应值<br/>
</code><br/>
5.<code>updateValue(_:forKey:)</code>方法可以设置或者更新特定键对应的值(当存在键时即为更新值 否则为设置值)<br/>
<code>updateValue(_:forKey:)</code>方法会返回对应值的类型的可选值(因为可能没有oldvalue因此为可选类型)</p>

<pre><code class="language-swift">if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {
    print(&quot;The old value for DUB was (oldValue).&quot;)
}
// 输出 &quot;The old value for DUB was Dublin.&quot;
</code></pre>

<p>6.下标语法来在字典中检索特定键对应的值,因为可能不存在这个键，因此返回的为可选类型</p>

<pre><code class="language-swift">if let airportName = airports[&quot;DUB&quot;] {
    print(&quot;The name of the airport is (airportName).&quot;)
} else {
    print(&quot;That airport is not in the airports dictionary.&quot;)
}
</code></pre>

<p>7.通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对</p>

<pre><code class="language-swift">airports[&quot;APL&quot;] = &quot;Apple Internation&quot;
// &quot;Apple Internation&quot; 不是真的 APL 机场, 删除它
airports[&quot;APL&quot;] = nil
// APL 现在被移除了
</code></pre>

<p>8.<code>removeValue(forKey:)</code>也可以用来在字典中移除键值对<br/>
在键值对存在的情况下会移除该键值对并且返回被移除的值 或者在没有值的情况下返回<code>nil</code></p>

<pre><code class="language-swift">if let removedValue = airports.removeValue(forKey: &quot;DUB&quot;) {
    print(&quot;The removed airport&#39;s name is (removedValue).&quot;)
} else {
    print(&quot;The airports dictionary does not contain a value for DUB.&quot;)
}
</code></pre>

<h3 id="toc_22">字典遍历</h3>

<p><code>for-in</code>遍历字典中的键值对，字典中的数据项都以<code>(key, value)</code>元组形式返回</p>

<pre><code class="language-swift">for (airportCode, airportName) in airports {
    print(&quot;\(airportCode): \(airportName)&quot;)
}
</code></pre>

<p>通过访问<code>keys</code>或者<code>values</code>属性，我们也可以遍历字典的键或者值</p>

<pre><code class="language-swift">for airportCode in airports.keys {
    print(&quot;Airport code: (airportCode)&quot;)
}
for airportName in airports.values {
print(&quot;Airport name: (airportName)&quot;)
}
</code></pre>

<p>我们可以直接使用<code>keys</code>或者<code>values</code>属性构造一个新数组</p>

<pre><code class="language-swift">let airportCodes: [String] = airports.keys
// airportCodes 是 [&quot;YYZ&quot;, &quot;LHR&quot;]
let airportNames: [String] = airports.values
// airportNames 是 [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]
let airportCodes = airports.keys.sorted()

//创建键或者值的新数组
</code></pre>

<blockquote>
<p><code>Swift</code>的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的<code>keys</code>或<code>values</code>属性使用<code>sorted()</code>方法</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编码]]></title>
    <link href="https://acefish.github.io/14976139025239.html"/>
    <updated>2017-06-16T19:51:42+08:00</updated>
    <id>https://acefish.github.io/14976139025239.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">unicode码</h2>

<p>unicode码表示 <code>U+F8FF</code> 可以用 <code>\uF8FF</code>即为unicode编码 F8FF即为这个字符的16进制表示</p>

<p>多个字符的unicode码可以组合为一个新的字符 例如<code>\ud83c\udf49</code>可以组合为<code>🍉</code>,一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<p>补充:<br/>
注意:<br/>
 <code>Swift</code>与<code>OC</code>不同，swift中将每个字符都看作可扩展的字形群,因此对于é(&quot;\u{65}\u{301}&quot;)看作一个字符,而对于OC这是两个字符,而对两者说字符串长度就是字符的数量</p>

<blockquote>
<p>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式<br/>
可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数<br/>
量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一<br/>
个长字符串，需要注意<code>characters</code>属性必须遍历全部的<code>Unicode</code>标量，来确定字符串的字符数量。<br/>
另外需要注意的是<strong>通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的 <code>length</code>属性相同</strong>。 <strong>NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集</strong>。作为佐证，当一个 NSString的length属性被一个Swift的String值访问时，实际上是调用了<code>utf16Count</code></p>
</blockquote>

<h2 id="toc_1">获取字符串中字符的unicode码</h2>

<pre><code class="language-objc">//其16进制就是字符‘的’的unicode码
unichar character = [@“的” characterAtIndex:0];
</code></pre>

<p>对于上面说的🍉这种多个unicode码组合字符 其index0位置为d83c index1位置为df49 由两个字符组成</p>

<blockquote>
<p>iOS开发中用<code>unichar</code>是两字节长的<code>char</code>，代表<code>unicode</code>的一个字符</p>
</blockquote>

<pre><code class="language-objc">//将unicode码转为字符
NSLog(@&quot;%@&quot;,[NSString stringWithCharacters:&amp;character length:1]);
</code></pre>

<p>补充:<br/>
与<code>char</code>的初始化相同 unichar a = &#39;2&#39;可以用单引号初始化unichar<br/>
不论char还是iOS开发中用的unichar 只能用上面的初始化方法初始化字符为ascii码</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串和字符]]></title>
    <link href="https://acefish.github.io/14976096897839.html"/>
    <updated>2017-06-16T18:41:29+08:00</updated>
    <id>https://acefish.github.io/14976096897839.html</id>
    <content type="html"><![CDATA[
<p>字符串是字符的集合,用<code>string</code>类型表示. 一个<code>String</code>的内容可以用许多方式读取，包括作为一个<code>Character</code>值的集合</p>

<p><code>Swift</code>的<code>String</code>和<code>Character</code>类型提供了快速和兼容<code>Unicode</code>的方式供代码使用。<br/>
String 类型是一种快速、现代化的字符串实现。 每一个字符串都是由编码无关的<code>Unicode</code>字<br/>
符组成，并支持访问字符的多种<code>Unicode</code>表示形式</p>

<h2 id="toc_0">字符串字面量</h2>

<pre><code class="language-swift">//someString 常量通过字符串字面量进行初始化
let someString = &quot;Some string literal value&quot;
</code></pre>

<h2 id="toc_1">初始化空字符串</h2>

<pre><code class="language-swift">var emptyString = &quot;&quot; // 空字符串字面量
var anotherEmptyString = String() // 初始化方法


if emptyString.isEmpty {
print(&quot;Nothing to see here&quot;)
}
// 打印输出：&quot;Nothing to see here&quot;
</code></pre>

<h2 id="toc_2">字符串可变性</h2>

<pre><code class="language-swift">//通过指定为变量使其可修改
var variableString = &quot;Horse&quot;
variableString += &quot; and carriage&quot;
// variableString 现在为 &quot;Horse and carriage&quot;
</code></pre>

<p>与OC中的<code>NSString</code>和<code>NSMutableSting</code>确定是否可更改不同,<code>Swift</code>中类似其他值取决于其被定义为常量还是变量</p>

<h2 id="toc_3">字符串是值类型</h2>

<p><strong><code>Swift</code>的<code>String</code>类型是值类型</strong>。如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。<strong>任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作</strong>。这样保证了在函数/方法中传递的是字符串的值。 </p>

<blockquote>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
</blockquote>

<p>注意:<code>Swift</code>的<code>String</code>是值类型而<code>NSString</code>是引用类型,<code>NSString</code>的意思是初始化了一个指针指向了这个字符串，但Swift <code>String</code>的意思则是把字符串字面量赋值给变量</p>

<h2 id="toc_4">使用字符</h2>

<p>可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code> 属性来获取每一个字符的值</p>

<pre><code class="language-swift">for character in &quot;Dog!?&quot;.characters {
    print(character)
}
// 
</code></pre>

<pre><code class="language-swift">//声明一个Character类型
let exclamationMark: Character = &quot;!&quot;

//用character类型数组初始化字符串
let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]
let catString = String(catCharacters)
print(catString)

</code></pre>

<h2 id="toc_5">连接字符串和字符</h2>

<p>字符串可以通过加法相加在一起<br/>
可以通过<code>+=</code>运算符将一个字符串添加到一个已经存在字符串变量上</p>

<pre><code class="language-swift">let string1 = &quot;hello&quot;
let string2 = &quot; there&quot;
var welcome = string1 + string2

var instruction = &quot;look over&quot;
instruction += string2
</code></pre>

<p>可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部</p>

<pre><code class="language-swift">//初始化字符也是用双引号
let exclamationMark: Character = &quot;!&quot;
welcome.append(exclamationMark)
// welcome 现在等于 &quot;hello there!&quot;
</code></pre>

<blockquote>
<p>初始化字符也是用双引号与c中使用单引号不同</p>
</blockquote>

<h2 id="toc_6">字符串插值</h2>

<p>可以用以反斜线为前缀的圆括号将常量、变量或表达式插入字符串中</p>

<pre><code class="language-swift">let multiplier = 3
let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;
// message 是 &quot;3 times 2.5 is 7.5&quot;
</code></pre>

<blockquote>
<p>插值字符串中写在括号中的表达式不能包含非转义反斜杠 ()，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>

<h2 id="toc_7">Unicode</h2>

<p>Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p>

<h3 id="toc_8">Unicode标量</h3>

<p><code>Unicode</code>标量是对应字符或者修饰符的唯一的21位数字</p>

<blockquote>
<p>Unicode 码位(code poing) 的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF<br/>
Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位，其码位范围是 U+D800 到 U+DFFF 。<br/>
不是所有的21位<code>Unicode</code>标量都代表一个字符，因为有一些标量是留作未来分配的。</p>
</blockquote>

<h3 id="toc_9">字符串字面量的特殊字符</h3>

<p>特殊字符</p>

<ul>
<li>转义字符 <code>\0</code> (空字符)、 <code>\\</code>(反斜线)、 <code>\t</code> (水平制表符)、 <code>\n</code> (换行符)、 <code>\r</code>(回车符)、 <code>\&quot;</code> (双引号)、 <code>\&#39;</code> (单引号)</li>
<li><code>Unicode</code>标量，写成<code>\u{n}</code>(u为小写)，其中n为任意一到八位十六进制数且可用的<code>Unicode</code>位码。</li>
</ul>

<pre><code class="language-swift">let char: Character = &quot;\u{24}&quot;// $, Unicode 标量 U+0024
let blackHeart = &quot;\u{2665}&quot; // ?, Unicode 标量 U+2665
</code></pre>

<h3 id="toc_10">可扩展的字形群集</h3>

<p>每一个<code>Swift</code>的<code>Character</code>类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<pre><code class="language-swift">/*
    字母 é 可以用单一的 Unicode 标量 é (U+00E9)来表示
    一个标准的字母e(U+0065)加上一个急促重音的标量(U+0301)，这样一对标量就表示了同样的字母é 
*/
let eAcute: Character = &quot;\u{E9}&quot; // é
let combinedEAcute: Character = &quot;\u{65}\u{301}&quot; // e 后面加上 ?
// eAcute 是 é, combinedEAcute 是 é
</code></pre>

<p>因此我们可以用很多复杂的脚本字符来表示单一的Character值</p>

<p>例如</p>

<pre><code class="language-swift">/*
    可拓展的字符群集可以使包围记号的标量包围其他Unicode标量，作为一个单一的Character值
*/
let enclosedEAcute: Character = &quot;\u{20DD}&quot;//&quot;⃝&quot;
let enclosedEAcute11: Character = &quot;\u{E9}\u{20DD}&quot;//é⃝
</code></pre>

<h2 id="toc_11">计算字符数量</h2>

<p>使用字符串的<code>characters</code>属性的<code>count</code>属性获取字符数量</p>

<p>注意:<br/>
我们在使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时不一定会改变字符数量</p>

<pre><code class="language-swift">var word = &quot;cafe&quot;//这时候字符数量是4
word += &quot;\u{301}&quot; //这时候字符数量还是4 因为e和新增的字符组合为é

let eAcute = &quot;\u{00E9}&quot; // é
eAcute.characters.count //字符数量为1
let combinedEAcute = &quot;\u{65}\u{301}&quot; //
combinedEAcute.characters.count //字符数量为1

</code></pre>

<p>注意:<br/>
 <code>Swift</code>与<code>OC</code>不同，swift中将每个字符都看作可扩展的字形群,因此对于é(&quot;\u{65}\u{301}&quot;)看作一个字符,而对于OC这是两个字符,而对两者说字符串长度就是字符的数量</p>

<blockquote>
<p>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式<br/>
可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数<br/>
量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一<br/>
个长字符串，需要注意<code>characters</code>属性必须遍历全部的<code>Unicode</code>标量，来确定字符串的字符数量。<br/>
另外需要注意的是<strong>通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的 <code>length</code>属性相同</strong>。 <strong>NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集</strong>。作为佐证，当一个 NSString 的 length 属性被一个Swift的 String 值访问时，实际上是调用了 <code>utf16Count</code></p>
</blockquote>

<h2 id="toc_12">访问和修改字符串</h2>

<h3 id="toc_13">字符串索引</h3>

<p><code>String.Index</code>对应着字符串中的每一个<code>Character</code>的位置，因此这个index相相当于是字符串中字符的索引</p>

<p>因为字符串中每个<code>Character</code>是可扩展的字符群集,所以想要知道每个字符的位置就必须将String便利一边才能确定</p>

<blockquote>
<p>这个index不一定是连续的</p>
</blockquote>

<pre><code class="language-swfit">let combinedEAcute = &quot;🍉&quot;
combinedEAcute.characters.count //1
combinedEAcute.startIndex //0
combinedEAcute.endIndex//2
let indx = combinedEAcute.index(after: combinedEAcute.startIndex)//2
</code></pre>

<p><code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引<br/>
<code>endIndex</code>属性可以可以获取<strong>最后一个<code>Character</code>的后一个位置的索引。</strong>因此<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的</p>

<p>可以使用<code>String</code>的<code>index(before:)</code>或<code>index(after:)</code>来获取前一个或者后一个,或者用<code>index(:_offsetBy:)</code>取得对应偏移量的索引</p>

<p>获取对应下标索引的字符:</p>

<pre><code class="language-swift">let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex]// G
greeting[greeting.index(before: greeting.endIndex)]// !
//当越界是或引发运行时的错误(可以在编译时就检测出来)
</code></pre>

<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符</p>

<pre><code class="language-swift">for index in greeting.characters.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
// 打印输出 &quot;G u t e n T a g ! &quot;
</code></pre>

<blockquote>
<p>我们在上面在<code>String</code>中获取的index的方法,可以用于在任意一个确认的并遵循<code>Collection</code>协议的类型里面(例如Array、Dictionary、Set)</p>
</blockquote>

<h3 id="toc_14">插入和删除</h3>

<p>调用<code>insert(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符，调用<code>insert(contentsOf:at:)</code>方法可以在一个字符串的指定索引插入一个段字符串。</p>

<pre><code class="language-swift">//注意必须是变量
var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, at: welcome.endIndex)
// welcome 变量现在等于 &quot;hello!&quot;
welcome.insert(contentsOf:&quot; there&quot;.characters, at: welcome.index(before: welcome.endIndex))
// welcome 变量现在等于 &quot;hello there!&quot;
</code></pre>

<p>调用<code>remove(at:)</code>方法可以在一个字符串的指定索引删除一个字符，调用<code>removeSubrange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>

<pre><code class="language-swift">welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome 现在等于 &quot;hello there&quot;
let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex
welcome.removeSubrange(range)
// welcome 现在等于 &quot;hello&quot;
</code></pre>

<blockquote>
<p><code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code>和<code>removeSubrange(_:)</code>方法在任意一个确认的并遵循<code>RangeReplaceableCollection</code>协议的类型里面，如上文所示是使用在 <code>String</code>中，您也可以使用在<code>Array</code>、<code>Dictionary</code>和<code>Set</code>中。</p>
</blockquote>

<h2 id="toc_15">比较字符串</h2>

<h3 id="toc_16">字符串/字符相等</h3>

<p>直接用 <code>==</code> 和 <code>!=</code>进行比较</p>

<p>判断标准等于的标准是:当有同样的语义和外观,就被认为是相等的,即使他们的可扩展字形群集可能由不同的<code>Unicode</code>标量构成</p>

<p>例如:<br/>
((U+00E9)标准等于((U+0065)(U+0301))) (都是<code>é</code>表示的有效方式)<br/>
U+0041(英语中的A)不等于U+0410(俄语中的A)尽管外观看着一样</p>

<h3 id="toc_17">前缀/后缀</h3>

<p>通过字符串的<code>hasPrefix(_:) / hasSuffix(_:)</code>方法来检查字符串是否用于特定前缀/后缀</p>

<h2 id="toc_18">字符串的Unicode表示</h2>

<p>当<code>Unicode</code>字符串写进文本文件或者其他存储时，<code>Unicode</code>会用几种<code>编码格式</code>编码(如：UTF-8 UTF-16 UTF-32) 每一个字符串中的小块编码都被称<code>代码单元</code></p>

<p>除了前面说过的用<code>for-in</code>对字符串遍历,然后访问每个<code>character</code>值的方式外:<br/>
其他三种<code>Unicode</code>兼容方式访问字符串</p>

<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的Unicode标量值集合，也就是字符串的UTF-32编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>

<p>let dogString = &quot;Dog‼🐶&quot;(其中“!!”为U+203C 🐶为U+1F436)</p>

<h4 id="toc_19">UTF-8表示</h4>

<p>通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示， 其为<code>String.UTF8View</code>类型的属性， <code>UTF8View</code>是无符号8位(UInt8)值的集合，每一个UInt8值都是一个字符的UTF-8表示</p>

<pre><code class="language-swift">for codeUnit in dogString.utf8 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)// 68 111 103 226 128 188 240 159 144 182
/*
前三个10进制 codeUnit 值 ( 68 , 111 , 103 ) 代表了字符 D 、 o 和 g ，它们的 UTF-8 表示与
ASCII 表示相同。 接下来的三个10进制 codeUnit 值 ( 226 , 128 , 188 ) 是 DOUBLE 
EXCLAMATION MARK 的3字节 UTF-8 表示。 最后的四个 codeUnit 值 ( 240 , 159 , 144 , 182 ) 
是 DOG FACE 的4字节UTF-8 表示。
*/
</code></pre>

<blockquote>
</blockquote>

<h4 id="toc_20">UTF-16表示</h4>

<p>与utf-8类似,访问其utf-16属性,是<code>String.UTF16View</code>类型(<code>UInt16</code>值集合)</p>

<pre><code class="language-swift">for codeUnit in dogString.utf16 {
    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 55357 56374
</code></pre>

<h4 id="toc_21">Unicode标量表示</h4>

<p>通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的<code>Unicode</code>标量表示。为<code>UnicodeScalarView</code>类型的属性(<code>UnicodeScalar</code>类型的值的集合)。<br/>
<code>UnicodeScalar</code>是21位的<code>Unicode</code>代码点,拥有一个<code>value</code>属性，可以返回对应的21位数值，用 UInt32 来表示：</p>

<pre><code class="language-swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)
}
print(&quot;&quot;)
// 68 111 103 8252 128054
</code></pre>

<blockquote>
<p>我们平常代码中的Unicode编码就是这种21位<br/>
UTF-32也是编码一样为21位，因此swift中的有了unicodeScalars属性也就没有utf32属性</p>
</blockquote>

<p>每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值</p>

<pre><code class="language-Swift">for scalar in dogString.unicodeScalars {
    print(&quot;\(scalar) &quot;, terminator: &quot;&quot;)
}
// D o g !! 🐶
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 基本运算符]]></title>
    <link href="https://acefish.github.io/14974389141976.html"/>
    <updated>2017-06-14T19:15:14+08:00</updated>
    <id>https://acefish.github.io/14974389141976.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">赋值运算符</h2>

<pre><code class="language-swift">//赋值符可以赋值元组
let (x, y) = (1, 2)
// 现在 x 等于 1，y 等于 2
</code></pre>

<p>注意点:<br/>
与OC不同，赋值符不返回值,防止把想要判断相等运算符（ == ）的地方写成赋值符导致的错误</p>

<h2 id="toc_1">算术运算符</h2>

<pre><code class="language-swift">//加法运算符也可用于 String 的拼接
&quot;hello, &quot; + &quot;world&quot; // 等于 &quot;hello, world&quot;
</code></pre>

<p>注意:<br/>
与<code>OC</code>不同,<code>Swift</code>默认情况下不允许在数值运算中出现溢出情况.(可以使用<code>Swift</code>提供的溢出运算符实现溢出运算)</p>

<h2 id="toc_2">求余运算</h2>

<p>求余运算(<code>%</code>)在其他语言也叫取模运算</p>

<h3 id="toc_3">一元负号/正号运算符</h3>

<p>一元负/正号符（ -/+ ）写在操作数之前，中间没有空格。<br/>
负号或者正号可以抵消</p>

<h2 id="toc_4">组合赋值运算符</h2>

<p>例如:<br/>
<code>a += 2</code> //这组合赋值运算符也是没有返回值的（和赋值运算符一样）</p>

<blockquote>
<p>在Swift3 中已经移除了 ++ 或 -- 的自增 自减运算符</p>

<h2 id="toc_5">比较运算符</h2>

<p>和OC中是相同的,返回一个表达式是否成立的布尔值</p>

<p><code>Swift</code> 也提供恒等（<code>===</code>）和不恒等（<code>!==</code>）这两个比较符来判断两个对象是否引用同一个对象实例</p>
</blockquote>

<p>注意:</p>

<p><strong>元组的比较方法:</strong><br/>
当元组中的值可以比较时，你也可以使用这些运算符来比较它们的大小。例如，因为<code>Int</code>和<code>String</code>类型的值可以比较，所以类型为<code>(Int, String)</code>的元组也可以被比较。相反，<code>Bool</code> 不能被比较，也意味着存有布尔类型的元组不能被比较</p>

<p>比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的</p>

<pre><code class="language-swift">//当比较到1小于2就判断为ture 不会再比较下去
(1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true，因为 1 小于 2
(3, &quot;apple&quot;) &lt; (3, &quot;bird&quot;) // true，因为 3 等于 3，但是 apple 小于 bird
(4, &quot;dog&quot;) == (4, &quot;dog&quot;) // true，因为 4 等于 4，dog 等于 dog
</code></pre>

<blockquote>
<p>Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。</p>
</blockquote>

<h2 id="toc_6">三目运算</h2>

<h2 id="toc_7">空合运算符</h2>

<p>空合运算符<code>（a ?? b）</code>将对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>。表达式<code>a</code>必须是<code>Optional</code>类型。默认值<code>b</code>的类型必须要和<code>a</code>存储值的类型保持一致。</p>

<p>空合运算符有<code>a != nil ? a! : b</code>相当于这种表达</p>

<p>注意:<br/>
空合运算符也采用了短路求值,即当a为非空时,那么就不会再去计算b的值</p>

<h2 id="toc_8">区间运算符</h2>

<h3 id="toc_9">闭区间运算符</h3>

<p><code>a...b</code>定义一个包含从a到b(包括a和b)</p>

<pre><code class="language-swift">for index in 1...5 {
    print(&quot;\(index) * 5 = \(index * 5)&quot;)
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
</code></pre>

<h3 id="toc_10">半开区间运算符</h3>

<p><code>a..&lt;b</code>定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间</p>

<h2 id="toc_11">逻辑运算符</h2>

<p>与<code>&amp;&amp;</code> 或<code>||</code> 非<code>!</code></p>

<blockquote>
<p>与或非运算也是使用短路计算的</p>
</blockquote>

<p>注意:<br/>
<code>Swift</code>逻辑操作符 <code>&amp;&amp;</code> 和 <code>||</code> 是左结合的，即从左向右读,优先计算左边,建议加上括号来增加代码可读性</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见名词]]></title>
    <link href="https://acefish.github.io/14974079542932.html"/>
    <updated>2017-06-14T10:39:14+08:00</updated>
    <id>https://acefish.github.io/14974079542932.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">M2M</h3>

<p>M2M ：M2M是将数据从一台终端传送到另一台终端，也就是机器与机器（Machine to Machine）的对话</p>

<h3 id="toc_1">QoS</h3>

<p>QoS（Quality of Service，服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力, 是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术</p>

<h3 id="toc_2">嵌套函数</h3>

<p>嵌套函数，就是指在某些情况下，您可能需要将某函数作为另一函数的参数使用。</p>

<p>C语言中函数的定义都是相互平行、相互独立的，也就是说在函数定义时，函数体内不能包含另一个函数的定义，即函数不能嵌套定义，但可以嵌套调用。</p>

<h3 id="toc_3">重载</h3>

<p>重载:指两个函数的函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同<br/>
OC不完全支持重载,即OC支持参数个数不同的函数重载,Swift是完全支持重载的</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block实现原理]]></title>
    <link href="https://acefish.github.io/14972592855571.html"/>
    <updated>2017-06-12T17:21:25+08:00</updated>
    <id>https://acefish.github.io/14972592855571.html</id>
    <content type="html"><![CDATA[
<p>原文地址<a href="http://blog.ibireme.com/2013/11/27/objc-block/">objc 中的 block</a></p>

<h2 id="toc_0">block中的数据结构</h2>

<p><code>block</code>的定义:</p>

<pre><code class="language-objc">struct Block_descriptor_1 {
    uintptr_t reserved;
    uintptr_t size;
};
 
struct Block_layout {
    void *isa;
    volatile int32_t flags; // contains ref count
    int32_t reserved; 
    void (*invoke)(void *, ...);
    struct Block_descriptor_1 *descriptor;
    // imported variables
};
</code></pre>

<p>在oc中，凡是首地址是<code>*isa</code>的结构体指针，都可以认为是对象.这样在<code>objc</code>中，<code>block</code>实际上就算是对象。</p>

<pre><code class="language-objc">void foo_(){
    int i = 2;
    NSNumber *num = @3;
 
    long (^myBlock)(void) = ^long() {
        return i * num.intValue;
    };
 
    long r = myBlock();
}
//我们对上面的block的简单使用转换为c形式
//通用的block数据结构
struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};
//通用的block数据结构描述
struct __foo_block_desc_0 {
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);
    void (*dispose)(struct __foo_block_impl_0*);
};
 
//myBlock的数据结构定义
struct __foo_block_impl_0 {
    struct __block_impl impl;//包含通用数据结构定义
    struct __foo_block_desc_0* Desc;//对本block的结构描述指针
    int i;  //捕获的变量
    NSNumber *num;  //捕获的变量
};
 
//block数据的描述
static struct __foo_block_desc_0 __foo_block_desc_0_DATA = {
    0,
    sizeof(struct __foo_block_impl_0), //本block的占的自己空间大小（便分配空间）
    __foo_block_copy_0,
    __foo_block_dispose_0 //通用数据结构描述
};
 
//block中的方法
static long __foo_block_func_0(struct __foo_block_impl_0 *__cself) {//这个函数引用这个block的数据结构
    int i = __cself-&gt;i; // bound by copy
    NSNumber *num = __cself-&gt;num; // bound by copy
 
    return i * num.intValue;
}
 
void foo(){
    int i = 2;
    NSNumber *num = @3;
 
    struct __foo_block_impl_0 myBlockT;
    struct __foo_block_impl_0 *myBlock = &amp;myBlockT;
    myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;
    myBlock-&gt;impl.Flags = 570425344;
    myBlock-&gt;impl.FuncPtr = __foo_block_func_0;
    myBlock-&gt;Desc = &amp;__foo_block_desc_0_DATA;
    myBlock-&gt;i = i;
    myBlock-&gt;num = num;
 
    long r = myBlock-&gt;impl.FuncPtr(myBlock);
}

</code></pre>

<p>创建<code>block</code>就是创建了一个结构体,用<code>block捕获的变量</code>来初始化结构体体中数据,block内部的代码提取为block结构体中的c函数,这个c函数参数为一个指向本block的指针,执行时将这个struct指针传过去,通过这个指针获取block捕获的变量进行c函数的计算</p>

<p><code>block</code>中包含了被引用的自由变量(由struct持有)，也包含了控制成分的代码块(由函数指针持有)符合闭包(<code>closure</code>)的概念。</p>

<h2 id="toc_1">block的copy</h2>

<p><code>block</code>中的<code>isa</code>指向的是该<code>block</code>的<code>Class</code>.这些Class都有:</p>

<ul>
<li>_NSConcreteStackBlock ---- 栈上创建的block</li>
<li>_NSConcreteMallocBlock ---- 堆上创建的block</li>
<li>_NSConcreteGlobalBlock ---- 作为全局变量的block</li>
<li>_NSConcreteWeakBlockVariable ---- 用于GC不再讨论</li>
<li>_NSConcreteAutoBlock ---- 用于GC不再讨论</li>
<li>_NSConcreteFinalizingBlock ---- 用于GC不再讨论</li>
</ul>

<p>1.全局block<br/>
全局block是当一个block内部没有捕获任何外部变量时，就会是一个全局block类型。此时，这个block与一个函数无异。所以，那么它就应该有和函数一样的静态特性。而且，我们在调用block的时候，其实和普通C函数的调用很相似，都是名称加括号：block()。 全局block的地址是在全局变量常量区的</p>

<p><strong>当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。</strong></p>

<p>函数返回时，函数的栈帧被销毁，这个<code>block</code>的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用<code>Block_copy()</code>方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送<code>retain</code>，增加<code>block</code>的引用计数。</p>

<h2 id="toc_2">__block类型变量</h2>

<p>默认捕获到的对象直接赋值给<code>block</code>结构体，不能修改,那么当我们给其加上<code>__block</code>修饰时,原本的捕获的int值位置变为一个<code>struct</code>，这个struct首地址也为<code>*isa</code>.</p>

<p>因此，这个值才能被<code>block</code>共享、并且不受栈帧生命周期的限制、在<code>block</code>被<code>copy</code>后，能够随着<code>block</code>复制到堆上。</p>

<h2 id="toc_3">注意事项:</h2>

<p>1.静态存储区的变量：例如全局变量、方法中的static变量<br/>
<strong>引用，可修改</strong>。</p>

<p>2.block接受的参数<br/>
传值，可修改，和一般函数的参数相同。</p>

<p>3.栈变量 (被捕获的上下文变量)<br/>
const，不可修改。 当block被copy后，block会对 id类型的变量产生强引用。<br/>
每次执行block时,捕获到的变量都是最初的值。</p>

<p>4.栈变量 (有__block前缀)<br/>
引用，可以修改。如果时id类型则不会被<code>block retain</code>,必须手动处理其内存管理。<br/>
如果该类型是C类型变量，<code>block</code>被<code>copy</code>到<code>heap</code>后,该值也会被挪动到<code>heap</code></p>

<h2 id="toc_4">使用注意点:</h2>

<ol>
<li><p>内存方面</p>

<p><code>Block_copy()</code>和<code>Block_release()</code>必须一一匹配，否则会内存泄漏或crash。</p>

<p><code>__block</code>这个修饰词会将原本的简单类型转化为较大的<code>struct</code>，这会给内存、调用带来额外的开销，使用时需要注意。</p></li>
<li><p>ARC模式下的block使用<br/>
在ARC模式下我们 不用手动<code>copy/release</code>，<br/>
但是</p>

<pre><code class="language-objc">void (^aBlock)(void);//定义一个aBlock对象（__strong）
aBlock = ^{ printf(&quot;ok&quot;); };
//只要一个block被赋值给一个strong变量，会自动copy
//strong变量就是一个强引用指针  copy到堆后将对地址赋值给这个指针 对象引用着这个block
</code></pre>

<p>block是对象，所以这个aBlock默认是有__strong修饰符的，即<code>aBlock</code>对该block有<code>strong <br/>
references</code>。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的<br/>
block基本都是在堆上的。</p>

<pre><code class="language-objc">//对于这个例子
void (^aBlock)(void) = nil; 
if (!aBlock) {
    aBlock = ^{ printf(&quot;hehe&quot;); };
}
//block此时block已经被释放,该处留下了一个`dangling pointer`
aBlock();
</code></pre>

<p>这种情况 苹果建议尽量避免这种情况。</p></li>
<li><p>block易引起的循环引用问题</p>

<p>当block被copy之后(如开启了ARC、或把block放入dispatch queue)，该block对它捕获的对象产生<br/>
strong references (非ARC下是retain),所以有时需要避免block copy后产生的循环引用。</p>

<p>如果用self引用了block，block又捕获了self，这样就会有循环引用。因此，需要用weak来声明self</p>

<pre><code class="language-objc">    - (void)configureBlock {
    XYZBlockKeeper * __weak weakSelf = self;
    self.block = ^{
    [weakSelf doSomething]; //捕获到的是弱引用
    }
    }
    //当前前对象的成员变量对象，同样也会造成对self的引用
    - (void)configureBlock {
    id tmpIvar = _ivar; //临时变量,避免了self引用
    self.block = ^{
    [tmpIvar msg];
    }
    }
</code></pre>

<p>为了避免循环引用，可以这样理解<code>block</code>：<code>block</code>就是一个对象，它捕获到的值就是这个对象的<code>@property(strong)</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三方登录分享]]></title>
    <link href="https://acefish.github.io/14972581397752.html"/>
    <updated>2017-06-12T17:02:19+08:00</updated>
    <id>https://acefish.github.io/14972581397752.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">shareSdk使用</h2>

<p><a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">集成步骤</a><br/>
对于<code>shareSDK</code>中初始化第三方应用平台,我们可以通过<code>ShareSDK registerApp:@&quot;iosv1101&quot; activePlatforms:</code>方法中传入各个平台的appkey等信息进行初始化,或者添加各个平台的<code>URL type</code>然后简单的用<code>share SDK</code>中<code>connect</code>方法进行初始化</p>

<p>注意：<br/>
1. 在<code>shareSDK.xml</code>文件中传入各个平台的<code>key</code>和<code>serect</code><br/>
2. 现在需要在<code>plist</code>文件添加第三方应用白名单才可以打开第三方应用</p>

]]></content>
  </entry>
  
</feed>
