<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2018-07-30T11:54:43+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[进程&&线程]]></title>
    <link href="https://acefish.github.io/15331071952550.html"/>
    <updated>2018-08-01T15:06:35+08:00</updated>
    <id>https://acefish.github.io/15331071952550.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-python">print(&#39;Process (%s) start...&#39; % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    #子进程
    print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))
else:
    print(&#39;I (%s) just created a child process (%s).&#39; % (os.getpid(), pid))
    
# Process (28301) start...
# I (28301) just created a child process (28302).
# I am child process (28302) and my parent is 28301.
</code></pre>

<h2 id="toc_0">multiprocessing</h2>

<p>因为在windows是没有<code>fork</code>调用的，所以为了跨平台支持,可以使用<code>multiprocessing</code>跨平台的多进程模块<br/>
<code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象</p>

<pre><code class="language-python">
from multiprocessing import Process
import os

def run_proc(name):
    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))

print(&quot;parent process %s&quot; % os.getpid())
p=Process(target=run_proc, args=(&quot;test&quot;,)) #创建子进程
print(&quot;child process will start&quot;)  
p.start()# 启动子进程
p.join() # 等待子进程结束后继续运行
print(&quot;child process end&quot;)

# parent process 28492
# child process will start
# Run child process test (28493)...
# child process end

</code></pre>

<blockquote>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
</blockquote>

<h3 id="toc_1">Pool</h3>

<pre><code class="language-python">from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))

if __name__==&#39;__main__&#39;:
    print(&#39;Parent process %s.&#39; % os.getpid())
    p = Pool(4) #设置同事可以执行4个进程
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print(&#39;Waiting for all subprocesses done...&#39;)
    p.close() # 调用close()之后就不能继续添加新的Process了
    p.join()  # 对Pool对象调用join()会等待所有子进程执行完毕，在
    print(&#39;All subprocesses done.&#39;)
</code></pre>

<h3 id="toc_2">子进程</h3>

<p><code>subprocess</code>模块 允许我们创建子线程,连接其输入、输出、错误通道</p>

<pre><code class="language-python">import subprocess

print(&#39;$ nslookup www.python.org&#39;)
r = subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])
# 相当于在命令行执行  nslookup www.python.org
print(&#39;Exit code:&#39;, r)


# 子进程还需要输入，则可以通过communicate()方法输入：
import subprocess

print(&#39;$ nslookup&#39;)
p = subprocess.Popen([&#39;nslookup&#39;], stdin=·, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b&#39;set q=mx\npython.org\nexit\n&#39;)
print(output.decode(&#39;utf-8&#39;))
print(&#39;Exit code:&#39;, p.returncode)

</code></pre>

<h3 id="toc_3">进程间通信</h3>

<p>进程间通信，可以通过<code>mutiprocessing</code>提供的<code>Queue</code>和<code>pipes</code>等方式交换数据</p>

<pre><code class="language-python"># 一个queue 可以往里 读写数据 实现数据交换共享

from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)
        print(&#39;Get %s from queue.&#39; % value)

if __name__==&#39;__main__&#39;:
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
</code></pre>

<blockquote>
<p>父进程所有Python对象都必须通过pickle序列化再传到子进程去</p>
</blockquote>

<h2 id="toc_4">多线程</h2>

<p>我们通常使用<code>threading</code>模块操作线程</p>

<p>启动线程: 就是将要执行的任务任务函数传入创建<code>Thread</code>实例，然后<code>start()</code>开始执行</p>

<pre><code class="language-python">import time, threading

# 新线程执行的代码:
def loop():
    print(&#39;thread %s is running...&#39; % threading.current_thread().name)
    n = 0
    while n &lt; 5:
        n = n + 1
        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))
        time.sleep(1)
    print(&#39;thread %s ended.&#39; % threading.current_thread().name)

print(&#39;thread %s is running...&#39; % threading.current_thread().name)
#
t = threading.Thread(target=loop, name=&#39;LoopThread&#39;)
t.start()
t.join()
print(&#39;thread %s ended.&#39; % threading.current_thread().name)
</code></pre>

<blockquote>
<p><code>Python</code>的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>
</blockquote>

<h3 id="toc_5">Lock</h3>

<p>避免多线程对数据读写的冲突，需要lock</p>

<pre><code class="language-python">balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire() #当有多个线程执行时，只有一个县城能成功获取锁
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
</code></pre>

<h3 id="toc_6">多核问题</h3>

<p>Python由于历史遗留问题,同一进程的不同线程其实只能用到一个cpu核,即使启动了多个线程</p>

<blockquote>
<p>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>

<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
</blockquote>

<h2 id="toc_7">ThreadLocal</h2>

<p>多线程中，为不同线程绑定不同数据时,可以使用<code>ThreadLocal</code></p>

<pre><code class="language-python">import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    # 获取当前线程关联的student:
    std = local_school.student
    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target= process_thread, args=(&#39;Bob&#39;,), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre>

<p>每个线程可以读写<code>ThreadLocal</code>对象的属性,但是互不影响，只操作自己线程对应值，互不干扰，也不用管理锁的问题</p>

<blockquote>
<p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p>
</blockquote>

<h3 id="toc_8">分布式进程</h3>

<p>在<code>Thread</code>和<code>Process</code>中应该优先选择<code>Process</code>，因为其更稳定，而且可以分布到多台机器上，而<code>Thread</code>只能分不到同一台机器的多个CPU上</p>

<p>在<code>mutiprocessing</code>的子模块<code>manager</code>支持把多进程分布到多台机器</p>

<p>一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IO编程]]></title>
    <link href="https://acefish.github.io/15329386758024.html"/>
    <updated>2018-07-30T16:17:55+08:00</updated>
    <id>https://acefish.github.io/15329386758024.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-python">f = open(&#39;/Users/fish/Desktop/readme.txt&#39;, &#39;r&#39;)
content=f.read() 
print(content)
f.close()
</code></pre>

<p>文件使用完必须关闭，文件对象会占用系统资源，操作系统同时能打开文件数量也是有限的<br/>
为了保证每次不论是否文件读碟出现<code>IOError</code>出错 都能正确关闭文件，通常这么写:</p>

<pre><code class="language-python">try:
    f = open(&#39;/path/to/file&#39;, &#39;r&#39;)
    print(f.read())
finally:
    if f:
        f.close()

# 使用 python的with语句来自动帮我们调用close()方法
#与try...finall..效果相同代码更简洁

with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre>

<p><code>read()</code>方法会一次性读取全部内容,如果文件过大会挑战内存<br/>
<code>read(size)</code>每次最多读取size字节的内容<br/>
<code>readline()</code>每次读取一行内容<br/>
<code>readlines()</code>一次性读取所有行,返回一个<code>list</code></p>

<blockquote>
<p>类似文件这种 open()函数返回可以read()的对象，均称为 file-like Object，除此之外还有内存的字节流、网络流、自定义流</p>
</blockquote>

<h3 id="toc_0">二进制文件</h3>

<p>默认读取的为UTF-8编码的文本文件,如果为二进制文件,需要用<code>rb</code>模式打开</p>

<pre><code class="language-python">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.jpg&#39;, &#39;rb&#39;)
&gt;&gt;&gt; f.read()
# b&#39;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#39; # 十六进制表示的字节
</code></pre>

<h3 id="toc_1">其它编码格式</h3>

<p>对于非<code>UTF-8</code>编码的文本文件,需要<code>open()</code>函数需要传入<code>encoding</code>参数</p>

<pre><code class="language-python">f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)
</code></pre>

<p>当编码不规范，文本中夹杂着非法编码字符时，会发生转码错误(<code>UnicodeDecodeError</code>)，此时可以通过加入参数<code>errors</code>来指定处理方式，常用的为直接忽略</p>

<pre><code class="language-python">f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)
</code></pre>

<h3 id="toc_2">写文件</h3>

<p>写文件也是调用<code>open()</code>函数 只是传入的标识符为<code>w</code>或者<code>wb</code>表示写文本文件或写二进制文件</p>

<pre><code class="language-python">f3 = open(&#39;/Users/fish/Desktop/readme.txt&#39;, &#39;wb&#39;)
f3.write(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
f3.close()
</code></pre>

<blockquote>
<p>与读文件相同要记得调用<code>close()</code>方法,否则可能有部分未写入</p>
</blockquote>

<p>与读文件相同,可以通过<code>with</code>语句 确保自动调用close()方法</p>

<pre><code class="language-python">with open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) as f:
    f.write(&#39;Hello, world!&#39;)
</code></pre>

<blockquote>
<p>通过<code>encoding</code>参数将字符转为指定编码<br/>
<code>w</code>默认为覆盖模式 <code>a</code>是append模式</p>
</blockquote>

<h2 id="toc_3">StringIO 和 BytesIO</h2>

<p>内存中进行读写</p>

<pre><code class="language-python">from io import StringIO

f4=StringIO(&quot;初始\n 字符串&quot;)
f4.write(&quot;hello,&quot;)
f4.write(&quot; &quot;)
f4.write(&quot;world!&quot;)

print(f4.getvalue())  # getvalue()方法用于获得写入后的内容
#hello, world!

from io import BytesIO
f5=BytesIO()
f5.write(&quot;中文&quot;.encode(&quot;utf-8&quot;))
print(f5.getvalue())
# b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
</code></pre>

<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：<br/>
和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p>

<pre><code class="language-python">from io import StringIO
f = StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)
while True:
     s = f.readline()
     if s == &#39;&#39;:
         break
     print(s.strip())

# Hello!
# Hi!
# Goodbye!

from io import BytesIO
f = BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
f.read()
# b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;

</code></pre>

<h2 id="toc_4">操作文件和目录</h2>

<p>操作文件和目录<br/>
通过<code>os</code>模块提供的功能</p>

<pre><code class="language-python">import os
os.name # posix 操作系统类型(posix表示是Linux、Unix、Mac OS，nt表示是Windows)

os.uname() #查看详细的系统信息
#posix.uname_result(sysname=&#39;Darwin&#39;, nodename=&#39;fishdeMacBook-Pro.local&#39;, release=&#39;17.5.0&#39;, version=&#39;Darwin Kernel Version 17.5.0: Fri Apr 13 19:32:32 PDT 2018; root:xnu-4570.51.2~1/RELEASE_X86_64&#39;, machine=&#39;x86_64&#39;)
</code></pre>

<h3 id="toc_5">环境变量</h3>

<pre><code class="language-python">os.environ #操作系统定义的全部环境变量
os.environ.get(&quot;PATH&quot;) # 获取某个环境变量值
os.environ.get(&#39;x&#39;, &#39;default&#39;) # 
</code></pre>

<h3 id="toc_6">操作文件和目录</h3>

<p>操作文件和目录的函数 在<code>os</code>和<code>os.path</code>中</p>

<pre><code class="language-python">import os

currentPath=os.path.abspath(&quot;.&quot;)  # .表示当前路径
print(currentPath) # /Users/fish/Desktop/LYY/Python

joinDir=os.path.join(&quot;/Users/fish/Desktop&quot;, &quot;testDir&quot;) #在目录下新建目录 获取新目录路径
print(joinDir) # /Users/fish/Desktop/testDir

splitDir=os.path.split(&quot;/Users/fish/Desktop/testDir&quot;)
print(splitDir) #(&#39;/Users/fish/Desktop&#39;, &#39;testDir&#39;)  获取最后一部分文件或目录
splitext=os.path.splitext(&quot;/Users/fish/Desktop/testDir&quot;) #获取扩展名 如果最后一部分为目录 则为空
print(splitext) # (&#39;/Users/fish/Desktop/testDir/readme&#39;, &#39;.txt&#39;)

os.mkdir(&quot;/Users/fish/Desktop/testDir2&quot;) #新建目录
os.rmdir(&quot;/Users/fish/Desktop/testDir2&quot;) #删除目录

os.path.join(&quot;/Users/fish/Desktop&quot;, &quot;readme.txt&quot;)
os.rename(&#39;/Users/fish/Desktop/readme.txt&#39;, &#39;/Users/fish/Desktop/readme.py&#39;)  # 重命名文件
os.remove(&#39;/Users/fish/Desktop/readme.py&#39;) # 删除文件

dirlist=os.listdir(&quot;.&quot;) #获取当前目录下的所有文件夹列表
os.path.isdir(&quot;.&quot;) # 判断是否为文件夹目录

</code></pre>

<p>当合并路径时,不要直接拼接字符串，通过<code>os.path.join()</code>函数可以正确处理不用操作系统的路径分隔符.<br/>
同理，拆分字符串时通过<code>os.path.split()</code>函数，可以把路径拆分为两部分，后一部分总是最后级别的目录或文件名<br/>
<code>os.path.splitext()</code>可以直接让你得到文件扩展名</p>

<blockquote>
<p>在<code>os</code>模块中并没有复制文件函数,可以再<code>shutil</code>模块中提供了<code>copyfile()</code>函数等使用的文件操作函数</p>
</blockquote>

<h2 id="toc_7">序列化</h2>

<p>Python通过<code>pickle</code>模块实现序列化</p>

<pre><code class="language-python">import pickle
#序列化
dict1=dict(name=&quot;Bob&quot;, age=24, score=88)
data=pickle.dumps(dict1)
print(data) #b&#39;\x80\x03}q\...\x04KXu.&#39;

#直接将序列化的内容写入文件
file1=open(&quot;/Users/fish/Desktop/readme.txt&quot;, &quot;wb&quot;)
pickle.dump(dict1, file1)
file1.close()

#  将文件从磁盘读到内存后使用pickle.loads()方法反序列化出对象， 
#  也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象
file2=open(&quot;/Users/fish/Desktop/readme.txt&quot;, &quot;rb&quot;)
dict2=pickle.load(file2)
file2.close()
print(dict2) #{&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 24, &#39;score&#39;: 88}


</code></pre>

<h3 id="toc_8">JSON</h3>

<p>dict可以转为json序列化</p>

<pre><code class="language-python">import json
print(json.dumps(dict1)) # {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 24, &quot;score&quot;: 88}

file1=open(&quot;/Users/fish/Desktop/readme.txt&quot;, &quot;w&quot;)
json.dump(dict1, file1)
file1.close()  # 文件内容为 {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 24, &quot;score&quot;: 88}
</code></pre>

<p>将class 序列化为 json</p>

<pre><code class="language-python">import json

#序列化  原理是先将class转为dict 然后将dict序列化json

class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;Bob&#39;, 20, 88)

#专门写一个转换函数 将 class 转为json
def student2dict(std):
    return {
        &#39;name&#39;: std.name,
        &#39;age&#39;: std.age,
        &#39;score&#39;: std.score
    }
# 传入更多参数来 指定序列化规则
print(json.dumps(s, default=student2dict))  #{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}

# 可以这么写 对大多数class都有__dict__属性来存储实例变量(__slots__除外)
print(json.dumps(s, default=lambda obj: obj.__dict__))

# 反序列化  原理为将json反序列化为dict 然后转为 class实例

def dict2student(d):
    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])
json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
print(json.loads(json_str, object_hook=dict2student))

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[错误、调试、测试]]></title>
    <link href="https://acefish.github.io/15325716345284.html"/>
    <updated>2018-07-26T10:20:34+08:00</updated>
    <id>https://acefish.github.io/15325716345284.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">错误处理</h2>

<h3 id="toc_1">try</h3>

<pre><code class="language-python">try:
    print(&quot;try...&quot;)
    result=10/0
    print(&quot;result 10/0=&quot;, result)
except Exception as e:  #捕获所有的异常
    # raise  #raise 语句不带参数 就会把错误原样抛出
    print(&quot;error+&quot;, e)
else:
    print(&quot;no erro&quot;) #没有错误发生时 执行
finally:
    print(&quot;finally...&quot;)

print(&quot;end...&quot;)

# try...
# error+ division by zero
# finally...
# end...

</code></pre>

<p>根据捕捉不用类型的错误</p>

<pre><code class="language-python">try:
    print(&#39;try...&#39;)
    r = 10 / int(&#39;a&#39;)
    print(&#39;result:&#39;, r)
except ValueError as e:   #如果int()函数发生错误
    print(&#39;ValueError:&#39;, e)
except ZeroDivisionError as e:  # 发现除数为0错误
    print(&#39;ZeroDivisionError:&#39;, e)
finally:
    print(&#39;finally...&#39;)
print(&#39;END&#39;)
</code></pre>

<p>Python的错误也是class,所有错误继承自<code>BaseException</code>，所以使用<code>exception</code>时可以捕获所有其子类错误</p>

<blockquote>
<p>捕获错误可以跨越多层调用,</p>

<p>如果错误没有被捕获,就会一级一级往上抛出,最后被Python解释器捕获,打印错误信息并退出程序的执行</p>

<p>发生错误时可以通过分析错误的调用异常栈，定位错误的位置信息</p>
</blockquote>

<h3 id="toc_2">抛出错误</h3>

<p>自定义错误类，抛出错误，尽量使用内置的错误类型,只有在必要时才需要定义自己的错误类型</p>

<h2 id="toc_3">调试</h2>

<h3 id="toc_4">断言</h3>

<p>断言使用<code>assert</code>关键字</p>

<pre><code class="language-python">def my_func_div(s):
    n=int(s)
    assert n!=0, &quot;n is zero&quot;
    return 10/n

my_func_div(&quot;0&quot;)

# AssertionError: n is zero
</code></pre>

<p>断言失败,<code>assert</code>语句会抛出<code>AssertionError</code><br/>
Python解释器可以通过 添加参数<code>- O</code> 参数关闭所有assert 这时<code>assert</code>就可看做pass</p>

<h3 id="toc_5">logging</h3>

<p>logging不会抛出错误，而且可以输出到文件<br/>
logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p>

<pre><code class="language-python">import logging
logging.basicConfig(level=logging.INFO)

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print(10 / n)
</code></pre>

<blockquote>
<p>logging语句允许指定记录信息的级别,共有<code>debug</code> <code>info</code> <code>warning</code> <code>error</code>这几个级别,当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
</blockquote>

<h3 id="toc_6">pdb 单步调试</h3>

<p><code>pdb</code>是python解释器的调试器,可以让程序但不执行，可以随时查看运行的状态</p>

<pre><code class="language-python">s = &#39;0&#39;
n = int(s)
print(10 / n)
</code></pre>

<p><code>python -m pdb xxx.py</code></p>

<p><img src="media/15325716345284/15329379992787.jpg" alt="" style="width:803px;"/><br/>
<img src="media/15325716345284/15329380931674.jpg" alt="" style="width:806px;"/><br/>
输入 <code>l</code>  查看diamante<br/>
<code>n</code> 单步执行代码<br/>
<code>p 变量名</code> 查看变量当前值<br/>
<code>q</code> 结束调试</p>

<h3 id="toc_7">pdb.set_trace() 断点</h3>

<p><code>import pdb</code> 在可能出错的地方放<code>pdb.set_trace()</code>就设置了一个断点,程序会在断点处进入pdb调试环境  可以用<code>c</code>继续执行</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面对对象高级编程]]></title>
    <link href="https://acefish.github.io/15324890369623.html"/>
    <updated>2018-07-25T11:23:56+08:00</updated>
    <id>https://acefish.github.io/15324890369623.html</id>
    <content type="html"><![CDATA[
<p>对于python这种动态语言,我们可以在创建了class实例之后，给其绑定属性甚至绑定方法</p>

<pre><code class="language-python">class My_TestClass(object):
    &quot;&quot;&quot;docstring for My_TestClass&quot;&quot;&quot;
    pass

test1=My_TestClass()
test1.name=&quot;liyuyuan&quot; # 给实例绑定对象

def set_name(self, name):
    self.name=name

from types import MethodType
test1.set_name=MethodType(set_name, test1) #实例对象绑定方法
test1.set_name(&quot;lyy&quot;)
print(test1.name)  # lyy
</code></pre>

<blockquote>
<p>给一个实例对象绑定的方法，对另外的实例对象是不起作用的，应该给<code>class</code>绑定方法<br/>
动态语言允许我们在程序运行过程中动态给<code>class</code>增加功能</p>
</blockquote>

<pre><code class="language-python">My_TestClass.set_name=set_name
test2=My_TestClass()
test2.set_name(&quot;wtt&quot;)
print(test2.name) # wtt
</code></pre>

<h2 id="toc_0"><strong>slots</strong></h2>

<p>通过<code>__slots__</code>来对实例的属性进行限制能添加的属性</p>

<pre><code class="language-python">class My_Slots_Class(object):
    &quot;&quot;&quot;docstring for My_Slots_Class&quot;&quot;&quot;
    __slots__=(&quot;name&quot;, &quot;score&quot;)
    # def __init__(self, age): #不能有 name、score外的其他属性
    #   self.age=age
    pass
        

slot1=My_Slots_Class()
slot1.age=10 #AttributeError: &#39;My_Slots_Class&#39; object has no attribute &#39;age&#39;
</code></pre>

<blockquote>
<p><code>__slots__</code>定义属性仅对当前类实例起作用,对继承的子类是不起作用的，可以在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
</blockquote>

<pre><code class="language-python">class My_Slots_Subclass(My_Slots_Class):
    &quot;&quot;&quot;docstring for My_Slots_Subclass&quot;&quot;&quot;
    __slots__=(&quot;age&quot;)
    pass
#此时允许的属性为子类的__slots__加上父类的__slots__
slot2=My_Slots_Subclass()
slot2.age=22
slot2.ttt=10  #AttributeError: &#39;My_Slots_Subclass&#39; object has no attribute &#39;ttt&#39;
</code></pre>

<h2 id="toc_1">@property</h2>

<p>python内置的<code>@property</code>装饰器就负责把一个方法变为属性调用</p>

<pre><code class="language-python">class My_Property_Class(object):
    @property
    def age(self):
        print(&quot;获取age&quot;,self._age)
        return self._age

    @age.setter
    def age(self, age):
       #可以在此处检查传入参数处理
        print(&quot;设置age&quot;,age)
        self._age=age

property1=My_Property_Class()
property1.age=10 #设置age 10
property1.age # 获取age 10
</code></pre>

<p>如果我们只定义<code>@property</code>那么该属性就是只读的</p>

<h2 id="toc_2">多继承</h2>

<p>python中支持多继承,一个子类可以同时获得多个父类的所有功能</p>

<h3 id="toc_3">MixIn</h3>

<p>一般设计为单继承,但是当需要额外功能时可以用过多继承实现,这就是<br/>
<code>MixIn</code></p>

<h2 id="toc_4">定制类</h2>

<p>类似<code>__slots__</code>限制类的属性<br/>
<code>__len__()</code>方法让class能作用域<code>len()</code>函数</p>

<h3 id="toc_5"><strong>str</strong></h3>

<p><code>__str__()</code> 对于打印出来的对象信息修改<br/>
<code>__repr__()</code>对程序员看到的对象信息修改</p>

<pre><code class="language-python">class Student(object):
...     def __init__(self, name):
...         self.name = name
...     def __str__(self):
...         return &#39;Student object (name: %s)&#39; % self.name
            __repr__ = __str__ #经常把两个写作相同
...
print(Student(&#39;Michael&#39;)) #Student object (name: Michael)
#当开发者在命令行直接输入对象 会打印对象信息，这是调用的是__repr__()
</code></pre>

<h3 id="toc_6"><strong>iter</strong></h3>

<p>如果类需要被<code>for...in</code>循环,必须实现<code>__iter__()</code>方法,返回一个可迭代对象，然后调用对象的<code>__next__()</code>方法获取循环下一个值,直到遇到<code>StopIteration</code>错误退出循环</p>

<blockquote>
<p>学习迭代器一章知道,调用iter()方法转为迭代器,然后调用next方法获取下一个值,其内部实现就是<code>__iter__()</code>和<code>__next__()</code></p>
</blockquote>

<pre><code class="language-python">
class My_Iter_Class(object):
    &quot;&quot;&quot;docstring for My_Iter_Class&quot;&quot;&quot;
    def __init__(self):
        self.a=0
    def __iter__(self):
        return self

    def __next__(self):
        self.a+=1
        while self.a&gt;10:
            raise StopIteration()
        print(self.a)


for x in My_Iter_Class():
    pass


</code></pre>

<h3 id="toc_7"><strong>getitem</strong></h3>

<p>对于实现了<code>__iter__()</code>和<code>__next__()</code>可以用for遍历,但是并不能像list一样取某个下标或者进行切片操作,这时需要实现<code>__getitem__()</code>方法</p>

<pre><code class="language-python">class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        #判断是否为切片对象
        if isinstance(n, slice): # n是切片  
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
</code></pre>

<blockquote>
<p>在<code>__getitem__()</code>方法中，需要判断是取下标索引传入参数为<code>int</code>，还是传入的为切片<code>slice</code>进行切片操作<br/>
上面对切片操作并不完善，比如对于负数的处理</p>
</blockquote>

<p><strong>对应于__getitem__()还有__setitem__()来对类进行赋值 <strong>delitem</strong>()删除某个元素</strong></p>

<h3 id="toc_8"><strong>getattr</strong></h3>

<p>当我们调用类中不存在的属性或方法时时，Python解释器会试图调用<code>__getattr__(self, &#39;attr&#39;)</code>来获得属性或方法，我们就可以通过这个方法来返回对应不存在属性值或方法</p>

<blockquote>
<p>如果我们实现了这个方法,默认返回是<code>None</code>无法提示用户该属性不存在,我们可以返回一个<code>raise AttributeError</code>错误</p>
</blockquote>

<h3 id="toc_9"><strong>call</strong></h3>

<p>当我们在类内部实现<code>__call__()</code>方法后,我们就可以直接对实例进行调用</p>

<pre><code class="language-python">class My_Call_Class(object):
    def __call__(self):
        print(&quot;调用自身call&quot;)

obj1=My_Call_Class()
obj1() # 调用自身call

#判断一个对象是否可调用
if callable(obj1): #True
    print(&quot;可调用&quot;)  #可调用

</code></pre>

<blockquote>
<p>对于可直接调用对象，可以将其看做函数,可以传参数</p>
</blockquote>

<h2 id="toc_10">枚举类</h2>

<p>Python为定义大量常量的枚举 提供了<code>Enum</code>类</p>

<p>使用Enum实现一个简单的枚举</p>

<pre><code class="language-python">Month = Enum(&quot;Month&quot;, (&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;))
print(Month.Jan) # Month.Jan
print(Month.Mar.value) # 3

# __members__返回所有成员的name-&gt;value的map
for name, member in Month.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)
</code></pre>

<p>对于某些情况我们可能需要自定义枚举,可以从<code>Enum</code>派生出自定义类</p>

<pre><code class="language-python">class WeekDay(Enum):
    Sun=7
    Mon=1
    Tue=2
    Wed=3
    Thu=4
    Fri=5
    Sat=6

print(WeekDay.Sun) #WeekDay.Sun
print(WeekDay.Fri.value) #5

for name, member in WeekDay.__members__.items():
    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)
</code></pre>

<p><code>Enum</code>可以把相关常量定义在一个不可变<code>class</code>中,成员之间可以直接比较</p>

<h2 id="toc_11">元类</h2>

<p><strong>动态语言和静态语言最大的不同就是,函数和类的定义不是编译时定义的而是运行时动态创建的</strong></p>

<p>当python解释器载入模块时，就会依次执行该模块中的所有语句</p>

<p><code>class</code>的定义是在运行时动态创建的，创建<code>class</code>的方法就是使用<code>type()</code>函数</p>

<p>利用<code>type</code>函数创建一个class</p>

<pre><code class="language-python">def hello_func(self, name=&quot;world&quot;):
    print(&quot;hello, &quot;, name)

#用type创建Hello class
Hello_Class=type(&quot;Hello&quot;, (object,), dict(hello=hello_func))

h1= Hello_Class()
h1.hello() # hello,  world
</code></pre>

<p>用type定义的类与class定义的完全相同,python解释器遇到class定义类也是仅仅扫描一下后调用<code>type()</code>方法来定义类</p>

<blockquote>
<p>当前执行的模块名字为__main__</p>
</blockquote>

<h3 id="toc_12">metaclass</h3>

<p><code>metaclass</code>允许我们创建或者修改类</p>

<p><code>metaclass</code>是类的模板，所以必须从<code>type</code>类型派生</p>

<p>该节不常用,自行参考<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000">廖雪峰的python学习元类</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面对对象编程]]></title>
    <link href="https://acefish.github.io/15324145349319.html"/>
    <updated>2018-07-24T14:42:14+08:00</updated>
    <id>https://acefish.github.io/15324145349319.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类和实例</h2>

<p><code>class</code>关键字定义类<br/>
类名通常首字母大写</p>

<pre><code class="language-python">class My_Class_Student(object):
    &quot;&quot;&quot;docstring for My_Class_Student&quot;&quot;&quot;
    def __init__(self, name):
        super(My_Class_Student, self).__init__()
        self.name = name
        
lyy=My_Class_Student(&quot;liyuyuan&quot;)

print(lyy)
print(lyy.name) # liyuyuan
</code></pre>

<p><code>__init__</code>方法定义初始化对象时必须要传入的参数,比如上面student初始化时必须传入name</p>

<p>在类中定义的函数，第一个参数永远是实例变量<code>self</code>，调用时不用传递该参数</p>

<h3 id="toc_1">数据封装</h3>

<p>使用类中定义的方法来实现数据封装</p>

<pre><code class="language-python">class My_Class_Student(object):
    &quot;&quot;&quot;docstring for My_Class_Student&quot;&quot;&quot;
    def __init__(self, name):
        super(My_Class_Student, self).__init__()
        self.name = name
    def print_name(self):
        print(self.name)
        
lyy=My_Class_Student(&quot;liyuyuan&quot;)

print(lyy)
print(lyy.name) # liyuyuan
lyy.print_name() #liyuyuan

</code></pre>

<h2 id="toc_2">访问限制</h2>

<p>让内部属性不被外部访问，可以再属性名称前加双下划线<code>__</code>，在python中，以<code>__</code>开头的变量名就为私有变量,外部不能访问（只能为<code>__</code>不能<code>_</code>）</p>

<pre><code class="language-python">class My_Class_Student(object):
    &quot;&quot;&quot;docstring for My_Class_Student&quot;&quot;&quot;
    def __init__(self, name):
        super(My_Class_Student, self).__init__()
        self.__name = name
    def print_name(self):
        print(self.__name)
        
lyy=My_Class_Student(&quot;liyuyuan&quot;)

print(lyy.__name) # AttributeError:&#39;My_Class_Student&#39; object has no attribute &#39;__name&#39;
lyy.print_name() #liyuyuan
</code></pre>

<blockquote>
<p>变量名为<code>__xxx__</code>是特殊变量，外部可以直接访问的</p>

<p>对于单下划线开头的变量,虽然可以访问,但是约定俗成不要访问,当做私有变量</p>

<p>对于<code>__</code>开头的变量，其实python是将其改名为<code>_classname__变量名</code>，我们也可以通过其进行访问，不建议</p>
</blockquote>

<h2 id="toc_3">继承和多态</h2>

<h3 id="toc_4">继承</h3>

<pre><code class="language-python">class Animal(object):
    def run(self):
        print(&#39;Animal is running...&#39;)

#继承了Animal 就自带了run方法
class Dog(Animal):
    pass

#重写父类继承的方法
class Cat(Animal):
    def run(self):
        print(&#39;Cat is running...&#39;)
    
</code></pre>

<h3 id="toc_5">多态</h3>

<p>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p>

<pre><code class="language-python">b = Animal() # b是Animal类型
isinstance(b, Animal)  #True
</code></pre>

<blockquote>
<p>对于静态语言(java等),需要传入的必须是Animal类型或者其子类,否则无法调用其方法</p>

<p>对于python等动态语言,没有类型检查,只需要保证其有执行的方法就行了，就可以执行<br/>
这就是鸭子类型</p>
</blockquote>

<h2 id="toc_6">获取对象信息</h2>

<h3 id="toc_7">type()</h3>

<p>用<code>type()</code>来获取对象类型</p>

<pre><code class="language-python">if type(&quot;name&quot;) == type(&quot;dd&quot;):
    print(&quot;类型相同+&quot;,type(&quot;name&quot;)) # 类型相同+ &lt;class &#39;str&#39;&gt;
</code></pre>

<h3 id="toc_8">isinstance()</h3>

<p>对于继承关系来说,<code>type()</code>并不好用,我们可以使用<code>isinstance()</code>函数来判断<code>class</code>类型<br/>
<code>isinstance()</code>对于该类型以及父类继承链 均返回<code>True</code></p>

<pre><code class="language-python">#用type() 判断的基本类型 也可以用isinstance判断
isinstance(123, int) # True


# 判断是否为某些类型的一种
 isinstance([1, 2, 3], (list, tuple))  #True

</code></pre>

<h3 id="toc_9">dir() getattr() setattr() hasattr()</h3>

<p>用<code>dir()</code>来获得对象的所有属性和方法</p>

<p><code>hasattr()</code>判断该对象是否有此属性<br/>
<code>setattr()</code>设置一个属性<br/>
<code>getattr()</code>获取该属性的值 ，当试图获取不存在的属性，会抛出<code>AttributeError</code>错误</p>

<h2 id="toc_10">实例属性和类属性</h2>

<p>对于类属性,直接在<code>class</code>定义</p>

<pre><code class="language-python">class My_Student_Class(object):
    &quot;&quot;&quot;docstring for My_Student_Class&quot;&quot;&quot;
    name=&quot;My_Student_Class&quot; #在类中直接定义的类属性

stu1=My_Student_Class()
# 因为对象没有name属性,因此继续查找class的name属性
print(stu1.name) # My_Student_Class
print(My_Student_Class.name) #My_Student_Class
stu1.name=&quot;liyuyuan&quot;
print(stu1.name,&quot;  &quot;,My_Student_Class.name) #  liyuyuan    My_Student_Class
del stu1.name #删除实例的name属性
print(stu1.name) # My_Student_Class
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模块]]></title>
    <link href="https://acefish.github.io/15324005146874.html"/>
    <updated>2018-07-24T10:48:34+08:00</updated>
    <id>https://acefish.github.io/15324005146874.html</id>
    <content type="html"><![CDATA[
<p>在python中一个.py文件就称为一个模块</p>

<p>使用模块不仅可以增加代码的维护性和复用性,还可以避免函数名和变量名冲突,相同名字的函数和变量可以存在不同模块中</p>

<p>为了避免模块名冲突,<code>Python</code>引入了按照目录组织模块的方法:<strong>包</strong>,只要我们的报名不与别人冲突,那么所有模块就不会冲突</p>

<blockquote>
<p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是mycompany。</p>
</blockquote>

<p><img src="media/15324005146874/15324024289634.jpg" alt="" style="width:587px;"/></p>

<ol>
<li>文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。</li>
<li>mycompany.web也是一个模块</li>
</ol>

<h2 id="toc_0">使用模块</h2>

<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&quot;这是一个测试模块&quot; #任何模块的第一个字符串都会被视为模块的注释

__author__=&quot;ACEfish&quot;


import sys #导入模块

def test():
    args = sys.argv #sys模块有一个argv变量，用list存储了命令行的所有参数
    if len(args)==1:
        print(&quot;只有一个参数&quot;,args[0])
    elif len(args)==2:
        print(&quot;两个参数&quot;,args[0],args[1])
    else :
        print(&quot;too many params!&quot;)


if __name__ == &quot;__main__&quot;: #当我们在命令行执行该文件时，会把一个特殊变量__name__置为__main__,而如果在其他地方导入该hello模块时，if判断将失败因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
    test()
else:
    print(&quot;不执行测试模块&quot;)
</code></pre>

<blockquote>
<p>当我们在命令行执行该文件时，会把一个特殊变量__name__置为__main__,而如果在其他地方导入该hello模块时，if判断将失败因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
</blockquote>

<h3 id="toc_1">作用域</h3>

<p><code>python</code>中并没有绝对的限制<code>private</code>函数或变量,因此：</p>

<ol>
<li>正常的函数和变量名是公开的</li>
<li>类似<code>__xxx__</code>是特殊变量，可以被直接引用，但是有特殊用途,例如: <code>__author__</code> <code>__name__</code></li>
<li>类似<code>_xxx</code>或者<code>__xxx</code>是非公开的，不应该被引用</li>
</ol>

<h2 id="toc_2">第三方模块</h2>

<h3 id="toc_3">模块搜索路径</h3>

<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p>

<p><strong>默认情况下，<code>Python解释器</code>会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：</strong></p>

<pre><code class="language-python">import sys
sys.path
</code></pre>

<p>如果我们要添加自己的搜索目录，有两种方法：</p>

<ol>
<li>直接修改<code>sys.path</code>，添加要搜索的目录</li>
<li>设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数式编程]]></title>
    <link href="https://acefish.github.io/15320795459657.html"/>
    <updated>2018-07-20T17:39:05+08:00</updated>
    <id>https://acefish.github.io/15320795459657.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">高阶函数</h2>

<ol>
<li><p>变量可以指向函数</p>
<pre><code class="language-python">print(abs(-10)) # 10
abs_func=abs<br/>
print(abs_func(-10)) # 10
</code></pre></li>
<li><p>函数名也是变量<br/>
例如 <code>abs</code>就是一个指向获取绝对值的函数，我们可以试着将<code>abs</code>指向其它对象,这时<code>abs</code>也就无法完成获取绝对值</p></li>
<li><p>传入参数<br/>
函数可以接收另外一个函数作为参数</p>
<pre><code class="language-python">def my_funcparam_func(x, y, f):
   return f(x)+f(y)<br/>
print(my_funcparam_func(10,-10,abs))  #20
</code></pre></li>
</ol>

<h3 id="toc_1">map/reduce</h3>

<ol>
<li><p>map用法<br/>
map将传入的参数依次作用域每个元素，将结果作为<code>Iterator</code>返回</p>
<pre><code class="language-python">r1=map(my_func_xx,[1,2,3,4,5])
list1=list(r1) #因为返回的时Iterator惰性序列,使用list将整个序列计算返回list<br/>
print(list1)  # [1, 4, 9, 16, 25]
</code></pre></li>
<li><p>reduce用法<br/>
<code>reduce</code>把一个函数作用在一个序列上,这个函数接收两个参数，将结果继续和下一个元素做累计运算</p>
<pre><code class="language-python">from functools import reduce
def my_func_add(x, y):<br/>
    return x+y<br/>
list2=reduce(my_func_add,[1,2,3,4])<br/>
print(list2) #10
</code></pre>
<h3 id="toc_2">filter</h3></li>
</ol>

<p><code>filter</code>将传入函数依次作用于每个元素,然后根据返回值为<code>True</code>或者<code>False</code>，决定保留或者丢弃该元素</p>

<pre><code class="language-python">    def my_is_odd(x):
        return x%2==0
    #返回的还是Iterator的惰性序列
    list3=list(filter(my_is_odd, [1,2,4,5,6]))
    print(list3)  #[2, 4, 6]
</code></pre>

<h3 id="toc_3">排序</h3>

<p><code>sorted</code>函数</p>

<pre><code class="language-python">list4=[1, 2,-4,0,-3]
#直接用sorted函数排序
sorted(list4) # [-4, -3, 0, 1, 2]
sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;]) #[&#39;Credit&#39;, &#39;Zoo&#39;, &#39;about&#39;, &#39;bob&#39;]
#用关键字排序
sorted(list4, key=abs) #[0, 1, 2, -3, -4]
#反向排序 
sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)

</code></pre>

<p>默认对字符串的排序,按照ASCII码大小比较,<br/>
<code>key</code>指定的函数作用域list的每个元素.并根据返回结果进行排序</p>

<h2 id="toc_4">返回函数</h2>

<p>函数作为结果值进行返回</p>

<pre><code class="language-python">def my_lazy_sum(*args):
    def my_sum():
        sum=0
        for x in args:
            sum+=x
        return sum
    return my_sum

my_f=my_lazy_sum(1,2,3,4)
my_f() #10

</code></pre>

<p>在函数内部又定义了函数,内部函数可以引用外部函数的参数和局部变量,当外部函数返回内部函数时,参数和变量都保存在返回的函数中，这就是<code>闭包</code></p>

<h3 id="toc_5">闭包</h3>

<p>注意:返回的函数并不会立即执行，而是直到调用才执行,因此函数内用到的变量是执行时的变量值,为了避免:<strong>返回函数时，不要饮用任何循环变量或后续会变化的变量</strong></p>

<h2 id="toc_6">匿名函数</h2>

<p><code>lambda</code>关键字表示匿名函数，冒号前为函数参数<br/>
匿名函数也可以作为返回值</p>

<pre><code class="language-python">my_f2=lambda x: x*x
print(my_f2(2)) #4
</code></pre>

<h2 id="toc_7">装饰器</h2>

<p>函数有<code>__name__</code>属性，可以拿到函数的名字</p>

<pre><code class="language-python">def my_func_now(x):
    return x*3

name=my_func_now.__name__
print(name) #my_func_now
</code></pre>

<p>定义一个装饰器decorator</p>

<pre><code class="language-python">def my_custom_decorator(func):
    def my_wrapper(*args, **kw):
        print(&quot;call %s()&quot;%func.__name__)
        return func(*args, **kw)
    return my_wrapper
</code></pre>

<p>用装饰器装饰一个函数</p>

<pre><code class="language-python">@my_custom_decorator #相当于执行了my_log=my_custom_decorator(my_log)
def my_log():
    print(&quot;my_log_func&quot;)

my_log() 
#call my_log()
# my_log_func
</code></pre>

<p>在执行<code>my_log</code>函数不仅会执行函数本身，还会运行装饰器的<code>my_wrapper</code>函数</p>

<p><code>decorator</code>还可以传入参数，就需要更复杂的3层嵌套</p>

<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
    
@log(&#39;execute&#39;) #3层嵌套相当于:  now = log(&#39;execute&#39;)(now)
def now():
    print(&#39;2015-3-25&#39;)
#execute now():
#2015-3-25
</code></pre>

<blockquote>
<p>当需要在装饰器中获取到真正执行的函数名称时,我们可以使用<code>Python</code>内置的<code>functools.wraps</code></p>
</blockquote>

<pre><code class="language-python">import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__) #此时获取到的name为装饰的函数名称，而不是wrapper
        return func(*args, **kw)
    return wrapper
</code></pre>

<h2 id="toc_8">偏函数</h2>

<p>使用<code>functools.partial</code>将函数的某些参数固定住（设置默认值）,返回一个新的函数</p>

<pre><code class="language-python">import functools

int2=functools.partial(int, base=2)
print(int2(&quot;100&quot;))  #4
</code></pre>

<p>实际<code>functools.partial</code>接受三个参数:函数对象、<code>*args</code>、<code>**kw</code>,会将<code>*args</code>参数部分自动加到函数对象的左边,而将<code>**kw</code>一部分自动加到右边</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS CPU 和 Xcode Architectures]]></title>
    <link href="https://acefish.github.io/15318113047968.html"/>
    <updated>2018-07-20T14:33:10+08:00</updated>
    <id>https://acefish.github.io/15318113047968.html</id>
    <content type="html"><![CDATA[
<p>arm64：iPhone6s | iphone6s plus｜iPhone6｜ iPhone6 plus｜iPhone5S | iPad Air｜ iPad mini2(iPad mini with Retina Display)<br/>
armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)<br/>
armv7：iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p>

<p>i386是针对intel通用微处理器32位处理器<br/>
x86_64是针对x86架构的64位处理器</p>

<p>模拟器32位处理器测试需要i386架构，<br/>
模拟器64位处理器测试需要x86_64架构，<br/>
真机32位处理器需要armv7,或者armv7s架构，<br/>
真机64位处理器需要arm64架构。</p>

<p>Xcode中指令集相关选项（Build Setting中）</p>

<p>Architectures<br/>
指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p>

<p>Valid Architectures<br/>
限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定</p>

<p>Build Active Architecture Only<br/>
指定是否只对当前连接设备所支持的指令集编译<br/>
当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。</p>

<p>Valid Architectures 设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高级特性]]></title>
    <link href="https://acefish.github.io/15319012648780.html"/>
    <updated>2018-07-18T16:07:44+08:00</updated>
    <id>https://acefish.github.io/15319012648780.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">切片</h2>

<p>list的切片</p>

<pre><code class="language-python">listTest = list(range(100))

listTest[:10]  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
listTest[:10:2] #[0, 2, 4, 6, 8]
listTest[-10:] # [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
listTest[:] # 拷贝一个新的list 相当于深拷贝
</code></pre>

<p>元组:<br/>
元组的切片结果 仍为不可变的元组</p>

<pre><code class="language-python">(0, 1, 2, 3, 4, 5)[:3] #(0, 1, 2)
</code></pre>

<p>字符串也可看做一种list，可执行切片</p>

<pre><code class="language-python">&#39;ABCDEFG&#39;[:3] #&#39;ABC&#39;
&#39;ABCDEFG&#39;[::2] #&#39;ACEG&#39;
</code></pre>

<h2 id="toc_1">迭代</h2>

<pre><code class="language-python">#遍历dict
for key in dict2: #遍历所有键
for key in dict2.values(): #遍历所有值
for key in dict2.items(): #遍历所有键值对，返回为元组
    print(key)
</code></pre>

<p>当遍历时需要下标时,用enumerate()方法可以获取索引</p>

<pre><code class="language-python">for x, value in enumerate(dict2):
    print(x, value)
</code></pre>

<h2 id="toc_2">列表生成器</h2>

<pre><code class="language-python">L1=list(range(1,11))
print(L1) #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
L2=[x*x for x in L1]
print(L2) #[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
L3=[x*x for x in L1 if x%2 == 0]
print(L3) # [4, 16, 36, 64, 100]
L4=[str(x1)+str(x2) for x1 in list(range(3)) for x2 in list(range(3,6))]
print(L4) # [&#39;03&#39;, &#39;04&#39;, &#39;05&#39;, &#39;13&#39;, &#39;14&#39;, &#39;15&#39;, &#39;23&#39;, &#39;24&#39;, &#39;25&#39;]
</code></pre>

<h2 id="toc_3">生成器 generator</h2>

<p>在列表中一遍循环一边计算的机制,称为生成器：<code>generator</code></p>

<p>创建生成器:</p>

<ol>
<li><p>方法一: 通过将列表生成器的<code>[]</code>改为<code>()</code></p>
<pre><code class="language-python"> LI1=list(range(1,5))
LI2=(x*x for x in LI1)<br/>
#通过next()方法来获取生成器中的下一个值 直到最后一个元素抛出错误<br/>
print(next(LI2))<br/>
print(next(LI2))<br/>
print(next(LI2))<br/>
print(next(LI2))<br/>
print(next(LI2)) # 抛出 StopIteration错误<br/>
# 通过next()方法太麻烦,我们应该用 for 循环 不用关心StopIteration错误<br/>
for x in LI2:<br/>
    print(x)<br/>
# 1<br/>
# 4<br/>
# 9<br/>
# 16
</code></pre></li>
<li><p>方法二: 函数中包含<code>yield</code>关键字,为一个generator函数<br/>
generator函数在遇到yield关键字时会中断，返回yeild后的值,next之后会继续执行,直到没有yeild就会报错<br/>
当然也可以通过<code>for</code>循环来获取</p>
<pre><code class="language-python">def my_generatorFuc():
    print(&quot;step1&quot;)<br/>
    yield (1)<br/>
    print(&quot;step2&quot;)<br/>
    yield (5)<br/>
    print(&quot;step3&quot;)<br/>
    yield(10)<br/>
    return 100
</code></pre></li>
</ol>

<blockquote>
<p>采用<code>next()</code>可以当遇到<code>StopIteration</code>错误可以获取到<code>generator</code>函数的<code>return</code>值,返回值包含在<code>StopIteration</code>的<code>value</code>中<br/>
采用<code>for</code>循环获取不到函数的返回值,因此需要捕获<code>StopIteration</code>错误</p>
</blockquote>

<h2 id="toc_4">迭代器</h2>

<p> 对于可以用for循环的对象称为可迭代对象:<code>Iterable</code><br/>
 目前常用的可迭代对象有:<br/>
 1. list、tuple、dict、set、str<br/>
 2. generator:生成器和带<code>yield</code>的generator函数<br/>
 <br/>
 可以被next()函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code><br/>
 生成器都是迭代器,但是list、tuple、dict、set、str等是可迭代对象但不是迭代器<br/>
 </p>

<blockquote>
<p><code>Iterator</code>对象表示的是一个数据流，是一个惰性序列,不能事先知道序列长度，只能通过需要是<code>next()</code>计算下一个序列值</p>

<p><code>for</code>循环本质上是通过不停调用<code>next()</code>来实现的</p>

<p>list、tuple、dict、set、str等可迭代对象可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象</p>
</blockquote>

<pre><code class="language-python">it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break
</code></pre>

<p> <br/>
 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数]]></title>
    <link href="https://acefish.github.io/15318121291068.html"/>
    <updated>2018-07-17T15:22:09+08:00</updated>
    <id>https://acefish.github.io/15318121291068.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常用函数</h2>

<h3 id="toc_1">类型转换</h3>

<pre><code class="language-python">int(&#39;123&#39;)
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float(&#39;12.34&#39;)
12.34
&gt;&gt;&gt; str(1.23)
&#39;1.23&#39;
&gt;&gt;&gt; str(100)
&#39;100&#39;
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(&#39;&#39;)
False
</code></pre>

<h2 id="toc_2">定义函数</h2>

<pre><code class="language-python">def my_abs(x):
    # 检查参数类型 
    if not isinstance(x, (int, float)):
       # 当参数类型错误时  抛出错误
        raise TypeError(&quot;bad operate Params type&quot;)

    if x&gt;0:
        return x
    else:
        return -x

print(my_abs(&quot;-333&quot;)) #TypeError: bad operate Params type
</code></pre>

<p>定义一个空函数</p>

<pre><code class="language-python">def nop():
    pass
# pass用作占位符 
</code></pre>

<p>返回多个返回值<br/>
返回的其实为单一一个值，一个<code>元组</code>,我们通过多个变量接收一个元组,按位置赋值</p>

<pre><code class="language-python">import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

x, y = move(100, 100, 60, math.pi / 6)
print(x, y)
151.96152422706632 70.0
</code></pre>

<blockquote>
<p>若函数结束时没有<code>return</code>语句，就自动添加 <code>return None</code></p>
</blockquote>

<h2 id="toc_3">函数参数</h2>

<p>python的函数定义简单,灵活度很大.除了正常的必选参数外,还能使用默认参数、可变参数、关键字参数。</p>

<p><strong>参数组合</strong></p>

<blockquote>
<p>在Python中，可以使用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，但是参数的定义顺序必须是:<code>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</code></p>
</blockquote>

<pre><code class="language-python">def f1(a, b, c=0, *args, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)

def f2(a, b, c=0, *, d, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)
</code></pre>

<h3 id="toc_4">默认参数</h3>

<p>必选参数在前,默认参数在后</p>

<pre><code class="language-python">def my_power(x, n=2):
    total = 1
    for s in range(1,n+1):
        total = total*x
    return total

print(my_power(2))  # 4
</code></pre>

<p><strong>定义默认参数时: 默认参数必须指向不变对象,否则可变对象会成为函数内静态变量会在多次调用时变化，影响函数调用结果</strong></p>

<blockquote>
<p>使用默认参数即可省略参数，降低调用难度</p>
</blockquote>

<h3 id="toc_5">可变参数</h3>

<p>当不确定参数的个数时,可以使用可变参数，可以传入任意个参数,包括0个参数</p>

<pre><code class="language-python">def my_sum(*numbers):
    sum=0
    for x in numbers:
        sum += x

    return sum

print(my_sum(1,2,3,4)) # 10
numbers = [1,2,3,4,5]
#通过给list 或者 tuple前加*  将其元素变为可变参数
print(my_sum(*numbers)) #15 
</code></pre>

<p>传入的可变参数在函数内部封装为一个元组</p>

<h3 id="toc_6">关键字参数</h3>

<p>可以传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动封装为dict</p>

<pre><code class="language-python">def my_personFuc(name, age, **kw):
    print(&quot;name:&quot;, name, &quot;age:&quot;, age, kw)

my_personFuc(&quot;lyy&quot;, 24, city=&quot;luoyang&quot;) #name: lyy age: 24 {&#39;city&#39;: &#39;luoyang&#39;}
my_personFuc(&quot;wt&quot;, 20) # name: wt age: 20 {}

kwDict={&quot;city&quot;:&quot;beijing&quot;}
# 解构字典
my_personFuc(&quot;yt&quot;, &quot;25&quot;, **kwDict) # name: yt age: 25 {&#39;city&#39;: &#39;beijing&#39;}
</code></pre>

<blockquote>
<p>对于关键字参数，对于直接传入的参数，采用<code>=</code>而且<code>key</code>不能为str类似的字符串</p>
</blockquote>

<h3 id="toc_7">命名关键字参数</h3>

<pre><code class="language-python">#命名需要关键字 * ，在 * 之后的为命名关键字参数，
def my_keyPerson(name, age, *, city, job):
    print(name, age, city, job)

#命名关键字必须传入参数名 否则会报错 
my_keyPerson(&quot;lyy&quot;, 24, city=&quot;luoyang&quot;, job=&quot;iOS&quot;) # lyy 24 luoyang iOS

# 可以为可变参数隔开
def my_keyPerson1(name, age, *args, city, job):
    print(name, age, args, city, job)

# 明明关键字可以有缺省值,这样调用时候可以不传入city参数
def my_keyPerson2(name, age, *, city=&#39;Beijing&#39;, job):
    print(name, age, city, job)

</code></pre>

<h2 id="toc_8">递归函数</h2>

<p>解决递归调用栈溢出的方法是通过<code>尾递归优化</code>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。<br/>
<code>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</code>。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况</p>

<pre><code class="language-python"># 递归函数
def fact(n):
    if n==1:
        return 1
    return n + fact(n - 1)

print(fact(10))  # 55
# 栈溢出
print(fact(1000))  #RecursionError: maximum recursion depth exceeded in comparison

#尾递归优化后
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
</code></pre>

<blockquote>
<p>目前包括Python在内的编程语言都没有做尾递归优化,因此类似上面的尾递归优化之后仍会导致栈溢出</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语句]]></title>
    <link href="https://acefish.github.io/15317414032911.html"/>
    <updated>2018-07-16T19:43:23+08:00</updated>
    <id>https://acefish.github.io/15317414032911.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">list</h2>

<pre><code class="language-python">
list1=[1, 2, 3]

print(len(list1)) #长度 3
print(&quot;第一个元素:%s&quot; % (list1[0])) #从0开始获取第一个元素 1
print(&quot;最后一个元素:%s&quot; % (list1[-1])) #从-1开始获取最后一个元素 3

list1.append(4) #追加元素到末尾
print(&quot;m末尾追加元素：%s&quot;%(list1[-1]))  # 4

list1.insert(1, 1) #向索引1插入1
print(list1)  # [1, 1, 2, 3, 4]

list1.pop() #删除末尾元素
print(list1)  # [1, 1, 2, 3]

list1.pop(1) #删除指定索引位置元素
print(list1)  # [1, 2, 3]

list1[1] = 1 #替换元素
print(list1)  # [1, 1, 3]

list1[2] = &quot;第3个元素&quot;  #list中的数据类型可以不同
list1.append(False)
list1.append([5,6])
print(list1)  # [1, 1, &#39;第3个元素&#39;, False, [5, 6]]
</code></pre>

<h2 id="toc_1">tuple</h2>

<pre><code class="language-python">tuple1=(1,) #定义只有一个元素的元组 不能使用 tuple1=(1)这样定义为1这个数
print(tuple1) # (1,)
#tuple一经定义便不能修改，不过不变的是每个元素的指向,而可以修改器内指针元素指向的对象
tuple2=() # 定义一个空元组
</code></pre>

<blockquote>
<p>因为tuple与list相比不能修改,所以更安全，尽量使用元组</p>
</blockquote>

<h2 id="toc_2">条件语句</h2>

<pre><code class="language-python">if len(tuple2)==0:
    print(&quot;空元组&quot;)
elif len(tuple2)&gt;0:   # else if的缩写
    print(&quot;非空数组&quot;)
else:
    print(&quot;无效&quot;)
</code></pre>

<blockquote>
<p>对于判断条件中的非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code></p>
</blockquote>

<h2 id="toc_3">input</h2>

<pre><code class="language-python">birth=input(&quot;birth:&quot;)
birth=int(birth)
if birth &gt; 25:
    print(&quot;人到中年，身不由己&quot;)
else:
    print(&quot;你还年轻&quot;)
</code></pre>

<blockquote>
<p>input默认导入的为一个字符串 因此需要转换类型为int才能进行与数字进行比较</p>
</blockquote>

<h2 id="toc_4">for循环</h2>

<pre><code class="language-python">for x in list1: #遍历列表
    print(x)

for x in range(1,10): 
    print(x)
</code></pre>

<h2 id="toc_5">break continue</h2>

<p><code>break</code>用于提前退出循环<br/>
<code>continue</code>用于跳过当前这次循环</p>

<pre><code class="language-python">for x in range(1,10):
    if x==5:
        break
    print(x)
    
    for x in range(1,10):
    if x==5:
        continue
    print(x)
</code></pre>

<blockquote>
<p>不要滥用break和continue，容易逻辑分差太多而出错</p>
</blockquote>

<h2 id="toc_6">dict</h2>

<pre><code class="language-python">dict1={&quot;lyy&quot;:25, &quot;wtt&quot;:20}
dict1[None] = 10
dict1[&#39;Adam&#39;] = 67
print(dict1[None]) # 10
print(dict1) #{&#39;lyy&#39;: 25, &#39;wtt&#39;: 20, None: 10, &#39;Adam&#39;: 67}

#判断key是否存在  key in dict
if &quot;lyy&quot; in dict1:
    print(dict1[&quot;lyy&quot;])   #25

print(dict1.get(&quot;eee&quot;, &quot;placehoder&quot;)) #placehoder  获取key如果没有就返回None或自指定的value

dict1.pop(&quot;lyy&quot;)  #pop删除指定键
if &quot;lyy&quot; in dict1:
    print(dict1[&quot;lyy&quot;])
else:
    print(&quot;lyy不存在&quot;)  #不存在
    

dict1[(1,)] = &quot;name&quot;  #用元组作为key
print(dict1[(1,)])  #name
#虽然元组也是不可变对象 但是元素不能为list等可变对象
dict1[(1,[1,2])] = &quot;name&quot;  #报错  unhashable type: &#39;list&#39;
</code></pre>

<p><code>dict</code>的<code>key</code>必须为不可变对象,例如字符串，整数等，而list是可变的不能作为key</p>

<blockquote>
<p>和list比较，dict有以下几个特点：<br/>
查找和插入的速度极快，不会随着key的增加而变慢；<br/>
需要占用大量的内存，内存浪费多。<br/>
而list相反：<br/>
查找和插入的时间随着元素的增加而增加；<br/>
占用空间小，浪费内存很少。</p>
</blockquote>

<p>补充知识:</p>

<p><strong>dict()</strong>函数 用于创建一个字典,返回一个字典</p>

<pre><code class="language-python">class dict(**kwarg)  # **kwargs -- 关键字
class dict(mapping, **kwarg)  # mapping -- 元素的容器
class dict(iterable, **kwarg) # iterable -- 可迭代对象


dict()                        # 创建空字典
{}
dict(a=&#39;a&#39;, b=&#39;b&#39;, t=&#39;t&#39;)     # 传入关键字
{&#39;a&#39;: &#39;a&#39;, &#39;b&#39;: &#39;b&#39;, &#39;t&#39;: &#39;t&#39;}
dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))   # 映射函数方式来构造字典
{&#39;three&#39;: 3, &#39;two&#39;: 2, &#39;one&#39;: 1} 
dict([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])    # 可迭代对象方式来构造字典
{&#39;three&#39;: 3, &#39;two&#39;: 2, &#39;one&#39;: 1}
</code></pre>

<h2 id="toc_7">Set</h2>

<p><code>set</code>中不能元素不能重复,因此只能为不可变对象</p>

<p>要创建<code>set</code>需要用<code>list</code>作为输入集合</p>

<pre><code class="language-python">set1 = set([1, &quot;name&quot;, 1])
print(set1)  # {1, &#39;name&#39;}
set1.add(&quot;1&quot;)
set1.add(1)
print(set1)  # {1, &#39;1&#39;, &#39;name&#39;}
set1.remove(1)
print(set1)  # {&#39;1&#39;, &#39;name&#39;}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python基础]]></title>
    <link href="https://acefish.github.io/15317258769792.html"/>
    <updated>2018-07-16T15:24:36+08:00</updated>
    <id>https://acefish.github.io/15317258769792.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">数据类型</h2>

<h3 id="toc_1">字符串</h3>

<p><strong>字符串是不可变的</strong></p>

<ol>
<li>用<code>&#39;</code>或者<code>&quot;</code>括起来的文本</li>
<li>可以通过 <code>\</code>转义字符来在文本中转义,进行<code>\n</code>换行 <code>\t</code>制表</li>
<li>可以通过在文本前加<code>r</code>表示文本不转义</li>
<li>用三个单引号<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的文本可以在内部直接换行而不需要<code>\n</code></li>
</ol>

<pre><code class="language-python">print(&quot;hello, world&quot;)
print(&quot;I\&#39;m OK!&quot;)
print(&quot;\t文本&quot;)
print(r&#39;&#39;&#39;\\line1
line2
line3aaaa&#39;&#39;&#39;)
</code></pre>

<h3 id="toc_2">布尔</h3>

<p><code>True</code>  真<br/>
<code>False</code> 假</p>

<p>布尔运算<br/>
<code>and</code>  与<br/>
<code>or</code>   或<br/>
<code>not</code>  非</p>

<h3 id="toc_3">空值</h3>

<p><code>None</code>表示空值</p>

<h2 id="toc_4">变量</h2>

<p>定义变量<br/>
<code>a=1</code></p>

<blockquote>
<p>python是动态语言 因此可以将不同类型的变量赋值给同一变量</p>
</blockquote>

<pre><code class="language-python">a=False
a=&quot;aa&quot;
print(a)
</code></pre>

<h2 id="toc_5">常量</h2>

<p>在python中常用全大写的变量名来表示常量</p>

<blockquote>
<p>python中除法<code>/</code>的结果为浮点数(即使整除),  <code>//</code>为地板除，两个除法的结果仍为整数</p>
</blockquote>

<pre><code class="language-python">print(10/3)   3.3333333333333335
print(10//3)   3
print(9/3)    3.0
print(9//3)   3
print(12.7//5.1)   2.0
print(1.2/3)    0.39999999999999997
</code></pre>

<h2 id="toc_6">编码</h2>

<p>在python3中字符串以Unicode编码，</p>

<p>可以通过<code>ord()</code>函数获取字符的整数表示<br/>
可以通过<code>chr()</code>函数将编码转为对应字符</p>

<pre><code class="language-python">print(ord(&quot;😱&quot;)) //128561
print(chr(128561)) //😱
//当知道字符的整数编码,可以用16进制来写str
print(&#39;\u4e2d\u6587&#39;) //中文
</code></pre>

<p>Python对bytes类型的数据用带<code>b</code>前缀的单引号或双引号表示:</p>

<pre><code class="language-python">x = b&#39;ABC&#39;
</code></pre>

<blockquote>
<p>python的字符串<code>str</code>在内存中以Unicode表示,当在网上传输或者保存磁盘时,需要将其转为以字节为单位的<code>bytes</code>使用<code>encode()</code>,而当从网络或磁盘读取数据读到的是<code>bytes</code>,将butes转为str，使用<code>decode()</code>方法</p>
</blockquote>

<p>可以通过<code>encode()</code>方法将<code>str</code>编码为指定的<code>bytes</code></p>

<pre><code class="language-python">print(&quot;中文&quot;.encode(&quot;utf-8&quot;))  # b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
print(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;))  #中文

#如果bytes中存在一小部分无效字节,可以添加errors=&#39;ignore&#39;来忽略错误的字节
b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)  #中
</code></pre>

<p><code>len()</code>函数用来计算<code>str</code>字符串的字符数,对于<code>bytes</code>则计算其字节数:</p>

<pre><code class="language-python">&gt;&gt;&gt; len(b&#39;ABC&#39;)
3
&gt;&gt;&gt; len(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
6
&gt;&gt;&gt; len(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
</code></pre>

<blockquote>
<p>为避免乱码,请坚持使用UTF-8编码进行转换,因此对于python的源码文件,指定其为UTF-8编码保存,并通过<code># -*- coding: utf-8 -*-</code>告诉编译器按照UTF-8读取源码</p>
</blockquote>

<p><strong><code># -*- coding: utf-8 -*-</code></strong></p>

<h2 id="toc_7">格式化</h2>

<pre><code class="language-python"># 格式化
print(&quot;这是字符串的%s格式化&quot; % (&quot;栗豫塬&quot;))
print(&quot;my name is %s age is %d height %.2f&quot; % (&quot;栗豫塬&quot;, 24, 17.0))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stack Navigation]]></title>
    <link href="https://acefish.github.io/15312926184354.html"/>
    <updated>2018-07-11T15:03:38+08:00</updated>
    <id>https://acefish.github.io/15312926184354.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">navigationOptions</h3>

<p>title: 导航栏的标题</p>

<p>header: 导航栏设置对象</p>

<p>headerTitle: 导航栏的标题, 可以是字符串也可以是个组件<br/>
headerBackTitle: 左上角的返回键文字, 默认是上一个页面的title，设置这个属性会覆盖掉title的值<br/>
headerRight: 导航栏右按钮<br/>
headerLeft: 导航栏左按钮<br/>
headerStyle: 导航栏的style<br/>
headerTitleStyle: 导航栏的title的style<br/>
headerTintColor: 返回按钮的颜色<br/>
headerPressColorAndroid ：按压返回按钮显示的颜色 安卓系统 &gt;= 5.0才有效。<br/>
gesturesEnabled ：是否允许右滑返回，在iOS上默认为true，在Android上默认为false</p>

<h3 id="toc_1">StackNavigatorConfig</h3>

<ul>
<li>initialRouteName: 设置默认的页面组件，必须是上面已注册的页面组件</li>
<li>initialRouteParams: 初始路由的参数</li>
<li>navigationOptions: 屏幕导航的默认选项</li>
<li>paths: RouteConfigs里面路径设置的映射</li>
<li>mode: 页面切换模式:
<ul>
<li>card: 普通app常用的左右切换</li>
<li>modal: 上下切换</li>
</ul></li>
<li>headerMode: 导航栏的显示模式:
<ul>
<li>float: 无透明效果, 默认</li>
<li>screen: 有渐变透明效果, 如微信QQ的一样</li>
<li>none: 隐藏导航栏</li>
</ul></li>
<li>cardStyle: 样式</li>
<li>onTransitionStart: 页面切换开始时的回调函数</li>
<li>onTransitionEnd: 页面切换结束时的回调函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[混合开发(OC)]]></title>
    <link href="https://acefish.github.io/15304988629042.html"/>
    <updated>2018-07-02T10:34:22+08:00</updated>
    <id>https://acefish.github.io/15304988629042.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">声明类 实现协议</h2>

<p>需要实现了<code>RCTBridgeModule</code>协议类,<br/>
导入<code>#import &lt;React/RCTBridgeModule.h&gt;</code></p>

<p>实现协议需要包含这个宏，可以添加参数作为访问此模块的名字 通常不指定默认使用类名<br/>
<code>RCT_EXPORT_MODULE();</code></p>

<h2 id="toc_1">声明原生方法给js调用</h2>

<p>声明需要提供给<code>React Native</code>组件调用的方法，即导出的方法<br/>
<code>RCT_EXPORT_METHOD()</code></p>

<pre><code class="language-javascript">//在OC中
RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
{
  RCTLogInfo(@&quot;Pretending to create an event %@ at %@&quot;, name, location);
}
//在js中这样调用
import { NativeModules } from &#39;react-native&#39;;
var CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent(&#39;Birthday Party&#39;, &#39;4 Privet Drive, Surrey&#39;);
</code></pre>

<p>通常我们将多个参数使用一个字典进行存放</p>

<pre><code class="language-javascript">#import &lt;React/RCTConvert.h&gt;

RCT_EXPORT_METHOD(addEvent:(NSString *)name details:(NSDictionary *)details)
{
  NSString *location = [RCTConvert NSString:details[@&quot;location&quot;]];
  NSDate *time = [RCTConvert NSDate:details[@&quot;time&quot;]];
  ...
}

CalendarManager.addEvent(&#39;Birthday Party&#39;, {
  location: &#39;4 Privet Drive, Surrey&#39;,
  time: date.toTime(),
  description: &#39;...&#39;
})
</code></pre>

<h3 id="toc_2">声明回调函数</h3>

<pre><code class="language-javascript">
//原生
//原生模块通常只应调用回调函数一次。但是，它可以保存callback并在将来调用
RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
{
  NSArray *events = ...
  callback(@[[NSNull null], events]);
}

//js调用
CalendarManager.findEvents((error, events) =&gt; {
  if (error) {
    console.error(error);
  } else {
    this.setState({events: events});
  }
})

//采用promise

//原生
RCT_REMAP_METHOD(findEvents,
                 resolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject)
{
  NSArray *events = ...
  if (events) {
    resolve(events);
  } else {
    reject(error);
  }
}
//js调用
async function updateEvents() {
  try {
    var events = await CalendarManager.findEvents();
    this.setState({ events });
  } catch (e) {
    console.error(e);
  }
}

updateEvents();

</code></pre>

<h2 id="toc_3">多线程</h2>

<p>生模块不应对自己被调用时所处的线程做任何假设。React Native在一个独立的串行GCD队列中调用原生模块的方法，但这属于实现的细节，并且可能会在将来的版本中改变。通过实现方法<code>- (dispatch_queue_t)methodQueue</code>，原生模块可以指定自己想在哪个队列中被执行。</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code></pre>

<p>如果一个操作需要花费很长时间，原生模块不应该阻塞住，而是应当声明一个用于执行操作的独立队列</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_queue_create(&quot;com.facebook.React.AsyncLocalStorageQueue&quot;, DISPATCH_QUEUE_SERIAL);
}
</code></pre>

<blockquote>
<p>在模块之间共享分发队列<br/>
methodQueue方法会在模块被初始化的时候被执行一次，然后会被React Native的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p>
</blockquote>

<h2 id="toc_4">导出常量</h2>

<pre><code class="language-objectivec">- (NSDictionary *)constantsToExport
{
  return @{ @&quot;firstDayOfTheWeek&quot;: @&quot;Monday&quot; };
}
</code></pre>

<h2 id="toc_5">给JS发送事件</h2>

<p>继承<code>RCTEventEmitter</code>，实现<code>suppportEvents</code>方法并调用<code>self sendEventWithName:</code></p>

<pre><code class="language-objectivec">#import &lt;React/RCTEventEmitter.h&gt;

- (NSArray&lt;NSString *&gt; *)supportedEvents
{
  return @[@&quot;EventReminder&quot;];
}

- (void)calendarEventReminderReceived:(NSNotification *)notification
{
  NSString *eventName = notification.userInfo[@&quot;name&quot;];
  [self sendEventWithName:@&quot;EventReminder&quot; body:@{@&quot;name&quot;: eventName}];
}

</code></pre>

<p>JavaScript代码可以创建一个包含你的模块的NativeEventEmitter实例来订阅这些事件。</p>

<pre><code class="language-javascript">import { NativeEventEmitter, NativeModules } from &#39;react-native&#39;;
const { CalendarManager } = NativeModules;

const calendarManagerEmitter = new NativeEventEmitter(CalendarManager);

const subscription = calendarManagerEmitter.addListener(
  &#39;EventReminder&#39;,
  (reminder) =&gt; console.log(reminder.name)
);
...
// 别忘了取消订阅，通常在componentWillUnmount生命周期方法中实现。
subscription.remove();
</code></pre>

<h2 id="toc_6">原生UI</h2>

<p>原生视图需要被一个RCTViewManager来管理和创建。本质上都是单例 - React Native只会为每个管理器创建一个实例。它们创建原生的视图并提供给<code>RCTUIManager</code>，<code>RCTUIManager</code>则会反过来委托它们在需要的时候去设置和更新视图的属性。RCTViewManager还会代理视图的所有委托，并给JavaScript发回对应的事件</p>

<ol>
<li>创建<code>RCTViewManager</code>的子类</li>
<li>添加<code>RCT_EXPORT_MODULE()</code>标记宏</li>
<li><p>实现<code>-(UIView *)view</code>方法</p></li>
<li><p>在js代码中将视图变为可用的React组件</p></li>
</ol>

<pre><code class="language-javascript">// MapView.js
var { requireNativeComponent } = require(&#39;react-native&#39;);

// requireNativeComponent 自动把这个组件提供给 &quot;RNTMapManager&quot;
module.exports = requireNativeComponent(&#39;RNTMap&#39;, null);
</code></pre>

<h3 id="toc_7">声明属性</h3>

<pre><code class="language-objectivec">//声明属性
RCT_EXPORT_VIEW_PROPERTY(pitchEnabled, BOOL)

//设置属性之后，在js中可以直接设置
&lt;MapView pitchEnabled={false} /&gt;

//比较复杂的属性
RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RNTMap)
{
  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组件属性一]]></title>
    <link href="https://acefish.github.io/15293961047296.html"/>
    <updated>2018-06-19T16:15:04+08:00</updated>
    <id>https://acefish.github.io/15293961047296.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">View</h2>

<h3 id="toc_1">颜色与边框</h3>

<ol>
<li>backgroundColor: 背景颜色</li>
<li>opacity: 0~1透明度</li>
<li><p>borderStyle: 边框风格</p>
<ul>
<li>solid: default 实线边框</li>
<li>dotted: 点状边框</li>
<li>dashed: 虚线边框</li>
</ul></li>
<li><p>borderColor: 边框颜色,可以单独定义上下左右</p></li>
<li><p>borderRadius: 定义圆角边框,可单独定义四个角</p></li>
</ol>

<blockquote>
<p>大部分组件继承了View的属性</p>
</blockquote>

<h3 id="toc_2">视觉效果</h3>

<h4 id="toc_3">阴影</h4>

<ol>
<li>shadowColor</li>
<li>shadowOffset</li>
<li>shadowOpacity</li>
<li>shadowRadius</li>
</ol>

<h4 id="toc_4">overflow</h4>

<p>取值为 visible和hidden(默认),定义子组件产出父组件部分的是否显示，当设置为visible时，仅对ios平台有效,显示超出父组件部分</p>

<h4 id="toc_5">elevation</h4>

<p>Android平台特有效果,在组件周围渲染阴影</p>

<h3 id="toc_6">变形</h3>

<p>利用<code>transform</code>设置组件的变形,包括<code>translate</code>平移,<code>scale</code>缩放,<code>rotate</code>旋转,<code>skew</code>倾斜</p>

<pre><code class="language-javascript">const styles = StyleSheet.create({
    view1Style: {
        ....
        transform: [{scale:2}, {rotateZ:&quot;45deg&quot;}]
    }
})
//Xdeg 表示角度 取值0-360
</code></pre>

<h3 id="toc_7">回调函数</h3>

<p>回调函数命名 onB 即B事件发生的回调函数</p>

<h4 id="toc_8">onLayOut</h4>

<p>当View组件被加载或者改变布局时</p>

<h4 id="toc_9">onTouchStart、onTouchMove、onTouchEnd</h4>

<p>开始触摸事件、触摸点移动事件、触摸结束事件<br/>
三个回调函数带一个event参数,</p>

<pre><code class="language-javascript">//Event结构有用对象
{
 timeStamp: aNumber, //时间戳
 nativeEvent: {
    locationX: aNumber,
    locationY: aNumber,
 }
}
</code></pre>

<pre><code class="language-javascript">//示例 demo
constructor(props) {
        super(props)
        this._onTouchStart = this._onTouchStart.bind(this)
    }

    _onTouchStart(event) {
        console.log( event.nativeEvent.locationX)
    }

    render() {
        return(
            &lt;View style={styles.containStyle}&gt;
                &lt;View style={styles.view1Style} onTouchStart={this._onTouchStart}&gt;

                &lt;/View&gt;
            &lt;/View&gt;
        )
    }
</code></pre>

<h4 id="toc_10">removeClippedSubviews</h4>

<p>布尔属性，与性能有关的，属性为true将允许释放不在显示范围内的子组件，需要将overflow设置为hidden才会生效</p>

<h3 id="toc_11">onLayOut</h3>

<p>应用通过<code>Dimension</code>获取屏幕宽高，Dimensions.get(&#39;window&#39;).width/height,获取到的宽和高是实时屏幕的宽和高,当横置时宽大于高</p>

<h3 id="toc_12">pointEvents</h3>

<p>在RN中 触摸事件总是传递给最上层的组件，当被遮盖的组件需要向银行触摸事件，就需要从View继承的<code>pointEvents</code></p>

<p>可以取值为<code>none</code> <code>box-none</code> <code>box-only</code> <code>auto</code></p>

<p><strong>none:</strong> 发生在本组件和子组件的触摸事件交给本组件的父组件处理<br/>
<strong>box-none:</strong> 本组件显示范围内，非子组件显示范围内的时间交给本组件父组件处理,子组件显示范围交给子组件处理<br/>
<strong>box-only:</strong> 本组件显示范围内的所有触摸事件都交给本组件处理<br/>
<strong>auto:</strong> 视组件不同而不同 不是所有组件都支持box-none和box-only</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[补充]]></title>
    <link href="https://acefish.github.io/15290351401483.html"/>
    <updated>2018-06-15T11:59:00+08:00</updated>
    <id>https://acefish.github.io/15290351401483.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">当安装了第三方库之后 需要重新yarn安装依赖</h3>

<p><code>yarn install</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象]]></title>
    <link href="https://acefish.github.io/15289781671435.html"/>
    <updated>2018-06-14T20:09:27+08:00</updated>
    <id>https://acefish.github.io/15289781671435.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">JS创建对象以及对象属性的几种方式</h2>

<h3 id="toc_1">1.创建直接的对象</h3>

<pre><code class="language-javascript">person=new Object();
person.firstname=&quot;Bill&quot;;
person.lastname=&quot;Gates&quot;;
person.age=56;
person.eyecolor=&quot;blue&quot;;
</code></pre>

<h3 id="toc_2">2.替代语法(使用对象 literals)</h3>

<pre><code class="language-javascript">person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,age:50,eyecolor:&quot;blue&quot;};

</code></pre>

<h3 id="toc_3">3.函数对象构造器</h3>

<pre><code class="language-javascript">function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}
</code></pre>

<h3 id="toc_4">4.使用class</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[导航页面]]></title>
    <link href="https://acefish.github.io/15289587744708.html"/>
    <updated>2018-06-14T14:46:14+08:00</updated>
    <id>https://acefish.github.io/15289587744708.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">适配不同平台</h3>

<ol>
<li><p>文件适配</p>
<p>通过命名文件后缀为 <code>.android.js</code> 和 <code>.ios.js</code>文件 RN会根据不同平台加载不同文件</p></li>
<li><p>平台检测</p></li>
</ol>

<pre><code class="language-javascript">import {
    Platform

} from &#39;react-native&#39;
if(Platform.OS === &quot;android&quot;) {
//安卓代码
} else  {
//iOS代码
}
</code></pre>

<h3 id="toc_1">监测android物理后退按钮时间</h3>

<pre><code class="language-javascript">//对于android 点击后退按钮 如果当前有后退视图就后退 并返回true 否则返回false标识后退事件没被处理 传递给操作系统 就退出应用
    handleBackAndroid() {
        if (this.navigator.getCurrentRoutes().length &gt; 1) {
            this.navigator.pop()
            return true
        } else  {
            return false
        }
    }
    //组件挂接到当前页面
    componentDidMount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.addListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }
    //组件挂接到当前页面
    componentWillUnmount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.removeListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }

</code></pre>

<p>可以使用<code>BackAndroid</code>的<code>addEventListener</code>函数挂接多个监听器,当返回键按下，最后的的最先执行 如果返回false会接下来执行倒数第二个 所有的都执行完 才会交给安卓操作系统</p>

<p><code>BackAndroid.exitApp();</code>可以 直接退出应用</p>

<h3 id="toc_2">颜色</h3>

<ol>
<li><code>rgba(52, 52, 52, 0.5)</code></li>
<li><code>0xF5FCFF01</code></li>
<li><code>#F5FCFF</code></li>
<li><code>rgb(245, 255, 255)</code></li>
<li><code>hsl(360, 100%, 100%)</code></li>
<li><code>hsla(360, 100%, l00%, 1.0)</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[状态机]]></title>
    <link href="https://acefish.github.io/15288713693530.html"/>
    <updated>2018-06-13T14:29:29+08:00</updated>
    <id>https://acefish.github.io/15288713693530.html</id>
    <content type="html"><![CDATA[
<p>ReactNative 将UI视作一个状态机,每个UI场景就是状态机的一个状态</p>

<blockquote>
<p>不要在状态机变量中存放于显示无关的变量,会导致务必要渲染UI</p>
</blockquote>

<h2 id="toc_0">State</h2>

<blockquote>
<p>尽可能让自定义的组件成为无状态组件<br/>
好的reactnative设计思路:创建多个只负责渲染数据的无状态组件，将他们封装在一个有状态的reactnative组件中,有状态的组件封装了UI交互的逻辑，而无状态的组件负责渲染UI界面。</p>
</blockquote>

<pre><code class="language-javascrip">constructor(props) {
        super(props)
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    updateNum(newText) {
        this.setState((state) =&gt; {
            return {input: newText}
        });
    }

    updatePWD(newText) {
        this.setState(() =&gt; {
            return {
                inputPWD : newText
            }
        })
    }
</code></pre>

<p>通过this.state.状态机变量名 访问状态机变量</p>

<p>我们需要将状态机变量看做 <strong>不可变常量</strong>，不能直接改变状态机变量，只能通过<strong>setState</strong>函数</p>

<h2 id="toc_1">渲染</h2>

<p>setState函数原型：<code>setState(oldState, callback)</code> 第二个参数为回调函数,会在setState完成并且重新渲染完成(如果需要的话)后被调用</p>

<p>如果setState函数将传入函数的返回值与当前状态机相比没有任何修改或增加,将不会进行渲染</p>

<p>改变状态机变量后 所有与状态机变量值有关系的组件都会被刷新。</p>

<blockquote>
<p>当修改组件的状态机变量值后，ReactNative会在考虑清楚如何高效的渲染UI后,执行SetState的箭头函数来渲染组件,因此setState是异步执行的函数</p>

<p>当子组件需要渲染时,那么该子组件的各个生命周期的函数都会按声明周期调用 这就是渲染高效的原因</p>
</blockquote>

<h3 id="toc_2">判断是否渲染</h3>

<pre><code class="language-javascript">//判断是否渲染，实现这个函数后,会在重新渲染组件前，调用这个函数，返回false就放弃渲染组件
shouldComponentUpdate() {
        if (this.state.input.length &lt; 3) {
            return true;
        }
        return false;
    }
</code></pre>

<h3 id="toc_3">强制渲染</h3>

<p><code>forceUpdate(callback)</code> <br/>
当UI的可变数据来源为属性和状态之外获取时,可以使用这个函数要求重新渲染，这会导致所有级别的UI都重新读取、计算、渲染。</p>

<blockquote>
<p>这个渲染过程不会调用<code>shouldComponentUpdate</code><br/>
可以通过回调函数,在执行结束后调用<br/>
尽量避免使用</p>
</blockquote>

<h3 id="toc_4">render渲染过程</h3>

<p>RN通过<code>render</code>实现重新渲染。原型为<code>ReactComponent render()</code><br/>
任何组件都必须有这个函数 也必须只能返回一个可渲染组件<br/>
通过修改属性或者状态机变量来触发render的重新渲染，而不是直接调用这个函数</p>

<h3 id="toc_5">简洁写法</h3>

<pre><code class="language-javascript">    //简洁写法1（通过指定参数名称与状态机变量名称相同 省略）
    updateNum(input) {
        this.setState(() =&gt; {
            return {input}
        })
    }
    
    //简洁写法2（省略箭头函数）
    updateNum(input) {
        this.setState( {input})
    }
 ```

## 成员变量

```javascript
    constructor(props) {
        super(props)
        this.myProperty1 = &quot;test&quot;
        this.myProperty2 = true
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    //就可以在组件中使用myProperty1  myProperty2 这两个成员变量
</code></pre>

<p>组件可以有静态变量、静态成员函数，直接用<code>类名.</code>调用</p>

<h3 id="toc_6">回调函数绑定</h3>

<pre><code class="language-javascript">//在constuctor函数中
this.updateNum = this.updateNum.bind(this)
</code></pre>

<p>绑定操作是为了让回调函数能正确解析出this，否则this.updateNum函数被执行时,指向另外对象而不是该组建类的实例</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flex]]></title>
    <link href="https://acefish.github.io/15287061850668.html"/>
    <updated>2018-06-11T16:36:25+08:00</updated>
    <id>https://acefish.github.io/15287061850668.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基本概念</h2>

<p>采用Flex布局的元素，称为容器，它的所有子元素 自动成为容器成员<br/>
<img src="media/15287061850668/15287068668255.png" alt=""/></p>

<h2 id="toc_1">容器属性</h2>

<pre><code class="language-text">flex-direction
flex-warp
flex-flow
justify-content
align-items
align-content
</code></pre>

<h3 id="toc_2">flex-direction</h3>

<p>决定主轴的方向 </p>

<ul>
<li>row:default 主轴为水平方向，起点在左端</li>
<li>row-reverse: 主轴为水平 起点在右端</li>
<li>column: 主轴为垂直方向，起点在上</li>
<li>colum-reverse:主轴为垂直方向 起点在下</li>
</ul>

<h3 id="toc_3">flex-warp</h3>

<p>当一条轴线放不下的情况 如何换行</p>

<ul>
<li>nowarp: default 不换行</li>
<li>wrap: 换行 第一行在上方</li>
<li>warp-reverse:换行，第一行在下方</li>
</ul>

<h3 id="toc_4">flex-flow</h3>

<p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>

<h3 id="toc_5">justify-content</h3>

<p>项目在主轴上的对齐方式</p>

<ul>
<li>flex-start: 左对齐</li>
<li>flex-end: 右对齐</li>
<li>center: 居中</li>
<li>space-between: 两端对齐，项目之间间隔相等</li>
<li>space-around: 每个项目两侧间隔相等</li>
</ul>

<h3 id="toc_6">align-items属性</h3>

<p>align-items属性定义项目在交叉轴上如何对齐</p>

<ul>
<li>flex-start: 交叉轴的起点对齐</li>
<li>flex-end: 交叉轴的终点对齐</li>
<li>center: 交叉轴的中间对齐</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
<li>strech: default 项目未设置高度或者设为auto，将默认占满整个容器</li>
</ul>

<h3 id="toc_7">align-content</h3>

<p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>

<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch：default 轴线占满整个交叉轴。</li>
</ul>

<h2 id="toc_8">项目属性</h2>

<pre><code class="language-text">order
flex-grow
flex-shrink
flex-basis
flex
align-self
</code></pre>

<h3 id="toc_9">order属性</h3>

<p>定义项目的排列顺序 数值越小 越靠前 默认为NO</p>

<h3 id="toc_10">flex-grow</h3>

<p>定义项目的放大比例 默认为0，即 如果存在剩余空间 也不放大<br/>
如果所有项目的<code>flex-grow</code>属性都为1，它们将等分剩余空间,如果属性为2，其它项目为1，则前者占据的剩余空间比其它多一倍</p>

<h3 id="toc_11">flex-shrink</h3>

<p>定义项目的缩小比例 默认为1 即如果空间不足 该项目将缩小<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小<br/>
负值无效</p>

<h3 id="toc_12">flex-basis</h3>

<p>定义在分配多余空间之前，项目占据的主轴空间， 根据这个值计算是否有剩余空间，默认值为<code>auto</code>即项目的本来大小</p>

<h3 id="toc_13">flex</h3>

<p>flex属性是flex-shrink、flex-grow、flex-basis的简写，默认值是0，1，auto，后两个属性是可选的<br/>
该属性有两个快捷值：auto（1 1 auto） 和none（0 0 auto）</p>

<h3 id="toc_14">align-self</h3>

<p>允许单个项目与其它项目有不一样的对齐方式，可覆盖<code>align-items</code>属性 默认值为<code>auto</code>表示继承父元素的<code>align-items</code>属性,如果没有父属性则等同于<code>stretch</code></p>

<h1 id="toc_15">ReactNative Flex</h1>

]]></content>
  </entry>
  
</feed>
