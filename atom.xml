<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2019-05-21T14:47:51+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[RACSignal]]></title>
    <link href="https://acefish.github.io/15578383647199.html"/>
    <updated>2019-05-14T20:52:44+08:00</updated>
    <id>https://acefish.github.io/15578383647199.html</id>
    <content type="html"><![CDATA[
<p><code>RACSignal</code>继承自<code>RACStream</code>，对该抽象类的方法进行了重写实现</p>

<h3 id="toc_0"><code>return</code>方法</h3>

<pre><code class="language-objectivec">+ (RACSignal *)return:(id)value {
    return [RACReturnSignal return:value];
}
/**
RACReturnSignal *signal = [[self alloc] init];
signal-&gt;_value = value;
*/
</code></pre>

<h3 id="toc_1"><code>-bind</code>方法</h3>

<pre><code class="language-objectivec">
/**
实现过程
1. 订阅原始信号值
2. 当原信号发送值时，使用bindblock对其进行转换
3. 如果bindblock返回一个信号，订阅该信号，并在收到该信号值时，将所有值传递给接收者subscriber
4. 如果bindblock请求终止就向原信号发出`-sendError:`消息
5. 当所有信号完成，向订阅者发送`-sendCompleted`
6. 无论何时 当信号发生错误，向订阅者发送-sendError: 消息
*/

- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block
</code></pre>

<p><code>-bind</code>方法在原始信号每次发出消息时，执行<code>RACSignalBindBlock</code>对其进行变换生成一个新的信号</p>

<p>示例:</p>

<pre><code class="language-objectivec">//示例1：
RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendNext:@4];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        //简单的利用bind将 原始信号的值进行了一个变换
        value = @(value.integerValue * value.integerValue);
        return [RACSignal return:value];
    };
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;signal: %@&quot;, x);
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@&quot;bindSignal: %@&quot;, x);
}];
</code></pre>

<h3 id="toc_2">-concat方法</h3>

<pre><code class="language-objectivec">- (RACSignal *)concat:(RACSignal *)signal {
    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {

        [self subscribeNext:^(id x) {
            [subscriber sendNext:x];
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            [signal subscribe:subscriber];
        }];
    }] setNameWithFormat:@&quot;[%@] -concat: %@&quot;, self.name, signal];
}
</code></pre>

<p>当原始信号<code>completed</code>后 subcribe contact的信号</p>

<h3 id="toc_3">-concat方法</h3>

<ul>
<li>(RACSignal *)zipWith:(RACSignal *)signal</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RACStream]]></title>
    <link href="https://acefish.github.io/15578193513091.html"/>
    <updated>2019-05-14T15:35:51+08:00</updated>
    <id>https://acefish.github.io/15578193513091.html</id>
    <content type="html"><![CDATA[
<p><code>RACStream</code>是继承自NSObject最基础的类，其它的子类例如<code>RCSignal</code>、<code>RACSequence</code>均继承自该类</p>

<p><code>RACStream</code>作为一个抽象类存在，本身并不提供任何方法的实现，内部方法均为抽象方法，在调用时抛出异常</p>

<pre><code class="language-objectivec">+ (__kindof RACStream *)empty {
    NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
}
- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block
// return 根据该value 返回一个RACStream对象
+ (__kindof RACStream *)return:(id)value
- (__kindof RACStream *)concat:(RACStream *)stream
- (__kindof RACStream *)zipWith:(RACStream *)stream

</code></pre>

<p>但是在RACStream的Operations分类<code>RACStream (Operations)</code>提供了更丰富的方法</p>

<pre><code class="language-objectivec">//对信号的值进行map映射
- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block {
    Class class = self.class;

    return [[self bind:^{
        return ^(id value, BOOL *stop) {
            id stream = block(value) ?: [class empty];
            NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);

            return stream;
        };
    }] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];
}
- (__kindof RACStream *)flatten
- (__kindof RACStream *)map:(id (^)(id value))block
- (__kindof RACStream *)mapReplace:(id)object

//根据规则过滤
- (__kindof RACStream *)filter:(BOOL (^)(id value))block
- (__kindof RACStream *)ignore:(id)value

//对RACTuple中每个值进行处理 
- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock

//将RACStream 前拼上一个新的值
- (__kindof RACStream *)startWith:(id)value

//跳过固定个数的值
- (__kindof RACStream *)skip:(NSUInteger)skipCount
//接收前固定个数的值
- (__kindof RACStream *)take:(NSUInteger)count

//将一组Stream按照block的规则合并为一个  
+ (__kindof RACStream *)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, id))block
+ (__kindof RACStream *)zip:(id&lt;NSFastEnumeration&gt;)streams
+ (__kindof RACStream *)zip:(id&lt;NSFastEnumeration&gt;)streams reduce:(RACGenericReduceBlock)reduceBlock

//一组Stream contact(连接)
+ (__kindof RACStream *)concat:(id&lt;NSFastEnumeration&gt;)streams

//用初始值开始reduce 返回每次block之后的结果
- (__kindof RACStream *)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id, id, NSUInteger))reduceBlock

//忽略不符合条件的
- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate
- (__kindof RACStream *)takeWhileBlock:(BOOL (^)(id x))predicate

//忽略不符合条件的 直到第一个符合条件的
- (__kindof RACStream *)skipUntilBlock:(BOOL (^)(id x))predicate
- (__kindof RACStream *)skipWhileBlock:(BOOL (^)(id x))predicate

//忽略未改变值的改变
- (__kindof RACStream *)distinctUntilChanged
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MatrixiOS学习]]></title>
    <link href="https://acefish.github.io/15560883411509.html"/>
    <updated>2019-04-24T14:45:41+08:00</updated>
    <id>https://acefish.github.io/15560883411509.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">学习到的知识点</h2>

<h4 id="toc_1">1.使用协议和继承进行规范开发</h4>

<p>在项目中定义了plugin的基类<code>MatrixPlugin</code>继承自协议<code>MatrixPluginProtocol</code>，而接下来的组件开发，只需要继承自<code>MatrixPlugin</code>，然后实现协议中的方法即可</p>

<p>而当回调时，也不需要知道具体是哪个<code>plugin</code>，只需指定其实一个继承了协议的插件即可:<br/>
<code>- (void)onInit:(id&lt;MatrixPluginProtocol&gt;)plugin</code>,就可以使用其在协议中指定的方法</p>

<h4 id="toc_2">2.利用运行时实现NSCoding协议</h4>

<p>利用运行时方法获取对象类以及父类的所有属性变量属性变量，执行<code>encodeObject</code>和<code>decodeObjectForKey</code>方法</p>

<p><a href="media/15560883411509/MatrixBaseModel.mm">MatrixBaseMode</a></p>

<h4 id="toc_3">3. 对于app中常用文件路径可以专门写个工具类，为避免每次都访问使用单例</h4>

<pre><code class="language-objectivec">+ (NSString *)matrixCacheRootPath
{
    static NSString *s_rootPath;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
        s_rootPath = [paths[0] stringByAppendingString:@&quot;/Matrix&quot;];
        if ([[NSFileManager defaultManager] fileExistsAtPath:s_rootPath] == NO) {
            [[NSFileManager defaultManager] createDirectoryAtPath:s_rootPath withIntermediateDirectories:YES attributes:nil error:nil];
        }
    });
    return s_rootPath;
}
</code></pre>

<h4 id="toc_4">4.判断app是否处于调试环境下</h4>

<pre><code class="language-objectivec">+ (BOOL)isBeingDebugged
{
    // Returns true if the current process is being debugged (either
    // running under the debugger or has a debugger attached post facto).
    int                 junk;
    int                 mib[4];
    struct kinfo_proc   info;
    size_t              size;
    
    // Initialize the flags so that, if sysctl fails for some bizarre
    // reason, we get a predictable result.
    
    info.kp_proc.p_flag = 0;
    
    // Initialize mib, which tells sysctl the info we want, in this case
    // we&#39;re looking for information about a specific process ID.
    
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PID;
    mib[3] = getpid();
    
    // Call sysctl.
    
    /**
     *int sysctl(int *name, u_int namelen, void *old, size_t *oldlen, void *newp, size_t newlen);
     *name参数是一个用以指定查询的信息数组；
     *namelen用以指定name数组的元素个数；
     *old是用以函数返回的缓冲区；
     *oldlen用以指定oldp缓冲区长度；
     *newp和newlen在设置时使用；
     *当进程被调试器依附时，kinfo_proc结构下有一个kp_proc结构域，
     kp_proc的p_flag的被调试标识将被设置，即会进行类似如下的设置：
     kinfo_proc.kp_proc.p_flag&amp;P_TRACED
     其中P_TRACED的定义如下：
     #define P_TRACED        0x00000800
     */
    
    
    size = sizeof(info);
    junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, NULL, 0);
    assert(junk == 0);
    
    // We&#39;re being debugged if the P_TRACED flag is set.
    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);
}
</code></pre>

<p>以及一些获取app基本信息的方法<br/>
<a href="media/15560883411509/MatrixDeviceInfo.mm">MatrixDeviceInfo</a></p>

<h4 id="toc_5">5. atexit(func)在app正常退出时调用函数</h4>

<p><code>atexit</code>函数是一个特殊的函数，它在正常退出程序时调用的函数<br/>
atexit设置的函数会在exit过程中被调用，exit调用终止处理函数的顺序和atexit登记的顺序相反</p>

<p>进程终止的方式有8种:</p>

<ol>
<li>从main函数返回</li>
<li>调⽤用exit函数</li>
<li>调⽤用_exit或_Exit； </li>
<li>最后⼀一个线程从启动例程返回；</li>
<li>最后⼀一个线程调⽤用pthread_exit</li>
<li>调⽤用abort函数； </li>
<li>接到一个信号并终⽌； </li>
<li>最后⼀一个线程对取消请求做出响应<br/>
其中前5种为正常终止，而后3种为异常终止</li>
</ol>

<p><code>_exit</code>和<code>_Exit</code>立即进入内核，而exit会进行一些清理工作<br/>
exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。 </p>

<h4 id="toc_6">6. 使用dispatch_block_cancel()来取消执行某些未来执行的block</h4>

<h4 id="toc_7">7. MatrixAppRebootAnalyzer中对App启动和关闭状态的监控</h4>

<p>Matrix中对应用被杀原因检测<br/>
<img src="media/15560883411509/15562491518956.jpg" alt="" style="width:500px;"/></p>

<h4 id="toc_8">8.获取CPU</h4>

<p><code>WCCPUHandler</code>文件中对于CPU usage的计算</p>

<h4 id="toc_9">9.获取线程信息</h4>

<p><code>WCGetMainThreadUtil</code>文件中使用基于KSCrash获取堆栈</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mach-O文件结构]]></title>
    <link href="https://acefish.github.io/15559005276972.html"/>
    <updated>2019-04-22T10:35:27+08:00</updated>
    <id>https://acefish.github.io/15559005276972.html</id>
    <content type="html"><![CDATA[
<p>参考资料:<br/>
<a href="http://jianli2017.top/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pod repo update]]></title>
    <link href="https://acefish.github.io/15556625620569.html"/>
    <updated>2019-04-19T16:29:22+08:00</updated>
    <id>https://acefish.github.io/15556625620569.html</id>
    <content type="html"><![CDATA[
<p>我们平时开发pod update或者pod install , 这里其实 pod的工作就是根据pod库名在master/Specs/中找到对应的库，若指定版本则找到指定版本的podspec,否则找最高版本的podspec，找到后根据podsepc文件中的配置下载指定的库资源。</p>

<p>那么pod repo update 的工作就是更新pod资源目录，也就是master下的资源，简单说 如果有一个第三方库发布了一个最新的版本，如果你不执行pod repo update，那么你的本地是不会知道有一个最新版本的，还会一直以你本地的资源目录为准。那么你永远都拿不到这个库的最新版本。</p>

<p>使用pod update是默认会执行一遍pod repo update ，所以会发现如果你的pod库引用多了，每次pod update都很慢，网络如果不好更是经常会断掉，就是因为你在更新pod时，也更新了资源目录</p>

<p>pod update 工作流程 :</p>

<ul>
<li>先拉取远程最新目录，再根据目录中的资源重新更新一遍pod</li>
<li>如果你的podfile中每个库都指定了版本还好，如果没有，那么每次都是拉一遍最新库， 这时候就要用到命令
<code>
pod update --no-repo-update
</code></li>
</ul>

<p>有些时候会引用一些私有库 ， <code>pod repo update</code> 会把<code>~/.cocoapods/repos/</code>这个目录下所有的资源库目录都更新一遍，有时候不想更新master，只想更新某个具体的私有库 可以使用<code>pod repo update ~/.cocoapods/repos/***/</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[otool命令]]></title>
    <link href="https://acefish.github.io/15554889031358.html"/>
    <updated>2019-04-17T16:15:03+08:00</updated>
    <id>https://acefish.github.io/15554889031358.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时]]></title>
    <link href="https://acefish.github.io/15553854847636.html"/>
    <updated>2019-04-16T11:31:24+08:00</updated>
    <id>https://acefish.github.io/15553854847636.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instruments Help]]></title>
    <link href="https://acefish.github.io/15553150729300.html"/>
    <updated>2019-04-15T15:57:52+08:00</updated>
    <id>https://acefish.github.io/15553150729300.html</id>
    <content type="html"><![CDATA[
<p>官方文档<a href="https://help.apple.com/instruments/mac/current/#//apple_ref/doc/uid/TP40004652-CH5">Instruments Help</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO]]></title>
    <link href="https://acefish.github.io/15551517319694.html"/>
    <updated>2019-04-13T18:35:31+08:00</updated>
    <id>https://acefish.github.io/15551517319694.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">官方文档地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的泛型]]></title>
    <link href="https://acefish.github.io/15550609641165.html"/>
    <updated>2019-04-12T17:22:44+08:00</updated>
    <id>https://acefish.github.io/15550609641165.html</id>
    <content type="html"><![CDATA[
<p><a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC]]></title>
    <link href="https://acefish.github.io/15549735665033.html"/>
    <updated>2019-04-11T17:06:06+08:00</updated>
    <id>https://acefish.github.io/15549735665033.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE">官方文档地址</a></p>

<p><code>KVC(Key-value coding)</code>是由<code>NSKeyValueCoding</code>非正式协议(其实就是我们所的分类或类别)启用的机制，通过该机制提供了对属性的间接访问。<br/>
当对象符合键值编码时，属性可以通过字符串参数进行接口寻址。<br/>
这种对属性的间接访问机制提供了对实例变量和其相关访问器方法的直接访问</p>

<blockquote>
<p>键值编码是一个基本概念，是许多其他Cocoa技术的基础，例如键值观察(KVO)，Cocoa绑定，CoreData和AppleScript能力。在某些情况下，键值编码还有助于简化代码。</p>
</blockquote>

<p>通过KVC 我们可以实现以下功能:</p>

<ol>
<li>获取对象属性</li>
<li>操作对象属性</li>
<li>在集合对象上进行集合运算符运算</li>
<li>获取非对象属性</li>
<li>通过keyPath来获取对象属性</li>
</ol>

<p><code>NSObject</code>的<code>NSKeyValueCoding</code>分类实现了KVC方法，并提供默认实现;而<code>NSArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code>等都又提供了自己的实现</p>

<p><img src="media/15549735665033/15550373964851.jpg" alt="" style="width:200px;"/></p>

<p>为了使对象符合键值编码，应确保其实现了NSKeyValueCoding非正式协议，并实现了相应的方法，<code>NSObject</code>使用了<code>NSKeyValueCoding</code>协议并为它们和其它基本方法提供了默认实现。因此从NSObject派生的对象，大部分工作已经完成；</p>

<p>符合键值编码的对象可以实现其他Cocoa的技术:</p>

<ol>
<li>KVO</li>
<li>Cocoa绑定：这一系列技术完全实现了模型 - 视图 - 控制器范例，其中模型封装应用程序数据，视图显示和编辑数据，控制器在两者之间进行调解。 阅读<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i">Cocoa Bindings编程主题</a>以了解有关Cocoa绑定的更多信息。</li>
<li>CoreData: <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075">文档地址</a></li>
<li>AppleScript：  <a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i">AppleScript Overview</a></li>
</ol>

<h2 id="toc_0">API</h2>

<h4 id="toc_1">直接访问对象属性</h4>

<pre><code class="language-objectivec">- (nullable id)valueForKey:(NSString *)key;
- (void)setValue:(nullable id)value forKey:(NSString *)key;
</code></pre>

<pre><code class="language-objectivec">//点语法访问器
myAccount.currentBalance = @(100.0);
[myAccount setCurrentBalance:@(100.0)];

//KVC
[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];
NSNumber *currentBalance = [myAccount valueForKey:@&quot;currentBalance&quot;];

Person *owerModel = [[Person alloc] init];
[myAccount setValue:owerModel forKeyPath:@&quot;ower&quot;];
</code></pre>

<blockquote>
<p>对于<code>forKey:</code>不常用，因为我们均可以使用<code>forKeyPath:</code>来代替，对于keyPath只有一层也是可以的</p>
</blockquote>

<h4 id="toc_2">路径访问属性</h4>

<pre><code class="language-objectivec">- (nullable id)valueForKeyPath:(NSString *)keyPath;
- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;
</code></pre>

<pre><code class="language-objectivec">//键路径是以点分隔的多个键字符串  指定了要遍历的对象属性序列
[myAccount setValue:@&quot;lyy&quot; forKeyPath:@&quot;ower.name&quot;];
NSString *name = [myAccount valueForKeyPath:@&quot;ower.name&quot;];
</code></pre>

<h4 id="toc_3">键未定义异常</h4>

<p>当找不到key命名的属性时，会调用获取值的 </p>

<pre><code class="language-objectivec">- (id)valueForUndefinedKey:(NSString *)key;
- (void)setValue:(id)value forUndefinedKey:(NSString *)key;
</code></pre>

<p>找不到系统会默认引发一个<code>NSUndefinedKeyException</code>异常，可以通过重写这两个方法避免崩溃</p>

<blockquote>
<p>对于keyPath的方式访问属性，kayPath的键对应对象属性序列，到哪一级找不到对应属性，就会触发对应该级对象的这个两个方法，而不是总触发第一级对象的</p>
</blockquote>

<h4 id="toc_4">对于非对象值</h4>

<p>当<code>setValue</code>时，如果属性不是对象值，而是标量或者结构体时，KVC会自动将value拆箱然后赋值给属性<br/>
同理，当<code>valueForKey/keyPath:</code>会自动将属性值装箱，返回一个<code>NSNumber</code>或者<code>NSValue</code></p>

<pre><code class="language-objectivec">//封装为为NSValue
NSPoint、NSRange、NSRect、NSSize
</code></pre>

<h4 id="toc_5">对于nil</h4>

<ul>
<li><p>对于属性为对象值时，可以直接设置对象值为nil，或者获取对象指为nil</p></li>
<li><p>对于属性为非对象值，即为标量或者结构体时，此时系统无法帮我们拆箱,会触发<code>setNilValueForKey:</code>方法，并且引发一个<code>NSInvalidArgumentException</code>异常，可以通过重写该方法避免</p></li>
</ul>

<h3 id="toc_6">多值访问</h3>

<pre><code class="language-objectivec">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;
- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;
</code></pre>

<p>提供了可以同时获取和设置多个值的方法，相当于一次性掉了多次<code>valueForKey</code>和<code>setValue:forKey:</code>，当key值不存在时也会触发<strong>键未定义异常</strong>的崩溃和避免崩溃方法<br/>
注意： 这两个方法中只能设置的为key，而不能使用keyPath</p>

<h3 id="toc_7">访问集合属性</h3>

<p>对于属性为集合对象，与获取普通对象属性相同，可以直接获取和设置到集合对象属性值</p>

<pre><code class="language-objectivec">[myAccount setValue:dataArr forKey:@&quot;transactionsArray&quot;];
NSArray *obj = [myAccount valueForKeyPath:@&quot;transactionsArray&quot;];
</code></pre>

<p>另外一个较常用的功能,我们可以使用<code>valueForKeypath:</code>直接获取数组中每个对象的属性值集合</p>

<pre><code class="language-objectivec">NSArray *obj1 = [myAccount valueForKeyPath:@&quot;transactionsArray.payee&quot;];
</code></pre>

<p>在keyPath中遇到数组时，会对数组中的每个元素都执行接下来的<code>valueForKeyPath:</code>,最后返回一个值的集合</p>

<p>但是对于集合的属性集合<code>setValue:forkey/KeyPath:</code>并不好用，其并不会将value中的数组分别复制给key中的属性，而是会将value直接赋值给每个key中的属性</p>

<h3 id="toc_8">操作集合属性</h3>

<p>对于集合属性 我们想要修改其内容 需要先用<code>valueForKeyPath</code>获取到其不可变属性值，然后用其创建可变对象值然后修改，再用<code>setValueForKeyPath</code>方法重新设置回去，较麻烦</p>

<p>苹果提供了直接可以获取集合属性的可变对象进行操作的方法</p>

<pre><code class="language-objectivec">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;
- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;

- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath;

- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;
- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;
</code></pre>

<p>会返回一个行为继承于<code>NSMutableArray/NSMutableOrderedSet/NSMutableSet</code>的内置对象，对这个对象直接操作(例如增加、删除元素)，系统会根据我们的操作直接修改原对象<br/>
这样修改维护集合中的对象，还可以<strong>支持键值观察机制</strong></p>

<blockquote>
<p>这种方法只适合直接修改集合属性，而不适合修改集合属性的属性值集合，原因和不对其使用<code>setValue:forkey/KeyPath:</code>原因相同</p>
</blockquote>

<h3 id="toc_9">属性验证</h3>

<p>NSKeyValueCoding协议提供了支持属性验证的方法。 可以通过调用</p>

<pre><code class="language-objectivec">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;

- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;
</code></pre>

<p>协议的默认实现会像实例搜索是否存在实现了<code>validate&lt;Key&gt;:error:</code>方法，默认为返回YES表示验证成功，我们可以再这个方法中实现自己的验证逻辑</p>

<pre><code class="language-objectivec">BankAccount *myAccount = [[BankAccount alloc] init];
NSError *error;
NSNumber *balance = @(100.0);
BOOL result = [myAccount validateValue:&amp;balance forKey:@&quot;currentBalance&quot; error:&amp;error];

//BankAccount.m
- (BOOL)validateCurrentBalance:(id *)ioValue error:(NSError *__autoreleasing *)outError {
    if (!ioValue || ((NSNumber *)*ioValue).integerValue &gt;= 100) {
        *outError = [NSError errorWithDomain:@&quot;错误qqq&quot; code:123 userInfo:@{@&quot;key&quot;: @&quot;金额太大了&quot;}];
        return NO;
    }
    return YES;
}
</code></pre>

<p>当然如果不想每个不同key验证都写一次验证方法的话，就直接继承实现自己的validateValue</p>

<pre><code class="language-objectivec">- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable __autoreleasing *)outError {
    
    if (!ioValue || ((NSNumber *)*ioValue).integerValue &gt;= 100) {
        *outError = [NSError errorWithDomain:@&quot;错误qqq&quot; code:123 userInfo:@{@&quot;key&quot;: @&quot;金额太大了&quot;}];
        return NO;
    }
    return YES;
}
</code></pre>

<blockquote>
<p><code>- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</code>怎么使用呢????</p>
</blockquote>

<h2 id="toc_10">集合运算符</h2>

<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW9">官方文档</a></p>

<p>使用<code>valueForKeyPath:</code>时，可以在路径中嵌入<strong>集合运算符</strong><br/>
集合运算符是在<code>@</code>关键字标识，指定了getter应该执行的操作，以便在数据返回之前以某种方式操作数据</p>

<p><img src="media/15549735665033/15550626615233.jpg" alt="" style="width:500px;"/></p>

<p>当keyPath包含集合运算符时，@前路径为左键路径，表示相对操作对象的集合路径，当操作对象直接为集合对象时，可以省略左键路劲;@运算符后的为右键路径，表示操作的集合中的属性，除了<code>@count</code>都需要右键路径</p>

<p>集合运算符共有三种类型:</p>

<ul>
<li><p>聚合运算符<br/>
以某种方式合并集合中的对象，并返回和右键路径属性相同类型的一个值;（@count例外）</p>
<ol>
<li><p><strong>@avg</strong> 读取右键属性值，并将其转为<code>double</code>类型(将nil转为0)，计算其算术平均值，返回一个<code>NSNumber</code>对象</p>
<pre><code class="language-objectivec">NSNumber *transactionAverage = [self.transactions valueForKeyPath:@&quot;@avg.amount&quot;];
</code></pre></li>
<li><p><strong>@count</strong> 获取集合中元素个数，忽略右键属性(如果有)</p>
<pre><code class="language-objectivec">NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@&quot;@count&quot;];
</code></pre></li>
<li><p><strong>@max</strong> 搜索右键属性对应的值集合 返回最大的那个(比较时忽略nil)<br/>
比较使用的时<code>compare:</code>方法，因此右键属性值必须能响应该方法</p>
<pre><code class="language-objectivec">NSDate *latestDate = [self.transactions valueForKeyPath:@&quot;@max.date&quot;];
</code></pre>
<blockquote>
<p><code>Foundation</code>中内置很多类都已经实现了该方法，我们也可以通过自己实现<code>- (NSComparisonResult)compare:(id)other</code>方法来实现自定义model的compare</p>
</blockquote></li>
<li><p><strong>@min</strong><br/>
与@max同理</p></li>
<li><p><strong>@sum</strong> 将集合中右键元素都转为double类型(将nil转为0)求和</p></li>
<li><p><strong>@count</strong></p></li>
</ol>
<pre><code class="language-objectivec">    NSInteger count = [[myAccount.transactionsArray valueForKeyPath:@&quot;@count&quot;] integerValue];
</code></pre></li>
<li><p>数组运算符<br/>
返回一个NSArray实例，返回集合中属性的子集</p>
<p><strong>@distinctUnionOfObject</strong>返回一个数组其中包含了右键属性的不重复的值的集合(不包含nil元素)；</p>
<pre><code class="language-objectivec">NSArray *arr = [myAccount valueForKeyPath:@&quot;transactionsArray.@distinctUnionOfObjects.amount&quot;];
</code></pre>
<p><strong>@unionOfObjects</strong> 返回右键属性值的集合并不会去重(不包含nil元素)</p></li>
<li><p>嵌套操作符<br/>
嵌套运算符处理嵌套的集合，集合的条目本身就包含了一个集合</p></li>
</ul>

<p><strong>@distinctUnionOfArrays</strong> 返回右键集合属性的所有集合元素中不重复值的集合</p>

<pre><code class="language-objectivec">    NSArray *arr = [objArray valueForKeyPath:@&quot;@distinctUnionOfArrays.transactionsArray.payee&quot;];
</code></pre>

<p><strong>unionOfArrays</strong> 返回右键集合属性的所有元素集合（不去重）</p>

<pre><code class="language-objectivec">    NSArray *arr1 = [objArray valueForKeyPath:@&quot;@unionOfArrays.transactionsArray.payee&quot;];
</code></pre>

<p><strong>@distinctUnionOfSets</strong> 与<code>distinctUnionOfArrays</code>类似 不同的是 其需要NSSet实例属性包含NSSet集合</p>

<h2 id="toc_11">KVC的搜索规则</h2>

<!--学习自简书[KVC原理剖析](https://www.jianshu.com/p/1d39bc610a5b)
-->

<p>NSObject提供的<code>NSKeyValueCoding</code>协议默认实现，将基于键的访问映射到对象属性。这些协议方法使用key参数在自己对象实例中搜索访问器、实例变量以及某些约定命名方法</p>

<h3 id="toc_12">基础Getter的搜索模式</h3>

<p><code>valueForKey:</code>的默认实现，会根据key参数在对象实例中进行以下搜索流程:</p>

<ol>
<li>按顺序搜索实例变量中的方法名类似:<code>get&lt;Key&gt;</code>、<code>&lt;Key&gt;</code>、<code>is&lt;Key&gt;</code>或者<code>_&lt;Key&gt;</code>的方法,如果找到直接跳到第5步</li>
<li><p>搜索实例中匹配<code>countOf&lt;Key&gt;</code>方法和<code>objectIn&lt;Key&gt;AtIndex:</code>方法(对应NSArray类的基本方法)以及<code>&lt;key&gt;AtIndexes:</code>(对应NSArray的<code>objectsAtIndexes:</code>方法)，如果找到第一个方法以及至少后两个方法中的一个，就创建一个相应NSArray所有方法的集合代理对象并返回，否则执行第3步</p>
<p>这个代理对象会将接收到的所有NSArray消息转换为<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>方法的组合来交给原始对象响应。如果原始对象还实现了<code>get&lt;Key&gt;:range:</code>可选方法，也会在适当时候是使用；这个数组代理对象工作起来就像真的NSArray一样</p>
<blockquote>
<p>代理对象的作用只是将交给其的方法进行组合，转交给原始对象响应，让其工作的像一个真的数组一样</p>
</blockquote></li>
<li><p>搜索名字为<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf &lt;Key&gt;</code>的三个方法(对应NSSet类定义方法)，如果找到这个3个方法就返回一个响应所有NSSet方法的代理对象，否则执行第4步<br/>
其会将随后收到的所有NSSet方法转换为上面3个方法的组合，让这个代理对象就像真的NSSet一样</p></li>
<li><p>如果上面方法都没找到，并且接收对象的<code>accessInstanceVariablesDirectly</code>类方法返回YES。就按顺序搜索<code>_&lt;key&gt;</code>、<code>_isKey</code>、<code>&lt;Key&gt;</code>、<code>is&lt;Key&gt;</code>实例变量名，找到的话执行第5步，否则执行第6步</p></li>
<li><p>如果是对象就直接返回，如果为非对象就装箱返回</p></li>
<li><p>如果都没找到就触发<code>valueForUndefineKey:</code>异常</p></li>
</ol>

<h3 id="toc_13">基础Setter模式搜索</h3>

<ol>
<li>按顺序搜索名字为<code>set&lt;Key&gt;</code>或者<code>_set&lt;Key&gt;</code>的访问器，找到就直接调用</li>
<li>如果找不到简单访问器，并且类方法<code>accessInstanceVariablesDirectly</code>类方法返回YES，并且按顺序查找<code>&lt;Key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>实例变量，如果找到直接设置值</li>
<li>以上两步都找不到,带用<code>setValue:forUndefinedKey:</code>默认会引发异常</li>
</ol>

<h3 id="toc_14">可变数组的搜索模式</h3>

<p><code>mutableArrayValueForKey:</code>用一下流程返回一个可变数组的代理对象</p>

<ol>
<li><p>搜索方法<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>(对应NSMutableArray的私有方法<code>insertObject:atIndex:</code>和<code>removeObjectAtIndex:</code>)，或者方法名为<code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>（对应NSMutableArray的为<code>insertObjects:atIndexes:</code>和<code>removeObjectsAtIndexes:</code>）。假如对象有至少一个insert方法或者一个remove方法，就返回一个响应<code>NSMutableArray</code>方法的代理对象。</p>
<p>代理对象通过发送一些组合的消息insertObject:in<Key>AtIndex:, removeObjectFrom<Key>AtIndex:, insert<Key>:atIndexes:,和remove<Key>AtIndexes:给<code>mutableArrayValueForKey:</code>消息的原始接收者来响应这些插入或者删除方法</p>
<p>当接收<code>mutableArrayValueForKey：</code>的原始消息对象实现名称为<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>的（可选）替换方法时，代理对象也会在适当时使用这些方法以获得最佳性能。</p>
<blockquote>
<p>代理的可变对象会响应所有NSMUtalbeArray方法，并将其转交给原始的对象消息接受者，对集合数组进行修改</p>
</blockquote></li>
<li><p>如果对象没有可变数组方法，就搜索名称为<code>set&lt;Key&gt;:</code>的访问器方法，这种情况会向<code>mutableArrayValueForKey:</code>的原始接收者发出<code>set&lt;Key&gt;</code>方法来，来响应NSMutableArray代理对象的消息</p>
<blockquote>
<p>注意: 这种方法的机制会比上一步的效率低得多，它会重复创建集合而不是修改原有集合,在使用KVC时应该尽量避免这种情况</p>
</blockquote></li>
<li><p>加入以上2中都没找到哦，并且对象响应<code>accessInstanceVariablesDirectly</code>类方法返回YES，就按顺序搜索<code>_&lt;Key&gt;</code>和<code>&lt;Key&gt;</code>的实例变量<br/>
找到这样的实例变量，就返回一个代理对象，会把NSMutableArray消息转发给实例变量</p></li>
<li><p>如果以上消息都失败了，就返回一个NSMutableArray的代理对象，该对象在收到<code>NSMutablrArray</code>消息后向<code>mutableArrayValueForKey:</code>原始接受者发出<code>setValue:ForUndefineKey:</code>消息，会引起<code>NSUndefinedKeyException</code>异常</p></li>
</ol>

<h3 id="toc_15">MutableOrderedSet的搜索模式</h3>

<p><code>mutableOrderedSetValueForKey</code> 与 数组搜索模式类似 ，只是其第一步搜索的方法为<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>、 <code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>和可选方法<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject: 或 replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></p>

<h3 id="toc_16">MutableSet搜索模式</h3>

<p>和mutableArray类似</p>

<p>第一步方法为:<br/>
<code>add&lt;Key&gt;Object:</code>和 <code>remove&lt;Key&gt;Object:</code> <code>add&lt;Key&gt;:</code>和<code>remove&lt;Key&gt;:</code>和可选方法<code>intersect&lt;Key&gt;: or set&lt;Key&gt;:</code></p>

<p>多了第二步骤搜索:<br/>
加入<code>mutableSetValueForKey</code>方法调用者是<code>manager object</code>则搜索模式不在继续,详情看CoreData核心编程指南</p>

<h2 id="toc_17">KVC性能</h2>

<p>KVC性能没有直接访问属性快，但是性能消耗微乎其微;<br/>
但是需要注意对操作可变集合对象的搜索模式，最好自己实现方法，避免重复创建集合进行赋值，这样性能消耗太大</p>

<h2 id="toc_18">注意</h2>

<ol>
<li>KVC本质是运行时查找对象实例的方法或变量，因此可以利用其访问私有变量，因此可以利用这一点，修改系统组件的样式或属性</li>
<li>为避免KVC的硬编码，可以采用<code>NSStringFromSelector(@selector(METHODNAME))</code></li>
<li>可以用KVC来触发KVO，即使在对象没有set访问器方法的情况下，即直接时候使用kvc赋值给对象的实例变量而该变量没有set方法时</li>
</ol>

<p>参考资料: <a href="https://www.jianshu.com/p/1d39bc610a5b">KVC原理剖析</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[main函数之前发生了什么]]></title>
    <link href="https://acefish.github.io/15549543814877.html"/>
    <updated>2019-04-11T11:46:21+08:00</updated>
    <id>https://acefish.github.io/15549543814877.html</id>
    <content type="html"><![CDATA[
<p>学习自sunnyxx的<a href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></p>

<h2 id="toc_0">dyld</h2>

<h3 id="toc_1">动态链接库</h3>

<p>iOS中用到系统frameWork都是动态链接的</p>

<p>使用<code>otool</code>命令查看依赖的动态库</p>

<pre><code class="language-objectivec">otool -L TestMain

TestMain:
    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
    /System/Library/Frameworks/UIKit.framework/UIKit
    /System/Library/Frameworks/Foundation.framework/Foundation
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
    /usr/lib/libobjc.A.dylib    /usr/lib/libSystem.B.dylib 
</code></pre>

<p>除了我们添加或依赖的系统动态库，还有默认添加的lib:<code>libobjc</code>（objc和runtime需要依赖的库），<code>libSystem</code>包含了很多系统界别的lib,常用到的有：</p>

<ul>
<li>libdispatch(GCD)</li>
<li>libsystem_c(C语言库)</li>
<li>libsystem_blocks(Block)</li>
<li>libcommonCrypto(加密库，比如常用的md5函数)</li>
</ul>

<p>这些库都是<code>dylib</code>格式</p>

<h3 id="toc_2">dyld(the dynamic link editor)</h3>

<p>Apple的动态链接器，系统kernel做好启动程序的准备后由dyld负责,dyld作用顺序概括:</p>

<ol>
<li>从kernel留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li>
<li>non-lazy符号立即link到可执行文件，lazy的存到表里</li>
<li>为可执行文件执行静态初始化</li>
<li>找到可执行文件的main函数，准备参数并调用</li>
<li>程序执行中 绑定lazy符号、提供runtime动态加载、提供调试器的接口</li>
<li>程序main函数return后执行static terminator</li>
<li>某些场景下 main函数结束后调用libSystem的__exit函数</li>
</ol>

<p>dyld是开源的，<a href="https://github.com/opensource-apple/dyld">源码github地址</a></p>

<p>在项目源码中有<code>dyldStartup.s</code>这个汇编文件，实现了<code>__dyld_start</code>,其主要实现了:</p>

<ol>
<li>调用dyldbootstrap::start()方法</li>
<li>上个方法返回了main函数地址，填入参数并调用main函数</li>
</ol>

<p><img src="media/15549543814877/15549648909838.jpg" alt="" style="width:350px;"/></p>

<p>栈底的dyldbootstrap::start()方法，继而调用了dyld::_main()方法，其中完成了刚才说的递归加载动态库过程，由于libSystem默认引入，栈中出现了libSystem_initializer、libdispatch_init、_objc_init等的初始化方法。</p>

<h2 id="toc_3">ImageLoader</h2>

<p>image指二进制文件，里面是各种符号和代码等，因此ImageLoader是将这些文件加入内存</p>

<h2 id="toc_4">runtime与load</h2>

<p><code>libSystem</code>是是若干系统lib的集合容器，里面就一个<code>init.c</code>文件，因此调用<code>libSystem_initializer</code>会逐步调用到<code>_objc_init</code>，这个就是objc和runtime<br/>
的初始化入口</p>

<p>这里除了初始化runtime环境外，_objc_init绑定了新image被加载后的<code>callback</code>：</p>

<pre><code class="language-objectivec">dyld_register_image_state_change_handler(
dyld_image_state_bound, 1, &amp;map_images);
dyld_register_image_state_change_handler(
dyld_image_state_dependents_initialized, 0, &amp;load_images);
</code></pre>

<p>当新的image被加载进来之后由<code>runtime</code>去解析这个二进制文件的符号表和代码</p>

<p><img src="media/15549543814877/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-11%2014.28.40.png" alt=" 屏幕快照 2019-04-11 14.28.40" style="width:300px;"/></p>

<p>整个调用顺序:</p>

<ol>
<li>dyld将整个应用程序二进制文件初始化</li>
<li>由ImageLoader读取image，其中包括了代码、类和方法各种符号</li>
<li>因为runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime处理</li>
<li>runtime调用回调函数<code>map_image</code>做解析处理，之后<code>load_images</code>调用<code>call_load_methods</code>方法，遍历所有加载的class，然后按照继承和层架关系调用Class和其Category的<code>+load()</code>方法</li>
</ol>

<h3 id="toc_5">load方法收集</h3>

<p>在<code>loadImage</code>后 会调用<code>prepare_load_methods</code>方法来获取所有类的列表，并且收集其中load方法。这个方法中会调用<code>schedule_class_load</code>遍历类递归至根节点来收集完成的关系树，并执行<code>add_class_to_loadable_list</code>将其加入执行列表， 然后调用<code>call_load_methods</code>方法，其会创建一个<code>autoreleasePool</code>使用函数指针来动态调用类和<code>Category</code>的<code>+load</code>方法</p>

<p>此时，可执行文件中和动态库所有符号<code>Class、Protocol、Selector、IMP...</code>等都已经按照格式加载到内存，并被runtime管理，这样之后，<code>runtime</code>运行时机制和那些方法（动态添加class、swizzle等）才能生效</p>

<h2 id="toc_6">真正的main函数</h2>

<p>当前面的这些操作结束，dyld会清理现场，将调用栈回归，调用真正的main函数</p>

<p><img src="media/15549543814877/15549695741385.jpg" alt="" style="width:300px;"/></p>

<h2 id="toc_7">补充</h2>

<p>此处只提及了runtime这个分支的初始化以及所做的事情，真正流程比这个复杂的多，还有类似<code>GCD</code><code>XPC</code>等系统库分支</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIApplicationMain]]></title>
    <link href="https://acefish.github.io/15547885598364.html"/>
    <updated>2019-04-09T13:42:39+08:00</updated>
    <id>https://acefish.github.io/15547885598364.html</id>
    <content type="html"><![CDATA[
<p>创建一个应用程序对象和代理，并且设置事件循环(包括应用的runloop)</p>

<pre><code class="language-objectivec">int UIApplicationMain(int argc, char * _Nullable *argv, NSString *principalClassName, NSString *delegateClassName);
//argc: argv参数的个数
//argv: 提供给main函数的参数
//principalClassName: 设置UIApplicaion类或其子类的名字，可以为nil即默认为UIApplication
//delegateClassName: 设置代理，假如从应用的main nib file加载可以该参数传空
</code></pre>

<blockquote>
<p>If the application’s Info.plist file specifies a main nib file to be loaded, by including the NSMainNibFile key and a valid nib file name for the value, this function loads that nib file.</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15543696145918.html"/>
    <updated>2019-04-04T17:20:14+08:00</updated>
    <id>https://acefish.github.io/15543696145918.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络安全、本地存储安全和逆向]]></title>
    <link href="https://acefish.github.io/15543692800437.html"/>
    <updated>2019-04-04T17:14:40+08:00</updated>
    <id>https://acefish.github.io/15543692800437.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时]]></title>
    <link href="https://acefish.github.io/15543581687703.html"/>
    <updated>2019-04-04T14:09:28+08:00</updated>
    <id>https://acefish.github.io/15543581687703.html</id>
    <content type="html"><![CDATA[
<p>苹果开放的<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/">源码</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15543461783731.html"/>
    <updated>2019-04-04T10:49:38+08:00</updated>
    <id>https://acefish.github.io/15543461783731.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础使用]]></title>
    <link href="https://acefish.github.io/15542595230571.html"/>
    <updated>2019-04-03T10:45:23+08:00</updated>
    <id>https://acefish.github.io/15542595230571.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-objectivec">//直接定义
@property (nonatomic, copy) void(^block)(NSInteger);

//方法中定义
block:(void(^) (NSInteger index))block;

//其他定义
typedef void(^Block)(NSInteger index);
@property (nonatomic, copy) Block block;
</code></pre>

<pre><code class="language-objectivec">//声明加定义
returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态库与动态库]]></title>
    <link href="https://acefish.github.io/15542163059530.html"/>
    <updated>2019-04-02T22:45:05+08:00</updated>
    <id>https://acefish.github.io/15542163059530.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">库</h2>

<p>库(library)就是一堆对象文档(.o文件)的归档，是一段编译好的二进制代码,加上头文件来供别人使用。</p>

<p>使用库的情况:</p>

<ol>
<li>当我们想封装代码给别人使用而不想别人看到源码</li>
<li>当代码不会经常改动，可以将其打包成库，减少编译时间</li>
</ol>

<h2 id="toc_1">静态库</h2>

<p>静态库:在静态链接时会被直接复制目标程序中，这样在编译完成后程序并没有外部依赖，但是目标程序会变大</p>

<p>静态库在windows中为<code>.lib</code> mac和linux下为<code>.a</code> mac下还有 <code>.framework</code></p>

<h2 id="toc_2">动态库</h2>

<p>动态库:动态库在静态链接时并不会被拷贝到目标程序中，目标程序只会存储指向动态库的引用，程序运行时，动态库才会真正加载进来，动态库不需要拷贝到程序中，不影响程序体积，同一份库可以被多个程序使用，但是使目标程序依赖于外部环境</p>

<p>动态库在windows下为<code>.dll</code> mac为<code>.dylib和.framework</code> linux下为<code>.so</code> (系统提供的framework都是动态库)</p>

<p>在Xcode7之后，<code>.dylib</code>文件替换为了<code>.tbd</code>文件</p>

<p>动态库好处:</p>

<ul>
<li>代码共用: 在磁盘中只需要一份，可以让多个程序共用依赖链接</li>
<li>易于维护: 因为是程序执行时才link的，因此lib很容易更新替换</li>
<li>减少可执行文件体积: 不需要打包进可执行文件，因此执行文件体积就小了很多</li>
</ul>

<h3 id="toc_3">.dylib与.tbd</h3>

<p><code>.tbd</code>是基于文本的，因此只是包含在项目中的文本文件，其作用是指向所需的<code>.dylib</code>二进制文件链接。因为文本文件比二进制文件小很多，因此可以减少其下载大小(在实际动态链接时，仍然链接的为.dylib文件)</p>

<h3 id="toc_4">.framwork</h3>

<p>在iOS开发中还会用到<code>Framework</code>，在iOS8之前 只能使用苹果的framework动态库，而在iOS8之后，开发者可以自己打包framework，但是自己开发的framework还是类似静态库，需要拷贝到app中，苹果又把这种 Framework 称为 Embedded Framework</p>

<h3 id="toc_5">系统的.framework与.dylib</h3>

<p>系统为什么提供了.dylib动态库还有.framework动态库<br/>
个人觉得是因为他们层级不一样,.dylib是系统操作<strong>系统内置库</strong>，底层的；.framework是开发的应用层级<strong>框架</strong></p>

<h2 id="toc_6">参考资料</h2>

<p><a href="http://www.cnblogs.com/Jenaral/p/5530383.html">iOS 静态库，动态库与 Framework 浅析</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APP启动优化]]></title>
    <link href="https://acefish.github.io/15542146663946.html"/>
    <updated>2019-04-02T22:17:46+08:00</updated>
    <id>https://acefish.github.io/15542146663946.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">App启动主要包括三个阶段</h2>

<ol>
<li>main()函数执行前</li>
<li>main()函数执行后</li>
<li>首屏渲染完成</li>
</ol>

<h3 id="toc_1">main函数执行前</h3>

<ul>
<li>加载可执行文件</li>
<li>加载动态链接库</li>
<li>Objc运行时的初始处理，包括Objc相关类的注册、category注册、selector唯一性检查等</li>
<li>初始化，包括执行+load()方法，attribute((constructor))修饰的函数调用、创建C++静态全局变量</li>
</ul>

<p>因此可做的优化:</p>

<ul>
<li>减少动态库加载。每个库本身都有依赖关系,使用更少的动态库，如果使用的动态库数量较多，尽量将多个动态库合并。苹果支持做多可以支持6个非系统动态库合并为一个</li>
<li>减少加载启动后不会去使用的类或者方法</li>
<li>+load()方法内容可以放到首屏渲染完成后再执行，或者使用<code>+initialize()</code>方法替换。因为，在一个<code>+load()</code>方法中，进行运行时方法替换操作会带来4好眠的消耗，避免积少成多，对启动速度带来影响</li>
<li>控制C++全局变量的数量</li>
</ul>

<h3 id="toc_2">main函数执行后</h3>

<p>main()执行后的阶段，从main()函数执行开始，到<code>appDelegate</code>中<code>didFinishLaunchingWithOptions</code>方法里首屏渲染相关方法执行完成</p>

<p>这个阶段主要为首页需要的业务代码，包括：</p>

<ul>
<li>首屏初始化所需配置文件读写操作</li>
<li>首屏列表大数据的读取</li>
<li>首屏渲染的大量计算等</li>
</ul>

<p>我们不应该把各种初始化都放在这个时候，应该只在这个时候放置首屏渲染必须的任务</p>

<h3 id="toc_3">首屏渲染完成后</h3>

<p>非首屏其它业务模块的初始化，监听的注册、配置文件的读取等。即，截止到<code>didFinishLaunchingWithOptions</code>方法作用域执行收评渲染之后所有方法执行完成。</p>

<h2 id="toc_4">优化</h2>

<h3 id="toc_5">功能级别优化</h3>

<p>main（）函数开始执行后，到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做</p>

<h3 id="toc_6">方法级别的优化</h3>

<p>即检查首屏渲染完成前主线程有哪些耗时的方法，将耗时方法滞后或者异步。</p>

<blockquote>
<p>常见的耗时方法通常是计算大量数据时，即加载、编辑、存储图片和文件等资源时，但是也有可能为其它方法类似load方法太多的堆积耗时</p>
</blockquote>

<h4 id="toc_7">1. 定时抓取主线程上的方法堆栈，计算一段时间内各个方法的耗时</h4>

<p>Xcode中的Time Profiler就是这种方式</p>

<p>这种方法需要考虑设置抓取的定时间隔，间隔长了会漏掉一些方法，导致检查出来耗时不准确；而设置的短了，抓取堆栈方法本身调用过多也会影响整体耗时，导致结果不准确</p>

<p>一般将时间设置为0.01s，这样对整体耗时影响小，虽然此时很多耗时方法不准确了，但是因为整体耗时更加重要，这也是够用的</p>

<h4 id="toc_8">2. 对obcc_msdSend方法进行hook掌握所有方法的执行耗时</h4>

<p>hook <code>objc_msgSend</code>优点是非常精确，而缺点即只能针对OC方法，对C方法和block方法需要使用<code>libffi</code>的<code>ffi_call</code>来hook了，但是编写维护相关工具门槛较高</p>

<p><strong>原理</strong>:<br/>
OC中的每个对象都会指向一个类，每个类也都有一个方法类表，方法列表中的方法由<code>selector</code>函数指针<code>metadata</code>组成，objc_msgSend就是在运行时根据对象和方法的selector去找相应的函数指针，然后执行，然后执行，因此objc_msgSend是OC放大执行的必经之路<br/>
objc_msgSend调用频率最高，本身是用汇编语言写的，可以提高app生命周期的性能，也可以实现未知参数跳转到任意函数指针的功能</p>

<h2 id="toc_9">Hook objc_msgSend方法</h2>

<p>Fackbook开源了一个库，可以再iOS上运行的Mach-O二进制文件中动态地重新绑定符号，<strong>fishhook</strong><a href="https://github.com/facebook/fishhook">源码地址</a></p>


]]></content>
  </entry>
  
</feed>
