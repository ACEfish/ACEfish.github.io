<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2019-10-31T14:35:27+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15724227215760.html"/>
    <updated>2019-10-30T16:05:21+08:00</updated>
    <id>https://acefish.github.io/15724227215760.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SceneDelegate In Xcode11]]></title>
    <link href="https://acefish.github.io/15724059867930.html"/>
    <updated>2019-10-30T11:26:26+08:00</updated>
    <id>https://acefish.github.io/15724059867930.html</id>
    <content type="html"><![CDATA[
<p>参考<a href="https://learnappmaking.com/scene-delegate-app-delegate-xcode-11-ios-13/?utm_campaign=iOS%2BDev%2BWeekly&amp;utm_medium=web&amp;utm_source=iOS%2BDev%2BWeekly%2BIssue%2B426">The Scene Delegate In Xcode 11 And iOS 13</a></p>

<h2 id="toc_0">App Delegate</h2>

<p>其中的<code>application(:didFinishLaunchingWithOptions:)</code>函数是系统开始应用后调用的第一个函数，继承自<code>UIApplicationDelegate</code>协议</p>

<p>在iOS12时，我们在appDelegate中做的事情：</p>

<ul>
<li>设置app的第一个<code>view controller</code></li>
<li>配置应用程序设置和启动组件，例如日志记录和云服务等</li>
<li>注册app的推送处理，以及响应发送到app的推送的处理</li>
<li>响应对app的生命周期事件，例如进入后台、启动app、退出app等</li>
</ul>

<pre><code class="language-objectivec">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool
{   
    let timeline = TimelineViewController()
    let navigation = UINavigationController(rootViewController: timeline)

    let frame = UIScreen.main.bounds
    window = UIWindow(frame: frame)

    window!.rootViewController = navigation
    window!.makeKeyAndVisible()

    return true
}
</code></pre>

<p>创建一个ViewController，放入<code>navigation controller</code>中，设置为UIWindow对象的的<code>rootViewController</code>。这个window是appdelegate 的属性，并且是app拥有的一个window。</p>

<p>window是一个重要的概念，本质上window就是我们的应用程序，大多数iOS应用只有这一个window，它包含了app的用户界面，将event事件分发到view中，并且提供了展示app内容的主要背景。</p>

<h2 id="toc_1">Scene Delegate</h2>

<p>在iOS13以上，<code>scene delegate</code>接管了app delegate的一些角色。最重要的是，<strong>window的概念已经被scene取代。一个应用程序可以有多个场景，而一个场景现在可以用作app的用户界面和内容的背景。</strong></p>

<p>具有多场景的app概念很有趣，可以允许你在iOS和iPadOS中构建多窗口应用程序。例如，文字处理器应用程序中的每个文本文档都可以有自己的场景。用户还可以创建场景副本，一次有效的运行一个app的多个实例。</p>

<p>在Xcode11实际使用中，使用sceneDelegate的位置：</p>

<ol>
<li>一个新的iOS项目具有<code>SceneDelegate</code>类，该类会自动创建，其中包含常用的声明周期事件，例如<code>active、resign和disconnect</code></li>
<li><code>Appdelegate</code>类具有和<code>Scene</code>相关的两个函数<code>application（_：configurationForConnecting：options :)</code>和<code>application（_：didDiscardSceneSessions :)</code></li>
<li>Info.plist文件中有<code>Application Scene Manifest</code>，列出此应用程序中包含的Scene，包括其class、delegate、storyboard名称</li>
</ol>

<h3 id="toc_2">Scene Delegate Class</h3>

<p>在<code>SceneDelegate</code>类中，最重要的是<code>scene(_:willConnectTo:options:).</code>函数，某些方面来说，其重要性与iOS12的<code>application(_:didFinishLaunchingWithOptions:)</code>类似。当场景添加到App中后，该函数会被调用，因此这是配置该Scene的理想位置。</p>

<p>需要注意<code>SceneDelegate</code>也使用<code>delegate</code>,<mark>并且通常一个<code>delegate</code>会响应任何场景，使用一个delegate去配置应用程度的所有场景</mark></p>

<p>在<code>SceneDelegate</code>中包含以下函数：</p>

<ul>
<li><code>sceneDidDisconnect(_:)</code>当一个场景与应用程序断开连接时被调用(注意场景以后可以重连)</li>
<li><code>sceneDidBecomeActive(_:)</code>当用户开始和场景交互时调用。(例如当从应用程序切换器中选择时)</li>
<li><code>sceneWillResignActive（_ :)</code>当用户停止和场景交互时调用(例如切换到另外一个场景时)</li>
<li><code>sceneWillEnterForeground（_ :)</code>当场景进入前台时，即从背景状态恢复时，调用</li>
<li><code>sceneDidEnterBackground（_ :)</code>当场景进入后台时调用，此时应用已经最小化并存在于后台</li>
</ul>

<blockquote>
<p>这些函数是应用程序的典型生命周期事件</p>
</blockquote>

<h3 id="toc_3">Appdelegate： Scene Sessions</h3>

<p>iOS13的AppDelegate，包含了两个scene session管理相关的delegate函数。当app中创建scene后，<code>scene session</code>将会跟踪和该场景相关的所有信息</p>

<ul>
<li><code>Application（_：configurationForConnecting：options :)</code>在创建新场景时需要返回配置对象</li>
<li><code>Application（_：didDiscardSceneSessions :)</code>当app的用户通过应用切换器关闭一个或者多个场景时调用</li>
</ul>

<p>目前，<code>Scene session</code>用于指定场景角色，例如<code>External Display</code>或者<code>CarPlay</code>。还可以用于还原scene状态。状态还原在应用启动之间保留并重新创建UI。还可以将用户信息分配给场景会话，这实际是一个可以放入任何内容的字典</p>

<p><code>application（_：didDiscardSceneSessions :)</code>，在app的用户通过应用切换器关闭一个或者多个场景时调用。可以使用此函数处理这些scene所需要的资源，因为不再需要这些资源。</p>

<p><code>application（_：didDiscardSceneSessions :)</code>与<code>sceneDidDisconnect（_ :)</code>对比，后者只会在场景断开连接时调用，但是并不一定会被丢弃，因为可以重新连接，而<code>application（_：didDiscardSceneSessions :)</code>标记为使用应用程序切换器退出场景的时候</p>

<h3 id="toc_4">info.plist Application Scene Manifest</h3>

<p>app支持的每个scene都需要在<code>Application Scene Mainifest</code>中声明。大多数app只有一个场景，但是可以创建更多的场景，例如用于响应推送通知或者特定操作的特定场景</p>

<p>注意：声明的时session type而不是session本身。因此应用程序可以支持一个场景，创建该场景的副本，然后使用该场景副本创建多窗口应用程序</p>

<p>//Object-C版本<br/>
<img src="media/15724059867930/15724244483633.jpg" alt="" style="width:872px;"/></p>

<p>//swift版本<br/>
<img src="media/15724059867930/15724423133368.jpg" alt="" style="width:864px;"/></p>

<p>顶层入口为<code>Application Scene Mainifest</code>，而在其下为<code>Enable Multiple Windows</code>，需要设置为YES来支持多窗口应用程序。下面是<code>Scene Configuration</code>，其中<code>Application Session Role</code>用于声明app内部的scene，而还有另外一个<code>External Display Session Role</code>用于声明屏幕外的场景。<br/>
其中最重要的为<code>Application Session Role</code>数组：</p>

<ul>
<li><code>configuration</code>名字，必须为唯一的</li>
<li>场景的类名称</li>
<li>场景的代理类名称，通常为<code>SceneDelegate</code></li>
<li>包含初始UI的<code>storyboard</code>名称</li>
</ul>

<p>而SceneDelegate、Appdelegate中的scene session、以及<code>Application Scene Manifest</code>是怎么协同工作来创建多窗口应用呢？</p>

<ul>
<li>SceneDelegate类 管理场景的声明周期</li>
<li>Appdelegate中有新功能，管理场景会话、提供场景的配置数据</li>
</ul>

<h2 id="toc_5">Scene Delegate 和 SwiftUI</h2>

<p>最简单的引导iOS13应用程序的方法时使用SwiftUI，而SwiftUI App也主要依靠SceneDelegate来设置app的初始UI</p>

<p><img src="media/15724059867930/15724423966124.jpg" alt="" style="width:866px;"/></p>

<ol>
<li>并没有设置StoryBoard名称</li>
<li>如果支持多窗口 需要设置<code>Enable Mutiple Window</code>为YES</li>
</ol>

<pre><code class="language-swift">class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        let contentView = ContentView()

        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }
...
</code></pre>

<ul>
<li><code>scene（_：willConnectTo：options :)</code>代理函数在将新场景添加到应用后调用。提供了一个Scene(以及session).此<code>UIWindowScene</code>是由App创建的，因此无需手动进行操作</li>
<li>还有使用window属性，但是现在已经成为Scene的一部分。在<code>if let</code>代码块中，使用场景初始化UIWindow对象</li>
<li>设置了根视图控制器，将window设置给window属性，并且将该窗口<code>makeKeyAndVisible</code>，即将该窗口设置于App的UI前</li>
<li>ContenView是特定于SwiftUI进行创建的，通过<code>UIHostingController</code>将其添加为根视图控制器，将基于SwiftUI视图显示到屏幕上</li>
<li>请注意：<code>UIScene</code>类型的Scene参数是<code>UIWindowScene</code>类型的，但是使用<code>as?</code>类型转换(猜测虽然目前场景大多为<code>UIWindowScene</code>类型，但是将来会有更所类型场景)</li>
</ul>

<h2 id="toc_6">SceneDelegate With Storyboards</h2>

<p>在未来虽然有可能看到更多<code>SwiftUI</code>应用，但是目前来说storyboards更加常见</p>

<p>目前使用Storyboard我们无需做任何操作，只需要<code>File → New → Project…</code>然后选择<code>singleApp</code>，最后选择<code>Storyboard for User Interface</code>就可以了</p>

<ul>
<li>此时可以再Application Scene Manifest找到Main Storyboard</li>
<li>默认情况下，App Delegate将会使用<code>Default scene configuration</code></li>
<li>默认情况下，SceneDelegate设置一个UIWindow对象，并使用<code>Main.STORYBOARD</code>创建初始UI</li>
</ul>

<h2 id="toc_7">自己编程方式设置App</h2>

<p>当我们不使用storyboards单独使用Xib创建AppUI，此时在<code>SceneDelegate</code>的<code>scene（_：willConnectTo：options :)</code>函数中设置初始视图控制器</p>

<pre><code class="language-swift">class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)
    {
        if let windowScene = scene as? UIWindowScene {

            let window = UIWindow(windowScene: windowScene)
            let timeline = TimelineViewController()

            let navigation = UINavigationController(rootViewController: timeline)
            window.rootViewController = navigation

            self.window = window
            window.makeKeyAndVisible()
        }
    }

    ...
</code></pre>

<ul>
<li>使用<code>windowScene</code>对象(由scene参数通过类型转换)初始化window属性，</li>
<li>在<code>if let</code>block中的代码 与iOS12或者更低版本设置视图控制器的方式类似。初始化带导航控制器的视图控制器，将其分配给rootViewController属性</li>
<li>最后将window常量，设置给window属性，并将其设置为<code>keyAndVisible</code>，使其在屏幕最前方</li>
</ul>

<blockquote>
<p>这种方式设置SceneDelegte只是将代码从Appdelegate移过来 并且配置<code>Application Scene Manifest.</code>即可</p>
</blockquote>

<h2 id="toc_8">Scene-Based 声明周期</h2>

<p>添加对场景的支持会更改您的应用对生命周期事件的响应方式。在没有Scene的App中，<code>App delegate</code>对象处理到前台或后台的过渡。当您向App添加Scene支持时，UIKit会将职责转移到<code>scene delegate</code>对象上。<code>Scene</code>的生命周期彼此独立，并且独立于应用程序本身，因此<code>scene delegate</code>对象必须处理过渡。</p>

<p>如果您的应用程序还支持iOS 12或更低，则可以在<code>App delegate</code>和<code>scene delegate</code>对象中处理生命周期过渡。 UIKit仅只会通知一个delegate对象。在iOS 13及更高版本中，UIKit会通知您的<code>scene delegate</code>对象。在iOS 12及更低版本中，UIKit会通知您的<code>App delegate</code>。<br/>
有关如何处理生命周期事件的信息，请参阅<a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">管理应用程序的生命周期</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15723433400719.html"/>
    <updated>2019-10-29T18:02:20+08:00</updated>
    <id>https://acefish.github.io/15723433400719.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15723307191677.html"/>
    <updated>2019-10-29T14:31:59+08:00</updated>
    <id>https://acefish.github.io/15723307191677.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试 -- RunLoop]]></title>
    <link href="https://acefish.github.io/15723294922603.html"/>
    <updated>2019-10-29T14:11:32+08:00</updated>
    <id>https://acefish.github.io/15723294922603.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">RunLoop概念</h2>

<p>RunLoop是通过内部维护<code>事件循环</code>来对事件/消息进行管理的对象</p>

<ol>
<li>当没有消息处理时，休眠避免资源被占用，此时由用户态切换到内核态</li>
<li>当有消息需要处理时，立即被唤醒，此时由内核态切换到用户态</li>
</ol>

<blockquote>
<p>为什么Main函数不会退出？</p>

<p>UIApplicationMain内部默认开启了主线程的RunLoop，并执行了一段while循环代码</p>
</blockquote>

<h2 id="toc_1">RunLoop数据结构</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试-NSOperation、自旋和互斥锁]]></title>
    <link href="https://acefish.github.io/15723153205618.html"/>
    <updated>2019-10-29T10:15:20+08:00</updated>
    <id>https://acefish.github.io/15723153205618.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">NSOperationQueue的优点</h2>

<ol>
<li>可以添加任务以来，方便控制执行顺序</li>
<li>可以设定操作执行的优先级</li>
<li>任务执行状态控制：isReady、isExecuting、isFinished、isCancelled</li>
<li><p>可以设置最大并发量</p></li>
</ol>

<ul>
<li><p>NSOperation<br/>
执行的操作，就是期望在线程中执行的代码。在GCD中是放在放在block中的。而在NSOperation中是使用其子类NSIvocationOperation、NSBlockOperation，或者自定义子类来进行操作的封装</p></li>
<li><p>NSOperationQueue<br/>
操作队列，存放操作的队列。和GCD的FIFO不同，NSOperationQueue对于添加到队列中的操作，首先进入准备就绪状态(就绪状态取决于操作之间的依赖关系)，然后对进入就绪状态的操作开始执行顺序（非结束顺序）由操作之间相对的优先级决定(优先级是操作对象自身的属性)<br/>
操作队列通过设置最大并发数来控制并发、串行。<code>NSOperation</code>为我们提供了两种队列，主队列和自定义队列。主队列运行在主线程之上，而其他队列都在后台运行。’</p></li>
</ul>

<h2 id="toc_1">NSThread+runloop实现常驻线程</h2>

<p>因为每次开辟子线程都会消耗CPU，当需要频繁使用子线程时，就会消耗大量的CPU，而且因为创建线程都是在任务执行完成后就释放了，不能再次利用，这时可以考虑创建一个常驻线程</p>

<h2 id="toc_2">自旋锁和互斥锁</h2>

<ul>
<li>自旋锁：<br/>
用于保护多线程共享资源的锁，与一般互斥锁(mutex)不同之处在于当自旋锁尝试获取锁时以 忙等待的形式不断地循环检查锁是否时可用的。当上一个线程的任务没有执行完毕时被锁住，那么下一个线程会一直等待（不会睡眠），当上一线程的任务完成后，下一个线程才会立即执行<br/>
在对于多CPU的环境中，对于持有锁的时间较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能</li>
<li><p>互斥锁：<br/>
当上一个线程的任务没有完成时 下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程任务执行完毕，下一个线程会自动唤醒 然后执行任务</p></li>
<li><p>优缺点：<br/>
优点：自旋锁不会引起调用者睡眠，所以不会进行线程调度，CPU时间片轮转等好事操作。所有如果能在短时间内获得锁，自旋锁的效率远高于 互斥锁<br/>
缺点：自旋锁会一直占用CPU，在未获得锁的时候，一直运行--&quot;自旋&quot;。所以占用着CPU，如果不能短时间获得锁，无疑会使CPU的效率降低。<mark>自旋锁不能实现递归调用</mark></p></li>
</ul>

<p>自旋锁：atomic、OSSpinLock、dispatch_semaphore_t<br/>
互斥锁：pthread_mutex、@synchronized、NSLock、NSConditionLock 、NSCondition、NSRecursiveLock</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试-进程、线程、多进程、多线程、任务]]></title>
    <link href="https://acefish.github.io/15722324806873.html"/>
    <updated>2019-10-28T11:14:40+08:00</updated>
    <id>https://acefish.github.io/15722324806873.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">进程</h2>

<ol>
<li>进程是具有一个独立功能的程序关于某次数据集合的一次云层活动，是操作系统分配资源的基本单元</li>
<li>进程是指正在独立运行的一个应用程序，就是一段程序的执行过程，可以理解为手机上的一个打开的app</li>
<li>进程之间是相互独立的，进程运行在专用并且受保护的内存空间中，拥有独立运行所需要的全部资源</li>
</ol>

<h2 id="toc_1">线程</h2>

<ol>
<li>程序执行流的最小单元，线程是进程中的一个实体</li>
<li>一个进程想要执行任务，必须至少有一条线程，引用程序启动时候，系统会默认开启一条线程，也就是主线程</li>
</ol>

<h2 id="toc_2">进程和线程关系</h2>

<ol>
<li>线程是进程的执行单元，进程的所有任务都在线程中执行</li>
<li>线程是CPU分配资源和调度的最小单位</li>
<li>一个程序可以对应多个进程，一个进程中可以有多个线程，但是至少要有一条线程</li>
<li>同一个进程内的线程共享进程资源</li>
</ol>

<h2 id="toc_3">多进程</h2>

<ul>
<li>进程是程序在计算机上的一次活动。当运行一个程序时，就启动了一个进程。</li>
<li>进程分为系统进程和用户进程。用于完成操作系统各种功能的进程就是系统进程，是处于运行状态下的操作系统本身；由用户启动的进程是用户进程，进程是操作系统进行资源分配的单位</li>
<li>进程可以被细化为线程，就是进程能有多个独立运行的更小单位。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程</li>
</ul>

<h2 id="toc_4">多线程</h2>

<ol>
<li>同一时间，一个CPU上只能处理1条线程。而多线程并发执行，其实是CPU快速的在多条线程之间切换</li>
<li><p>如果线程非常多的话，CPU在多个线程中切换，就会消耗很多的CPU资源，线程被执行的频次会降低</p></li>
<li><p>多线程优点：</p>
<ul>
<li>能适当提高程序执行效率</li>
<li>能适当提高资源利用率</li>
</ul></li>
<li><p>多线程缺点：<br/>
开启线程是需要占用一定的资源空间的，但是如果开启大量线程，就会占用一定资源空间，降低程序性能</p></li>
</ol>

<h2 id="toc_5">任务</h2>

<h2 id="toc_6">GCD和NSOperation</h2>

<p>GCD是面向底层的C语言的API，<code>NSOperationQueue</code>是用GCD进行封装构建的，是GCD的高级抽象</p>

<ol>
<li>GCD执行效率高，而且由于队列中执行的时block构成的任务，因此是一个轻量级的数据结构，写起来其也方便</li>
<li>GCD只支持FIFO队列，而<code>NSOperationQueue</code>可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序</li>
<li><code>NSOperationQueue</code>设置可以跨队列设置依赖任务，但是GCD只能通过设置串行队列，或者添加barrier任务，才能控制执行顺序</li>
<li><code>NSOperationQueue</code>因为面向对象，所以可以支持KVO，可以监测operation的执行状态</li>
</ol>

<p>当只是简单用到异步操作，没有特别复杂的线程关系管理，推荐使用GCD<br/>
当考虑到异步操作之间的事务性、顺序性、依赖关系，此时GCD需要自己写更多代码实现，而NSOperationQueue已经内建了这些支持</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Tagged Pointer]]></title>
    <link href="https://acefish.github.io/15722317560486.html"/>
    <updated>2019-10-28T11:02:36+08:00</updated>
    <id>https://acefish.github.io/15722317560486.html</id>
    <content type="html"><![CDATA[
<p><a href="https://www.jianshu.com/p/c9089494fb6c">深入理解Tagged Pointer</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试---内存管理]]></title>
    <link href="https://acefish.github.io/15721685619236.html"/>
    <updated>2019-10-27T17:29:21+08:00</updated>
    <id>https://acefish.github.io/15721685619236.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">内存布局</h2>

<p><img src="media/15721685619236/15721695768950.jpg" alt="" style="width:672px;"/></p>

<ul>
<li>栈： 方法调用、局部变量 连续地址，从高地址到低地址</li>
<li>堆：分配的内存对象、是离散的，从低地址到高地址，需要我们手动进行内存管理</li>
<li>为初始化数据区（bss）：为初始化的全局变量等</li>
<li>已初始化数据（data区）：已初始化的全局变量等</li>
<li>代码段（text）：程序代码</li>
</ul>

<h3 id="toc_1">2. 各个数据类型占据字节空间</h3>

<ul>
<li>char: 1字节 也就是2<sup>8</sup> 即 256个ASCII字符</li>
<li>char*：指针变量，(32位机器的寻址为2<sup>32即32bit，就是4字节。对于64位编译器来说就是8字节)</sup></li>
<li>short int：2字节</li>
<li>int：4字节</li>
<li>unsigned int：4字节</li>
<li>long：在64位编译器下为8字节，在32位下为4字节</li>
<li>long long：8字节</li>
<li>unsigned long long: 8字节</li>
<li>float：4字节</li>
<li>double：8字节</li>
</ul>

<h3 id="toc_2">static、const、sizeOf关键字</h3>

<h4 id="toc_3">static关键字</h4>

<p><code>static</code>关键字的主要作用有两个，一个是用于修饰存储类型使其成为静态存储类型，二是用于修饰链接属性使之成为内部链接属性</p>

<ul>
<li>静态存储类型： <mark>在函数内定义的静态局部变量</mark>，存储在内存的静态存储区，所以即使该函数运行结束，该值也不会被销毁，等待下次运行进行使用。 
<mark>在函数外定义的静态变量——静态全局变量</mark>，该变量的作用域只能在该变量的文件中，不能被其他文件通过extern引用</li>
<li>内部链接属性：静态函数只能在声明它的源文件中使用</li>
</ul>

<h4 id="toc_4">const关键字</h4>

<ol>
<li>声明常量，使得指定变量不能修改</li>
<li>修饰函数形参，使得形参在函数内不能修改，表示输入参数</li>
<li>修饰函数返回值，使得函数返回值不能修改</li>
</ol>

<h4 id="toc_5">sizeof关键字</h4>

<p>在编译阶段处理，结果为对象或类型所占的内存字节数</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS-面试  OC语言特性]]></title>
    <link href="https://acefish.github.io/15721610726321.html"/>
    <updated>2019-10-27T15:24:32+08:00</updated>
    <id>https://acefish.github.io/15721610726321.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">分类</h2>

<ol>
<li>分类的作用<br/>
声明私有方法，将大体积的类分开，可以将framework中的私有方法公开</li>
<li>分类的特点<br/>
是在运行时，才将<code>Category</code>中的实例方法列表、协议列表、属性列表添加到主类上(所以Category中的方法都是在主类的同名方法之前的)，然后才提柜调用所有类的load方法，这些方法都是在main函数之前执行的。</li>
<li>分类可以添加哪些内容<br/>
实例方法、类方法、协议、属性(通过添加setter和getter方法，并没有添加实例变量)</li>
<li>如果有两个分类A和B，分类中有一个同名方法，哪个方法最终会生效？<br/>
取决于分类的编译顺序，后编译的那个分类的同名方法生效，而之前的会被覆盖(并不是真正的覆盖，因为其与的方法仍然存在只是访问不到，因为在添加类方法是倒序遍历方法列表的，因因此最后编译的分类的方法会在方法列表前面，访问时就会先被访问到。因此，如果生命一个和原类方法同名的方法，也会覆盖原类方法)</li>
<li>添加了两个同名的分类 会报错的</li>
<li>分类能添加成员变量吗?<br/>
分类是不能添加成员变量。只能通过运行时中的关联对象来模拟实现成员变量，实际~~~~是关联内容，所有对象的关联内容都放在同一个全局容器哈希表中:<code>AssociationsHashMap</code>，由于<code>AssociationsManager</code>统一管理</li>
</ol>

<h2 id="toc_1">扩展</h2>

<ol>
<li>扩展的作用<br/>
声明私有属性、声明方法、声明私有成员变量</li>
<li>扩展的特点<br/>
编译时决议，只能以声明的形式存在，我们不能为系统类添加扩展</li>
</ol>

<h2 id="toc_2">代理</h2>

<p>传递方式是一对多的</p>

<h2 id="toc_3">通知</h2>

<p>使用观察者模式来实现跨层传递信息，传递方式是一对多的</p>

<h2 id="toc_4">KVO</h2>

<p>是另外一种观察者模式  </p>

<p>当被观察额peoperty值发生变化时，或者它以来的某个key发生变化时 就会触发<code>observeValueForKeyPath:ofObject:change:context:</code>方法</p>

<p>可以用一下几种方式触发被改变property值：</p>

<ol>
<li>使用key-value 的 accessor方法</li>
<li>使用 kvc方法 例如 <code>setValue:forKey:、insertValue:inPropertyWithKey:</code></li>
<li>使用<code>mutableArrayValueForKey:</code>取得一份代理对象，并操作这个代理对象</li>
</ol>

<p>我们也可以手动发送<code>change notification</code>。</p>

<pre><code class="language-objectivec">- (void)setValue:(id)value
{
    [self willChangeValueForKey:@&quot;key&quot;];
    
    [super setValue:value];
    
    [self didChangeValueForKey:@&quot;key&quot;];
}
</code></pre>

<h2 id="toc_5">KVC</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试-UI、事件传递、图像显示、性能优化]]></title>
    <link href="https://acefish.github.io/15719721721875.html"/>
    <updated>2019-10-25T10:56:12+08:00</updated>
    <id>https://acefish.github.io/15719721721875.html</id>
    <content type="html"><![CDATA[
<p>参考<a href="14951065647732.html">图层性能</a></p>

<h2 id="toc_0">时间处理原理</h2>

<p>UIView为CALayer提供内容、负责处理触摸等事件，参与响应链</p>

<p>CALayer虽然不参与响应链 但是有一系列的方法帮助处理事件</p>

<pre><code class="language-objectivec">-containsPoint:  //如果该点在该图层 就返回yes
-hitTest:  //接受一个point作为参数  返回的是图层本身或者包含这个坐标点的子节点图层
</code></pre>

<p>事件传递过程：<br/>
点击屏幕后 UIApplication-&gt;UIWindow，通过pointinside方法来判断该方法是否在该视图中</p>

<pre><code class="language-objectivec">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;
</code></pre>

<p>然后在所有子视图中重复该动作  直到找到点击所在区域视图  然后在反向重复进行</p>

<pre><code class="language-objectivec">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;
</code></pre>

<p>找到能处理此事件视图 如果一直传递到UIApplication都没有被处理掉 就会被忽略</p>

<h2 id="toc_1">图像显示原理</h2>

<p>可以参考GPU渲染文档 <a href="15643878437057.html">渲染</a></p>

<p>简单版本的渲染流程</p>

<ol>
<li>更新视图树</li>
<li>CPU计算要显示的内容，在runLoop的beforeWatting和Exit时 将更新的视图树打包发送给独立负责渲染的drawRender进程</li>
<li>数据在Render Server后 会被反序列化 而在的图层树 根据图层树使用画家算法 得到最终的渲染树  渲染树信息转换为<code>OpenGL ES/Metal</code> 发送给GPU进行渲染</li>
<li>GPU进行渲染和纹理合成<br/></li>
<li>将结果放到帧缓冲区</li>
<li>视频控制器根据Vsync信号 指定时间去提取帧缓冲区的屏幕显示</li>
<li>显示到屏幕上</li>
</ol>

<p>一般页面为60fps， 即一秒就要更新60帧 </p>

<h2 id="toc_2">滑动优化方案</h2>

<p>针对CPU 将以下操作放到子线程</p>

<ol>
<li>对象的创建、调整、销毁 放到子线程</li>
<li>将布局计算、文本计算、高度缓存等 放到子线程</li>
<li>预渲染(文本的异步绘制、图片解码等)</li>
</ol>

<p>GPU: 纹理渲染 视图合成</p>

<p>一般遇到性能问题，经常考虑是否发生了一下操作</p>

<ol>
<li>是否收到CPU和GPU的限制</li>
<li>是否有不必要的CPU渲染</li>
<li>是否有太多的离屏渲染</li>
<li>是否有奇怪的图片格式或者尺寸</li>
<li>是否有太多图层混合操作</li>
<li>是否有昂贵的View效果</li>
<li>View的层次结构是否合理</li>
</ol>

<h2 id="toc_3">UI绘制的原理</h2>

<p><img src="media/15719721721875/15719869651266.jpg" alt="" style="width:683px;"/></p>

<ul>
<li>当调用<code>[UIView SetNeedsDisplay]</code>时  并没有立即执行绘制工作，而是执行<code>[View.layer setNeedDisplay]</code>方法  给当前的layer打上“脏”标记</li>
<li>RunLoop快要结束时 调用layer的display方法 进入当前视图的真正绘制中</li>
<li>在layer的display内部 系统判断layer的delegate是否实现<code>displayLayer:</code>的delegate方法。如果实现了就执行异步绘制，否则交给系统的绘制流程</li>
</ul>

<h3 id="toc_4">系统绘制流程</h3>

<p><img src="media/15719721721875/15719878775435.jpg" alt="" style="width:688px;"/></p>

<ul>
<li>在layer的内部创建一个backing store,即CGContextRef上下文</li>
<li>如果layer有delegate：<br/>
执行[layer.delegate drawLayer:incntext]方法(这个方法在系统内部执行)，在方法内部调用view的drawReact方法，也就是重写view的drawRect方法 才会被调用</li>
<li>如果没有delegate就会调用layer的<code>drawInContext</code>方法 可以重写layer的该放大</li>
<li>将绘制结果提交给GPU</li>
</ul>

<p><img src="media/15719721721875/15719888857380.jpg" alt="" style="width:689px;"/></p>

<h2 id="toc_5">iOS视图约束</h2>

<h3 id="toc_6">自动约束方法</h3>

<ol>
<li><p>updateConstraintsIfNedded<br/>
触发开始约束更新<br/>
当有新的布局时，系统调用此方法确保视图和子视图约束信息的更新，系统会自动调用这方法，我们也可以手动调用此方法，来检查最新的约束条件</p></li>
<li><p>updateConstraints<br/>
更新约束<br/>
我们可以通过重写此方法来设置自己的约束，系统在调用layOut布局之前，回调用这个方法，确认在视图的约束<br/>
当我们的视图有约束变化或者失效，我们可以改变这些约束然后调用<code>setNeedUpdateConstraints</code>标记约束需要更新<br/>
需要在此方法最后调用<code>super updateConstraints</code></p></li>
<li><p>-（BOOL）neddUpdateConstrains<br/>
调用此方法根据此方法的返回 决定是否需要更新约束</p></li>
<li><p>setNeedsUpdateConstraints<br/>
当视图需要更新时 我们可以调用此方法，然后在系统决定更新时机</p></li>
</ol>

<h3 id="toc_7">updateConstranins和layOut方法联系</h3>

<p>AutoLayout在更新显示view之前，会先调用updateContrains和layingOutView，layout和依赖于Contrains，而view的最终显示依赖于layout</p>

<p>第一步：update constrains 进行视图的约束，从俯视图到子视图更新约束信息，可以通过调用<code>setNeedsUpdateConstraints</code>来触发此步骤. 而当我们做出一些改变约束的事情事，可以调用<code>updateConstraintsIfNedded</code>来通知约束改变，可以在<code>updateConstraints</code>方法中重写或者补充一些视图的约束</p>

<p>第二步: lauout 根据上一步的约束结果，从父视图到子视图来设置视图的bounds frame等 确定试图位置，与constrains类似 有<code>setNeedLayout</code> <code>layoutIfNeeded</code> <code>layoutSubviews</code>方法</p>

<p>第三步: 此步骤时 把view展示在屏幕上 此步骤可以通过<code>setNeedDisplay</code>来触发</p>

<p>这三个步骤互相依赖，每一步的触发都依赖于上一步</p>

<h3 id="toc_8">补充</h3>

<p>`UIViewControlle</p>

<pre><code class="language-text">```r`中有`- (void)updateViewConstraints`默认实现是调用UIView的`uodateConstraints`


    

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block、Delegate、Notification]]></title>
    <link href="https://acefish.github.io/15719108696882.html"/>
    <updated>2019-10-24T17:54:29+08:00</updated>
    <id>https://acefish.github.io/15719108696882.html</id>
    <content type="html"><![CDATA[
<p>三种常见的回调方式</p>

<p>block和delegate都可以进行通知</p>

<ol>
<li><p>delegate的运行成本低 block的运行成本高<br/>
block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是加计数，使用完或者block置nil后才消除。对对象的引用 甚至还有可能会拷贝对象 或者 对对象造成循环引用<br/>
delegate只是保存了一个对象指针，直接回调，没有额外消耗</p></li>
<li><p>使用场景的区别<br/>
block更加轻型 使用起来更加方便 常在局部使用 能增加代码的可读性 和 可维护性</p>
<p>delegate 能减少代码的耦合度，使事件的监听和事件的处理相分离。语法定义清晰，一个代理可以执行多个协议方法 而不需要创建新的代理，减少维护成本。可以同时实现多个代理</p></li>
</ol>

<h2 id="toc_0">notification</h2>

<p>也是iOS中常用的传值和回调方式</p>

<p>采用单例设计模式<br/>
使用起来加单，代码精简，可以实现一对多传值</p>

<p>缺点是： </p>

<ul>
<li>必须要在使用完成后注销通知，否则有可能出现crash</li>
<li>增加调试难度很难跟踪动作进行</li>
<li>并不能获取发送通知后的反馈</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么类别具有更高优先级]]></title>
    <link href="https://acefish.github.io/15719084787065.html"/>
    <updated>2019-10-24T17:14:38+08:00</updated>
    <id>https://acefish.github.io/15719084787065.html</id>
    <content type="html"><![CDATA[
<p>dyld和runtime结合</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题]]></title>
    <link href="https://acefish.github.io/15719057934061.html"/>
    <updated>2019-10-24T16:29:53+08:00</updated>
    <id>https://acefish.github.io/15719057934061.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>OC类可以多继承吗？可以实现多接口吗？Category是什么？重写一个类使用继承好还是分类好？<br/>
OC不能多继承，可以实现多接口，通过实现多接口可以完成类似多继承。使用Category好，使用Category只会对本分类有效，不会影响到其他类和原有类关系</p></li>
<li><p>import和#include的区别，@class、#import&lt;&gt;和import“”</p>
<p>import是OC导入的关键字 include是C和C++导入的关键字,使用#import会保证只导入一次，不重复导入，相当于 #include和#pragma once。@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含;#import&lt;&gt;用来包含系统的头文件，#import“”用来包含用户头文件。</p></li>
<li><p>常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</p>
<p>答：object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。<mark>NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long</mark>。</p></li>
<li><p>类别的作用？继承和类别在实现中有何不同？<br/>
类别可以在不获悉，不改变原有代码的情况下，向里面添加新的方法，只能添加不能删除和修改。如果和原有类中方法产生冲突，则类覆盖原来的方法，因为类别具有更高的优先级。</p></li>
<li><p>为什么说OC是运行时动态语言<br/>
这里涉及了两个概念： <br/>
    运行时：将数据类型的确定由编译时，推迟到了运行时，在运行时才去确定一个对象的类别，以及调用该类别对象指定方法。其为动态语言 即为可以在运行时改变其结构<br/>
    多态：不同对象以自己的方式响应相同的消息能力即为多态。</p>
<blockquote>
<p>补充：<br/>
动态可以为：动态类型(比如经过类型判断可以将类型进行转换)、动态绑定(函数和selector的动态绑定)、动态加载(比如根据不同机型加载不同资源文件)</p>
</blockquote></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Collections and asynchronous updates]]></title>
    <link href="https://acefish.github.io/15719000093976.html"/>
    <updated>2019-10-24T14:53:29+08:00</updated>
    <id>https://acefish.github.io/15719000093976.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概述</h2>

<p>ASCollectionNode和ASTableNode使用相同的内部类(ASRangeController和ASDataController)来简化大多数的操作。</p>

<p><code>ASRangeController</code>负责确定哪些Collection cell node 是在一定范围内并且为cell node以及其子节点设置正确的 interface state</p>

<p><code>ASDataController</code>是支持UICollectionView的真实数据源。负责处理批处理更新，以线程安全的方式将其转发到bacKing View.</p>

<h2 id="toc_1">批量更新</h2>

<p><code>UICollectionView</code>允许客户端提交单个编辑而不需要包装在批处理更新中。<code>ASCollectionNode</code>虽然也允许这么做，但是在后台操作会自动捆绑到批处理更新中，因此也叫做<code>change set(更改集 _ASHierarchyChangeSet)</code>。批处理操作也可以嵌套，最后是单个的更改集<br/>
值得注意的是，在其生命周期开始，UICollectionView需要执行初始数据加载。可以简单的通过调用<code>-reladData</code>实现,这也包装在ASCollectionNode的更改集中。因此，初始数据加载只是另一个更改集，就像其它更改一样。</p>

<h2 id="toc_2">改变集 处理流程</h2>

<p><code>ASCollectionNode</code>不接受也不处理单个的编辑操作。其<code>ASDataController</code>公开的主要数据更新方法为<code>-updateWithChangeSet:（_ ASHierarchyChangeSet *）changeSet</code>，并且在通过此方法提交之前，必须将编辑操作包装在更改集中，可以将这个方法是为处理更改集的通道</p>

<p>通道在开始处理主线程的更改集之前，切换到后台线程执行昂贵的操作，最后返回到主线程将其转发到UICollectionView</p>

<h3 id="toc_3">内部队列和数据集</h3>

<p>由于通道在多个线程上运行，因此每个改变集都需要通过通道确保数据的一致性，不仅与数据源而且与backing View保持一致。在内部，<code>ASDataController</code>使用两个队列和数据集来简化通道</p>

<p>这两个队列称为<code>_editingTransactionQueue</code>和<code>_mainSerialQueue</code>。前者为串行后台dispatch_queue,后者为<code>ASMainSerialQueue</code></p>

<p>两个数据集为<code>pendingMap</code>和<code>visibleMap</code>。它们每个都是ASElementMap实例，<code>ASElementMap</code>是不可变的、主线程的<code>ASCollectionElement</code>的集合</p>

<p>每一个<code>ASCollectionElement</code>代表colletion视图中的item或者supplementary视图。它具有足够的信息帮助ASDataController来初始化和测量backing ASCellNode以及最终要的nodeblock。这个block是在进程开始时被data source返回的，并且被element引用直到该block被执行。在首次调用<code>-[ASCollectionElement node]</code>被调用时 该block被执行。一旦被执行，<code>ASCellNode</code>将会被element强应用并且block被释放。这意味着任何给定时间，element要不具有node block 要不具有node instance，不能同时拥有两者。如果caller想要获取node，只有在node已经被初始化的情况下，此时应该调用<code>-nodeIfAllocated</code></p>

<h2 id="toc_4">Data Source index space VS UIKit index space</h2>

<p>由于每个改变集都是异步处理，因此可能需要支持多个<code>UICollectionView</code>在多个主线程run loop中使用改变集。</p>

<p>在任何给定时间，ASDataController的pendingMap是从数据源获取的最新map，因此它位于数据源索引空间中。另一方面，visibleMap是UICollectionView当前显示的元素的集合。结果，它在UIKit索引空间中。</p>

<h3 id="toc_5">工作的五个步骤</h3>

<p>每个改变集都会执行这5个步骤</p>

<ol>
<li>该进程从主线程开始。此时pendingMap和visibleMap是同一个。制作一个pendingMap的mutalbe copy，然后根据改变集来进行更新。这包括，移除旧的items，向数据源查询插入新的items。在这步结束时，将会更新<code>pendingMap</code>反应data source的整体视图</li>
<li>这是一个可选的步骤，仅当layout delegate设置为data controller时执行。默认，data controller一次性的初始化和测量所有的items(步骤3)。具有layout delegate时可以使其他类自定义此行为，例如，ASCollectionLayout仅初始化和测量足够的cell填充可见口。当用户滚动时，将按需分配更多cell，为此，layout delegate可能需要构造一个上下文，该上下文必须在同一主线程runloop上发生，</li>
<li>在<code>_editingTransactionQueue</code>，分配和测量<code>pendingMap</code>的所有element，或者调用layout delegate让其决定。在此步骤结束时，element已经准备好被backing view使用</li>
<li>在block中计划执行下一步，通过<code>_mainSerialQueue</code>将其添加到主线程队列中。如果在此点之前还有其他尚未调度到队列的block被调度，执行步骤5</li>
<li>通知ASRangeController，colletionView的布局协调器，更重要的时，向collection发送有关更改集的信息。ASColelctionView调用其超类来执行批处理更新，在批处理中，pendingMap被更改为visibleMap。 UICollectionView要求将新数据集部署在-[UICollectionView performBatchUpdates：completion：]的更新块中。它还要求编辑操作必须按照特定的顺序进行，并由步骤1之前的更改集验证</li>
</ol>

<h2 id="toc_6">动画</h2>

<h2 id="toc_7">移动操作</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[官方文档]]></title>
    <link href="https://acefish.github.io/15718858302183.html"/>
    <updated>2019-10-24T10:57:10+08:00</updated>
    <id>https://acefish.github.io/15718858302183.html</id>
    <content type="html"><![CDATA[
<p><a href="https://github.com/mxcl/PromiseKit/blob/master/Documentation/GettingStarted.md">官方文档学习地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Layout Specs]]></title>
    <link href="https://acefish.github.io/15710248960458.html"/>
    <updated>2019-10-14T11:48:16+08:00</updated>
    <id>https://acefish.github.io/15710248960458.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Layout specs</h2>

<h3 id="toc_1">Layout flow</h3>

<p>Layout计算是 通过以下启动触发器来递归完成。一个layout布局完成的启动触发器就是 当父节点改变时。这触发器也在第一次node树被创建时发生。</p>

<p><code>ASDisplayNode</code>第一个重要分支是顶层的<code>[ASDisplayNode calculateLayoutThatFits]</code>，这个方法将会选择布局引擎是<code>Texture布局</code>还是<code>Yoga</code></p>

<pre><code class="language-objectivec">- (ASLayout *)calculateLayoutThatFits:(ASSizeRange)constrainedSize
{
  __ASDisplayNodeCheckForLayoutMethodOverrides;

  switch (self.layoutEngineType) {
    case ASLayoutEngineTypeLayoutSpec:
      return [self calculateLayoutLayoutSpec:constrainedSize];
#if YOGA
    case ASLayoutEngineTypeYoga:
      return [self calculateLayoutYoga:constrainedSize];
#endif
      // If YOGA is not defined but for some reason the layout type engine is Yoga
      // we explicitly fallthrough here
    default:
      break;
  }

  // If this case is reached a layout type engine was defined for a node that is currently
  // not supported.
  ASDisplayNodeAssert(NO, @&quot;No layout type determined&quot;);
  return nil;
}
</code></pre>

<p>基于UIKit系统，Texture在不同阶段遵循以下过程</p>

<ol>
<li>ASDisplayNode和ASLayout初始化。这是完全独立与UIKit存在。这是当一个布局计算创建时</li>
<li>UIView/CALayer初始化。遵循UIKit管理惯例，即在布局大小之前创建要显示的UIKit items。然而，它们是在UIKit层次，允许下列的布局触发器</li>
<li>UIView/CALayer布局。这是UIKit递归操作之后的结果。这和步骤1中的布局计算不同，这是仅仅为了使用已经准备好的布局，并且将其应用到UIView/CALayer中 进行布局调整</li>
<li>如有必要，在其中渲染CALayer的光栅化。UIKit可以将UIKit层次结构绘制到屏幕上</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node Lifecycle]]></title>
    <link href="https://acefish.github.io/15707800044047.html"/>
    <updated>2019-10-11T15:46:44+08:00</updated>
    <id>https://acefish.github.io/15707800044047.html</id>
    <content type="html"><![CDATA[
<p><code>Texture</code>使用ARC，因此对象不再有强引用时就会被dealloc。而对于ASDisplayNode和其子类来说，不同node有不同的生命周期，因此了解其生命周期以及 enter interface和loading state  是很有用的</p>

<h2 id="toc_0">node container 管理node</h2>

<p>node container负责它们管理的node的声明周期。一般来说，<code>node container</code>会在需要时尽快分配节点，并在不需要时释放它们。<code>Texture</code>假设<code>node container</code>完全管理其node，而客户端 不保留这些节点 和/或 修改其生命周期。例如，客户端不应该尝试存储由于<code>ASCollectionNode、ASPageNode或ASTableNode</code>初始化的<code>ASCellNode</code>实例</p>

<p><code>ASCollectionNode</code>和<code>ASTableNode</code>在将<code>ASCellNodes</code>添加到container node立即对其进行初始化，不论是通过reload data或者作为批处理的一部分更新。类似于<code>UICollectionView/UITableView</code>，第一次数据加载都是在没有先前数据集合的基础上重新加载数据。但是又与<code>UICollectionView/UITableView</code>不同，其cell在被显示之前会被重用和重新配置，而<code>ASCollectionNode和ASTableNode</code>不会重用<code>ASCellNode</code>。这就会导致结果，由collection和table管理的<code>ASCellNode</code>数量和截止到那时为止插入的items和rows相同</p>

<p>目前为止，ASCollectionNode和ASTableNode的当前实现会在插入所有cell后立即初始化它们。即，如果客户端执行100个items插入到collection node中的批处理更新，则该collection node将会初始化100个单元节点作为批处理更新的一部分。它还将在每个新的cell node上执行布局结算。因此，在该过程结束时，collection node将会管理100个节点，并且这些节点已经计算出可以使用的布局</p>

<p>由于上面所说的行为，ASCollection和ASTableNode可能需要一段时间才能处理插入大量items的批处理更新。在这种情况下，建议使用<code>node block</code>API，该API允许在主线程外并行初始化。如果仍然需要考虑性能，则使用批处理提取API拆分数据集，并在最终用户滚动时，逐渐向容器节点公开更多数据</p>

<h2 id="toc_1">ASCollectionLayout</h2>

<p>为了解决上面所说的处理大型数据集合的弊端，为<code>ASCollectionNode</code>引入了新的API，使其可以再用户滚动时，延迟初始化和布局cell node。但是，由于某些限制，此功能仅仅适用于知道每个cell node大小的colletion layout。例如，轮播图，分页布局等</p>

<h3 id="toc_2">ASCellNodes的 dealloction</h3>

<p>因为ASCellNode并未重用，因此与<code>UICollectionViewCell或UITableViewCell</code>相比，他们具有更长的生命周期。当不再使用ASCellNodes并将其从容器中删除时，将会释放。这可能发生在重新加载数据 或者 删除批处理数据更新之后，或者在node container不再使用而被释放。</p>

<p>对于后者node container不再被使用而被释放的情况，它们的单元节点不会立即释放。这是因为collection node和table nodes中可能持有大量的cell nodes，并且同时释放他们，这会导致明显的延迟。为了避免这种情况，使用了<code>ASDeallocQueue</code>帮助在后台线程释放。<br/>
由于<code>ASDataController</code>实例是所有单元节点的真正所有者–它对所有单元节点都有很强的引用.因此，所有这些单元节点也都从主线程中释放。因此，可以预期从释放集合或表视图开始，直到所有单元节点都完全释放并回收其内存为止的延迟。在调试内存泄漏时，请记住这一点，这一点很重要：DataController引用的对象可能需要一点时间才能被<code>Instruments</code>显示为已经dealloc。</p>

<h3 id="toc_3">ASDeallocQueue</h3>

<p><code>ASDeallocQueue</code>通过增加每个对象的引用计数（基本上保留它们并充当其唯一所有者）来帮助延迟分配给它的对象的重新分配，然后稍后在后台线程上释放它们</p>

<h2 id="toc_4">未被Container管理的Node</h2>

<p>这些节点通常由客户端代码直接创建，例如cell node的直接或间接子节点。因为node通常存在于视图结构层次中，整个node视图层次和root node有相同的生命周期。最后，如果root node由node container管理(直接被ASViewController管理，或者间接作为collection或者table的 cell node被管理)，则整个node 视图层次都由node  container管理</p>

<h3 id="toc_5">自动节点管理(ASM)下的声明周期</h3>

<p>ASM允许简单的返回包含给定时间父节点需要的子节点布局规范来操作节点的结构层次。纹理通过比较先前和当前的布局规范计算子节点的插入和删除，并更新节点层次。为了支持两个布局之间的动画，新的节点在动画之前就插入，为新来的动画做准备。新的节点在开始时就被父节点保留，而在动画结束后，删除旧的节点，如果旧节点没有被其他引用或者保留 将将被释放</p>

<h2 id="toc_6">node interface state</h2>

<p>在智能预加载的支持下，ASTableView和ASCollectionView都使用<code>ASRangeController</code>确定他们管理的每个ASCellNode的状态，并将该状态递归设置为层次结构中的每个节点</p>

<h2 id="toc_7">Node loading state</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程]]></title>
    <link href="https://acefish.github.io/15707737201639.html"/>
    <updated>2019-10-11T14:02:00+08:00</updated>
    <id>https://acefish.github.io/15707737201639.html</id>
    <content type="html"><![CDATA[
<p><code>Texture</code>是对资源的高效利用来给用户提供高帧速的体验。换言之，科学的在线程间分配工作，使默认的runLoop保持精简，实时允许用户的输入事件，并且消耗主队列上安排的工作</p>

<p>遵循以下规定：</p>

<ol>
<li>使用UIKit API必须通过<code>dispatch_get_main_queue()</code>或者使用<code>ASPerformBlockOnMainThread()</code>在主线程执行</li>
<li>一般来说 其它任何事情都应该在后台发生</li>
</ol>

<h2 id="toc_0">Run Loop、Threads and Queues</h2>

<h2 id="toc_1">ASMainSerialQueue</h2>

<p><code>ASMainSerialQueue</code>确保在不中断的情况下在主线程执行工作，其主要区别是，使用<code>dispatch_async(dispatch_get_main_queue, block)</code>会在块的执行之间中断。<br/>
因此接口将在主线程中的队列中执行所有可能操作，然后再将控制权转移给OS</p>

<p>此接口会调用<code>ASPerformBlockOnMainThread</code>。当其他线程pop block在主线程执行时，该接口就会锁定其他线程，确保其在主调度队列和runloop的其它循环之前</p>

<p>并且由于是同步机制，<code>ASMainSerialQueue</code>是串行的，因此可以确保按照顺序执行。一个示例是将以下块排队: 更改视图属性-&gt;触发布局更新-&gt;动画。 由于ASMainSerialQueue可能会较早执行，因此要比使用<code>dispatch_async（dispatch_get_main_queue（））</code>发送的块较早执行。</p>

<p>这实际上只是主调度队列的缓冲区，为计划工作提供了更多可见性。该接口确保计划的所有内容都将在主线程以同一操作顺兴进行</p>

<h3 id="toc_2">ASRunLoopQueue</h3>

<h3 id="toc_3">Locks and Safety</h3>

<h3 id="toc_4">线程竞争</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodes]]></title>
    <link href="https://acefish.github.io/15698393226216.html"/>
    <updated>2019-09-30T18:28:42+08:00</updated>
    <id>https://acefish.github.io/15698393226216.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ASDisplayNode</h2>

<p><code>ASDisplayNode</code>是UIView和CALayer的主要抽象。与UIView创建和持有<code>CALayer</code>相同，Node创建和持有UIView</p>

<pre><code class="language-objectivec">ASDisplayNode *node = [[ASDisplayNode alloc] init];
node.backgroundColor = [UIColor orangeColor];
node.bounds = CGRectMake(0, 0, 100, 100);
NSLog(@&quot;Underlying view: %@&quot;, node.view);
</code></pre>

<p>node拥有与<code>UIView</code>相同的所有属性，view和layer的所有属性都会映射到node，非常方便我们使用</p>

<pre><code class="language-objectivec">ASDisplayNode *node = [[ASDisplayNode alloc] init];
node.clipsToBounds = YES;       // not .masksToBounds
node.borderColor = [UIColor blueColor];  //layer name when there is no UIView equivalent
NSLog(@&quot;Backing layer: %@&quot;, node.layer);
</code></pre>

<p>当与node container一起使用时，node的属性将会在后台线程设置，</p>

<h3 id="toc_1">视图包装器</h3>

<p>有时，我们提供一个视图作为node的backing view。这个视图在block中提供，block中返回视图并进行保存。此时，这些node的展示会同步发生，因为只有node中的<code>_ASDisplayView</code>才会异步显示，在普通包装的UIView并不会异步显示</p>

<pre><code class="language-objectivec">ASDisplayNode *node = [ASDisplayNode alloc] initWithViewBlock:^{
    SomeView *view  = [[SomeView alloc] init];
    return view;
}];
</code></pre>

<p>我们通常使用这个方法将UIView的子类转换为<code>ASDisplayNode</code>子类，来包装现有视图</p>

<h2 id="toc_2">ASCellNode</h2>

<p>是Texture中的cell类，<code>ASCellNode</code>可以和<code>ASTableNodes</code>、<code>ASCollectionNodes</code>、<code>ASPageNodes</code>一起使用</p>

<h3 id="toc_3">使用cellNode的三种方式</h3>

<h4 id="toc_4">子类化</h4>

<p>与子类化<code>ASDisplayNode</code>几乎相同，需要使用以下方法:</p>

<ul>
<li>-init</li>
<li>-layoutSpecThatFits</li>
<li>-didLoad</li>
<li>-layout</li>
</ul>

<h4 id="toc_5">使用ASViewController初始化</h4>

<p>将视图控制器作为视图放入cell的scroll node或者page node</p>

<p>举个例子:<br/>
编写一个用于管理<code>ASTableNode</code>的视图控制器。将该表作为<code>ASPagenode</code>的页面，使用<code>initWithViewControllerBlock</code></p>

<pre><code class="language-objectivec">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index
{
    NSArray *animals = self.allAnimals[index];
    
    ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^UIViewController * _Nonnull{
        return [[AnimalTableNodeController alloc] initWithAnimals:animals];
    } didLoadBlock:nil];
    node.style.preferredSize = pagerNode.bounds.size;
    return node;
}
</code></pre>

<blockquote>
<p>注意</p>

<p>使用这个方式设置的node，需要设置其<code>.style.preferredSize</code>。</p>
</blockquote>

<h4 id="toc_6">使用UIView和CALayer初始化</h4>

<p>当如果有<code>UIView</code>或者<code>CALayer</code>子类 作为cell</p>

<pre><code class="language-objectivec">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(NSInteger)index
{
    NSArray *animal = self.animals[index];
    
    ASCellNode *node = [[ASCellNode alloc] initWithViewBlock:^UIView * _Nonnull{
        return [[SomeAnimalView alloc] initWithAnimal:animal];
    }];

    node.style.preferredSize = pagerNode.bounds.size;
    
    return node;
}
</code></pre>

<p>虽然可以这么做 但是推荐将现有的UIView类转为ASCellNode的子类 获取异步显示的优势</p>

<h3 id="toc_7">Never Show Placeholders</h3>

<p>通常，如果cell在其到达屏幕之前仍为display完成，将会显示占位符直到绘制内容完成</p>

<p>但是，当如果我们不想要看到placeholder内容，可以将其属性<code>neverShowPlaceholders</code>设置为<code>YES</code></p>

<pre><code class="language-objectivec">node.neverShowPlaceholders = YES;
</code></pre>

<p>将其设置为yes，则cell的主线程将会被阻塞，直到cell显示完成为止。</p>

<h4 id="toc_8">UITableViewCell的特殊属性</h4>

<p>在<code>ASCellNode</code>中也存在和<code>UITableViewCell</code>中的类似<code>selectionStyle、accessoryType和seperatorInset</code>等我们偶尔可能使用的属性</p>

<h2 id="toc_9">ASButtonNode</h2>

<p>类似UIButton继承自UIControl，而ASButtonNode也继承自<code>ASControlNode</code>。</p>

<h3 id="toc_10">control state</h3>

<pre><code class="language-objectivec">[buttonNode setTitle:@&quot;Button Title Normal&quot; withFont:nil withColor:[UIColor blueColor] forState:ASControlStateNormal];

//可以通过设置Attribute  设置更多自定义属性
[self.buttonNode setAttributedTitle:attributedTitle forState:ASControlStateNormal];
</code></pre>

<h3 id="toc_11">Target-Action</h3>

<pre><code class="language-objectivec">[buttonNode addTarget:self action:@selector(buttonPressed:) forControlEvents:ASControlNodeEventTouchUpInside];
</code></pre>

<h3 id="toc_12">Content Alignment</h3>

<p><code>ASButtonNode</code>提供了<code>contentVerticalAlignment和contentHorizontalAlignment</code>属性，可以轻松设置对齐方式</p>

<pre><code class="language-objectivec">self.buttonNode.contentVerticalAlignment = ASVerticalAlignmentTop;
self.buttonNode.contentHorizontalAlignment = ASHorizontalAlignmentMiddle;
</code></pre>

<h3 id="toc_13">注意</h3>

<h2 id="toc_14">ASTextNode</h2>

<p>Texture中的主要文本节点，通常在使用UILabel的情况下使用。拥有完整的富文本支持，并且继承自ASControlNode，</p>

<h3 id="toc_15">使用</h3>

<p>ASTextNode的接口对于使用UILabel的人来说非常熟悉，第一个不同的地方在于node仅使用attribute而不能使用纯文字字符</p>

<pre><code class="language-objectivec">NSDictionary *attrs = @{ NSFontAttributeName: [UIFont fontWithName:@&quot;HelveticaNeue&quot; size:12.0f] };
NSAttributedString *string = [[NSAttributedString alloc] initWithString:@&quot;Hey, here&#39;s some text.&quot; attributes:attrs];

_node = [[ASTextNode alloc] init];
_node.attributedText = string;
</code></pre>

<h3 id="toc_16">截断字符串</h3>

<p>当显示文本的空间小于要显示的文本必须空间，将会尽可能多的显示文本，并且所有被截断字符串将会被截断字符串替换。</p>

<pre><code class="language-objectivec">_textNode = [[ASTextNode alloc] init];
_textNode.attributedText = string;
_textNode.truncationAttributedText = [[NSAttributedString alloc]
</code></pre>

<p>默认情况下，截断字符串为<code>...</code></p>

<h3 id="toc_17">Link Attributes</h3>

<p>为了将文本指定为链接，需要将<code>linkAttribute</code>数组设置为字符串数组，将该数组用作属性字符串中链接的键。在设置attribute时，将这些键指向响应的NSURL</p>

<pre><code class="language-objectivec">_textNode.linkAttributeNames = @[ kLinkAttributeName ];

NSString *blurb = @&quot;kittens courtesy placekitten.com \U0001F638&quot;;
NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:blurb];
[string addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;HelveticaNeue-Light&quot; size:16.0f] range:NSMakeRange(0, blurb.length)];
[string addAttributes:@{
                      kLinkAttributeName: [NSURL URLWithString:@&quot;http://placekitten.com/&quot;],
                      NSForegroundColorAttributeName: [UIColor grayColor],
                      NSUnderlineStyleAttributeName: @(NSUnderlineStyleSingle | NSUnderlinePatternDot),
                      }
              range:[blurb rangeOfString:@&quot;placekitten.com&quot;]];
_textNode.attributedText = string;
_textNode.userInteractionEnabled = YES;
</code></pre>

<h3 id="toc_18">ASTextNodeDelegate</h3>

<p>实现<code>ASTextNodeDelegate</code>允许类对与文本相关联的各种事件做出反应</p>

<p>例如点击事件:</p>

<pre><code class="language-objectivec">- (void)textNode:(ASTextNode *)richTextNode tappedLinkAttribute:(NSString *)attribute value:(NSURL *)URL atPoint:(CGPoint)point textRange:(NSRange)textRange
{
  // the link was tapped, open it
  [[UIApplication sharedApplication] openURL:URL];
}
</code></pre>

<p>类似的:</p>

<pre><code class="language-objectivec">– textNode:longPressedLinkAttribute:value:atPoint:textRange:

– textNode:shouldHighlightLinkAttribute:value:atPoint:

– textNode:shouldLongPressLinkAttribute:value:atPoint:
</code></pre>

<h3 id="toc_19">具有行间距的文本导致不正确的最大行数</h3>

<p>当多行文本中使用<code>NSParagraphStyle</code>修改了非默认的<code>lineSpacing</code>，那么就会导致设置的最大行数不正确</p>

<pre><code class="language-objectivec">NSString *someLongString = @&quot;...&quot;;

NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
paragraphStyle.lineSpacing = 10.0;

UIFont *font = [UIFont fontWithName:@&quot;SomeFontName&quot; size:15];

NSDictionary *attributes = @{
    NSFontAttributeName : font,
    NSParagraphStyleAttributeName: paragraphStyle
};

ASTextNode *textNode = [[ASTextNode alloc] init];
textNode.maximumNumberOfLines = 4;
textNode.attributedText = [[NSAttributedString  alloc] initWithString:someLongString
</code></pre>

<p>为了暂时解决此问题 可以通过设置<code>truncationMode</code>为<code>NSLineBreakByTruncatingTail</code></p>

<pre><code class="language-objectivec">ASTextNode *textNode = [[ASTextNode alloc] init];
textNode.maximumNumberOfLines = 4;
textNode.truncationMode = NSLineBreakByTruncatingTail;
textNode.attributedText = [[NSAttributedString  alloc] initWithString:someLongString
</code></pre>

<h2 id="toc_20">ASImageNode</h2>

<p>等效于<code>UIImageView</code>。最基本的区别在于图像默认情况下是异步解码的。并且还有其他功能，例如支持GIF和<code>imageModificationBlocks</code></p>

<h3 id="toc_21">基础使用</h3>

<p>使用方式与imageView 基本相同</p>

<pre><code class="language-objectivec">ASImageNode *imageNode = [[ASImageNode alloc] init];
imageNode.image = [UIImage imageNamed:@&quot;someImage&quot;];
imageNode.contentMode = UIViewContentModeScaleAspectFill;
</code></pre>

<h3 id="toc_22">图像变换和效果</h3>

<p>通过为imageNode设置<code>imageModificationBlock</code>,可以定义需要在imagenode上设置的任何需要图像异步发生的转换，包括圆角、添加边框、覆盖花纹等</p>

<h3 id="toc_23">图像裁剪</h3>

<p>image的默认mode为<code>UIViewContentModeScaleAspectFill</code>，图片将会放大填充内容区域，并且裁剪掉超出的内容部分。</p>

<p>我们可以通过设置<code>cropRect</code>来移动图片，其为单元矩阵，默认值为(0.5,0.5,0,0)，要显示左侧内容，可将其x设置为0，以为这图片原点从{0, 0}开始，而非默认值</p>

<h3 id="toc_24">强制放大</h3>

<p>默认情况下，图像过小而无法放入已设置的imageNode的边界时，将不会在CPU上放大图像。</p>

<p>如果您想更改此事实，可以将forceUpscaling设置为YES。这样做意味着您每次使用小于目标位置的图像时，您的应用程序都会占用更多内存</p>

<h3 id="toc_25">检测图像缩放</h3>

<p>通过使用<code>pixel scaling tool</code>可以方便的查看图片放大或者缩小了多少</p>

<h2 id="toc_26">ASNetworkImageNode</h2>

<p>当需要显示远程的图像时，可以使用<code>ASNetworkImageNode</code>,需要做的就是将.URL属性设置为合适的NSURL实例，图像将会异步加载并呈现</p>

<pre><code class="language-objectivec">ASNetworkImageNode *imageNode = [[ASNetworkImageNode alloc] init];
imageNode.URL = [NSURL URLWithString:@&quot;https://someurl.com/image_uri&quot;];
</code></pre>

<h3 id="toc_27">Network Image 布局</h3>

<p>因为<code>ASNetworkImageNode</code>并未限制内容大小，因此必须指定layout的大小</p>

<ol>
<li>style.preferredSize</li>
</ol>

<p>当我们想要使用标准尺寸时</p>

<pre><code class="language-objectivec">- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constraint
{
    imageNode.style.preferredSize = CGSizeMake(100, 200);
    ...
    return finalLayoutSpec;
}
</code></pre>

<ol>
<li>ASRatioLayoutSpec</li>
</ol>

<p>使用<code>ASRatioLayoutSpec</code>为图像分配一个比例，当图像加载完成后 将会保持该比例</p>

<pre><code class="language-objectivec">- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constraint
{
    CGFloat ratio = 3.0/1.0;
    ASRatioLayoutSpec *imageRatioSpec = [ASRatioLayoutSpec ratioLayoutSpecWithRatio:ratio child:self.imageNode];
    ...
    return finalLayoutSpec;
}
</code></pre>

<h3 id="toc_28">引擎组件</h3>

<p>如果选择没有包括<code>PINRemoteImage</code>和<code>PINCache</code>，那么将失去对<code>jpeg</code>的渐进支持，并且需要自定义实现<code>ASImageCacheProtocol</code>的缓存</p>

<h3 id="toc_29">渐进式JPEG支持</h3>

<p>由于包含了<code>PINRemoteImage</code>，NetworkImageNode现在支持加载渐进式的JPEG。意味着，如果服务器提供了这种jpeg，则图像会将以较低的质量快速显示，并且随着加载更多的数据而扩大</p>

<p>启用渐进加载只需要设置<code>shouldRenderProgressImages</code>为<code>YES</code></p>

<pre><code class="language-objectivec">networkImageNode.shouldRenderProgressImages = YES;
</code></pre>

<blockquote>
<p>注意</p>

<p>这种方式是使用一张逐渐加载的图像。如果服务器只能使用常规的JPEG，但是可以提供多个版本来提高质量，那么应该使用<code>ASMultiplexImageNode</code></p>
</blockquote>

<h3 id="toc_30">自动缓存</h3>

<p>使用<code>PINCache</code>自动缓存网络图像</p>

<h3 id="toc_31">GIF支持</h3>

<p>ASNetworkImageNode通过PINRemoteImage的beta版PINAnimatedImage提供GIF支持。注意！除非shouldCacheImage设置为NO，否则该支持将不适用于本地文件。</p>

<h2 id="toc_32">ASVideoNode</h2>

<p>方便我们在app中展示视频</p>

<blockquote>
<p>使用<code>ASVideoNode</code>就会连接<code>AVFoundation</code>，因为在内部底层中使用了<code>AVPlayerLayer</code>和<code>AVFoundataion</code></p>
</blockquote>

<h3 id="toc_33">基础使用</h3>

<p>最简单的方式就是设置一个<code>AVAsset</code>资源</p>

<pre><code class="language-objectivec">ASVideoNode *videoNode = [[ASVideoNode alloc] init];

AVAsset *asset = [AVAsset assetWithURL:[NSURL URLWithString:@&quot;http://www.w3schools.com/html/mov_bbb.mp4&quot;]];
videoNode.asset = asset;
</code></pre>

<h3 id="toc_34">自动播放、自动重复、自动静音</h3>

<p>通过一些简单的BOOL属性，设置视频播放</p>

<pre><code class="language-objectivec">//进入可见范围后自动播放
videoNode.shouldAutoplay = YES;
//视频无限循环播放
videoNode.shouldAutorepeat = NO;
//将静音设置为YES 将会关闭视频声音
videoNode.muted = YES;
</code></pre>

<h3 id="toc_35">占位图像</h3>

<p>因为video node继承自<code>ASNetworkImageNode</code>，因此可以使用<code>URL</code>属性设置其占位图像。加入决定不这么做，则视频的第一针将会自动解码并作为占位图像</p>

<h3 id="toc_36">ASVideoNode Delegate</h3>

<p>有很多delegate可以对视频事件作出响应，</p>

<p>例如,当播放状态改变时:</p>

<pre><code class="language-objectivec">- (void)videoNode:(ASVideoNode *)videoNode willChangePlayerState:(ASVideoNodePlayerState)state toState:(ASVideoNodePlayerState)toState;
</code></pre>

<h2 id="toc_37">ASMapNode</h2>

<p>帮助显示用户地离区域</p>

<h3 id="toc_38">基础使用</h3>

<p>只需要输入要显示位置的坐标即可</p>

<pre><code class="language-objectivec">ASMapNode *mapNode = [[ASMapNode alloc] init];
mapNode.style.preferredSize = CGSizeMake(300.0, 300.0);

// San Francisco
CLLocationCoordinate2D coord = CLLocationCoordinate2DMake(37.7749, -122.4194);

// show 20,000 square meters
mapNode.region = MKCoordinateRegionMakeWithDistance(coord, 20000, 20000);
</code></pre>

<h3 id="toc_39">MKMapSnapshotOptions</h3>

<p>可以通过option属性 定义<code>node</code>的主要组件部分</p>

<ul>
<li>MKMapCamera:  相机的高度和仰角</li>
<li>MKMapRect：CGRect</li>
<li>MKMapRegion：控制焦点的坐标 以及 焦点周围的大小和显示</li>
<li>MKMapType：设置为Standard、Satellite(卫星)等</li>
</ul>

<pre><code class="language-objectivec">MKMapSnapshotOptions *options = [[MKMapSnapshotOptions alloc] init];
options.mapType = MKMapTypeSatellite;
options.region = MKCoordinateRegionMakeWithDistance(coord, 20000, 20000);
mapNode.options = options;
</code></pre>

<h3 id="toc_40">标记</h3>

<p>设置标记，要做的就是为<code>ASMapNode</code>分配标记数组</p>

<pre><code class="language-objectivec">//在地图中间直接显示图钉标记
MKPointAnnotation *annotation = [[MKPointAnnotation alloc] init];
annotation.coordinate = CLLocationCoordinate2DMake(37.7749, -122.4194);

mapNode.annotations = @[annotation];
</code></pre>

<h3 id="toc_41">实时地图</h3>

<p>将map node从静态的地图转换为可交互的<br/>
<code>mapNode.liveMap = YES;</code></p>

<p>与UIKit视图一样，实时模式下的MKMapView并不是线程安全的</p>

<h3 id="toc_42">MKMapView Delegate</h3>

<pre><code class="language-text">如果启用了实时地图模式，并且您需要对与地图节点关联的任何事件做出反应，则可以设置mapDelegate属性。该代理应该实现MKMapViewDelegate协议。
</code></pre>

<h2 id="toc_43">ASControlNode</h2>

<p>ASControlNode与UIControl等效。我们不会直接创建实例，可以子类化其作为自己的控件。<code>ASTextNode、ASImageNode、ASVideoNode、ASMapNode</code>都是ASControlNode的子类</p>

<p>这意味着我们可以将任何文本或者图像作为按钮，而不必像UIKIt中依赖于手势识别器，或使用UIBUtton</p>

<h3 id="toc_44">Control state</h3>

<pre><code class="language-objectivec">typedef NS_OPTIONS(NSUInteger, ASControlState) {
    ASControlStateNormal       = 0,
    ASControlStateHighlighted  = 1 &lt;&lt; 0,  // used when isHighlighted is set
    ASControlStateDisabled     = 1 &lt;&lt; 1,
    ASControlStateSelected     = 1 &lt;&lt; 2,  // used when isSelected is set
    ...
};
</code></pre>

<h3 id="toc_45">Target-Action 机制</h3>

<p>类似UIControl  ASControlNode中也有一系列事件</p>

<pre><code class="language-objectivec">typedef NS_OPTIONS(NSUInteger, ASControlNodeEvent)
{
  /** A touch-down event in the control node. */
  ASControlNodeEventTouchDown         = 1 &lt;&lt; 0,
  /** A repeated touch-down event in the control node; for this event the value of the UITouch tapCount method is greater than one. */
  ASControlNodeEventTouchDownRepeat   = 1 &lt;&lt; 1,
  /** An event where a finger is dragged inside the bounds of the control node. */
  ASControlNodeEventTouchDragInside   = 1 &lt;&lt; 2,
  /** An event where a finger is dragged just outside the bounds of the control. */
  ASControlNodeEventTouchDragOutside  = 1 &lt;&lt; 3,
  /** A touch-up event in the control node where the finger is inside the bounds of the node. */
  ASControlNodeEventTouchUpInside     = 1 &lt;&lt; 4,
  /** A touch-up event in the control node where the finger is outside the bounds of the node. */
  ASControlNodeEventTouchUpOutside    = 1 &lt;&lt; 5,
  /** A system event canceling the current touches for the control node. */
  ASControlNodeEventTouchCancel       = 1 &lt;&lt; 6,
  /** All events, including system events. */
  ASControlNodeEventAllEvents         = 0xFFFFFFFF
};
</code></pre>

<h3 id="toc_46">Hit Test Slop</h3>

<p>尽管所有的node均有<code>hitTestSlop</code>属性，但是在control node中最常用</p>

<pre><code class="language-objectivec">CGFloat horizontalDiff = (bounds.size.width - _playButton.bounds.size.width)/2;
CGFloat verticalDiff = (bounds.size.height - _playButton.bounds.size.height)/2;

_playButton.hitTestSlop = UIEdgeInsetsMake(-verticalDiff, -horizontalDiff, -verticalDiff, -horizontalDiff);

</code></pre>

<h3 id="toc_47">Hit Test Visualization</h3>

<h2 id="toc_48">ASScrollNode</h2>

<p>ASScrollNode是一个<code>ASDisplayNode</code>,其底层是一个<code>UIScrollView</code>.其可以自动采用ASLayoutSpec的大小作为可滚动的contentSize</p>

<h3 id="toc_49">自动管理contentSize</h3>

<p>启用后，由ASSCrollNode布局规范计算的大小将定义滚动视图的<code>.contentSize</code>。在此模式下，滚动视图的边界会填充父级尺寸</p>

<p><code>AutomaticManagesContentSize</code>对于实现了<code>layoutSpecThatFits</code>的ASScrollNode子类很有用，也适用设置了<code>.layoutSpecBlock</code>基类。这两种情况下都通常适用<code>.automaticallyManagesSubnodes</code>属性，以便将layout spec中的node自动添加到可滚动区域</p>

<p>适用这种方法无需捕获布局大小，使用绝对布局规范作为包装器或在代码任何位置设置contentSize，都将会将layout布局更新。通常我们将返回<code>ASStackLayoutSpec</code>，可滚动区域将允许查看所有内容</p>

<h3 id="toc_50">滚动方向</h3>

<p>当使用<code>automaticallyManagersContentSize</code>时，特别因为默认是垂直而你想要水平方向时，这个属性是很有用的</p>

<p>这个属性控制了调整内容大小时的<code>constrainedSize</code></p>

<ul>
<li>Vertical：constrainedSize的.height是为无限制的(<code>CGFLOAT_MAX</code>)</li>
<li>Horizontal：</li>
<li>Vertical&amp;Horizontal：</li>
</ul>

<h2 id="toc_51">ASEditableTextNode</h2>

<p><code>ASEditableTextNode</code>通常在所有使用<code>UITextView</code>或者<code>UITextField</code>的地方使用。</p>

<p>在后台 使用了专门的UITextView作为其底层视图。当在主线程上操作时，你都可以直接访问和操作该视图</p>

<h3 id="toc_52">基础使用</h3>

<p>如果要默认情况下有文本，则可以将属性字符串分配给<code>attributedText</code>属性</p>

<pre><code class="language-objectivec">ASEditableTextNode *editableTextNode = [[ASEditableTextNode alloc] init];
editableTextNode.attributedText = [[NSAttributedString alloc] initWithString:@&quot;Lorem ipsum dolor sit amet.&quot;];
editableTextNode.textContainerInset = UIEdgeInsetsMake(8, 8, 8, 8);
</code></pre>

<h3 id="toc_53">Placeholder Text</h3>

<p>如果要显示占位符 只需要设置<code>attributedPlaceholderText</code>属性</p>

<pre><code class="language-objectivec">editableTextNode.attributedPlaceholderText = [[NSAttributedString alloc] initWithString:@&quot;Type something here...&quot;];
</code></pre>

<p>属性<code>isDisplayingPlaceholder</code>最初为YES，当输入文本设置为非空字符串时，又将切换为NO</p>

<h3 id="toc_54">Typing Attributes</h3>

<p>如果要修改用户将在在这text field中输入文字的style，可以设置<code>typingAttributes</code>属性</p>

<pre><code class="language-objectivec">editableTextNode.typingAttributes = @{NSForegroundColorAttributeName: [UIColor blueColor], 
                                      NSBackgroundColorAttributeName: [UIColor redColor]};
</code></pre>

<h3 id="toc_55">ASEditableTextNode Delegate</h3>

<p>可以使用一下delegate方法 来实现响应关联事件</p>

<pre><code class="language-objectivec">//
- (void)editableTextNodeDidBeginEditing:(ASEditableTextNode *)editableTextNode;

- (BOOL)editableTextNode:(ASEditableTextNode *)editableTextNode shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;

- (void)editableTextNodeDidChangeSelection:(ASEditableTextNode *)editableTextNode fromSelectedRange:(NSRange)fromSelectedRange toSelectedRange:(NSRange)toSelectedRange dueToEditing:(BOOL)dueToEditing;

- (void)editableTextNodeDidUpdateText:(ASEditableTextNode *)editableTextNode;
- 
- (void)editableTextNodeDidFinishEditing:(ASEditableTextNode *)editableTextNode;

</code></pre>

<h2 id="toc_56">ASMultiplexImageNode</h2>

]]></content>
  </entry>
  
</feed>
