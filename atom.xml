<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2020-02-28T00:56:02+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[git-lfs  playEngine]]></title>
    <link href="https://acefish.github.io/15950550096662.html"/>
    <updated>2020-07-18T14:50:09+08:00</updated>
    <id>https://acefish.github.io/15950550096662.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[develop pod]]></title>
    <link href="https://acefish.github.io/15950537874191.html"/>
    <updated>2020-07-18T14:29:47+08:00</updated>
    <id>https://acefish.github.io/15950537874191.html</id>
    <content type="html"><![CDATA[
<p>参考资料：<br/>
<a href="https://juejin.im/post/59f2c7eaf265da432c2318e5">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git submodule]]></title>
    <link href="https://acefish.github.io/15950434740712.html"/>
    <updated>2020-07-18T11:37:54+08:00</updated>
    <id>https://acefish.github.io/15950434740712.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15939325635012.html"/>
    <updated>2020-07-05T15:02:43+08:00</updated>
    <id>https://acefish.github.io/15939325635012.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[检测内存泄漏]]></title>
    <link href="https://acefish.github.io/15929893587832.html"/>
    <updated>2020-06-24T17:02:38+08:00</updated>
    <id>https://acefish.github.io/15929893587832.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Instruments - Leaks</h2>

<h2 id="toc_1">MLeaksFinder</h2>

<p>通过在 VC 被 pop 或 dismiss 时检测其自身及其子视图是否正确释放来实现</p>

<h2 id="toc_2">PLeakSniffer</h2>

<p>在 VC 释放后利用心跳机制来推测子视图是否被正常释放</p>

<h2 id="toc_3">使用符号断点识别</h2>

<p>通过添加对<code>[UIViewController dealloc]</code>方法添加符号断点，并针对该断点增加声音和log提示，这样当控制器销毁时可以听到提示音，如果没有听到的话 就意味着发生了泄漏</p>

<p><img src="media/15929893587832/15929922382570.jpg" alt="" style="width:1058px;"/></p>

<p><img src="media/15929893587832/15929922292498.png" alt="" style="width:451px;"/></p>

<p>设置提示因为pop提示音 并自动跳过断点</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocopods 提供Mater Repo CDN]]></title>
    <link href="https://acefish.github.io/15923801503172.html"/>
    <updated>2020-06-17T15:49:10+08:00</updated>
    <id>https://acefish.github.io/15923801503172.html</id>
    <content type="html"><![CDATA[
<p>在1.7.2版本中 添加了CDN <br/>
可以参考 <a href="https://blog.cocoapods.org/CocoaPods-1.7.2/">CocoaPods 1.7.2 — Master Repo CDN is Finalized!</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nvm node和Npm关系]]></title>
    <link href="https://acefish.github.io/15923637835016.html"/>
    <updated>2020-06-17T11:16:23+08:00</updated>
    <id>https://acefish.github.io/15923637835016.html</id>
    <content type="html"><![CDATA[
<p>node: 即为node.js是能在服务端运行的JS开放源码、跨平台的js运行环境</p>

<p>nvm: 是nodejs的版本管理工具 用于处理不同项目的不同node</p>

<p>npm: nodejs的包管理工具   当在安装node时  npm也会一起安装，用于管理nodejs中的第三方插件。类似Ruby中的bundler，对第三放依赖进行管理</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby和其生态链]]></title>
    <link href="https://acefish.github.io/15922151492984.html"/>
    <updated>2020-06-15T17:59:09+08:00</updated>
    <id>https://acefish.github.io/15922151492984.html</id>
    <content type="html"><![CDATA[
<p>Cocopods 思想其实借鉴了其他语言的PM工具 例如: <code>RubyGems</code> <code>Bundler</code> <code>npm</code> <code>Gradle</code></p>

<p>Cocopods 通过Ruby语言实现的，本身就是一个Gem包 </p>

<h2 id="toc_0">Ruby和其生态链</h2>

<p>参考链接 <a href="https://mp.weixin.qq.com/s/s2yJEb2P0_Kk-rIpYBi_9A">版本管理工具及 Ruby 工具链环境</a></p>

<p><code>RVM</code>和<code>rbenv</code>都是管理多个Ruby环境的工具 提供不同版本的Ruby环境管理的切换</p>

<h3 id="toc_1">RubyGems</h3>

<p><code>RubyGems</code>是Ruby的一个包管理工具 管理着用Ruby写的工具或者依赖，我们称之为<code>Gem</code></p>

<p><code>RubyGems</code>还提供了 Ruby 组件的托管服务，可以集中式的查找和安装<code>library</code>和<code>apps</code>，当我们使用<code>gem install xxx</code>会通过<code>rubygems.org</code>来查询对应的gem packetge。而我们iOS的日常中很多工具都是通过Gem提供的，如：<code>Bundler、fastlane、jazzy、CocoaPods</code>等</p>

<h4 id="toc_2">Bundler</h4>

<p>但是在默认情况下，Gems总是下载library的最新版本，无法达到我们的预期，我们<br/>
<strong>通过<code>Bundler</code>来管理Gem依赖，来隔离不同项目中的Gem版本和依赖环境的差异，其也是一个Gem</strong></p>

<p>通过读取项目中的依赖描述文件<code>Gemfile</code>，来确定各个Gems的版本号或者范围，提供了稳定的应用环境。使用<code>bundle install</code>将具体版本号写入<code>Gemfile.lock</code></p>

<h5 id="toc_3">Gemfile</h5>

<p>Bundler 依据项目中的 Gemfile 文件来管理 Gem</p>

<blockquote>
<p>CocoaPod 类似 iOS版的<code>RubyGems+Bundler</code>组合 <br/>
Bundler在一个Gem中依赖的其他Gem的版本<br/>
CocoaPod在一个iOS项目中管理其依赖的其他项目(Pod)的版本</p>
</blockquote>

<h3 id="toc_4">搭建一套合理的Ruby工具链</h3>

<p><img src="media/15922151492984/15923967991310.jpg" alt="" style="width:647px;"/></p>

<ol>
<li>使用 homebrew 安装 rbenv</li>
<li>使用 rbenv 管理 Ruby 版本</li>
<li>查询系统级 Gem 依赖<br/>
使用<code>gem list</code>查看当前环境下的所有Gem依赖</li>
</ol>

<h3 id="toc_5">使用Bundle来管理项目中的Gem依赖</h3>

<p>使用Bundle来锁定项目的Gem环境，来让团队统一Gem中的所有Ruby工具版本。避免文件冲突和不必要的错误</p>

<p>在项目中增加一个<code>Gemfile</code>文件 锁定当前项目的环境依赖</p>

<ol>
<li>初始化bundle环境<br/>
其实就是使用<code>bundle init</code>命令初始化一个gemfile文件</li>
<li><p>在 Gemfile  中声明使用的 CocoaPods 版本并安装</p>
<p>在Gemfile中使用DSL编写以下内容</p>
<pre><code class="language-objectivec">source &quot;https://rubygems.org&quot;
git_source(:github) {|repo_name| &quot;https://github.com/#{repo_name}&quot; }<br/>
# gem &quot;rails&quot;<br/>
gem &quot;cocoapods&quot;, &quot;1.5.3&quot;
</code></pre>
<p>然后使用<code>bundle install</code>进行安装，则指定cocopd版本安装成功 并且还保存了一份<code>Gemfile.lock</code>文件锁存依赖结果</p></li>
<li><p>使用当前环境的CocoaPods版本操作iOS工程</p>
<p>检查当前环境下的gem列表<br/>
    <code>bundle exec gem list</code> 当前环境的Gem列表</p>
<p>使用<code>bundle exec pod install</code>就可以使用<code>CocoaPods 1.5.3</code>的版本来执行install的pod操作</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15889382774457.html"/>
    <updated>2020-05-08T19:44:37+08:00</updated>
    <id>https://acefish.github.io/15889382774457.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSUserDefault]]></title>
    <link href="https://acefish.github.io/15889378272019.html"/>
    <updated>2020-05-08T19:37:07+08:00</updated>
    <id>https://acefish.github.io/15889378272019.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">SuitName</h2>

<pre><code class="language-objectivec">- (nullable instancetype)initWithSuiteName:(nullable NSString *)suitename NS_AVAILABLE(10_9, 7_0) NS_DESIGNATED_INITIALIZER;
</code></pre>

<p>在跨app间通信或者主App和Extension共享数据时,都会用到，一般配合AppGroup进行使用</p>

<p>此时两个App或者App和Extension需要加到同一个Group，然后分别调用</p>

<pre><code class="language-objectivec">- (NSUserDefaults *)userDefaults
{
    return [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.urwork.autosignin&quot;];   //name需要是Group的id
}
</code></pre>

<p>即可实现数据共享</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS模拟器上测试push]]></title>
    <link href="https://acefish.github.io/15882114916148.html"/>
    <updated>2020-04-30T09:51:31+08:00</updated>
    <id>https://acefish.github.io/15882114916148.html</id>
    <content type="html"><![CDATA[
<p>Xcode 11.4通过新家的<code>simctl</code>命令来使我们可以在模拟器上测试推送</p>

<h2 id="toc_0">启用推送权限</h2>

<p>首先需要确保已经有了在iOS模拟器上接收通知的权限</p>

<pre><code class="language-objectivec"> let center = UNUserNotificationCenter.current()
    center.requestAuthorization(options: [.alert, .sound]) { granted, error in
    // If `granted` is `true`, you&#39;re good to go!
}
</code></pre>

<blockquote>
<p>这只是普通的通知权限</p>
</blockquote>

<h2 id="toc_1">从终端向iOS模拟器发送通知</h2>

<p>最简单的测试通知的方法是使用<code>Poes</code>  它适合一个简单地命令行工具，在新的<code>simctl push</code>命令做了一层封装</p>

<p>使用Mint命令进行安装</p>

<pre><code class="language-objectivec">mint install AvdLee/Poes
</code></pre>

<p>在安装成功后，就可以简单使用以下方法发送通知</p>

<pre><code class="language-objectivec">$ poes send --bundle-identifier com.wetransfer.app --verbose
Generated payload:

{
  &quot;aps&quot; : {
    &quot;alert&quot; : {
      &quot;title&quot; : &quot;Default title&quot;,
      &quot;body&quot; : &quot;Default body&quot;
    },
    &quot;mutable-content&quot; : false
  }
}

Sending push notification...
Push notification sent successfully
</code></pre>

<p>这避免了创建Json文件的麻烦，并允许在测试app的推送通知时 快速进行迭代<br/>
<code>Poes</code>使用<code>xcrun simctl push</code>命令，并添加一层封装 可以根据参数正确生成Json文件</p>

<p>为了理解Poes到底做了什么 我们使用没有Poes情况下测试通知</p>

<h4 id="toc_2">使用Xcode命令行工具 从终端上使用模拟器</h4>

<p>Xcode command-line工具 允许从终端使用模拟器。可以启动模拟器、触发universal link等。 其中就有允许将推送发到iOS模拟器</p>

<pre><code class="language-objectivec">$ xcrun simctl push --help
Send a simulated push notification
Usage: simctl push &lt;device&gt; [&lt;bundle identifier&gt;] (&lt;json file&gt; | -)

    bundle identifier
         The bundle identifier of the target application
         If the payload file contains a &#39;Simulator Target Bundle&#39; top-level key this parameter may be omitted.
         If both are provided this argument will override the value from the payload.
    json file
         Path to a JSON payload or &#39;-&#39; to read from stdin. The payload must:
           - Contain an object at the top level.
           - Contain an &#39;aps&#39; key with valid Apple Push Notification values.
           - Be 4096 bytes or less.

Only application remote push notifications are supported. VoIP, Complication, File Provider, and other types are not supported.
</code></pre>

<p>可以看到需要以下参数</p>

<ul>
<li>device<br/>
将其设置为<code>booted</code>可以使用已经打开的模拟器<br/>
当然也可以使用<code>xcrun simctl list devices | grep Booted</code>命令获取设备的标识符</li>
<li>bundle identifier<br/>
设置为要测试推送通知的应用程序的标识符</li>
<li>json file<br/>
指向包含推送详细信息的Json文件  你也可以使用stdin提供JSON内容</li>
</ul>

<p>例如</p>

<pre><code class="language-perl">$ xcrun simctl push booted com.wetransfer.app payload.json 
Notification sent to &#39;com.wetransfer.app&#39;
</code></pre>

<p>其JSON文件内容为</p>

<pre><code class="language-javascript">{
    &quot;aps&quot;: {
        &quot;alert&quot;: {
            &quot;body&quot;: &quot;Gerard added something new - take a look&quot;,
            &quot;title&quot;: &quot;Photos&quot;
        }
    }
}
</code></pre>

<blockquote>
<p>可以在Apple的官方文档中<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html">Creating the Remote Notification Payload.</a>详细了解JSON文件的所有可能内容和结构</p>
</blockquote>

<h4 id="toc_3">使用APNS文件测试push notifications</h4>

<p>在iOS模拟器上测试推送通知的另一种方法是将APNS文件拖到iOS模拟器中。<br/>
其中APNS文件和上面的JSON文件几乎相同 但是添加了<code>Simulator Target Bundle</code>键 描述了要使用的包标识符</p>

<pre><code class="language-javascript">{
    &quot;Simulator Target Bundle&quot;: &quot;com.wetransfer.app&quot;,
    &quot;aps&quot;: {
        &quot;alert&quot;: {
            &quot;body&quot;: &quot;Gerard added something new - take a look&quot;,
            &quot;title&quot;: &quot;Photos&quot;
        }
    }
}
</code></pre>

<h5 id="toc_4">将APNS文件添加到共享库中</h5>

<p>可以通过将APNS文件添加到存储库中 使用同事可以测试应用程序的常见推送通知。您可以为每种通知类型保存配置。</p>

<h2 id="toc_5">总结</h2>

<p>目前测试通知很容易 </p>

<ul>
<li>使用Poes命令行工具轻松生成JSON有效负载</li>
<li>引用本地JSON有效负载文件</li>
<li>将APNS文件拖到模拟器中</li>
</ul>

<p><code>Poes</code>能够很简单快速的测试<br/>
而将APNS文件添加到您的存储库后，可以轻松地遍历应用程序的常见推送通知。</p>

<blockquote>
<p>通过学习<a href="https://www.avanderlee.com/category/workflow/"> workflow category page</a>来提升workflow</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IGListKit]]></title>
    <link href="https://acefish.github.io/15856524375795.html"/>
    <updated>2020-03-31T19:00:37+08:00</updated>
    <id>https://acefish.github.io/15856524375795.html</id>
    <content type="html"><![CDATA[
<p>本文学习自<a href="https://www.raywenderlich.com/9106-iglistkit-tutorial-better-uicollectionviews">IGListKit Tutorial: Better UICollectionViews</a></p>

<p>IGListKit是一个数据驱动<code>UICollectionView</code>框架，使用此框架提供对象数组显示在UICollectionView中。对于每种类型的对象，<code>Adapter</code>创建<code>Section controller</code>，其中包含创建cell的所有详细信息</p>

<p><img src="media/15856524375795/15933307105471.png" alt="" style="width:487px;"/><br/>
<code>IGListKit</code>会自动比较对象数据，并在其发生变化时执行<code>UICollectionView</code>的更新动画，而不需要自己实现<code>batch updating</code></p>

<h2 id="toc_0">使用IGListKit</h2>

<h4 id="toc_1">1.视图</h4>

<p>在<code>IGListKit</code>中，仍然使用UICollectionView以及<code>UICollectionViewFlowLayout</code>来初始化列表容器</p>

<h4 id="toc_2">2. 数据源</h4>

<p>在UICollectionView，通过<code>UICollectionViewDataSource</code>代理提供数据源<br/>
在IGListKit中，使用<code>ListAdapter</code>控制colletionView，实现<code>ListAdapterDataSource</code>协议作为数据源，此时不是提供cell以及的数量，而是返回一组<code>section controllers</code></p>

<pre><code class="language-swift">lazy var adapter: ListAdapter = {
  return ListAdapter(
  updater: ListAdapterUpdater(),
  viewController: self, 
  workingRangeSize: 0)
}()
</code></pre>

<ul>
<li>updater： 继承自ListUpdatingDelegate协议，处理row和section的更新。<code>ListAdapterUpdater</code>提供了一个默认的实现</li>
<li>viewController： 容纳adapter的控制器</li>
<li>workingRangeSize: 工作范围size。使用这个参数允许为可见范围外的section准备内容</li>
</ul>

<pre><code class="language-swift">adapter.collectionView = collectionView
adapter.dataSource = self
</code></pre>

<p>将adapter和collectionView绑定，并设置数据源datasource为self,因此需要继承实现<code>ListAdapterDataSource</code>协议</p>

<pre><code class="language-swift">objects(for:) // 返回要在collectionView上展示的一组数据

listAdapter(_:sectionControllerFor:) //为每个数据对象 返回一份section controller.

emptyView(for:) //当list是空的时候 展示的视图
</code></pre>

<h4 id="toc_3">Section Controller</h4>

<p><code>Section Controller</code>是一种抽象，用于给定数据对象，配置和控制collectionView的section中的cells。类似于针对View的View-Model<br/>
因此，为了区分不同类型的数据和行为，需要创建新的<code>SectionController</code></p>

<pre><code class="language-objectivec">class JournalSectionController: ListSectionController {
    override func numberOfItems() -&gt; Int {
        return 2
    }
    
    override func sizeForItem(at index: Int) -&gt; CGSize {
        .zero
    }
    
    override func cellForItem(at index: Int) -&gt; UICollectionViewCell {
        let cell = collectionContext?.dequeueReusableCell(of: cellClass, for: self, at: index)
        return cell
    }
    
    override func didUpdate(to object: Any) {
        entry = object as? JournalEntry
    }
    
    override func didSelectItem(at index: Int) {
  collectionContext?.performBatch(animated: true, updates: { batchContext in
    self.expanded.toggle()
    batchContext.reload(self)
  }, completion: nil)
}
}
</code></pre>

<p><code>didUpdate(to object: Any)</code>： IGListKit在将对象交给section controller之前调用。该方法在所有所有其他协议方法之前调用，可以用来保存传递进来的对象</p>

<p><code>cellForItem(at index: Int)</code>类似collectionView中的cellForItem，在其中复用cell</p>

<p><code>ListCollectionContext</code>：是带有adapter信息的上下文对象，collectionView和ViewController信息</p>

<p><code>didSelectItem:</code> 当进行点击事件时调用该方法</p>

<p><code>performBatch(animated:updates:completion:)</code>在一个<code>transaction</code>中执行批量更新，可以无论在何时当该sectionController中cell的内容或者数量改变时，调用其进行更新。</p>

<h4 id="toc_4">更新</h4>

<p>也可以通过adaper进行更新</p>

<pre><code class="language-swift">adapter.performUpdates(animated: true, completion: nil)
</code></pre>

<p>通过该方法使<code>ListAdapter</code>使其datasource更新数据源，询问新的对象。来更新、移动、插入对象</p>

<h2 id="toc_5">参考资料</h2>

<p><a href="https://www.jianshu.com/p/3517619085f7">https://www.jianshu.com/p/3517619085f7</a></p>

<p><a href="https://instagram.github.io/IGListKit/getting-started.html">https://instagram.github.io/IGListKit/getting-started.html</a></p>

<p><a href="https://juejin.im/entry/5bee4514e51d4556a633c6c9">https://juejin.im/entry/5bee4514e51d4556a633c6c9</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[状态管理]]></title>
    <link href="https://acefish.github.io/15844345314401.html"/>
    <updated>2020-03-17T16:42:11+08:00</updated>
    <id>https://acefish.github.io/15844345314401.html</id>
    <content type="html"><![CDATA[
<ul>
<li>如果状态是用户数据，如复选框的状态、滑块的位置、则该状态最好由父<code>Widget</code>管理</li>
<li>如果状态有关界面外观效果的，例如颜色、动画，则状态最好由Widget本身来管理</li>
<li>如果状态是不同Widget共享的，则最好由共同的父Widget管理</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异步]]></title>
    <link href="https://acefish.github.io/15833936883449.html"/>
    <updated>2020-03-05T15:34:48+08:00</updated>
    <id>https://acefish.github.io/15833936883449.html</id>
    <content type="html"><![CDATA[
<p>Dart中返回<code>Future</code>和<code>stream</code>对象的函数，即为异步函数<br/>
<code>async</code>和<code>await</code>关键字支持异步编程，这让我们能够写出和同步代码很像的异步代码</p>

<h2 id="toc_0">Future</h2>

<p><code>Future</code>和js中的<code>Promise</code>很像,表示一个异步操作的最终完成以及其结果的表示。</p>

<blockquote>
<p><code>Future</code>的所有API的返回仍是一个<code>Future</code>对象，所以很方便进行链式调用</p>
</blockquote>

<h4 id="toc_1">Future.then</h4>

<p>在<code>then</code>中接收异步结果 </p>

<pre><code class="language-dart">Future.delayed(new Duration(seconds: 2),(){
   return &quot;hi world!&quot;;
}).then((data){
   print(data);
});
</code></pre>

<h4 id="toc_2">Future.catchError</h4>

<p>如果发生异步错误 可以再<code>catchError</code>中捕获错误</p>

<pre><code class="language-dart">Future.delayed(new Duration(seconds: 2),(){
   //return &quot;hi world!&quot;;
   throw AssertionError(&quot;Error&quot;);  
}).then((data){
   //执行成功会走到这里  
   print(&quot;success&quot;);
}).catchError((e){
   //执行失败会走到这里  
   print(e);
});
</code></pre>

<p>不只是<code>catchError</code>回调才能捕获错误，then还有可选参数<code>onError</code>可以使用其捕获异常</p>

<pre><code class="language-dart">Future.delayed(new Duration(seconds: 2), () {
    //return &quot;hi world!&quot;;
    throw AssertionError(&quot;Error&quot;);
}).then((data) {
    print(&quot;success&quot;);
}, onError: (e) {
    print(e);
});
</code></pre>

<h4 id="toc_3">Future.whenComplete</h4>

<p>在异步任务无论失败或者成功都要回调</p>

<pre><code class="language-dart">Future.delayed(new Duration(seconds: 2),(){
   //return &quot;hi world!&quot;;
   throw AssertionError(&quot;Error&quot;);
}).then((data){
   //执行成功会走到这里 
   print(data);
}).catchError((e){
   //执行失败会走到这里   
   print(e);
}).whenComplete((){
   //无论成功或失败都会走到这里
});
</code></pre>

<h4 id="toc_4">Future.wait</h4>

<p>等待多个异步任务结束,</p>

<pre><code class="language-dart">Future.wait([
  // 2秒后返回结果  
  Future.delayed(new Duration(seconds: 2), () {
    return &quot;hello&quot;;
  }),
  // 4秒后返回结果  
  Future.delayed(new Duration(seconds: 4), () {
    return &quot; world&quot;;
  })
]).then((results){
//都成功触发then回调
  print(results[0]+results[1]);
}).catchError((e){
//有一个失败 就触发错误回调
  print(e);
});
</code></pre>

<h2 id="toc_5">Async/await</h2>

<p>用法与<code>js</code>中的<code>Async/await</code>中一样</p>

<h4 id="toc_6">用于消除<code>回调地狱</code></h4>

<p>虽然可以用<code>Future</code>来避免回调地狱 但是还是有一层回调的</p>

<pre><code class="language-dart">task() async {
   try{
    String id = await login(&quot;alice&quot;,&quot;******&quot;);
    String userInfo = await getUserInfo(id);
    await saveUserInfo(userInfo);
    //执行接下来的操作   
   } catch(e){
    //错误处理   
    print(e);   
   }  
}
</code></pre>

<ul>
<li><code>async</code>表示这是一个异步函数 函数返回一个Future对象， </li>
<li><code>await</code>后面是一个<code>Future</code>函数  表示等待该异步函数执行完成</li>
</ul>

<blockquote>
<p>其实无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。</p>
</blockquote>

<h2 id="toc_7">Stream</h2>

<p><code>Stream</code>也是用于接收异步事件数据，和<code>Future</code>不同的是，它可以接收多个异步操作的结果（成功或失败.即可以多次触发成功或者失败事件来传递结果数据或错误异常，常用于多次读取数据的异步场景任务</p>

<pre><code class="language-dart">Stream.fromFutures([
  // 1秒后返回结果
  Future.delayed(new Duration(seconds: 1), () {
    return &quot;hello 1&quot;;
  }),
  // 抛出一个异常
  Future.delayed(new Duration(seconds: 2),(){
    throw AssertionError(&quot;Error&quot;);
  }),
  // 3秒后返回结果
  Future.delayed(new Duration(seconds: 3), () {
    return &quot;hello 3&quot;;
  })
]).listen((data){
   print(data);
}, onError: (e){
   print(e.message);
},onDone: (){

});
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数]]></title>
    <link href="https://acefish.github.io/15833905857830.html"/>
    <updated>2020-03-05T14:43:05+08:00</updated>
    <id>https://acefish.github.io/15833905857830.html</id>
    <content type="html"><![CDATA[
<p><code>Dart</code>中的函数也是对象，并且有<code>Function</code>类型，意味着可以赋值给变量或者作为参数传递给其它函数</p>

<ol>
<li><p>函数声明</p>
<p><code>Dart</code>函数声明如果没有显示声明返回值类型会默认当做<code>dynamic</code>处理,注意，并没有返回类型推断</p></li>
<li><p>对于只包含一个表达式的函数，可以使用简写</p>
<pre><code class="language-objectivec">bool isNoble (int atomicNumber)=&gt; _nobleGases [ atomicNumber ] ！= null ;
</code></pre></li>
<li><p>函数作为变量</p>
<pre><code class="language-dart">var say = (str){
  print(str);<br/>
};<br/>
say(&quot;hi world&quot;);
</code></pre></li>
<li><p>函数作为参数</p>
<pre><code class="language-dart">void execute(var callback) {
    callback();<br/>
}<br/>
execute(() =&gt; print(&quot;xxx&quot;))
</code></pre></li>
<li><p>可选的位置参数<br/>
使用<code>[]</code>包装一组函数参数，标记为可选的位置参数，并放在参数列表的最后</p>
<pre><code class="language-dart">String say(String from, String msg, [String device]) {
  var result = &#39;$from says $msg&#39;;<br/>
  if (device != null) {<br/>
    result = &#39;$result with a $device&#39;;<br/>
  }<br/>
  return result;<br/>
}
</code></pre></li>
<li><p>可选的命名参数<br/>
使用<code>{param1, param2}</code>放在参数列表最后，用于指定命名参数</p>
<pre><code class="language-dart">//设置[bold]和[hidden]标志
void enableFlags({bool bold, bool hidden}) {<br/>
    // ... <br/>
}
</code></pre>
<blockquote>
<p>不能同时使用可选位置参数和命名参数</p>
</blockquote></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[变量声明]]></title>
    <link href="https://acefish.github.io/15833390987258.html"/>
    <updated>2020-03-05T00:24:58+08:00</updated>
    <id>https://acefish.github.io/15833390987258.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">var</h4>

<p>类似JS中的var,可以接收任何类型变量，但是Dart中的var变量一旦赋值，类型就会确定，且不能再改变其类型,因为Dart是强类型语言</p>

<h4 id="toc_1">dynamic和Object</h4>

<p><code>Object</code>是Dart中所有对象的根基类，即所有类型都是<code>Object</code>的子类(包括Function和Null)，所以任何类型数据都可以赋值给Object声明的对象。<br/>
<code>dynamic</code>和var一样是声明关键词，声明的变量可以赋值任何对象。<br/>
两者相同之处在于，声明的变量可以在后期改变赋值类型<br/>
不同之处在于，<code>dynamic</code>声明的对象编译器会提供所有可能的组合，而<code>Object</code>声明的对象只能使用Object的属性和方法，否则编译器会报错</p>

<pre><code class="language-dart">dynamic a;
 Object b;
 main() {
     a = &quot;&quot;;
     b = &quot;&quot;;
     printLengths();
 }   

 printLengths() {
     // no warning
     print(a.length);
     // warning:
     // The getter &#39;length&#39; is not defined for the class &#39;Object&#39;
     print(b.length);
 }
</code></pre>

<blockquote>
<p>dynamic的这个特性与Objective-C中的id作用很像,因此在使用时注意不要引入运行时错误</p>
</blockquote>

<h4 id="toc_2">final和const</h4>

<p>如果打算不更改某个对象，<br/>
<code>final</code>变量只能被设置一次，<br/>
<code>const</code>变量是一个编译时常量，final变量在第一次使用时被初始化<br/>
被<code>final</code>和<code>const</code>修饰的变量 ，变量类型可以省略</p>

<pre><code class="language-dart">//可以省略String这个类型声明
final str = &quot;hi world&quot;;
//final String str = &quot;hi world&quot;; 
const str1 = &quot;hi world&quot;;
//const String str1 = &quot;hi world&quot;;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter 中 State]]></title>
    <link href="https://acefish.github.io/15833390543109.html"/>
    <updated>2020-03-05T00:24:14+08:00</updated>
    <id>https://acefish.github.io/15833390543109.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">state生命周期</h2>

<p>示例代码如下:</p>

<pre><code class="language-dart">class _CounterWidgetState extends State&lt;CounterWidget&gt; {  
  int _counter;

  @override
  void initState() {
    super.initState();
    //初始化状态  
    _counter=widget.initValue;
    print(&quot;initState&quot;);
  }

  @override
  Widget build(BuildContext context) {
    print(&quot;build&quot;);
    return Scaffold(
      body: Center(
        child: FlatButton(
          child: Text(&#39;$_counter&#39;),
          //点击后计数器自增
          onPressed:()=&gt;setState(()=&gt; ++_counter,
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(CounterWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    print(&quot;didUpdateWidget&quot;);
  }

  @override
  void deactivate() {
    super.deactivate();
    print(&quot;deactive&quot;);
  }

  @override
  void dispose() {
    super.dispose();
    print(&quot;dispose&quot;);
  }

  @override
  void reassemble() {
    super.reassemble();
    print(&quot;reassemble&quot;);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print(&quot;didChangeDependencies&quot;);
  }

}
</code></pre>

<p>当我们创建一个路由，该路由中只有<code>CounterWidget</code>wiget</p>

<pre><code class="language-dart">Widget build(BuildContext context) {
  return CounterWidget();
}
</code></pre>

<p>此时我们运行应用打开路由界面，会log</p>

<pre><code class="language-dart">I/flutter ( 5436): initState
I/flutter ( 5436): didChangeDependencies
I/flutter ( 5436): build
</code></pre>

<p><mark>将statefulWeight插入widget树时，首先会调用<code>initState</code>方法</mark></p>

<p>当点击热重载按钮时</p>

<pre><code class="language-dart">I/flutter ( 5436): reassemble
I/flutter ( 5436): didUpdateWidget
I/flutter ( 5436): build
</code></pre>

<p><mark>热重载时，<code>didUpdateWidget</code>被调用</mark></p>

<p>当将<code>CounnterWidget</code>移除，将build方法更改</p>

<pre><code class="language-dart">Widget build(BuildContext context) {
  //移除计数器 
  //return CounterWidget();
  //随便返回一个Text()
  return Text(&quot;xxx&quot;);
}
</code></pre>

<p>此时热重载</p>

<pre><code class="language-dart">I/flutter ( 5436): reassemble
I/flutter ( 5436): deactive
I/flutter ( 5436): dispose
</code></pre>

<p><mark>当移除时，调用<code>deactive</code>和<code>dispose</code>方法</mark></p>

<ul>
<li><code>initState():</code>当<code>Widget</code>第一次插入到树中会被调用，对于每个State对象只会调用一次该回调，因此通常在其中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该方法中调用<code>BuildContext.inheritFromWidgetOfExactType</code>(该方法用于在Widget树中获取离当前widget最近的父级<code>InheritFromWidget</code>)，原因是在初始化完成后，widget树中的InheritFromWidget可能也会发生变化，所以应该在build()方法或者<code>didChangeDependencies()</code>中调用它</li>
<li><code>didChangeDependencies()</code>:当State对象的依赖发生变化时被调用；例如，之前<code>build()</code>中包含一个<code>InheritedWidget</code>，之后build()中<code>InheritdWidget</code>发生变化，此时<code>InheritedWidget</code>的子widget的<code>didChangeDependencies()</code>回调都会被调用。典型场景是当系统语言Locale或应用主题改变时，<code>Flutter framework</code>会通知widget调用此回调</li>
<li><code>build()</code>：主要用于构建Widget子树，在一下场景被调用
<ul>
<li>在<code>initState()</code>之后</li>
<li>在<code>didUpdateWidget()</code>之后</li>
<li>调用<code>setState()</code>后</li>
<li>调用<code>didChangeDependencies()</code>后</li>
<li>在State对象从树中的一个位置移除后(此时调用<code>deactive</code>)，又重新插入到其它位置之后</li>
</ul></li>
<li><code>reassemble()</code>:回调专门为开发调试提供，在热重载时被调用，在release模式下永远不会被调用</li>
<li><code>didUpdateWidget()</code>:在widget重新构建时，调用<code>Widget.canUpdate</code>检测Widget树中同一位置的新旧节点，决定是否需要更新，如果返回<code>true</code>调用此回调。其<code>Widget.canUpdate</code>会在新旧widget的key和runtimeType同时相等时返回true，</li>
<li><code>deactivate()</code>:当State从树中移除，会调用此回调。在一些场景下，<code>Flutter framework</code>会将<code>State</code>对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。</li>
<li><code>dispose()</code>：当<code>State</code>对象从树中永久移除时调用；通常在此回调中释放资源</li>
</ul>

<p><img src="media/15833390543109/15843498134277.jpg" alt="" style="width:770px;"/></p>

<blockquote>
<p>注意：在继承StatefulWidget重写其方法时，对于包含<code>@mustCallSuper</code>标注的父类方法，都要在子类方法中先调用父类方法。</p>
</blockquote>

<h2 id="toc_1">在Widget树中获取State对象</h2>

<p>有时，需要获取StatefulWidget对应的State对象来调用一些方法，例如通过<code>Scaffold</code>组件对象的状态类<code>ScaffoldState</code>可以打开<code>SnackBar</code>。存在两种可以在子widget中获取父<code>StatefuleWidget</code>的State对象</p>

<h3 id="toc_2">通过Context获取</h3>

<p><code>context</code>对象有一个<code>ancestorStateOfType(TypeMatcher)</code>方法，可以再当前节点沿着widget树向上查找指定类型的StateWidget对应的State对象</p>

<pre><code class="language-dart">Scaffold(
  appBar: AppBar(
    title: Text(&quot;子树中获取State对象&quot;),
  ),
  body: Center(
    child: Builder(builder: (context) {
      return RaisedButton(
        onPressed: () {
          // 查找父级最近的Scaffold对应的ScaffoldState对象
          ScaffoldState _state = context.ancestorStateOfType(
              TypeMatcher&lt;ScaffoldState&gt;());
          //调用ScaffoldState的showSnackBar来弹出SnackBar
          _state.showSnackBar(
            SnackBar(
              content: Text(&quot;我是SnackBar&quot;),
            ),
          );
        },
        child: Text(&quot;显示SnackBar&quot;),
      );
    }),
  ),
);
</code></pre>

<p>一般来说，如果<code>StatefulWidget</code>状态是私有的，不应该直接去获取其State对象。但是通过<code>context.ancestorStateOfType</code>获取获取statefulWidget 的状态方法是通用的，并不能在语法层面指定其状态是否私有<br/>
因此，在Flutter中有一个默认的约定：</p>

<ul>
<li>如果其状态是希望暴露的，则应该在<code>statefulWidget</code>中提供一个<code>of</code>静态方法来获取其state对象，可以直接通过此方法来获取.(这个约定在Flutter的SDK中也是随处可见的)</li>
</ul>

<pre><code class="language-dart">ScaffoldState _state=Scaffold.of(context); 
_state.showSnackBar(
  SnackBar(
    content: Text(&quot;我是SnackBar&quot;),
  ),
);
</code></pre>

<h3 id="toc_3">GlobalKey</h3>

<ol>
<li><p>给目标<code>StatefulWidget</code>添加<code>GlobalKey</code></p>
<pre><code class="language-dart">//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储
static GlobalKey&lt;ScaffoldState&gt; _globalKey= GlobalKey();<br/>
...<br/>
Scaffold(<br/>
    key: _globalKey , //设置key<br/>
    ...  <br/>
)
</code></pre></li>
<li><p>通过<code>GlobalKey</code>获取</p>
<pre><code class="language-dart">_globalKey.currentState.openDrawer()
</code></pre></li>
</ol>

<p><code>globalKey</code>是在整个APP引用element的机制，如果widget设置了<code>GlobalKey</code>，可以通过<code>glovalKey.currentWidget</code>获取该widget对象，<code>globalKey.currentElement</code>获得widget对应element对象，如果widget是<code>StatefulWidget</code>，可以通过<code>globalKey.currentState</code>获得widget对应的state对象</p>

<blockquote>
<p>使用<code>GlobalKey</code>开销就很大，应该尽量避免使用<br/>
同一和<code>GlobalKey</code>在整个widget树中必须是唯一的不能重复</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类簇]]></title>
    <link href="https://acefish.github.io/15828224173019.html"/>
    <updated>2020-02-28T00:53:37+08:00</updated>
    <id>https://acefish.github.io/15828224173019.html</id>
    <content type="html"><![CDATA[
<p><code>类簇</code>是Foundation框架中广泛使用的设计模式。将一些私有、具体的子类组合在一个公共的、抽象的超类下面，以这种方法来组织类可以简化一个面向对象框架的公开架构，而又不减少功能的丰富性。<br/>
类簇是属于工厂设计模式的</p>

<h2 id="toc_0">举例应用</h2>

<p>OC中的Number 可以表示很多类型的数值对象。其其实是一个抽象的基类，声明的方法一般都是操作其子类。 因为不同的数值类型可能有很多特征(可以从一个类型转换为另外一个类型，例如，可以描述其为字符串)，所以在Number类里有很多方法可以用来描述这些特征，但是他们因为是不同类型，其存储的需求一定是不同的，所以Number类中并不声明实例变量去存储数值，在子类中声明这样的实例变量并在Number的API中获得<br/>
<img src="media/15828224173019/15829916208263.jpg" alt="" style="width:396px;"/></p>

<p>我们一般通过一下方法</p>

<pre><code class="language-objectivec">NSNumber *aChar = [NSNumber numberWithChar:’a’];
NSNumber *anInt = [NSNumber numberWithInt:1];
NSNumber *aDouble = [NSNumber numberWithDouble:1.0];
</code></pre>

<p>其实生成的每个对象都属于不同的子类，虽然每个对象的类成员是隐藏的，但是抽象基类声明的接口是公共的。</p>

<h3 id="toc_1">常见公共基类类簇</h3>

<p><img src="media/15828224173019/15829929365031.jpg" alt="" style="width:285px;"/><br/>
也存在两个抽象公共类为类簇声明接口，但他们明确说明了两个点如何协作，其中一个公共的点声明所有类簇中对象都能响应的方法，另一点声明方法仅适合类簇对象内容能被修改的。</p>

<h2 id="toc_2">类簇的子类</h2>

<p>如果发现类簇并没有提供你的问题的方法，这是可能需要一个子类。</p>

<ul>
<li>需要创建一个文件存储而不是内存存储的数组对象，，就像要改变NSArray类簇的底层存储机制，那么必须创建一个子类</li>
<li>假设app需要在修改一些数据时提醒，此时没创建一个简单的类，将一个数据对象的基础框架定义。这个类的对象可以介入消息修改数据，拦截信息，代理，然后转发给嵌入式数据对象</li>
</ul>

<p>总之，如果需要管理对象的存储就创建一个真正的子类。否则创建一个复合对象，一个标准的基础框架对象嵌在你自己的设计的一个对象。</p>

<h4 id="toc_3">创建类簇的子类</h4>

<p>创建类簇的子类需要：</p>

<ol>
<li>继承类簇的虚基类</li>
<li>定义自己的存储</li>
<li>重写父类的初始化方法</li>
<li>重写父类的原始方法</li>
</ol>

<p>因为类簇的虚基类在类簇中仅有的公共访问点，所以只能继承虚基类，因此虽然可以继承其接口但是不能继承其实例变量，子类必须声明自己需要的实例变量，而且必须重写继承所有的方法，来访问对象的实例变量。这些方法叫做<mark>基元方法</mark></p>

<p>一个类的基元方法来自接口的底层。<br/>
例如，<code>NSArray</code>通过两个基元方法<code>count:和objectAtIndex:</code>存储数据并且通过下标访问，作为基础其它导出方法可以实现。<br/>
因此，必须确保重写继承的基元方法，来去保证其它继承的所有派生方法可以正常运转，即使我们没有重写其它方法</p>

<p>子类应该声明其<code>init、 +className</code>方法(如果其有实例变量的话)，应该在自己的初始化方法中调用基类的指定初始化器。应该重写所有的其它继承的初始化方法并且实现，使其有合理的行为方法，</p>

<h4 id="toc_4">组合类</h4>

<p>通过在自己设计的对象中植入类簇对象。创建一个组合复合对象。可以依靠类簇对象的功能，来截取复合对象要处理的消息。</p>

<p><img src="media/15828224173019/15831375615521.jpg" alt="" style="width:709px;"/></p>

<p>复合对象继承自类簇的虚基类，作为子类，必须重写基类的基元方法，也可以重写导出方法(非必须).</p>

<p>示例:<br/>
测试验证对数组中对象的修改 保证其有效性</p>

<pre><code class="language-objectivec">@interface ValidatingArray : NSMutableArray

{
    NSMutableArray *embeddedArray;
}

+ (instancetype)validatingArray;

- (instancetype)init;

- (NSUInteger)count;

- (id)objectAtIndex:(NSUInteger)index;

- (void)addObject:(id)anObject;

- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject;

- (void)removeLastObject;

- (void)removeObjectAtIndex:(NSUInteger)index;

- (void)insertObject:(id)anObject atIndex:(NSUInteger)index;

@end


#import &quot;ValidatingArray.h&quot;

@implementation ValidatingArray

+ (instancetype)validatingArray {
    return [[self alloc] init];
}

- (instancetype)init {
    if (self = [super init]) {
        embeddedArray = [NSMutableArray array];
    }
    return self;
}

- (NSUInteger)count {
    return embeddedArray.count;
}

- (id)objectAtIndex:(NSUInteger)index {
    return [embeddedArray objectAtIndex:index];
}

- (void)addObject:(id)anObject {
    // 自定义验证代码
    [embeddedArray addObject:anObject];
}

- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject {
    // 自定义验证
    [embeddedArray replaceObjectAtIndex:index withObject:anObject];
}

- (void)removeLastObject {
    // 自定义验证
    [embeddedArray removeLastObject];
}

- (void)removeObjectAtIndex:(NSUInteger)index {
    // 自定义验证
    [embeddedArray removeObjectAtIndex:index];
}

- (void)insertObject:(id)anObject atIndex:(NSUInteger)index {
    // 自定义验证
    [embeddedArray insertObject:anObject atIndex:index];
}

@end

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件响应链]]></title>
    <link href="https://acefish.github.io/15823466354492.html"/>
    <updated>2020-02-22T12:43:55+08:00</updated>
    <id>https://acefish.github.io/15823466354492.html</id>
    <content type="html"><![CDATA[
<p>参阅<a href="https://www.jianshu.com/p/b0884faae603">iOS事件处理，看我就够了~</a><br/>
参阅<a href="https://www.jianshu.com/p/c294d1bd963d">iOS触摸事件全家桶</a><br/>
参阅<a href="https://www.jianshu.com/p/df86508e2811">iOS 事件</a></p>

<h2 id="toc_0">触摸事件生成(触摸 &amp;&amp; 事件)</h2>

<h3 id="toc_1">UITouch</h3>

<ul>
<li>一个手指一次触摸屏幕，就对应生成一个UITouch对象。多个手指同时触摸屏幕，生成多个UITouch对象。</li>
<li>多个手指先后触摸，系统会根据触摸的位置判断是否更新同一个UITouch对象。若两个手指一前一后触摸同一个位置(即双击)，那么第一次触摸时生成一个UITouch对象，第二次触摸会更新这个UITouch对象，这是该UITouch对象的Tap Count属性值从1变成2，若两个手指一前一后触摸的位置不同，将会生成两个UITouch对象，两者之间没有联系</li>
<li>每个UITouch对象记录了触摸的一些信息，包括触摸时间、位置、阶段、所处的视图、窗口等信息。</li>
</ul>

<pre><code class="language-objectivec">// 触摸的各个阶段状态 
// 例如当手指移动时，会更新phase属性到UITouchPhaseMoved；
// 手指离屏后，更新到UITouchPhaseEnded
typedef NS_ENUM(NSInteger, UITouchPhase) {
    UITouchPhaseBegan,             // whenever a finger touches the surface.
    UITouchPhaseMoved,             // whenever a finger moves on the surface.
    UITouchPhaseStationary,        // whenever a finger is touching the surface but hasn&#39;t moved since the previous event.
    UITouchPhaseEnded,             // whenever a finger leaves the surface.
    UITouchPhaseCancelled,         // whenever a touch doesn&#39;t end but we need to stop tracking (e.g. putting device to face)
};
</code></pre>

<h3 id="toc_2">UIEvent</h3>

<p>触摸事件：<br/>
触摸的目的是生成触摸事件供响应者，一个触摸事件对应一个UIEvent对象，</p>

<p>UIEvent对象中的type属性标识了事件的类型</p>

<pre><code class="language-objectivec">typedef NS_ENUM(NSInteger, UIEventType) {
    UIEventTypeTouches, //touch事件
    UIEventTypeMotion, //运动事件
    UIEventTypeRemoteControl, //远程事件
    UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0), //按压事件
};
</code></pre>

<p>UIEvent对象中包含了触发该对象的触摸对象集合</p>

<pre><code class="language-objectivec">@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
</code></pre>

<h3 id="toc_3">UIResponder</h3>

<p><code>UIResponder</code>是iOS中用于处理事件的API，不仅用于接收事件，还可以处理对应事件，如果当前响应者不能处理，就转发给其他响应者</p>

<p><code>UIResponder</code>类中包含了<code>touchesBegan</code>、<code>pressesBegan</code>、<code>motionBegan</code>、<code>remoteControlReceivedWithEvent</code>等方法，可以通过这些方法获取对应回调消息。</p>

<p>应用程序通过响应者来接收和处理事件，响应者可以是继承自<code>UIResponder</code>的任何子类，例如<code>UIView、UIViewController、UIApplication</code>等。当事件到来之际，系统会将事件传递给合适响应者，并成为<code>第一响应者</code>。如果<code>第一响应者</code>未处理事件，就会在响应者链中传递，其规则由<code>UIResponder</code>的<code>nextResponder</code>决定，可以通过重写该属性决定传递规则。当事件到来时，第一响应者没有接收消息，就顺着响应者链向后传递</p>

<h2 id="toc_4">Hit-Test 寻找第一响应者</h2>

<p>当点击屏幕上的view时，UIKit会打包一个<code>UIEvent</code>对象，将其分发给正在活跃的app，放在当前<code>Application</code>维护的事件队列中<br/>
此时app的<code>UIApplication</code>单例对象就会从事件队列中获取最新的事件，然后分发给能处理该事件的对象。此时app的任务就是获取能够响应该事件的UIView了 这就是通过<code>HitTest</code>的作用了</p>

<h3 id="toc_5">Hit-Test</h3>

<p><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</code> <br/>
<code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</code>//判断点击区域是否在视图上，是则返回YES，不是返回NO</p>

<p><code>hitTest:withEvent:</code>方法内部会调用<code>pointInSide:withEvent:</code>方法，</p>

<p>具体流程：</p>

<ul>
<li><code>UIApplication</code>将事件传递给窗口对象<code>UIWindow</code>，优先询问后显示的窗口</li>
<li>如果<code>Window</code>不能响应事件，将事件传递给其它窗口；若窗口能响应事件，则<mark>从后向前</mark>(添加视图的逆序)询问窗口的子视图</li>
<li>类推，如果视图不响应事件，将其传递给同级的上一个视图，如果能响应，就遍历其子视图</li>
<li>如果其子视图都不能响应，则当前视图就是最合适的响应者</li>
</ul>

<p><code>hitTest:withEvent:</code>返回一个UIView对象,作为当前视图层次中的响应者。</p>

<p>其可能的实现为下：</p>

<pre><code class="language-objectivec">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    //3种状态无法响应事件
     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; 
    //触摸点若不在当前视图上则无法响应事件
    if ([self pointInside:point withEvent:event] == NO) return nil; 
    //从后往前遍历子视图数组 
    int count = (int)self.subviews.count; 
    for (int i = count - 1; i &gt;= 0; i--) 
    { 
        // 获取子视图
        UIView *childView = self.subviews[i]; 
        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标
        CGPoint childP = [self convertPoint:point toView:childView]; 
        //询问子视图层级中的最佳响应视图
        UIView *fitView = [childView hitTest:childP withEvent:event]; 
        if (fitView) 
        {
            //如果子视图中有更合适的就返回
            return fitView; 
        }
    } 
    //没有在子视图中找到更合适的响应视图，那么自身就是最合适的
    return self;
}
</code></pre>

<blockquote>
<p>注意：在log事件调用时，其视图hitTest和pointInSide方法会按照顺序调用两次</p>
</blockquote>

<h4 id="toc_6">视图无法响应事件的条件：</h4>

<ol>
<li>UIView的几种无法响应事件：
<ul>
<li>不允许交互：<code>userInteractionEnabled = NO</code></li>
<li>隐藏： <code>hidden = YES</code> 如果父视图隐藏 则子视图一会隐藏</li>
<li>透明度： alpha&lt;0.01  视图在0~0.01之间为透明  也会影响子视图透明度</li>
</ul></li>
<li>通过<code>pointInSide</code>的判断</li>
</ol>

<h2 id="toc_7">事件传递</h2>

<p>经过hit-test过程  UIApplication已经知道<code>第一响应者</code>，接下来</p>

<ul>
<li>将事件传递给第一响应者</li>
<li>将事件沿着响应链传递</li>
</ul>

<p><code>UIApplication</code>通过<code>sendEvent:</code>传递给事件所属window，然后window在通过<code>snedEvent:</code>将事件传递给<code>hit-tested View</code>即第一响应者</p>

<pre><code class="language-objectivec">//UIWindow
- (void)sendEvent:(UIEvent *)event;                    // called by UIApplication to dispatch events to views inside the window
</code></pre>

<p>通过在touchBegan的断点可以看到调用栈<br/>
<img src="media/15823466354492/15825512400627.jpg" alt="" style="width:625px;"/><br/>
其中window将UIEvent对象直接发送给对应hit-test View</p>

<blockquote>
<p>这是因为在hit-test过程时 将对应信息(对应的window和view)已经存入了UIEvent中的UITouch对象中</p>

<pre><code class="language-objectivec">//UITouch 的属性
@property(nullable,nonatomic,readonly,strong) UIWindow                        *window;
@property(nullable,nonatomic,readonly,strong) UIView                          *view;
</code></pre>
</blockquote>

<h3 id="toc_8">事件沿着响应链传递</h3>

<p>因为每个响应者一定是<code>UIRsponder</code>对象，其继承了4个响应触摸方法</p>

<pre><code class="language-objectivec">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches API_AVAILABLE(ios(9.1));
</code></pre>

<p>默认不做任何处理 只是将事件沿着<code>响应链</code>(不是父类)传递<br/>
<code>第一响应者</code>首先收到触摸事件，具有对触摸事件处理权，可以自己对其进行处理(通过重写该方法)，也可以将事件沿着响应链传递给<code>下个响应者</code>，这个由<code>响应者</code>之间构成的<code>视图链</code>就称为<code>响应链</code>(因此响应的过程为自上向下的)</p>

<p>响应者对事件处理：<br/>
<mark>响应者对事件的拦截和传递都是通过<code>touchesBegan:withEvent:</code>方法控制的，即只有能执行到该方法,才能有可能获取其它3个触摸事件方法</mark></p>

<ul>
<li>不拦截,即不重写该方法，默认沿着响应链传递 </li>
<li>拦截， 重写<code>touchesBegan:withEvent:</code>，并不将事件向下传递</li>
<li>拦截，重写<code>touchesBegan:withEvent:</code>， 但再方法内部执行<code>[super touchesBegan:withEvent:]</code> 将方法向下传递</li>
</ul>

<h4 id="toc_9">传递规则</h4>

<p>每个<code>UIResponder</code>都有下一个<code>nextResponder</code>，获取响应链中的下个响应者</p>

<p>如下图所示，因为响应链上的前两个响应者未响应<code>began</code>方法，因此默认调用<code>[UIResponder touchesBegan:withEvent:]</code>方法，方法内部调用<code>[super touchesBegan:withEvent:]</code>则执行<code>fowardTouchMethod</code><br/>
<img src="media/15823466354492/15825536407581.jpg" alt="" style="width:830px;"/></p>

<ul>
<li>UIView<br/>
若视图是控制器的根视图，则其nextResponder为控制器对象；否则，其nextResponder为父视图。</li>
<li>UIViewController<br/>
若控制器的视图是window的根视图，则其nextResponder为窗口对象；若控制器是从别的控制器present出来的，则其nextResponder为presenting view controller。</li>
<li>UIWindow<br/>
nextResponder为UIApplication对象</li>
<li>UIApplication<br/>
若当前应用的app delegate是一个UIResponder对象，且不是UIView、UIViewController或app本身，则UIApplication的nextResponder为app delegate</li>
</ul>

<blockquote>
<p>可以通过<code>responder.nextResponder</code>获取响应链中的所有响应对象</p>
</blockquote>

<h2 id="toc_10">UIGestureRecognizer 手势</h2>

<p>手势分为 <code>离散型手势</code>和<code>持续型手势</code>.系统提供的点按手势<code>UITapGestureRecognizer</code>和轻扫手势<code>UISwipeGestureRecongnizer</code>，其余的均为持续型手势。</p>

<p>主要区别在于其状态变化的过程</p>

<pre><code class="language-text">//离散型

识别成功: Possible-&gt;Recongnized
识别失败: Possible-&gt;Failed

//持续型
完整识别: Possible-&gt;Began-&gt;[Changed]-&gt;Ended
不完整识别: Possible-&gt;Began-&gt;[Changed]-&gt;Cancel
</code></pre>

<p><img src="media/15823466354492/15827277237498.jpg" alt="" style="width:267px;"/><br/>
我们自定义了<code>FSTapView、</code><code>FSLongPressView、</code><code>FSTapGestureRecognizer、</code><code>FSLongPressGestureRecognizer、</code><code>FSButton</code>和<code>FSControl</code>并在类内部 重写4个事件处理方法，打印其方法执行，<mark>注意</mark>在重写方法最后调用super进行继续分发</p>

<blockquote>
<p>GestureRecognizer虽然不是继承自UIResponder但是内部也有事件处理方法 会在接下来介绍<br/>
如果在GestureRecognizer接收到TouchEvent事件而没有调用super继续分发 则会导致该手势识别失败</p>
</blockquote>

<h3 id="toc_11">离散手势</h3>

<p>点点击添加了自定义点按视图时<br/>
<img src="media/15823466354492/15827327818395.jpg" alt="" style="width:1116px;"/><br/>
<img src="media/15823466354492/15827327970288.jpg" alt="" style="width:1096px;"/></p>

<p><img src="media/15823466354492/15827326493908.jpg" alt="" style="width:1095px;"/></p>

<pre><code class="language-objectivec">2020-02-26 22:48:34.999518+0800 Hit-Testing_Learn[36770:469711] -[FSTapGestureRecognizer touchesBegan:withEvent:]
2020-02-26 22:48:35.000166+0800 Hit-Testing_Learn[36770:469711] -[TapView touchesBegan:withEvent:]
2020-02-26 22:48:35.001275+0800 Hit-Testing_Learn[36770:469711] -[FSTapGestureRecognizer touchesEnded:withEvent:]
2020-02-26 22:48:35.001735+0800 Hit-Testing_Learn[36770:469711] -[ViewController2 tapEvent:]
2020-02-26 22:48:35.001915+0800 Hit-Testing_Learn[36770:469711] -[TapView touchesCancelled:withEvent:]
</code></pre>

<p>可以看到</p>

<ul>
<li><code>UIWindow</code>将事件传递给第一响应者<code>TapView</code>前，将事件传递给了手势<code>FSTapGestureRecognizer</code></li>
<li>若手势识别成功(即收到了<code>touchesBegan和touchesEnded</code>事件),则取消第一响应者对事件响应<code>[TapView touchesCancelled:withEvent:]</code></li>
<li>若手势识别未成功，第一响应者接手对事件进行处理</li>
</ul>

<p>注意:</p>

<blockquote>
<p>对于<code>FSTapGestureRecognizer</code>必须对<code>touchesBegan和touchesEnded</code>方法调用super继续,否则会导致手势识别失败<br/>
对于手势识别器调用super并不是让其向下一个手势识别器传递事件，测试可得不论是否使用super 所有手势识别器都可以收到touch事件. 即window发送事件会将事件发送到所有的UItouch的数组中的所有手势识别器，发送并没有什么特定顺序，只有一个可以识别成功，并且当其识别成功其余的识别器则会全部失败，只有所有的手势识别器都识别失败，hit-testView 才可以接收触摸事件</p>

<p>//TODO:<br/>
对于在添加了点按手势的视图上move 如果不超过视图范围，则手势和视图都可以收到move事件，如果在视图范围里离开手指？ 如果在视图范围外离开手指？如果超过一段时间?</p>
</blockquote>

<p>因此，可以得出结论 <mark>UIGestureRecognizer比UIResponder具有更高的事件响应的优先级</mark></p>

<p>在苹果官方文档也有这么一段话：</p>

<pre><code class="language-text">window将事件传递给手势识别器，然后将其传递给hit-test的添加了手势的视图。假如手势识别器以多点触摸顺序分析触摸流，但是并没有识别出其手势，则View将接收所有touch。如果手势识别器识别出手势，则将取消视图的其余touch。手势识别的常规操作顺序遵循以下路径，路径由`cancelsTouchesInView``delaysTouchesBegan``delaysTouchesEnded`属性的默认值确定
</code></pre>

<p><img src="media/15823466354492/15827311973724.jpg" alt="" style="width:678px;"/><br/>
UIGestureRecognizer对事件的响应也是通过touch相关的4个方法来实现的，但是其并不是继承自UIResponder而是NSObject，而这4个方法声明在UIGestureRecognizerSubclass.h中。</p>

<p><code>UIWindow</code>之所以知道把时间传递给那些手势识别器，主要通过<code>UIEvent</code>的Touch中的<code>gestureRecognizers</code>数组，而这个数组也是hit-test View寻找第一响应者过程中填充的。</p>

<p>UIWindow会取出UIEvent里面的gestureRecognizers数组的手势识别器，将事件传递给各个手势识别器，如果有一个手势识别器识别了事件，其他的手势识别器就不会响应该事件。</p>

<p>因为<code>手势识别器</code>识别事件，需要一定时间，因此<code>tapView</code>会先调用<code>touchbegan</code>，而因为手势识别器识别成功，则<code>UIApplication</code>向tapView发送取消(cancel)事件响应</p>

<h3 id="toc_12">持续型手势</h3>

<pre><code class="language-objectivec">2020-02-27 00:10:36.580259+0800 Hit-Testing_Learn[38200:533365] -[FSLongPressGestureRecognizer touchesBegan:withEvent:]
2020-02-27 00:10:36.581306+0800 Hit-Testing_Learn[38200:533365] -[LongPressView touchesBegan:withEvent:]
2020-02-27 00:10:37.582065+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.582259+0800 Hit-Testing_Learn[38200:533365] state --- 1
2020-02-27 00:10:37.582529+0800 Hit-Testing_Learn[38200:533365] -[LongPressView touchesCancelled:withEvent:]
2020-02-27 00:10:37.660837+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.661041+0800 Hit-Testing_Learn[38200:533365] state --- 2
2020-02-27 00:10:37.661267+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.661449+0800 Hit-Testing_Learn[38200:533365] state --- 2
2020-02-27 00:10:37.773423+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.773574+0800 Hit-Testing_Learn[38200:533365] state --- 2
2020-02-27 00:10:37.949981+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.950156+0800 Hit-Testing_Learn[38200:533365] state --- 2
2020-02-27 00:10:37.957969+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.958148+0800 Hit-Testing_Learn[38200:533365] state --- 2
2020-02-27 00:10:37.967924+0800 Hit-Testing_Learn[38200:533365] -[FSLongPressGestureRecognizer touchesEnded:withEvent:]
2020-02-27 00:10:37.968218+0800 Hit-Testing_Learn[38200:533365] -[ViewController2 longPressEvent:]
2020-02-27 00:10:37.968356+0800 Hit-Testing_Learn[38200:533365] state --- 3
</code></pre>

<p><img src="media/15823466354492/15827335289202.jpg" alt="" style="width:1343px;"/></p>

<p><img src="media/15823466354492/15827335827964.jpg" alt="" style="width:1340px;"/></p>

<p><img src="media/15823466354492/15827336077836.jpg" alt="" style="width:1297px;"/></p>

<p>在堆栈可以看出，第一次调用时在runloop中通知监听的手势识别器的观察者，对其长按事件进行相应，此时state为<code>UIGestureRecognizerStateBegan</code></p>

<p>第二次、第三次调用是UIWindow 先将事件传递给UIEvent的gestureRecognizers数组里的手势识别器，然后长按手势识别器FJFLongPressGestureRecognizer识别成功进行回调,此时手势识别器的state为UIGestureRecognizerStateChanged 和 UIGestureRecognizerStateEnded。</p>

<h3 id="toc_13">总结</h3>

<p>当触摸发生或者触摸的状态发生变化时，UIWindow都会传递事件寻求响应。</p>

<p>-UIWindow先将触摸事件传递给响应链上绑定的手势识别器，再发送给触摸对象对应的第一响应者。</p>

<ul>
<li><p>手势识别器识别手势期间，若触摸对象的触摸状态发生变化，事件都是先发送给手势识别器，再发送给第一响应者。</p></li>
<li><p>手势识别器如果成功识别手势，则通知UIApplication取消第一响应者对于事件的响应，并停止向第一响应者发送事件。</p></li>
<li><p>如果手势识别器未能识别手势，而此时触摸并未结束，则停止向手势识别器发送事件，仅向第一响应者发送事件。</p></li>
<li><p>如果手势识别器未能识别手势，且此时触摸已经结束，则向第一响应者发送end状态的touch事件，以停止对事件的响应。</p></li>
</ul>

<h3 id="toc_14">拓展</h3>

<p>在<code>UIGestureRecognizer</code>中存在以下3个属性</p>

<pre><code class="language-objectivec">@property(nonatomic) BOOL cancelsTouchesInView;       // default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL delaysTouchesBegan;         // default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesEnded;         // default is YES.  仅在此手势识别失败后，才将touchesEnded或pressesEnded事件传递到目标视图。 这样可以确保如果识别出手势，可以取消手势的触摸或按动
</code></pre>

<ol>
<li><p>cancelsTouchesInView</p>
<p>默认为YES。表示当手势识别器成功识别了手势之后，会通知Application取消响应链对事件的响应，并不再传递事件给第一响应者。若设置成NO，表示手势识别成功后不取消响应链对事件的响应，事件依旧会传递给第一响应者</p></li>
<li><p>delaysTouchesBegan <br/>
默认为NO。默认情况下手势识别器在识别手势期间，当触摸状态发生改变时，Application都会将事件传递给手势识别器和第一响应者；若设置成YES，则表示手势识别器在识别手势期间，截断事件，即不会将事件发送给第一响应者。</p></li>
<li><p>delaysTouchesEnded<br/>
默认为YES。当手势识别失败时，若此时触摸已经结束，会延迟一小段时间（0.15s）再调用响应者的touchesEnded:withEvent:；若设置成NO，则在手势识别失败时会立即通知Application发送状态为end的touch事件给第一响应者以调用 touchesEnded:withEvent:结束事件响应</p></li>
</ol>

<h2 id="toc_15">UIControl</h2>

<p><code>UIControl</code>是系统提供的能够以<code>target-action</code>模式处理触摸事件的控件，iOS中UIButton、UISegmentedControl、UISwitch等都是其子类<br/>
因为 UIControl是UIView子类，因此本身也具有<code>UIResponder</code>身份</p>

<p><code>UIControl</code>作为控件类的基类，它是一个<code>抽象基类</code>，我们不能直接使用UIControl类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。</p>

<h3 id="toc_16">Target-Action机制</h3>

<p>当事件将要发生时，事件会被发送到控件对象，然后控件对象触发target对象上的action行为，最终处理事件。<br/>
<code>UIControl</code>能够响应事件的控件，必须也需要事件交互符合条件才去响应，因此也会追踪事件发生的过程。和<code>UIResponder</code>以及<code>UIGestureRecongnizer</code>通过<code>touches</code>系列方法追踪，<code>UIControl</code>有独特的追踪方式:</p>

<pre><code class="language-objectivec">- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event {
    NSLog(@&quot;%s&quot;,__func__);
    return YES;
}
- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event {
    NSLog(@&quot;%s&quot;,__func__);
    return YES;
}
- (void)endTrackingWithTouch:(nullable UITouch *)touch withEvent:(nullable UIEvent *)event {
    NSLog(@&quot;%s&quot;,__func__);
}// touch is sometimes nil if cancelTracking calls through to this.
- (void)cancelTrackingWithEvent:(nullable UIEvent *)event {
    NSLog(@&quot;%s&quot;,__func__);
}   // event may be nil if cancelled for non-event reasons, e.g. removed from window
</code></pre>

<p>这4个方法和<code>UIResponder</code>的方法几乎温和,只是<code>UIControl</code>只能接收单点触控，因此参数是单个<code>UITouch</code>对象。和UIResponder职能类似，也是为了跟踪触摸的开始、滑动、结束、取消。不过，<code>UIControl</code>本身也是<code>UIResponder</code>，因此同样有touches系列的4个方法，事实上，UIControl的<code>Tracking</code>系列方法是在touch系列方法内部调用的。因此，UIControl中<code>touches</code>系列方法的默认实现和UIResponder还是有区别的</p>

<pre><code class="language-objectivec">2020-02-28 00:20:48.544827+0800 Hit-Testing_Learn[65809:1215013] -[FSTapGestureRecognizer touchesBegan:withEvent:]
2020-02-28 00:20:48.545294+0800 Hit-Testing_Learn[65809:1215013] -[FSButton touchesBegan:withEvent:]
2020-02-28 00:20:48.545425+0800 Hit-Testing_Learn[65809:1215013] -[FSButton beginTrackingWithTouch:withEvent:]
2020-02-28 00:20:48.545971+0800 Hit-Testing_Learn[65809:1215013] -[FSTapGestureRecognizer touchesEnded:withEvent:]
2020-02-28 00:20:48.546185+0800 Hit-Testing_Learn[65809:1215013] -[FSButton touchesEnded:withEvent:]
2020-02-28 00:20:48.546290+0800 Hit-Testing_Learn[65809:1215013] -[FSButton endTrackingWithTouch:withEvent:]
2020-02-28 00:20:48.546447+0800 Hit-Testing_Learn[65809:1215013] -[ViewController2 btnClickEvent:]
</code></pre>

<p><img src="media/15823466354492/15828208315732.jpg" alt="" style="width:1107px;"/><br/>
<img src="media/15823466354492/15828208589479.jpg" alt="" style="width:1084px;"/></p>

<ul>
<li>可以看到，Window先将时间传递给手势识别器，再传递给第一响应者<code>FSButton</code></li>
<li>手势识别器和第一响应者分别调用touch相关方法对事件进行识别</li>
<li><mark>最终第一响应者对事件进行相应调用<code>sendAction:to:forEvent</code>将target和action发送给UIApplication,UIApplication通过<code>sendAction:to:from:forevent</code>向target发送action</mark></li>
</ul>

<p>再来看自定义继承UIControl的<code>FSControl</code></p>

<pre><code class="language-objectivec">2020-02-28 00:32:26.644690+0800 Hit-Testing_Learn[66062:1228563] -[FSTapGestureRecognizer touchesBegan:withEvent:]
2020-02-28 00:32:26.645519+0800 Hit-Testing_Learn[66062:1228563] -[FSControl touchesBegan:withEvent:]
2020-02-28 00:32:26.645689+0800 Hit-Testing_Learn[66062:1228563] -[FSControl beginTrackingWithTouch:withEvent:]
2020-02-28 00:32:26.646929+0800 Hit-Testing_Learn[66062:1228563] -[FSTapGestureRecognizer touchesEnded:withEvent:]
2020-02-28 00:32:26.647320+0800 Hit-Testing_Learn[66062:1228563] -[ViewController2 tapEvent:]
2020-02-28 00:32:26.647492+0800 Hit-Testing_Learn[66062:1228563] -[FSControl touchesCancelled:withEvent:]
2020-02-28 00:32:26.647634+0800 Hit-Testing_Learn[66062:1228563] -[FSControl cancelTrackingWithEvent:]
</code></pre>

<p>此时结果和之前的<code>FSButton</code>优先级比手势识别器高截然相反，优先级竟然更低了</p>

<p>经过验证:<br/>
系统提供的有默认action操作的<code>UIControl</code>，例如<code>UIbutton、UISwitch</code>等的单击，<code>UIControl</code>的响应优先级比手势识别器高,而对于自定义的<code>UIControl</code>，响应的优先级比手势低<br/>
至于为什么会这样，没找到具体原因，但测试的结果，推测系统应该是依据UITouch的touchIdentifier来进行区别处理</p>

<h4 id="toc_17">target-action管理</h4>

<pre><code class="language-objectivec">
// 添加
- (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents
 // 删除
- (void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents

// 获取控件对象所有相关的target对象
// get info about target &amp; actions. this makes it possible to enumerate all target/actions by checking for each event kind
// 集合中可能包含NSNull 表明至少有一个nil目标对象
@property(nonatomic,readonly) NSSet *allTargets; 

- (nullable NSArray&lt;NSString *&gt; *)actionsForTarget:(nullable id)target forControlEvent:(UIControlEvents)controlEvent;    // single event. returns NSArray of NSString selector names. returns nil if none
</code></pre>

<p><code>UIControl</code>内部实际上有一个可变数组来保存<code>Target-Action</code>，数组中每个元素都是<code>UIControlTargetAction</code>对象。该类是私有类</p>

<pre><code class="language-objectivec">@interface UIControlTargetAction : NSObject {
    SEL _action;
    BOOL _cancelled;
    unsigned int _eventMask;// 事件类型,比如:UIControlEventTouchUpInside
    id _target;
}
</code></pre>

<h2 id="toc_18">总结  事件完整响应链</h2>

<ol>
<li>系统通过<code>IOKit.framework</code>来处理硬件操作，其中屏幕处理也通过IOKit完成(IOKit可能是注册监听了屏幕输出的端口)<br/>
当用户操作屏幕，IOKit收到屏幕操作，会将这次操作封装为IOHIDEvent对象。通过mach port(IPC进程间通信)将事件转发给SpringBoard来处理</li>
<li>SpringBoard是iOS系统的桌面程序。SpringBoard收到mach port发过来的事件，唤醒main runloop来处理</li>
<li>main runloop将事件交给source1处理，<code>source1</code>会调用<code>__IOHIDEventSystemClientQueueCallback()</code>函数<br/>
该函数会在内部判断是否有程序在前台显示，如果有通过<code>mach port</code>将<code>IOHIDEvent</code>事件转发给这个程序<br/>
如果前台没有程序在显示，则表明SpringBoard的桌面程序在前台显示，也就是用户在桌面进行了操作。<code>__IOHIDEventSystemClientQueueCallback()</code>函数会将事件交给<code>source0</code>处理，<code>source0</code>会调用<code>__UIApplicationHandleEventQueue()</code>函数，函数内部会做具体的处理操作</li>
<li>例如用户点击了某个应用程序的icon，会将这个程序启动。<br/>
应用程序接收到<code>SpringBoard</code>传来的消息，会唤醒<code>main runloop</code>并将这个消息交给source1处理，source1调用<code>__IOHIDEventSystemClientQueueCallback()</code>函数，在函数内部会将事件交给<code>source0</code>处理，并调用source0的<code>__UIApplicationHandleEventQueue()</code>函数。在__UIApplicationHandleEventQueue()函数中，会将传递过来的<code>IOHIDEvent</code>转换为<code>UIEvent</code>对象</li>
<li>在函数内部，将事件放入UIApplication的事件队列，等到处理该事件时，将该事件出队列，UIApplication将事件传递给窗口对象(UIWindow)，如果存在多个窗口，则从后往前询问最上层显示的窗口</li>
<li>窗口UIWindow通过hitTest和pointInside操作，判断是否可以响应事件，如果窗口UIWindow不能响应事件，则将事件传递给其他窗口；若窗口能响应事件，则从后往前询问窗口的子视图。</li>
<li>以此类推，如果当前视图不能响应事件，则将事件传递给同级的上一个子视图；如果能响应，就从后往前遍历当前视图的子视图</li>
<li>如果当前视图的子视图都不能响应事件，则当前视图就是第一响应者</li>
<li>找到第一响应者，事件的传递的响应链也就确定的</li>
<li>如果第一响应者非UIControl子类且响应链上也没有绑定手势识别器<code>UIGestureRecognizer</code>;</li>
<li>那么由于第一响应者具有处理事件的最高优先级，因此UIApplication会先将事件传递给它供其处理。首先，<code>UIApplication</code>将事件通过<code>sendEvent:</code>传递给事件所属的window，window同样通过<code>sendEvent:</code>再将事件传递给<code>hit-tested view</code>，即第一响应者,第一响应者具有对事件的完全处理权，默认对事件不进行处理，传递给下一个响应者(nextResponder)；如果响应链上的对象一直没有处理该事件，则最后会交给<code>UIApplication</code>，如果UIApplication实现代理，会交给<code>UIApplicationDelegate</code>，如果<code>UIApplicationDelegate</code>没处理，则该事件会被丢弃</li>
<li>如果第一响应者非UIControl子类但响应链上也绑定了手势识别器<code>UIGestureRecognizer</code></li>
<li>UIWindow会将事件先发送给响应链上绑定的手势识别器<code>UIGestureRecognizer</code>，再发送给第一响应者，如果手势识别器能成功识别事件，UIApplication默认会向第一响应者发送cancel响应事件的命令;如果手势识别器未能识别手势，而此时触摸并未结束，则停止向手势识别器发送事件，仅向第一响应者发送事件。如果手势识别器未能识别手势，且此时触摸已经结束，则向第一响应者发送end状态的touch事件，以停止对事件的响应</li>
<li>如果第一响应者是自定义的UIControl的子类同时响应链上也绑定了手势识别器<code>UIGestureRecognizer</code>;这种情况跟第一响应者非UIControl子类但响应链上也绑定了手势识别器<code>UIGestureRecognizer</code>处理逻辑一样</li>
<li>如果第一响应者是UIControl的子类且是系统类(UIButton、UISwitch)同时响应链上也绑定了手势识别器<code>UIGestureRecognizer</code></li>
<li>UIWindow会将事件先发送给响应链上绑定的手势识别器<code>UIGestureRecognizer</code>，再发送给第一响应者，如果第一响应者能响应事件，UIControl调用调用<code>sendAction:to:forEvent:</code>将target、action以及event对象发送给UIApplication，UIApplication对象再通过<code>sendAction:to:from:forEvent:</code>向target发送action</li>
</ol>

<h2 id="toc_19">示例：</h2>

<h3 id="toc_20">超出子视图范围</h3>

<p><img src="media/15823466354492/15824747327255.jpg" alt="" style="width:219px;"/><br/>
此时 当点击btn不在BView时，并不起作用，因为点击的点在btn的父视图Bview外 则事件无法传递到btn，如果想要点击外部区域也起作用</p>

<pre><code class="language-objectivec">//在BView重写
//处理超出区域点击无效的问题
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    
    if (self.isHidden == NO) {
        // 转换坐标
        CGPoint newPoint = [self convertPoint:point toView:self.btn];
        // 判断点击的点是否在按钮区域内
        if ( [self.btn pointInside:newPoint withEvent:event]) {
            //返回按钮
            return self.btn;
        }else{
            return [super hitTest:point withEvent:event];
        }
    }
    else {
        return [super hitTest:point withEvent:event];
    }
}
</code></pre>

<h3 id="toc_21">想要扩大视图的点击范围</h3>

<p>假如想要扩大按钮的点击范围</p>

<pre><code class="language-objectivec">//TabBar
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    //将触摸点坐标转换到在CircleButton上的坐标
    CGPoint pointTemp = [self convertPoint:point toView:self.indicateView];
    //若触摸点在CricleButton上则返回YES
    if ([self.indicateView pointInside:pointTemp withEvent:event]) {
        return YES;
    }
    //否则返回默认的操作
    return [super pointInside:point withEvent:event];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C二进制瘦身]]></title>
    <link href="https://acefish.github.io/15822611342755.html"/>
    <updated>2020-02-21T12:58:54+08:00</updated>
    <id>https://acefish.github.io/15822611342755.html</id>
    <content type="html"><![CDATA[
<p>参阅<a href="https://www.jianshu.com/p/e3cf048c67aa">Objective-C二进制瘦身</a></p>

]]></content>
  </entry>
  
</feed>
