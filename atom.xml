<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish的博客]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2017-06-13T16:11:55+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Block实现原理]]></title>
    <link href="https://acefish.github.io/14972592855571.html"/>
    <updated>2017-06-12T17:21:25+08:00</updated>
    <id>https://acefish.github.io/14972592855571.html</id>
    <content type="html"><![CDATA[
<p>原文地址<a href="http://blog.ibireme.com/2013/11/27/objc-block/">objc 中的 block</a></p>

<h2 id="toc_0">block中的数据结构</h2>

<p><code>block</code>的定义:</p>

<pre><code class="language-objc">struct Block_descriptor_1 {
    uintptr_t reserved;
    uintptr_t size;
};
 
struct Block_layout {
    void *isa;
    volatile int32_t flags; // contains ref count
    int32_t reserved; 
    void (*invoke)(void *, ...);
    struct Block_descriptor_1 *descriptor;
    // imported variables
};
</code></pre>

<p>在oc中，凡是首地址是<code>*isa</code>的结构体指针，都可以认为是对象.这样在<code>objc</code>中，<code>block</code>实际上就算是对象。</p>

<pre><code class="language-objc">void foo_(){
    int i = 2;
    NSNumber *num = @3;
 
    long (^myBlock)(void) = ^long() {
        return i * num.intValue;
    };
 
    long r = myBlock();
}
//我们对上面的block的简单使用转换为c形式
//通用的block数据结构
struct __block_impl {
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};
//通用的block数据结构描述
struct __foo_block_desc_0 {
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __foo_block_impl_0*, struct __foo_block_impl_0*);
    void (*dispose)(struct __foo_block_impl_0*);
};
 
//myBlock的数据结构定义
struct __foo_block_impl_0 {
    struct __block_impl impl;//包含通用数据结构定义
    struct __foo_block_desc_0* Desc;//对本block的结构描述指针
    int i;  //捕获的变量
    NSNumber *num;  //捕获的变量
};
 
//block数据的描述
static struct __foo_block_desc_0 __foo_block_desc_0_DATA = {
    0,
    sizeof(struct __foo_block_impl_0), //本block的占的自己空间大小（便分配空间）
    __foo_block_copy_0,
    __foo_block_dispose_0 //通用数据结构描述
};
 
//block中的方法
static long __foo_block_func_0(struct __foo_block_impl_0 *__cself) {//这个函数引用这个block的数据结构
    int i = __cself-&gt;i; // bound by copy
    NSNumber *num = __cself-&gt;num; // bound by copy
 
    return i * num.intValue;
}
 
void foo(){
    int i = 2;
    NSNumber *num = @3;
 
    struct __foo_block_impl_0 myBlockT;
    struct __foo_block_impl_0 *myBlock = &amp;myBlockT;
    myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;
    myBlock-&gt;impl.Flags = 570425344;
    myBlock-&gt;impl.FuncPtr = __foo_block_func_0;
    myBlock-&gt;Desc = &amp;__foo_block_desc_0_DATA;
    myBlock-&gt;i = i;
    myBlock-&gt;num = num;
 
    long r = myBlock-&gt;impl.FuncPtr(myBlock);
}

</code></pre>

<p>创建<code>block</code>就是创建了一个结构体,用<code>block捕获的变量</code>来初始化结构体体中数据,block内部的代码提取为block结构体中的c函数,这个c函数参数为一个指向本block的指针,执行时将这个struct指针传过去,通过这个指针获取block捕获的变量进行c函数的计算</p>

<p><code>block</code>中包含了被引用的自由变量(由struct持有)，也包含了控制成分的代码块(由函数指针持有)符合闭包(<code>closure</code>)的概念。</p>

<h2 id="toc_1">block的copy</h2>

<p><code>block</code>中的<code>isa</code>指向的是该<code>block</code>的<code>Class</code>.这些Class都有:</p>

<ul>
<li>_NSConcreteStackBlock ---- 栈上创建的block</li>
<li>_NSConcreteMallocBlock ---- 堆上创建的block</li>
<li>_NSConcreteGlobalBlock ---- 作为全局变量的block</li>
<li>_NSConcreteWeakBlockVariable ---- 用于GC不再讨论</li>
<li>_NSConcreteAutoBlock ---- 用于GC不再讨论</li>
<li>_NSConcreteFinalizingBlock ---- 用于GC不再讨论</li>
</ul>

<p>1.全局block<br/>
全局block是当一个block内部没有捕获任何外部变量时，就会是一个全局block类型。此时，这个block与一个函数无异。所以，那么它就应该有和函数一样的静态特性。而且，我们在调用block的时候，其实和普通C函数的调用很相似，都是名称加括号：block()。 全局block的地址是在全局变量常量区的</p>

<p><strong>当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。</strong></p>

<p>函数返回时，函数的栈帧被销毁，这个<code>block</code>的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用<code>Block_copy()</code>方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送<code>retain</code>，增加<code>block</code>的引用计数。</p>

<h2 id="toc_2">__block类型变量</h2>

<p>默认捕获到的对象直接赋值给<code>block</code>结构体，不能修改,那么当我们给其加上<code>__block</code>修饰时,原本的捕获的int值位置变为一个<code>struct</code>，这个struct首地址也为<code>*isa</code>.</p>

<p>因此，这个值才能被<code>block</code>共享、并且不受栈帧生命周期的限制、在<code>block</code>被<code>copy</code>后，能够随着<code>block</code>复制到堆上。</p>

<h2 id="toc_3">注意事项:</h2>

<p>1.静态存储区的变量：例如全局变量、方法中的static变量<br/>
<strong>引用，可修改</strong>。</p>

<p>2.block接受的参数<br/>
传值，可修改，和一般函数的参数相同。</p>

<p>3.栈变量 (被捕获的上下文变量)<br/>
const，不可修改。 当block被copy后，block会对 id类型的变量产生强引用。<br/>
每次执行block时,捕获到的变量都是最初的值。</p>

<p>4.栈变量 (有__block前缀)<br/>
引用，可以修改。如果时id类型则不会被<code>block retain</code>,必须手动处理其内存管理。<br/>
如果该类型是C类型变量，<code>block</code>被<code>copy</code>到<code>heap</code>后,该值也会被挪动到<code>heap</code></p>

<h2 id="toc_4">使用注意点:</h2>

<ol>
<li><p>内存方面</p>

<p><code>Block_copy()</code>和<code>Block_release()</code>必须一一匹配，否则会内存泄漏或crash。</p>

<p><code>__block</code>这个修饰词会将原本的简单类型转化为较大的<code>struct</code>，这会给内存、调用带来额外的开销，使用时需要注意。</p></li>
<li><p>ARC模式下的block使用<br/>
在ARC模式下我们 不用手动<code>copy/release</code>，<br/>
但是</p>

<pre><code class="language-objc">void (^aBlock)(void);//定义一个aBlock对象（__strong）
aBlock = ^{ printf(&quot;ok&quot;); };
//只要一个block被赋值给一个strong变量，会自动copy
//strong变量就是一个强引用指针  copy到堆后将对地址赋值给这个指针 对象引用着这个block
</code></pre>

<p>block是对象，所以这个aBlock默认是有__strong修饰符的，即<code>aBlock</code>对该block有<code>strong <br/>
references</code>。即aBlock在被赋值的那一刻，这个block会被copy。所以，ARC开启后，所能接触到的<br/>
block基本都是在堆上的。</p>

<pre><code class="language-objc">//对于这个例子
void (^aBlock)(void) = nil; 
if (!aBlock) {
    aBlock = ^{ printf(&quot;hehe&quot;); };
}
//block此时block已经被释放,该处留下了一个`dangling pointer`
aBlock();
</code></pre>

<p>这种情况 苹果建议尽量避免这种情况。</p></li>
<li><p>block易引起的循环引用问题</p>

<p>当block被copy之后(如开启了ARC、或把block放入dispatch queue)，该block对它捕获的对象产生<br/>
strong references (非ARC下是retain),所以有时需要避免block copy后产生的循环引用。</p>

<p>如果用self引用了block，block又捕获了self，这样就会有循环引用。因此，需要用weak来声明self</p>

<pre><code class="language-objc">    - (void)configureBlock {
    XYZBlockKeeper * __weak weakSelf = self;
    self.block = ^{
    [weakSelf doSomething]; //捕获到的是弱引用
    }
    }
    //当前前对象的成员变量对象，同样也会造成对self的引用
    - (void)configureBlock {
    id tmpIvar = _ivar; //临时变量,避免了self引用
    self.block = ^{
    [tmpIvar msg];
    }
    }
</code></pre>

<p>为了避免循环引用，可以这样理解<code>block</code>：<code>block</code>就是一个对象，它捕获到的值就是这个对象的<code>@property(strong)</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三方登录分享]]></title>
    <link href="https://acefish.github.io/14972581397752.html"/>
    <updated>2017-06-12T17:02:19+08:00</updated>
    <id>https://acefish.github.io/14972581397752.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">shareSdk使用</h2>

<p><a href="http://wiki.mob.com/ios%E7%AE%80%E6%B4%81%E7%89%88%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90/">集成步骤</a><br/>
对于<code>shareSDK</code>中初始化第三方应用平台,我们可以通过<code>ShareSDK registerApp:@&quot;iosv1101&quot; activePlatforms:</code>方法中传入各个平台的appkey等信息进行初始化,或者添加各个平台的<code>URL type</code>然后简单的用<code>share SDK</code>中<code>connect</code>方法进行初始化</p>

<p>注意：<br/>
1. 在<code>shareSDK.xml</code>文件中传入各个平台的<code>key</code>和<code>serect</code><br/>
2. 现在需要在<code>plist</code>文件添加第三方应用白名单才可以打开第三方应用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSURL]]></title>
    <link href="https://acefish.github.io/14968918049808.html"/>
    <updated>2017-06-08T11:16:44+08:00</updated>
    <id>https://acefish.github.io/14968918049808.html</id>
    <content type="html"><![CDATA[
<p>URL(统一资源定位符) 是一种 URI，URN(统一资源名称) 也是一种 URI，所以 URI (统一资源标志符)可被视为定位符，名称或两者兼备</p>

<h2 id="toc_0">URL Encode</h2>

<p><a href="http://www.jianshu.com/p/38f5f53dfbad">[iOS-Foundation] NSURL</a><br/>
<code>URL</code>采用<code>ASCII</code>编码格式，所以不支持如中文等非<code>ASCII</code>码字符，另外<code>URL</code>中保留的分隔符号(?、&amp;、=等)也无法作为内容，否则会引起歧义。<br/>
这就需要通过编码，用安全的字符来表示这些不符合要求的字符，格式是%加两位安全字符，所以 URL 编码也称为百分号编码。</p>

<pre><code class="language-objc">//Encode编码
NSString *urlString = @&quot;?&quot;;
NSString *encodedString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLHostAllowedCharacterSet]];
//encodedString值为 %3F
//替换不符合要求UTF-8编码为百分号编码字符
@interface NSCharacterSet (NSURLUtilities)
+ (NSCharacterSet *)URLUserAllowedCharacterSet;
+ (NSCharacterSet *)URLPasswordAllowedCharacterSet;
+ (NSCharacterSet *)URLHostAllowedCharacterSet;
+ (NSCharacterSet *)URLPathAllowedCharacterSet;
+ (NSCharacterSet *)URLQueryAllowedCharacterSet;
+ (NSCharacterSet *)URLFragmentAllowedCharacterSet;
@end
</code></pre>

<pre><code class="language-objc">//Unencode解码
+ (NSString *)decodeURLString:(NSString *)URLString {
    // 有时从服务端获取的 URL 中，空格被编码为+, 
    // 而方法- stringByRemovingPercentEncoding只替换百分号编码，
    // 所以要在执行该方法前，先将`+`替换掉(真正的加号字符是被百分号编码的)
    NSString *result = [URLString stringByReplacingOccurrencesOfString:@&quot;+&quot; withString:@&quot; &quot;];
    //替换所有百分号编码为UTF-8编码字符
    result = [result stringByRemovingPercentEncoding];
    return result;
}
</code></pre>

<h2 id="toc_1">NSURL</h2>

<p><a href="https://developer.apple.com/documentation/foundation/nsurl?preferredLanguage=occ">NSURL苹果官方文档</a></p>

<p>我们通过<code>NSURL</code>对象来构建一个资源定位符。对于本地文件的资源定位符,我们可以直接操作这些问价你的属性（比如修改文件的的最后修改日期）,对于远程资源我们可以将<code>NSURL</code>对象传递给其他API来获取内容,<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">Next About the URL Loading System</a></p>

<p><code>URL</code>对象是指向本地文件的首选方案,大多数进行文件数据读写对象都接受一个<code>NSURL</code>对象而不是一个文件路径.例如：可以用文件<code>NSURL</code>获取<code>NSString</code>  <code>initWithContentsOfURL:encoding:error:</code>,获取<code>data</code>  <code>initWithContentsOfURL:options:error:</code></p>

<p>你也可以用url资源定位符进行需要的操作,例如在<code>macOS</code>的<code>NSWorkspace</code>类和<code>iOS</code>的<code>UIApplication</code>类提供的<code>OpenURL:</code>方法来打开一个指定的URL位置</p>

<p>此外,我们可以通过使用粘贴板来对<code>NSURL</code>对象进行引用（AppKit框架的一部分）</p>

<p><code>NSURL</code>对应<code>Core Foundation</code>中的<a href="https://developer.apple.com/documentation/corefoundation/cfurlref?language=objc">CFURLRef</a>,我们可以查看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2">Toll-Free Bridging</a>来获取更多类似的与<code>Core Foundation</code>相对应的信息</p>

<p>补充：<br/>
Swift提供了<a href="https://developer.apple.com/documentation/foundation/url?language=objc">URL</a>结构，负责连接<code>NSURL</code>类，可以在<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13"> Classes and Structures</a>中查看更多信息</p>

<h3 id="toc_2">URL结构</h3>

<p>一个<code>NSURL</code>对象由两部分组成:一部分是可能为<code>nil</code>的<code>base URL</code>和一部分与<code>base URL</code>有相对关系的字符串<code>relativeString</code>。如果一个<code>NSURL</code>对象没有<code>base</code>部分只有<code>string</code>部分那么它被认为是绝对地址,否则为相对的.</p>

<pre><code class="language-objc">//file:///path/to/user/ as the base URL and folder/file.html
/**
    我们指定 file:///path/to/user/ 为baseURL folder/file 为字符串部分
*/
NSURL *baseURL = [NSURL fileURLWithPath:@&quot;file:///path/to/user/&quot;];
NSURL *URL = [NSURL URLWithString:@&quot;folder/file.html&quot; relativeToURL:baseURL];
NSLog(@&quot;absoluteURL = %@&quot;, [URL absoluteURL]);//file:///path/to/user/ as the base URL and folder/file.html
/**
    这个URL的
    absoluteString:  file:///file:/path/to/folder/file.html
    baseURL:  file:///file:/path/to/user
    relativeString： folder/file.html
*/
</code></pre>

<p>对于一个<code>URL</code>我们可以将其分为很多部分,例如一个url如下：<br/>
<code>https://johnny:p4ssw0rd@www.example.com:443/script.ext;param=value?query=value#ref</code></p>

<table>
<thead>
<tr>
<th>Component</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>scheme</td>
<td>https</td>
</tr>
<tr>
<td>user</td>
<td>johnny</td>
</tr>
<tr>
<td>password</td>
<td>p4ssw0rd</td>
</tr>
<tr>
<td>host</td>
<td><a href="http://www.example.com">www.example.com</a></td>
</tr>
<tr>
<td>port</td>
<td>443</td>
</tr>
<tr>
<td>path</td>
<td>/script.ext</td>
</tr>
<tr>
<td>pathExtension</td>
<td>ext</td>
</tr>
<tr>
<td>pathComponents</td>
<td>[&quot;/&quot;, &quot;script.ext&quot;]</td>
</tr>
<tr>
<td>parameterString</td>
<td>param=value</td>
</tr>
<tr>
<td>query</td>
<td>query=value</td>
</tr>
<tr>
<td>fragment</td>
<td>ref</td>
</tr>
</tbody>
</table>

<p><code>NSURL</code>也提供了很多属性让我们来获取每部分</p>

<h3 id="toc_3">书签以及安全范围</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 基础部分]]></title>
    <link href="https://acefish.github.io/14968373667230.html"/>
    <updated>2017-06-07T20:09:26+08:00</updated>
    <id>https://acefish.github.io/14968373667230.html</id>
    <content type="html"><![CDATA[
<p>Swift 包含了C和Objective-C上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。 Swift 还提供了三个基本的集合类型<code>Array</code> ，<code>Set</code> 和<code>Dictionary</code><br/>
除了我们熟悉的类型，<code>Swift</code>还增加了<code>Objective-C</code>中没有的高阶数据类型比如元组（<code>Tuple</code>）。<br/>
<code>Swift</code>还增加了可选（Optional）类型，用于处理值缺失的情况。</p>

<p><code>Swift</code>是一门类型安全的语言，这意味着<code>Swift</code>可以让你清楚地知道值的类型。</p>

<h2 id="toc_0">常量和变量</h2>

<p>常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>

<h3 id="toc_1">声明常量和变量</h3>

<p>用<code>let</code>来声明常量，用<code>var</code>来声明变量</p>

<pre><code class="language-Swift">//一行中声明多个
var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<p>注意:<strong>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。</strong></p>

<h3 id="toc_2">类型标注</h3>

<p>声明常量或者变量的时候可以加上类型标注，在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。(声明时如果有初始值，Swift可以推断出这个常量或者变量的类型)</p>

<pre><code class="language-Swift">//可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：
var red, green, blue: Double
</code></pre>

<h3 id="toc_3">常量和变量的命名</h3>

<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>

<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。（不推荐）</p>

<h3 id="toc_4">输出常量和变量</h3>

<p>用 <code>print(someValue, separator:, terminator:)</code> 函数来输出当前常量或变量的值:<br/>
<code>separator</code>用来设置各个值间的拼接字符串<br/>
<code>terminator</code>用来设置输出结果结束后的结束字符，默认为“\n”换行</p>

<pre><code class="language-swift">print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
print(&quot;111&quot;, &quot;222&quot;, separator:&quot;--&quot;, terminator:&quot;结束符 &quot;)
//输出结果(并没有换行)
//111--222结束符 111--222结束符
</code></pre>

<p><code>Swift</code>用<strong>字符串插值</strong>（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，<code>Swift</code>会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>

<pre><code class="language-Swift">/*
    若只是要print一个变量或者常量可以直接print，但是如果要将这个拼接到字符串中需要这
    样做
*/
print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)
// 输出 &quot;The current value of friendlyWelcome is Bonjour!
</code></pre>

<h2 id="toc_5">注释</h2>

<p>单行注释用双正斜杠<code>（ // ）</code>作为起始标记:<br/>
多行注释用：</p>

<pre><code class="language-swift">/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>

<p>多行注释可以去嵌套注释，我们可以方便的注释掉大段代码 即使代码中已经包含注释(oc中是没有多行注释的)</p>

<h2 id="toc_6">分号</h2>

<p><code>Swift</code>并不需要在末尾添加分号,但是如果单行内写多条语句时,必须用分号分开;</p>

<h2 id="toc_7">整数</h2>

<p><code>Swift</code> 提供了8，16，32和64位的有符号和无符号整数类型(即分别为1、2、4、8字节)。<br/>
命名:比如8位无符号整数类型是 UInt8 ，32位有符号整数类型是 Int32 。</p>

<h3 id="toc_8">范围</h3>

<p>我们可以用不同整数类型的<code>min</code>和<code>max</code>属性获取对应类型的最小值和最大值：</p>

<pre><code class="language-swift">//返回的类型正是其对应类型
let minValue = UInt8.min // minValue 为 0，是 UInt8 类型
let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型
</code></pre>

<p>Swift提供了整数类型<code>Int</code>和<code>UInt</code>其长度和当前平台<code>原生字长</code>相同</p>

<p>补充:<br/>
尽量不要使用<code>UInt</code> ，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断</p>

<h2 id="toc_9">浮点数</h2>

<p><code>Swift</code>提供了两种有符号浮点数类型：</p>

<ul>
<li>Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li>Float 表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>

<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择<code>Double</code>。</p>

<h2 id="toc_10">类型安全和类型推断</h2>

<p><code>Swift</code>是一个类型安全（type safe）的语言。因此它会在编译时进行类型检查,将不匹配的类型标记为错误。但是也不奥每个都显示的指定类型,编译器可以在编译代码的时候自动推断出表达式的类型。</p>

<pre><code class="language-swift">//当推断浮点数的类型时，Swift 总是会选择 Double 而不是 Float 
let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>

<h2 id="toc_11">数值型字面量</h2>

<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是 <code>0b</code></li>
<li>一个八进制数，前缀是 <code>0o</code></li>
<li>一个十六进制数，前缀是 <code>0x</code></li>
</ul>

<p>对于浮点数用10进制或者16进制表示，可以用指数来表示，10进制的指数为<code>e</code>(可为大写或小写)，16进制使用大写或者小写的<code>p</code></p>

<pre><code class="language-swift">1.25e2 表示 1.25 × 10^2，等于 125.0 
1.25e-2 表示 1.25 × 10^-2，等于 0.0125
0xFp2 表示 15 × 2^2，等于 60.0
0xFp-2 表示 15 × 2^-2，等于 3.75
</code></pre>

<p>补充:<br/>
为了可读性：整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>

<pre><code class="language-swift">let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>

<h2 id="toc_12">数值型类型转换</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift简介]]></title>
    <link href="https://acefish.github.io/14966582354331.html"/>
    <updated>2017-06-05T18:23:55+08:00</updated>
    <id>https://acefish.github.io/14966582354331.html</id>
    <content type="html"><![CDATA[
<p><code>Swift</code>采用了<code>Objective-C</code>的命名参数以及动态对象模型，可以无缝对接到现有的<code>Cocoa</code>框架，并且可以兼容<code>Objective-C</code>代码。在此基础之上，<code>Swift</code> 还有许多新特性并且支持过程式编程和面向对象编程。</p>

<p>特性:<br/>
程序入口:<br/>
<code>print(&quot;Hello, world!&quot;)</code><br/>
在<code>Swift</code>中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口 点，所以你也不需要<code>main()</code> 函数。</p>

<h2 id="toc_0">基础知识</h2>

<h3 id="toc_1">简单值</h3>

<p><strong>使用 <code>let</code> 来声明常量，使用 <code>var</code> 来声明变量</strong>。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能 为它赋值一次。</p>

<pre><code class="language-swift">let firstConstant = 10
var firstVariable:Double
</code></pre>

<p>在声明的同时赋值的话不需要声明类型,编译器可以推断出来，但是如果信息不够（没有初始值）,必须要在变量后声明类型;</p>

<p><strong>值永远不会被隐式转换为其他类型,如果要转换请显式转换</strong><br/>
整形转为字符串</p>

<pre><code class="language-swift">//显式强制类型装换
let width = 94
let widthLabel = &quot;The width is&quot; + String(width)
//使用 \() 来把一个浮点计算转换成字符串
let apples = 3
let appleSummary:String = &quot;I have \(apples) apples.&quot;
</code></pre>

<p>使用方括号<code>[]</code>来创建数组和字典，并使用<code>下标或者键(key)</code>来访问元素。最后一个元素后面允许有个逗号</p>

<pre><code class="language-swift">var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;]
shoppingList[1] = &quot;bottle of water&quot;
var occupations = [
    &quot;Malcolm&quot;: &quot;Captain&quot;,
    &quot;Kaylee&quot;: &quot;Mechanic&quot;,
]
occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发中的九种锁]]></title>
    <link href="https://acefish.github.io/14964011409915.html"/>
    <updated>2017-06-02T18:59:00+08:00</updated>
    <id>https://acefish.github.io/14964011409915.html</id>
    <content type="html"><![CDATA[
<p>我们在使用多线程的时候多个线程可能会访问同一块资源，这样就很容易引发数据错乱和数据安全等问题，这时候就需要我们保证每次只有一个线程访问这一块资源，锁 应运而生。</p>

<p>补充:<a href="http://www.cnblogs.com/huangjianwu/p/4575763.html">实现锁的多种方式和锁的高级用法</a><br/>
<a href="http://www.jianshu.com/p/938d68ed832c">iOS中保证线程安全的几种方式与性能对比</a></p>

<h2 id="toc_0">一、OSSpinLock 自旋锁</h2>

<p>OSSpinLock 自旋锁，性能最高的锁。在任何时刻只会有一个线程能获得锁,而其他线程忙着等待直到获得锁。缺点是<code>spinlock</code>使用不当(如临界区执行时间过长)会导致<code>cpu busy</code>飙高。不适合较长时间任务</p>

<pre><code class="language-objc">__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@&quot;需要线程同步的操作1 开始&quot;);
    sleep(3);
    NSLog(@&quot;需要线程同步的操作1 结束&quot;);
    OSSpinLockUnlock(&amp;theLock);

});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@&quot;需要线程同步的操作2&quot;);
    OSSpinLockUnlock(&amp;theLock);

});
</code></pre>

<pre><code class="language-objc">//
OS_SPINLOCK_INIT： 默认值为 0,在 locked 状态时就会大于 0，unlocked状态下为 0
OSSpinLockLock(&amp;oslock)：上锁，参数为 OSSpinLock 地址
OSSpinLockUnlock(&amp;oslock)：解锁，参数为 OSSpinLock 地址
OSSpinLockTry(&amp;oslock)：尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO
/**
当前线程锁失败，也可以继续其它任务，用 trylock 合适
当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock
*/
</code></pre>

<p>注意:<br/>
<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a></p>

<h2 id="toc_1">二、dispatch_semaphore 信号量</h2>

<p>是GCD的用来同步的一种方式<br/>
在没有等待情况出现时，它的性能比<code>pthread_mutex</code>还要高，但一旦有等待情况出现时，性能就会下降许多。相对于<code>OSSpinLock</code>来说，它的优势在于等待时不会消耗<code>CPU</code>资源。</p>

<pre><code class="language-objc">  dispatch_semaphore_t signal = dispatch_semaphore_create(1);
    dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(2);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        dispatch_semaphore_signal(signal);
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@&quot;需要线程同步的操作2&quot;);
        dispatch_semaphore_signal(signal);
    });
</code></pre>

<pre><code class="language-objc">dispatch_semaphore_create(1)： 传入值必须 &gt;=0, 若传入为 0 则阻塞线程并等待timeout,
时间到后会执行其后的语句
dispatch_semaphore_wait(signal, overTime)：可以理解为 lock,会使得 signal 值 -1，若信号量的值大于0，就可以继续往下执行,否则等待,如果在等待时间期间信号量一直为0，则会在`timeOut`后自动执行其后的语句。
//
dispatch_semaphore_signal(signal)：可以理解为 unlock,会使得 signal 值 +1
</code></pre>

<p>补充:<a href="http://www.cnblogs.com/snailHL/p/3906112.html">关于dispatch_semaphore的使用</a></p>

<h2 id="toc_2">三、@synchronized</h2>

<pre><code class="language-objc"> NSObject *obj = [[NSObject alloc] init];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        @synchronized(obj) {
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(3);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        }
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        @synchronized(obj) {
            NSLog(@&quot;需要线程同步的操作2&quot;);
        }
    });
</code></pre>

<p><code>@synchronized(obj)</code>指令使用的<code>obj</code>为该锁的唯一标识，只有当标识相同时，才为满足互斥.<br/>
<code>@synchronized</code>指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，<code>@synchronized</code>块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>补充：<a href="http://ios.jobbole.com/82826/">关于 @synchronized，这儿比你想知道的还要多</a></p>

<h2 id="toc_3">四、NSLock</h2>

<pre><code class="language-objc">    NSLock *lock = [[NSLock alloc] init];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        //[lock lock];
        [lock lockBeforeDate:[NSDate date]];
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(2);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        [lock unlock];

    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
            NSLog(@&quot;锁可用的操作&quot;);
            [lock unlock];
        }else{
            NSLog(@&quot;锁不可用的操作&quot;);
        }

        NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
        if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
            NSLog(@&quot;没有超时，获得锁&quot;);
            [lock unlock];
        }else{
            NSLog(@&quot;超时，没有获得锁&quot;);
        }

    });
    //运行结果
    2016-06-29 20:45:08.864 SafeMultiThread[35911:575795] 需要线程同步的操作1 开始
    2016-06-29 20:45:09.869 SafeMultiThread[35911:575781] 锁不可用的操作
    2016-06-29 20:45:10.869 SafeMultiThread[35911:575795] 需要线程同步的操作1 结束
    2016-06-29 20:45:10.870 SafeMultiThread[35911:575781] 没有超时，获得锁

</code></pre>

<p><code>lock</code>一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在<code>lock</code>外等待，只到<code>unlock</code>，才可访问</p>

<p><code>NSLock</code>是<code>Cocoa</code>提供给我们最基本的锁对象，这也是我们经常所使用的，除了常使用的<code>lock</code>和<code>unlock</code>方法外,还提供了:<br/>
<code>trylock</code>：能加锁返回<code>YES</code>并执行加锁操作，相当于<code>lock</code>，反之返回<code>NO</code><br/>
<code>lockBeforeDate</code>：这个方法表示会在传入的时间内尝试加锁，若能加锁则执行加锁操作并返回<code>YES</code>，反之返回<code>NO</code></p>

<h2 id="toc_4">五、NSRecursiveLock递归锁</h2>

<pre><code class="language-objc">    NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        static void (^RecursiveMethod)(int);

        RecursiveMethod = ^(int value) {

            [lock lock];
            if (value &gt; 0) {

                NSLog(@&quot;value = %d&quot;, value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            [lock unlock];
        };

        RecursiveMethod(5);
    });
    //执行结果
    2016-06-30 19:09:41.414 SafeMultiThread[30949:450684] value = 5
    2016-06-30 19:09:42.418 SafeMultiThread[30949:450684] value = 4
    2016-06-30 19:09:43.419 SafeMultiThread[30949:450684] value = 3
    2016-06-30 19:09:44.424 SafeMultiThread[30949:450684] value = 2
    2016-06-30 19:09:45.426 SafeMultiThread[30949:450684] value = 1
    
    
    //在上面如果用NSLock的话就会造成死锁的情况
    NSLock *lock = [[NSLock alloc] init];
    /**
        在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次
        锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死
        锁，线程被阻塞住了。
    */
</code></pre>

<p><code>NSRecursiveLock</code>递归锁，可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。<br/>
递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>补充:<a href="http://www.cocoachina.com/ios/20150513/11808.html">NSRecursiveLock递归锁的使用</a></p>

<h2 id="toc_5">六、NSConditionLock条件锁</h2>

<p>只是<code>lock</code>和<code>unlock</code>通常并不能满足我们的使用，我们通常在满足某条件的情况下才会打开这把锁，这时候我们可以使用<code>NSConditionLock条件锁</code></p>

<pre><code class="language-objc">    NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];

//线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    if([cLock tryLockWhenCondition:0]){
        NSLog(@&quot;线程1&quot;);
       [cLock unlockWithCondition:1];
    }else{
         NSLog(@&quot;失败&quot;);
    }
});

//线程2
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [cLock lockWhenCondition:3];
    NSLog(@&quot;线程2&quot;);
    [cLock unlockWithCondition:2];
});

//线程3
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    [cLock lockWhenCondition:1];
    NSLog(@&quot;线程3&quot;);
    [cLock unlockWithCondition:3];
});
/**
    我们在初始化 NSConditionLock 对象时，给了他的标示为 0
    执行 tryLockWhenCondition:时，我们传入的条件标示也是 0,所 以线程1 加锁成功
    执行 unlockWithCondition:时，这时候会把condition由 0 修改为 1
    因为condition 修改为了  1， 会先走到 线程3，然后 线程3 又将 condition 修改为 3
    最后 走了 线程2 的流程
*/
    
</code></pre>

<p><img src="media/14964011409915/14967500416387.png" alt=""/></p>

<p>相比于 NSLock 多了个<code>condition</code>参数，我们可以理解为一个条件标示.<br/>
我们还用它实现了任务支架你的依赖</p>

<pre><code class="language-objc">//可用功能如下:
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;

@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;

@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
</code></pre>

<h2 id="toc_6">七、NSCondition</h2>

<p>一种最基本的条件锁。手动控制线程<code>wait</code>和<code>signal</code>。</p>

<pre><code class="language-objc">NSCondition *condition = [[NSCondition alloc] init];

    NSMutableArray *products = [NSMutableArray array];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@&quot;wait for product&quot;);
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@&quot;custome a product&quot;);
            [condition unlock];
        }

    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }

    });
    
2016-06-30 20:21:25.295 SafeMultiThread[31256:513991] wait for product
2016-06-30 20:21:25.296 SafeMultiThread[31256:513994] produce a product,总量:1
2016-06-30 20:21:25.296 SafeMultiThread[31256:513991] custome a product
</code></pre>

<p><code>[condition lock]</code>一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问<br/>
<code>[condition unlock]</code>与lock 同时使用<br/>
<code>[condition wait]</code>让当前线程处于等待状态<br/>
<code>[condition signal]</code>CPU发信号告诉线程不用在等待，可以继续执行</p>

<pre><code class="language-objc">- (void)wait;//进入等待状态(当一个线程调用wait时其他线程就可以获得这个锁)
- (BOOL)waitUntilDate:(NSDate *)limit;//让一个线程等待一定的时间
- (void)signal;//唤醒一个等待的线程
- (void)broadcast;//唤醒所有等待的线程
</code></pre>

<p>补充:<br/>
这里需要注意wait和signal的问题：<br/>
    1: 其实，wait函数内部悄悄的调用了unlock函数（猜测，有兴趣可自行分析），也就是说在调用wati函数后，这个NSCondition对象就处于了无锁的状态，这样其他线程就可以对此对象加锁并触发该NSCondition对象。当NSCondition被其他线程触发时，在wait函数内部得到此事件被触发的通知，然后对此事件重新调用lock函数（猜测），而在外部看起来好像接收事件的线程（调用wait的线程）从来没有放开NSCondition对象的所有权，wati线程直接由阻塞状态进入了触发状态一样。这里容易造成误解。<br/>
    2: wait函数并不是完全可信的。也就是说wait返回后，并不代表对应的事件一定被触发了，因此，为了保证线程之间的同步关系，使用NSCondtion时往往需要加入一个额外的变量来对非正常的wait返回进行规避。<br/>
   3: 关于多个wait时的调用顺序，测试发现与wait执行顺序有关。</p>

<h2 id="toc_7">八、pthread_mutex互斥锁</h2>

<pre><code class="language-objc">  __block pthread_mutex_t theLock;
    pthread_mutex_init(&amp;theLock, NULL);

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            pthread_mutex_lock(&amp;theLock);
            NSLog(@&quot;需要线程同步的操作1 开始&quot;);
            sleep(3);
            NSLog(@&quot;需要线程同步的操作1 结束&quot;);
            pthread_mutex_unlock(&amp;theLock);

    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            sleep(1);
            pthread_mutex_lock(&amp;theLock);
            NSLog(@&quot;需要线程同步的操作2&quot;);
            pthread_mutex_unlock(&amp;theLock);

    });
2016-06-30 21:13:32.440 SafeMultiThread[31429:548869] 需要线程同步的操作1 开始
2016-06-30 21:13:35.445 SafeMultiThread[31429:548869] 需要线程同步的操作1 结束
2016-06-30 21:13:35.446 SafeMultiThread[31429:548866] 需要线程同步的操作2
    /**
        与OSSpinLock类似,pthread_mutex 中也有个pthread_mutex_trylock(&amp;pLock)，和上面提
        到的 OSSpinLockTry(&amp;oslock)区别在于，前者可以加锁时返回的是 0，否则返回一个错误提示
        码；后者返回的 YES和NO
    */
</code></pre>

<pre><code class="language-objc">1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);
初始化锁变量mutex。attr为锁属性，NULL值为默认属性。
2：pthread_mutex_lock(pthread_mutex_t mutex);加锁
3：pthread_mutex_tylock(*pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。
4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁
5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放
</code></pre>

<p><code>YYKit</code>源码<br/>
<img src="media/14964011409915/14967514267813.png" alt=""/></p>

<h2 id="toc_8">九、pthread_mutex(recursive)递归锁</h2>

<p>之前的lock是和unlock成对出现，同一线程多次 lock 是不允许的，而递归锁允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</p>

<pre><code class="language-objc">static pthread_mutex_t pLock;
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁
pthread_mutex_init(&amp;pLock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用

//1.线程1
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveBlock)(int);
    RecursiveBlock = ^(int value) {
        pthread_mutex_lock(&amp;pLock);
        if (value &gt; 0) {
            NSLog(@&quot;value: %d&quot;, value);
            RecursiveBlock(value - 1);
        }
        pthread_mutex_unlock(&amp;pLock);
    };
    RecursiveBlock(5);
});
//如果我们用 pthread_mutex_init(&amp;pLock, NULL) 初始化会出现死锁的情况，递归锁能很好的避免这种情况的死锁；
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[时间 时区]]></title>
    <link href="https://acefish.github.io/14958652887586.html"/>
    <updated>2017-05-27T14:08:08+08:00</updated>
    <id>https://acefish.github.io/14958652887586.html</id>
    <content type="html"><![CDATA[
<p>1.时区 时间</p>

<p>对于机器时间 <br/>
我们平常的<br/>
周六 = 7 周日 = 1 周一 = 2</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定时器]]></title>
    <link href="https://acefish.github.io/14958642376440.html"/>
    <updated>2017-05-27T13:50:37+08:00</updated>
    <id>https://acefish.github.io/14958642376440.html</id>
    <content type="html"><![CDATA[
<p>dispatch_source_set_timer  创建的定时器也会在启动时立马执行一次要执行block  而不是等指定时间后再触发</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextView]]></title>
    <link href="https://acefish.github.io/14957029093514.html"/>
    <updated>2017-05-25T17:01:49+08:00</updated>
    <id>https://acefish.github.io/14957029093514.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">1.代理</h3>

<p>对于我们在代码中修改textView的内容是不会走delegate中的这个方法的</p>

<pre><code class="language-objc">- (void)textViewDidChange:(UITextView *)textView {}
</code></pre>

<p>也不会走这个监听</p>

<pre><code class="language-objc">[ITNotificationCenter addObserver:self selector:@selector(textViewChangeContent:) name:UITextViewTextDidChangeNotification object:nil];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TableView]]></title>
    <link href="https://acefish.github.io/14956786717356.html"/>
    <updated>2017-05-25T10:17:51+08:00</updated>
    <id>https://acefish.github.io/14956786717356.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">preservesSuperviewLayoutMargins</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xib使用]]></title>
    <link href="https://acefish.github.io/14956304598531.html"/>
    <updated>2017-05-24T20:54:19+08:00</updated>
    <id>https://acefish.github.io/14956304598531.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">SizeClasses</h2>

<p><code>SizeClass</code>并不是对控件进行布局而是用于区分不同的屏幕尺寸<br/>
SizeClass之所以能适配所有型号，就是因为三个属性Compact(紧凑),Any(所有),regular(常规)。</p>

<h2 id="toc_1">适配不同设备的xib</h2>

<h3 id="toc_2">创建适配不同设备的xib</h3>

<p><img src="media/14956304598531/870B58F4-145B-4697-906B-682877E8518A.png" alt="870B58F4-145B-4697-906B-682877E8518A"/><br/>
<code>Install</code>选项勾选即可选择这个控件是否在此类设备中显示而左边的得弹框则可以选择此类设备是指:通过选择Width 和 Height  可以选定 是ipad 还是 iphone</p>

<h3 id="toc_3">创建针对不同设备的约束</h3>

<p><img src="media/14956304598531/DED74B15-FD5B-49EF-903D-D53E1CF680B6.png" alt="DED74B15-FD5B-49EF-903D-D53E1CF680B6"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设备标识]]></title>
    <link href="https://acefish.github.io/14956302391950.html"/>
    <updated>2017-05-24T20:50:39+08:00</updated>
    <id>https://acefish.github.io/14956302391950.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDatePicker]]></title>
    <link href="https://acefish.github.io/14955051645893.html"/>
    <updated>2017-05-23T10:06:04+08:00</updated>
    <id>https://acefish.github.io/14955051645893.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">UIDatePicker</h2>

<h3 id="toc_1">1.显示24小时制</h3>

<pre><code class="language-objc">self.timePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;en_GB&quot;];
</code></pre>

<h3 id="toc_2">2.添加事件</h3>

<pre><code class="language-objc">//与pickView不同
[self.timePicker addTarget:self action:@selector(timeChanged:) forControlEvents:UIControlEventValueChanged];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD]]></title>
    <link href="https://acefish.github.io/14954386080339.html"/>
    <updated>2017-05-22T15:36:48+08:00</updated>
    <id>https://acefish.github.io/14954386080339.html</id>
    <content type="html"><![CDATA[
<p>DISPATCH_TIME_FOREVER会一直等待block结束</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#pragma]]></title>
    <link href="https://acefish.github.io/14954384117214.html"/>
    <updated>2017-05-22T15:33:31+08:00</updated>
    <id>https://acefish.github.io/14954384117214.html</id>
    <content type="html"><![CDATA[
<p>#pragma clang diagnostic push</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图层性能]]></title>
    <link href="https://acefish.github.io/14951065647732.html"/>
    <updated>2017-05-18T19:22:44+08:00</updated>
    <id>https://acefish.github.io/14951065647732.html</id>
    <content type="html"><![CDATA[
<p>图层树</p>

<p>选择性地选取光栅化或者绘制图层内容在合适的时候重新分配给CPU和GPU</p>

<h3 id="toc_0">隐式绘制</h3>

<p>我们前几章讨论了几个场景下的优化:1.通过Core Graphics直接绘制 2.直接载入一个图片文件并赋值<br/>
给<code>contents</code>属性 3.事先绘制一个屏幕之外的<code>CGContext</code>上下文</p>

<p>我们可以通过以下方式创建隐式的寄宿图:<br/>
1. 使用特定的图层属性<br/>
2. 特定的视图<br/>
3. 特定的图层子类</p>

<h4 id="toc_1">文本</h4>

<p><code>CATextLayer</code>和<code>UILabel</code>都是直接将文本绘制在图层的寄宿图中。</p>

<p>尽可能地避免改变那些包含文本的视图的<code>frame</code>，因为这样做的话文本就需要重绘。例如，如果你想在图层的角落里显示一段静态的文本，但是这个图层经常改动，你就应该把文本放在一个子图层中。</p>

<h4 id="toc_2">光栅化</h4>

<p>启用<code>CALayer</code>的<code>shouldRaterize</code>属性会将图层绘制到一个屏幕之外的图像。然后这个图像会被缓存起来并绘制到实际图层的<code>contents</code>和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。</p>

<p>光栅化使用的当可以提供很大性能优势,但是避免使用在不断变动的图层上。否则缓存没用了。</p>

<p>可以使用<code>Instrument</code>查看一下<code>Color Hits Green</code>和<code>Misses Red</code>项目，是否已光栅化图像被频繁地刷新,可以知道我们是否正确使用了光栅化</p>

<h3 id="toc_3">离屏渲染</h3>

<p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染被唤起。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。图层的以下属性将会触发屏幕外绘制：</p>

<ul>
<li>圆角（当和 maskToBounds 一起使用时）</li>
<li>图层蒙板</li>
<li>阴影</li>
</ul>

<p>屏幕外渲染和我们启用光栅化时相似，除了它并没有像光栅化图层那么消耗大，子图层并没有被影响到，而且结果也没有被缓存，所以不会有长期的内存占用。但是如果太多图层在屏幕外渲染依然会影响性能</p>

<p>如果那些离屏绘制的图层并不会被频繁重绘的话,为这些图层开启光栅化也是一种优化方式</p>

<p>对于那些需要动画而且要在屏幕外渲染的图层来说，你可以用<code>CAShapeLayer</code>，<code>contentsCenter</code>或者<code>shadowPath</code>来获得同样的表现而且较少地影响到性能。</p>

<h4 id="toc_4">CAShaprLayer(圆角)</h4>

<p><code>cornerRadius</code>和<code>maskToBounds</code>独立作用的时候都不会有太大的性能问题，但是当他俩结合在一起，就触发了屏幕外渲染。</p>

<p>为了不引起性能问题,我们可以用现成的<code>UIBezierPath</code>的构造器<code>+ bezierPathWithRoundedRect:cornerRadius:</code>虽然不比直接用<code>cornerRadius</code>更快,但是避免性能问题</p>

<pre><code class="language-objc">    - (void)viewDidLoad
    {
        [super viewDidLoad];
        //create shape layer
        CAShapeLayer *blueLayer = [CAShapeLayer layer];
        blueLayer.frame = CGRectMake(50, 50, 100, 100);
        blueLayer.fillColor = [UIColor blueColor].CGColor;
        blueLayer.path = [UIBezierPath bezierPathWithRoundedRect:
        CGRectMake(0, 0, 100, 100) cornerRadius:20].CGPath;
        //add it to our view
        [self.layerView.layer addSublayer:blueLayer];
    }
</code></pre>

<h4 id="toc_5">可伸缩图片(圆角)</h4>

<p>另外一个创建圆角矩形的方法使用一个圆形内容图片,并设置其<code>contentsCenter</code>去创建一个可伸缩图片.<br/>
理论上来说，这个应该比用<code>CAShapeLayer</code>要快，因为一个可拉伸图片只需要18个三角形（一个图片是由一个3*3网格渲染而成），然而，许多都需要渲染成一个顺滑的曲线。在实际应用上，二者并没有太大的区别。</p>

<pre><code class="language-objc">- (void)viewDidLoad
{
    [super viewDidLoad];
    //create layer
    CALayer *blueLayer = [CALayer layer];
    blueLayer.frame = CGRectMake(50, 50, 100, 100);
    blueLayer.contentsCenter = CGRectMake(0.5, 0.5, 0.0, 0.0);
    blueLayer.contentsScale = [UIScreen mainScreen].scale;
    blueLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;Circle.png&quot;].CGImage;
    //add it to our view
    [self.layerView.layer addSublayer:blueLayer];
}
/**
    使用可伸缩图片的优势在于它可以绘制成任意边框效果而不需要额外的性能消耗。举个例子，可伸缩图片
    甚至还可以显示出矩形阴影的效果。
*/
</code></pre>

<h4 id="toc_6">shadowPath</h4>

<p>对于<code>shadowPath</code>属性，对于简单的几何图形(假设不包含任何透明部分或者子视图),创建阴影路径较容易，<code>Core Animation</code>绘制这个阴影也相当简单,避免了屏幕外图层部分预排版，对性能有好处。</p>

<p>如果是个复杂的图形,那么生成阴影路径就比较困难，可以考虑用绘图软件生成一个阴影背景图</p>

<h3 id="toc_7">混合和过度绘制</h3>

<p>我们知道,<code>GPU</code>每一帧可以绘制的像素有一个最大限制（就是所谓的<code>fill rate</code>），这个情况下可以轻易地绘制整个屏幕的所有像素。但是如果由于重叠图层的关系需要不停地重绘同一区域的话，掉帧就可能发生了。</p>

<p>GPU会放弃绘制那些完全被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的。所以为了加速处理进程，不到必须时刻不要使用透明图层。<br/>
任何情况下，你应该这样做：</p>

<ul>
<li>给视图的<code>backgroundColor</code>属性设置一个固定的，不透明的颜色</li>
<li>设置<code>opaque</code>属性为YES</li>
</ul>

<p>这样减少了混合行为（因为编译器知道图层后的东西不对最终像素残生影响）计算得到加速，因为<code>Core Animation</code>完全可以舍弃所有被完全遮盖的图层，避免了过度绘制。</p>

<p>如果用到了图像，尽量避免透明除非非常必要。如果图像要显示在一个固定的背景颜色或是固定的背景图之前，你没必要相对前景移动，你只需要预填充背景图片就可以避免运行时混色了。</p>

<p>如果是文本的话，一个不透明颜色背景的<code>UILabel</code>会比透明背景要更高效。</p>

<p>最后，明智地使用<code>shouldRasterize</code>属性，可以将一个固定的图层体系折叠成单张图片，这样就不需要每一帧重新合成了，也就不会有因为子图层之间的混合和过度绘制的性能问题了。</p>

<h3 id="toc_8">减少图层数量</h3>

<p>我们的图层呈现过程:<br/>
初始化图层，处理图层，打包通过<code>IPC</code>发给渲染引擎，转化成<code>OpenGL</code>几何图形，这些是一个图层的大致资源开销。</p>

<p>事实上，一次性在屏幕上显示的最大图层数量也是有限的。这取决于于iOS设备，图层类型，图层内容和属性等。</p>

<h4 id="toc_9">裁切</h4>

<p>不可见图层：</p>

<ul>
<li>图层在屏幕边界之外，或是在父图层边界之外。</li>
<li>完全在一个不透明图层之后。</li>
<li>完全透明</li>
</ul>

<p><code>Core Animation</code>非常擅长处理对视觉效果无意义的图层。但是经常性地，你自己的代码会比<code>Core Animation</code>更早地想知道一个图层是否是有用的。理想状况下，在图层对象在创建之前就想知道，以避免创建和配置不必要图层的额外工作。</p>

<p>示例:<br/>
当我们创建了很多图层,但是这些图层也许在屏幕外也许被遮盖,显示的数量一定，那么我们增加创建图层数量就会导致帧数下降,出现性能问题。</p>

<p>但是如果计算每个图层根据是否最终显示在屏幕上这是一个很难的过程。所以我们可以用另外一种方式优化:<br/>
随着视图的滚动动态地实例化图层而不是事先都分配好,这样，我们可以在创造它之前计算出是否需要它，接着，我们增加一些代码去计算可视区域这样就可以排除区域之外的图层了。</p>

<p>类似<code>UITableView</code>或者<code>UICollectionView</code>的机制</p>

<h4 id="toc_10">对象回收</h4>

<p>处理巨大数量的相似视图或图层时还有一个技巧就是回收他们。对象回收在<code>iOS</code>颇为常见；<code>UITableView</code>和 <code>UICollectionView</code> 都有用到，<code>MKMapView</code>中的动画<code>pin</code>码也有用到，还有其他很多例子。</p>

<p>做对象回收首先需要一个有一个对象池。进行对象的存取,避免了不断创建和释放对象(相当消耗资源因为涉及到内存的分配和销毁)而且也不必给相似实例重复赋值。</p>

<pre><code class="language-objc">@property (nonatomic, strong) NSMutableSet *recyclePool;
</code></pre>

<p>注意：<br/>
在本实例中做对象回收需要禁用隐式动画,因为之前图层对象都是在呈现之前改变属性,但是现在是回收的，需要禁用隐式动画,否咋改变属性就触发隐式动画</p>

<h4 id="toc_11">Core Graphics绘制</h4>

<p>在上面我们派出了那些没有显示在屏幕上的图层,对于那些显示的对屏幕有贡献的图层和视图，我们还有减少图层数量的方法</p>

<p>比如多个<code>UILabel</code>或者<code>UIImageView</code>我们可以把他们全部替换为单独视图然后用<code>-drawRect</code>方法绘制出这些复杂的视图层级</p>

<p>这个提议看上去并不合理因为大家都知道软件绘制行为要比<code>GPU</code>合成要慢而且还需要更多的内存空间，但是在因为图层数量而使得性能受限的情况下，软件绘制很可能提高性能呢，因为它避免了图层分配和操作问题。</p>

<p>你可以自己实验一下这个情况，它包含了性能和栅格化的权衡，但是意味着你可以从图层树上去掉子图层（用<code>shouldRasterize</code>，与完全遮挡图层相反）。</p>

<h4 id="toc_12">- renderInContext: 方法</h4>

<p>用<code>Core Graphics</code>去绘制一个静态布局有时候会比用层级的<code>UIView</code>实例来得快，但是使用<code>UIView</code>实例要简单得多而且比用手写代码写出相同效果要可靠得多，更边说<code>Interface Builder</code>来得直接明了。</p>

<p>如果大量的视图或者图层真的关联到了屏幕上将会是一个大问题。没有与图层树相关联的图层不会被送到渲染引擎，也没有性能问题（在他们被创建和配置之后）。</p>

<p>我们可以使用<code>CALayer</code>的<code>- renderInContext:</code>方法，你可以将图层及其子图层快照进一个<code>Core Graphics</code>上下文然后得到一个图片，可以直接显示在<code>UIImageView</code>中或者作为另外一个图层的<code>contents</code>。不同于<code>shouldRasterize</code>(要求图层与图层树相关联)，这个方法没有持续的性能消耗。</p>

<p>当图层内容改变，不同于<code>shouldRasterize</code>的自动地处理缓存和缓存验证，这张图片的刷新时机取决于我们自己，但是一旦图片被生成,相比让<code>Core Animation</code>处理一个复杂的图层树，你节省了相当客观的性能。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CGRect]]></title>
    <link href="https://acefish.github.io/14945853244045.html"/>
    <updated>2017-05-12T18:35:24+08:00</updated>
    <id>https://acefish.github.io/14945853244045.html</id>
    <content type="html"><![CDATA[
<p><code>CGRectContainsRect</code>判断两个rect是否有交叉<br/>
<code>CGRectContainsPoint</code>判断一个点是否在rect中</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像IO]]></title>
    <link href="https://acefish.github.io/14940350647350.html"/>
    <updated>2017-05-06T09:44:24+08:00</updated>
    <id>https://acefish.github.io/14940350647350.html</id>
    <content type="html"><![CDATA[
<p>和绘图相关的是图像性能，我们研究如何从闪存驱动器或者网络中加载和显示图片</p>

<p>补充知识:<br/>
<a href="http://www.cocoachina.com/ios/20170227/18784.html">图片加载解压</a>原理知识学习<br/>
<strong>图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程</strong><br/>
事实上不管是<code>JPEG</code>还是<code>PNG</code>图片，都是一种压缩的位图图形格式。只不过<code>PNG</code>图片是无损压缩，并且支持<code>alpha</code>通道，而<code>JPEG</code>图片则是有损压缩，可以指定<code>0-100%</code>的压缩比。值得一提的是，在苹果的<code>SDK</code> 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>

<pre><code class="language-objc">UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);
 
// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)            
UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);
</code></pre>

<h3 id="toc_0">加载和潜伏</h3>

<p>绘图实际消耗的时间并不是影响性能主要因素。图片消耗很大一部分内存,而且不太可能把需要显示的图片都保留在内存中,所以在应用运行时周期性的加载和卸载图片</p>

<p>图片文件的加载速度被<code>CPU</code>和<code>IO(输入输出)</code>同时影响。iOS设备中的闪存虽然比传统硬盘块,但是比RAM仍然慢了200倍，我们需要小心加载来避免延迟</p>

<ol>
<li><p>在程序生命周期不易察觉时来加载图片</p>

<p>比如启动或者屏幕切换<br/>
按下按钮和按钮响应时间之间最大延时大概200ms,而切换每帧动画16ms<br/>
可以程序首次启动加载图片,如果启动时间过长影响用户体验,超过20s苹果就会关闭你的应用了</p>

<p>但是有时候不适合提前加载所有图片,比如图片过多或者需要从网络远程下载图片</p></li>
</ol>

<h4 id="toc_1">线程加载</h4>

<p>对于在主线程加载图片(比如<code>[UIImage imageWithContentsOfFile:</code>)如果图片较大就会卡线程,我们需要在后台加载图片,可以使用<code>GCD</code>或者<code>NSOperationQueue</code>创建自定义线程，或者使用<code>CATiledLayer</code>,为了从远程网络加载图片，我们可以使用异步的<code>NSURLConnection</code>但是对本地存储的图片，并不十分有效。</p>

<h5 id="toc_2">GCD和 NSOperationQueue</h5>

<p>GCD（Grand Central Dispatch）和 NSOperationQueue 很类似，都给我们提供了队列闭包块来在线程中按一定顺序来执行。 NSOperationQueue 有一个Objecive-C接口（而不是使用GCD的全局C函数），同样在操作优先级和依赖关系上提供了很好的粒度控制，但是需要更多地设置代码。</p>

<p>下面是  我们在低优先级的后台队列而不是主线程用<code>GCD</code>加载图片</p>

<pre><code class="language-objc">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView
cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
//dequeue cell
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot;
forIndexPath:indexPath];
    //add image view
    const NSInteger imageTag = 99;
    UIImageView *imageView = (UIImageView *)[cell viewWithTag:imageTag];
    if (!imageView) {
        imageView = [[UIImageView alloc] initWithFrame: cell.contentView.bounds];
        imageView.tag = imageTag;
        [cell.contentView addSubview:imageView];
    }
//tag cell with index and clear current image
    cell.tag = indexPath.row;
    imageView.image = nil;
    //switch to background thread
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
    //load image
        NSInteger index = indexPath.row;
        NSString *imagePath = self.imagePaths[index];
        UIImage *image = [UIImage imageWithContentsOfFile:imagePath];
        //需要在主线程更新UI
        dispatch_async(dispatch_get_main_queue(), ^{
            if (index == cell.tag) {
                imageView.image = image; 
            }
        });
    });
    return cell;
}
</code></pre>

<p>由于视图在<code>UICollectionView</code>中是会重复利用的,因此我们加载图片时需要确定是否被不同索引重复利用。为<strong>避免图片加载到错误视图中,我们在加载前把单元格打上索引标签,然后在设置图片时检测标签是否改变</strong>.</p>

<h4 id="toc_3">延迟解压</h4>

<p>在上面我们认为 <strong>性能瓶颈在于 加载图片到内存中,其实这只是问题之一</strong>.</p>

<p><strong>一旦图片文件被加载就必须要进行解码，解码过程是一个相当复杂的任务，需要消耗非常长的时间。解码后的图片将同样使用相当大的内存</strong>。</p>

<p>用于加载的CPU时间与图片格式有关,<code>PNG</code>文件较大所以加载时间比<code>JPEG</code>更长,但是解码速度较快,而且<code>Xcode</code>会把<code>PNG</code>进行解码优化后引入工程.而<code>JPEG</code>图片较小,所以加载更快但是解压要消耗更长时间,因为<code>JPEG</code>解压算法比基于<code>zip</code>的<code>PNG</code>算法更加复杂</p>

<p>在加载图片时,<strong>iOS通常会在图片加载到内存之后,绘制之前解压,这通常是消耗时间问题所在</strong><br/>
避免延时加载方法:</p>

<ol>
<li>我们可以用<code>UIImage</code>的 <code>+imageNamed: 方法</code>，它不同于<code>+imageWithContentsOfFile: （和其他别的 UIImage 加载方法）</code>它可以避免延时加载，会在加载图片后立刻解压.但是这个方法只对资源束中图片有效.</li>
<li>另一种立刻加载图片的方法就是把它设置成图层内容，或者是<code>UIImageView</code>的<code>image</code>属性,但是这都需要在主线程进行,不能提升性能.</li>
<li><p>绕过<code>UIKit</code>，像下面这样使用<code>ImageIO</code>框架</p>

<pre><code class="language-objc">NSInteger index = indexPath.row;
NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];
NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache: @YES};
CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);
UIImage *image = [UIImage imageWithCGImage:imageRef];
CGImageRelease(imageRef);
CFRelease(source);
</code></pre>

<p>可以使用<code>kCGImageSourceShouldCache</code>来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。</p></li>
</ol>

<p>最后一种方式用<code>UIKit</code>加载图片,但是会立即绘制到<code>CGContext</code>中去.因为图片必须要在绘制之前解压,所以强制了解压的及时性,好处是绘制图片可以在后台线程执行,不会阻塞UI</p>

<p>强制解压提前渲染图片：</p>

<ul>
<li>将图片的一个像素绘制成一个像素大小的<code>CGContext</code>。这样仍会解压整张图片,但是绘制本身并没有消耗任何时间.加载的图片并不会在特定设备上为绘制做优化,所以可以在任何时间点绘制出来,iOS也就可以丢弃解压后的图片来节省内存</li>
<li>将整张图片绘制到<code>CGContext</code>中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一像素更需要复杂的计算,但是因此产生的图片将会为绘制做优化,而且由于原始压缩图片被抛弃了,iOS就不能够随时丢弃任何解压后的图片来节省内存了。</li>
</ul>

<p>注意苹果特别推荐了不要使用这些诡计来绕过标准图片解压逻辑（所以也是他们选择用默认处理方式的原因）,但是如果你使用很多大图来构建应用，那如果想提升性能，就只能和系统博弈了。</p>

<p>如果不使用<code>+ imageNamed:</code>，那么把整张图片绘制到<code>CGContext</code>可能是最佳的方式了。。尽管你可能认为多余的绘制相较别的解压技术而言性能不是很高，但是新创建的图片（在特定的设备上做过优化）可能比原始图片绘制的更快。</p>

<p>同样，如果想显示图片到比原始尺寸小的容器中，那么一次性在后台线程重新绘制到正确的尺寸会比每次显示的时候都做缩放会更有效</p>

<pre><code class="language-objc">//-collectionView:cellForItemAtIndexPath: 方法来重绘图片
UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];
...
//switch to background thread
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
//load image
    NSInteger index = indexPath.row;
    NSString *imagePath = self.imagePaths[index];
    UIImage *image = [UIImage imageWithContentsOfFile:imagePath];
    //redraw image using device context
    UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, YES, 0);
    [image drawInRect:imageView.bounds];
    image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    //set image on main thread, but only if index still matches up
    dispatch_async(dispatch_get_main_queue(), ^{
        if (index == cell.tag) {
            imageView.image = image;
        }
    });
});
return cell;

</code></pre>

<h4 id="toc_4">CATiledLayer</h4>

<p>我们在学习<code>CALayer</code>一章，<code>CATiledLayer</code>可以用来异步加载和显示大型图片，而不阻塞用户输入。</p>

<p>我们同样可以用<code>CATiledLayer</code>在<code>UICollectionView</code>中为每个表格创建分离的<code>CATiledLayer</code>实例加载传动器图片，每个表格仅使用一个图层。</p>

<p>但是这样也有弊端:</p>

<ul>
<li><code>CATiledLayer</code>的队列和缓存算法没有暴露出来，所以我们只能祈祷它能匹配我们的需求</li>
<li><code>CATiledLayer</code>需要我们每次重绘图片到<code>CGContext</code>中，即使它已经解压缩，而且和我们单元格尺寸一样（因此可以直接用作图层内容，而不需要重绘）</li>
</ul>

<pre><code class="language-objc">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    //dequeue cell
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];
    //add the tiled layer
    CATiledLayer *tileLayer = [cell.contentView.layer.sublayers lastObject];
    if (!tileLayer) {
        tileLayer = [CATiledLayer layer];
        tileLayer.frame = cell.bounds;
        tileLayer.contentsScale = [UIScreen mainScreen].scale;
        tileLayer.tileSize = CGSizeMake(cell.bounds.size.width * [UIScreen mainScreen].scale, cell.bounds.size.height * [UIScreen mainScreen].scale);
        tileLayer.delegate = self;
        [tileLayer setValue:@(indexPath.row) forKey:@&quot;index&quot;];
        [cell.contentView.layer addSublayer:tileLayer];
    }
    //tag the layer with the correct index and reload
    tileLayer.contents = nil;
    [tileLayer setValue:@(indexPath.row) forKey:@&quot;index&quot;];
    [tileLayer setNeedsDisplay];
    return cell;
}

- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //get image index
    NSInteger index = [[layer valueForKey:@&quot;index&quot;] integerValue];
    //load tile image
    NSString *imagePath = self.imagePaths[index];
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];
    //calculate image rect
    CGFloat aspectRatio = tileImage.size.height / tileImage.size.width;
    CGRect imageRect = CGRectZero;
    imageRect.size.width = layer.bounds.size.width;
    imageRect.size.height = layer.bounds.size.height * aspectRatio;
    imageRect.origin.y = (layer.bounds.size.height - imageRect.size.height)/2;
    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:imageRect];
    UIGraphicsPopContext();
}

/**
CATiledLayer 的 tileSize 属性单位是像素，而不是点，所以为了保证瓦
片和表格尺寸一致，需要乘以屏幕比例因子。
在 - drawLayer:inContext: 方法中，我们需要知道图层属于哪一个 indexPath 以加载正确的图片。这里我们利用了 CALayer 的KVC来存储和检索任意的值，将图层和索引打标签
*/
</code></pre>

<p>这样确实可以很好的解决了性能问题，有个小问题是图片加载到屏幕后有个明显的淡入,我们可以通过<code>CATiledLayer</code>的<code>fadeDuration</code>属性来调整淡入速度,甚至直接不要这个淡入,但是这样没法根本上去出问题:因为<strong>图片从加载到准备绘制总是有个延时的，所以会导致滑动时图片的跳入</strong>.(不仅仅是<code>CATiledLayer</code>，我们使用<code>GCD</code>也是有这个问题的)</p>

<p>即使使用上述我们讨论的所有加载图片和缓存的技术，有时候仍然会发现实时加载大图还是有问题。就和13章中提到的那样，iPad上一整个视网膜屏图片分辨率达到了2048x1536，而且会消耗12MB的RAM（未压缩）。第三代iPad的硬件并不能支持1/60秒的帧率加载，解压和显示这种图片。即使用后台线程加载来避免动画卡顿，仍然解决不了问题。</p>

<p>我们可以在加载的同时显示一个占位图片，但这并没有根本解决问题，我们可以做到更好。</p>

<h4 id="toc_5">分辨率交换</h4>

<p>视网膜分辨率代表人眼在正常视角能分辨的最小像素尺寸.但是这只是对于静态像素来说的,当我们观察一个移动图片时,眼镜对细节不敏感,所以低分辨率图片和视网膜质量图片就没什么区别了.</p>

<p>因此我们需要快速加载和显示移动大图,可以在移动传送器的时候显示一张小图(或者低分辨率图片),然后在停止之后换为大图。这意味着我们需要存两份不同分辨率图片,不过我们在应用中为了支持retina和非retina屏,这本来就是要做的<br/>
对于那些没有可用的低分辨率图片，我们可以动态将大图绘制到较小的CGContext,然后存到某处复用</p>

<h3 id="toc_6">缓存</h3>

<p>如果很多图片要显示 最好不要提前把所有图片都加载进来,而应该在移出屏幕后立即销毁。我们可以通过选择性缓存来避免来回滚动时图片的重复加载.</p>

<p>缓存原理:存储昂贵计算后的结果(或者从闪存或者网络加载的文件)在内存中,以便后续使用.缓存本来就是一个权衡过程,消耗内存和提高性能的权衡</p>

<p>大多数情况下,iOS为我们做好了图片的缓存.</p>

<h4 id="toc_7">+ imageNamed:方法</h4>

<p>我们知道用这个方法加载图片可以立刻解压图片而不用等到绘制的时候,除此之外另外一个好处就是:<strong>它在内存中自动缓存了解压后的图片</strong>，即使你没有保留对他的任何使用</p>

<p>对于iOS中那些主要的图片(如图标、按钮和背景图片)，我们这是最简单有效的方式.在nib中的图片同样也是用这种机制。</p>

<p>当然它并不是适用任何情况,有时候我们还是要实现自己的缓存机制:</p>

<ul>
<li><code>[UIImage imageNamed:]</code>方法仅仅适用于在应用程序资源束目录下的图片，但是大多数图片都是从网络或者用户的相机中获取,这种方法也就不适用了</li>
<li><code>[UIImage imageNamed:]</code>如果用来缓存那些大图,iOS系统很可能会移除这些图片来节省内存，在切换页面时性能就会下降。所以我们队传送器的图片使用单独的缓存机制把它和应用图片的生命周期解耦</li>
<li><code>[UIImage imageNamed:]</code>缓存机制并不是公开,所以我们不能很好的控制它。例如不能检测图片是否已经缓存，不能设置缓存大小，也没法控制图片从缓存移除</li>
</ul>

<h4 id="toc_8">自定义缓存</h4>

<p>自定义一个缓存是非常困难的，需要涉及这些方面:</p>

<ul>
<li>选择一个合适的<code>缓存键 - 缓存键</code>用来做图片的唯一标识。如果实时创建图片,通常不好生成一个字符串来区分别的图片。在我们的图片传送器例子，我们可以用图片的文件名</li>
<li>提前缓存 - 当然你如果我们生成和加载的代价很大,我们会想第一次用到的时候再去加载和缓存.提前加载的逻辑是应用内就有的,但是在我们的例子中这也很好实现，因为对于给定位置和方向我们很容易判读出下一张出现的图片。</li>
<li>缓存失效 - 图片文件发生改变,我们需要怎么通知缓存更新呢。我们的例子中是存程序资源加载静态图片不需要考虑这些.对于那些可能会被修改和覆盖的图片来说我们通常给在图片缓存时打上一个时间戳当文件更新时来作比较</li>
<li>缓存回收 - 当内存不够时,我们需要用合适的算法来清空缓存.幸运的是我们可以用苹果提供的叫<code>NSCache</code>通用解决方案</li>
</ul>

<h4 id="toc_9">NSCache</h4>

<p><code>NSCache</code>和<code>NSDictionary</code>类似。你可以通过<code>- setObject:forKey:</code>和<code>- object:forKey:</code>方法分别来插入，检索。不同的是<code>NSCache</code>在系统低内存是自动丢弃存储对象</p>

<p><code>NSCache</code>用来判断何时丢弃对象的算法并没有在文档中给出，但是你可以使用<code>- setCountLimit:</code>方法设置缓存大小，以及<code>- setObject:forKey:cost:</code>来对每个存储的对象指定消耗的值来提供一些暗示。</p>

<p>指定消耗数值可以用来指定相对的重建成本。如果对大图指定一个大的消耗值，那么缓存就知道这些物体的存储更加昂贵，于是当有大的性能问题的时候才会丢弃这些物体。你也可以用<code>- setTotalCostLimit:</code>方法来指定全体缓存的尺寸。</p>

<p><code>NSCache</code>是一个普遍的缓存解决方案</p>

<p>使用图片缓存和提前加载来扩展之前的传送器案例:</p>

<pre><code class="language-objc">- (UIImage *)loadImageAtIndex:(NSUInteger)index
{
    //set up cache
    static NSCache *cache = nil;
    if (!cache) {
        cache = [[NSCache alloc] init];
    }
    //if already cached, return immediately
    UIImage *image = [cache objectForKey:@(index)];
    if (image) {
        return [image isKindOfClass:[NSNull class]]? nil: image;
    }
    //set placeholder to avoid reloading image multiple times
    [cache setObject:[NSNull null] forKey:@(index)];
    //switch to background thread
    dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
        //load image
        NSString *imagePath = self.imagePaths[index];
        UIImage *image = [UIImage imageWithContentsOfFile:imagePath];
        //redraw image using device context
        UIGraphicsBeginImageContextWithOptions(image.size, YES, 0);
        [image drawAtPoint:CGPointZero];
        image = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();
        //set image for correct image view
        dispatch_async(dispatch_get_main_queue(), ^{ //cache the image
            [cache setObject:image forKey:@(index)];
            //display the image
            NSIndexPath *indexPath = [NSIndexPath indexPathForItem: index inSection:0]; 
            UICollectionViewCell *cell = [self.collectionView cellForItemAtIndexPath:indexPath];
            UIImageView *imageView = [cell.contentView.subviews lastObject];
            imageView.image = image;
        });
    });
    //not loaded yet
    return nil;
    }
    
    //效果确实更好了
</code></pre>

<h3 id="toc_10">文件格式</h3>

<p><strong>图片加载性能取决于加载大图的时间和解压小图的权衡</strong>.<br/>
很多苹果文档都说<code>PNG</code>是<code>iOS</code>所有图片加载的最好算法，但这是<strong>极度误导的过时信息</strong>了</p>

<p><code>PNG</code>图片使用的无损压缩算法可以比使用<code>JPEG</code>的图片做到更快地解压，但是由于闪存访问的原因，这些加载的时间并没有什么区别。</p>

<p>经过测试:<br/>
<code>PNG</code>和<code>JPEG</code>压缩算法作用于两种不同的图片类型：<code>JPEG</code>对于噪点大的图片效果很好；但是<code>PNG</code>更适合于扁平颜色，锋利的线条或者一些渐变色的图片。</p>

<p><img src="media/14940350647350/14949362399011.jpg" alt=""/></p>

<p>但是<code>JPEG</code>图片并不是所有情况都适用，如果图片需要透明效果或者压缩之后细节损失很多,就需要用别的格式了</p>

<h4 id="toc_11">混合图片</h4>

<p>对于包含透明的图片来说，最好是使用压缩透明通道的PNG图片和压缩RGB部分的JPEG图片混合起来加载。这就对任何格式都适用了，而且无论从质量还是文件尺寸还是加载性能来说都和PNG和JPEG的图片相近。</p>

<pre><code class="language-objc">- (void)viewDidLoad
{
    [super viewDidLoad];
    //load color image
    UIImage *image = [UIImage imageNamed:@&quot;Snowman.jpg&quot;];
    //load mask image
    UIImage *mask = [UIImage imageNamed:@&quot;SnowmanMask.png&quot;];
    //convert mask to correct format
    CGColorSpaceRef graySpace = CGColorSpaceCreateDeviceGray();
    CGImageRef maskRef = CGImageCreateCopyWithColorSpace(mask.CGImage, graySpace);
    CGColorSpaceRelease(graySpace);
    //combine images
    CGImageRef resultRef = CGImageCreateWithMask(image.CGImage, maskRef);
    UIImage *result = [UIImage imageWithCGImage:resultRef];
    CGImageRelease(resultRef);
    CGImageRelease(maskRef);
    //display result
    self.imageView.image = result;
}
</code></pre>

<p>我们不可能对每张图片都使用两个独立文件:<br/>
我们可以用一个第三方的<a href="https://github.com/nicklockwood/JPNG">JPNG库</a>，对这个技术提供了开源可复用的实现,并且直接添加<code>+imageNamed:</code>和 <code>+imageWithContentsOfFile:</code>方法的支持</p>

<h4 id="toc_12">JPEG 2000</h4>

<p>除了JPEG和PNG之外iOS还支持别的一些格式，例如TIFF和GIF，但是由于他们质量压缩得更厉害，性能比JPEG和PNG糟糕的多，所以大多数情况并不用考虑。</p>

<p>苹果低调添加了对<code>JPEG 2000</code>图片格式的支持，虽然并不是很好的支持,但是<code>JPEG 2000</code>图片在（设备和模拟器）运行时会有效，而且比<code>JPEG</code>质量更好，同样也对透明通道有很好的支持。但是<code>JPEG 2000</code>图片在加载和显示图片方面明显要比<code>PNG</code>和<code>JPEG</code>慢得多，所以对图片大小比运行效率更敏感的时候，使用它是一个不错的选择。</p>

<h4 id="toc_13">PVRTC</h4>

<p>当前iOS设备都有用<code>Imagination Technologies PowerVR</code>图像芯片作为<code>GPU</code>，<code>PowerVR</code>芯片支持一种叫做<code>PVRTC</code>的标准图片压缩.</p>

<p>和其他大多数图片格式不同,PVRTC不用提前解压就可以直接绘制到屏幕上。意味着在加载图片之后不需要有解压操作，所以内存中的图片比其他图片格式大大减少了(这取决于压缩设置，大概只有1/60那么大)</p>

<p>弊端：</p>

<ul>
<li>虽然它加载时消耗的<code>RAM</code>少,但是文件比<code>JPEG</code>大，甚至比<code>PNG</code>还大</li>
<li><code>PVRTC</code>必须是二维正方形</li>
<li>质量并不好，尤其是透明图片</li>
<li>PVRTC不能用Core Graphics绘制，也不能在普通的 UIImageView 显示，也不能直接用作图层的内容。你必须要用作OpenGL纹理加载PVRTC图片，然后映射到一对三角板来在 CAEAGLLayer 或者 GLKView 中显示。</li>
<li>OpenGL纹理加载PVRTC图片开销很大</li>
<li>使用的是不对称压缩算法,尽管立即解压 但是压缩过程很漫长</li>
</ul>

<p>如果愿意使用<code>OpenGL</code>,也愿意提前生成图片,那么可以用<code>PVRTC</code>，将提供相对于别的可用格式来说非常高效的加载性能。</p>

<p>我们可以使用<a href="http://www.imgtec.com/powervr/insider/sdkdownloads">Imagination Technologies PVRTexTool</a>，</p>

<pre><code class="language-objc">//终端将PNG转换为PVRTC命令
/Applications/Imagination/PowerVR/GraphicsSDK/PVRTexTool/CL/OSX_x86/PVRTexToolCL -i {input_file_name}.png -o {output_file_name}.pvr -legacypvr -p -f PVRTC1_4 -q pvrtcbest
</code></pre>

<p>用<code>openGL</code>实现<code>UIImageView</code>功能： <a href="https://github.com/nicklockwood/GLView">GLView的库</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效绘图]]></title>
    <link href="https://acefish.github.io/14939015823586.html"/>
    <updated>2017-05-04T20:39:42+08:00</updated>
    <id>https://acefish.github.io/14939015823586.html</id>
    <content type="html"><![CDATA[
<p>如果实现了<code>CALayerDelegate</code>协议中的<code>- srawLayer:inContext:</code>方法或者<code>UIView</code>的<code>- drawRect</code>方法（其实就是前者的包装）,图层创建了一个绘制上下文，需要的内存大小就是<code>图层宽*图层高*4字节(宽高单位是像素)</code>,图层每次绘制都需要抹掉内存重新分配</p>

<p>关于绘制的性能<br/>
提高绘制性能或者减少需要绘制的数量</p>

<h3 id="toc_0">软件绘图</h3>

<p>在<code>Core Animation</code>中的绘图通常是指<strong>软件绘图</strong><br/>
在iOS中，软件绘图通常是由<code>Core Graphics</code>框架完成来完成。但是，在一些必要的情况下，相比<code>Core Animation</code>和<code>OpenGL</code>，<code>Core Graphics</code>要慢了不少。</p>

<p>软件绘图不仅效率很低 而且很耗内存.CALayer只需要和自己相关的内存,只有他的寄宿图会消耗一点内存控件，即使直接赋给<code>contents</code>属性一张图片,也不需要增加额外的照片存储大小,如果相同的一张图片被多个图层作为<code>contents</code>属性，那么他们将会共用同一块内存，而不是复制内存块。</p>

<p><strong>但是如果实现了<code>CALayerDelegate</code>协议中的<code>- srawLayer:inContext:</code>方法或者<code>UIView</code>的<code>- drawRect</code>方法（其实就是前者的包装）,图层创建了一个绘制上下文，需要的内存大小就是<code>图层宽*图层高*4字节(宽高单位是像素)</code>,图层每次绘制都需要抹掉内存重新分配</strong></p>

<p><strong>绘图代价很大，尽量避免重绘你的视图</strong></p>

<h3 id="toc_1">矢量图形</h3>

<p>我们用的矢量绘图包含:</p>

<ul>
<li>任意多边形</li>
<li>斜线或曲线</li>
<li>文本</li>
<li>渐变</li>
</ul>

<p>实现一个划线应用:将用户的触摸手势转换成一个 UIBezierPath 上的点，然后绘制成视图。</p>

<p>1.用<code>Core Graphic</code>基于<code>drawRect</code>绘制</p>

<pre><code class="language-objc">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    CGPoint point = [[touches anyObject] locationInView:self];
    [self.path addLineToPoint:point];
    [self setNeedsDisplay];
}
- (void)drawRect:(CGRect)rect
{
    [[UIColor clearColor] setFill];
    [[UIColor redColor] setStroke];
    [self.path stroke];
}
</code></pre>

<p><code>[self setNeedsDisplay];</code>可以重绘视图,再次走<code>drawRect</code>方法,但是如果一直重绘而且绘制工作量增大就会导致帧数下降.</p>

<p>2.用<code>CAShaperLayer</code>绘制</p>

<pre><code class="language-objc">+ (Class)layerClass
{
    return [CAShapeLayer class];
}
</code></pre>

<p><code>Core Animation</code>为这些图层类型提供了专门的类，并提供了硬件支持,比如<code>CAShapeLayer</code>可以绘制多边形，直线和曲线。 <code>CATextLayer</code>可以绘制文本。<code>CAGradientLayer</code>用来绘制渐变。这些总体上都比<code>Core Graphics</code>更快，同时他们也避免了创造一个寄宿图。(<strong>这些图层是CA提供的,而我们的绘图用的是CG</strong>)</p>

<p>因此对于绘制矢量图层我们可以重写<code>UIView</code>的<code>layer</code>然后只需要将绘制的<code>path</code>赋值<code>CAShapeLayer</code>的<code>path</code>即可绘制，虽然性能依然下降但不明显几乎感觉不到帧率差异</p>

<h3 id="toc_2">脏矩形</h3>

<p>有时候我们没办法用<code>CAShapeLayer</code>等图层来代替<code>Core Graphics</code>，对于上面的例子,我们为了进一步提高性能,我们用一个“线刷”图片粘贴到用户手指触碰的地方</p>

<p>我们如果在用户手指移动就重绘视图将图片粘贴到用户手指移动过的所有点,这样绘制越多就越慢,仍会引起性能问题</p>

<p>为了减少不必要的绘制,Mac OS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。<strong>那些需要重绘的部分被称作『脏区域』。</strong>为了方便我们通常指出包含需要重绘的视图的矩形位置,就是<strong>脏矩形</strong></p>

<p>只改变了视图的部分区域的,重绘整个整个寄宿图就太浪费了,我们可以通过提供重绘区域.</p>

<p>当检测到需要重绘的区域时通过<code>setNeedsDisplayInRect:</code>标记,这样就会在一次试图刷新时调用调用视图的<code>- drawRect:</code>（或图层代理的<code>- drawLayer:inContext:</code>方法）</p>

<p>传入<code>- drawLayer:inContext:</code>的<code>CGContext</code>参数会自动被裁切以适应对应的矩形。为了确定矩形的尺寸大小，你可以用<code>CGContextGetClipBoundingBox()</code>方法来从上下文获得大小。调用<code>- drawRect()</code>会更简单，因为<code>CGRect</code>会作为参数直接传入。</p>

<p>当然如果你的裁剪逻辑相当复杂,那还是是让<code>Core Graphics</code>来为你重绘吧，</p>

<pre><code class="language-objc">- (void)addBrushStrokeAtPoint:(CGPoint)point
{
    //add brush stroke to array
    [self.strokes addObject:[NSValue valueWithCGPoint:point]];
    //set dirty rect
    [self setNeedsDisplayInRect:[self brushRectForPoint:point]];
}
- (CGRect)brushRectForPoint:(CGPoint)point
{
    return CGRectMake(point.x - BRUSH_SIZE/2, point.y - BRUSH_SIZE/2, BRUSH_SIZE, BRUSH_SIZE);
}
- (void)drawRect:(CGRect)rect
{
    //redraw strokes
    for (NSValue *value in self.strokes) {
        //get point
        CGPoint point = [value CGPointValue];
        //get brush rect
        CGRect brushRect = [self brushRectForPoint:point];
        //only draw brush stroke if it intersects dirty rect
        if (CGRectIntersectsRect(rect, brushRect)) {
        //draw brush stroke
        [[UIImage imageNamed:@&quot;Chalk.png&quot;] drawInRect:brushRect];
        }
    }
}
</code></pre>

<h3 id="toc_3">异步绘制</h3>

<p><code>UIKit</code>的单线程天性意味着寄宿图通畅要在主线程上更新，这意味着绘制会打断用户交互，甚至让整个<code>app</code>看起来处于无响应状态。</p>

<p>为了可以避免用户等待绘制：</p>

<h4 id="toc_4">CATiledLayer</h4>

<p><code>CATiledLayer</code>除了将图层再次分割成独立更新的小块外<br/>
<code>CATiledLayer</code>还有一个有趣的特性：在多个线程中为每个小块同时调用<code>- drawLayer:inContext:</code>方法。<br/>
这就避免了阻塞用户交互而且能够利用多核心新片来更快地绘制。只有一个小块的<code>CATiledLayer</code>是实现异步更新图片视图的简单方法。</p>

<h4 id="toc_5">drawsAsynchronously</h4>

<p>苹果为<code>CALayer</code>引入了这个令人好奇的属性，<code>drawsAsynchronously</code>属性对传入<code>-drawLayer:inContext:</code>的<code>CGContext</code>进行改动，允许<code>CGContext</code>延缓绘制命令的执行以至于不阻塞用户交互。</p>

<p>它与<code>CATiledLayer</code>使用的异步绘制并不相同。它自己的 <code>- drawLayer:inContext:</code>方法只会在主线程调用，但是<code>CGContext</code>并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。</p>

<p>根据苹果的说法。这个特性在需要频繁重绘的视图上效果最好（比如我们的绘图应用，或者诸如UITableViewCell 之类的），对那些只绘制一次或很少重绘的图层内容来说没什么太大的帮助。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用动画示例]]></title>
    <link href="https://acefish.github.io/14925128921601.html"/>
    <updated>2017-04-18T18:54:52+08:00</updated>
    <id>https://acefish.github.io/14925128921601.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">1.地震动画</h3>

<p>适合一整个大视图的突然晃动</p>

<pre><code class="language-objc">- (void)earthquake:(UIView*)itemView {
    CGFloat t = 2.0;
    CGAffineTransform leftQuake  = CGAffineTransformTranslate(CGAffineTransformIdentity, t, 0);
    CGAffineTransform rightQuake = CGAffineTransformTranslate(CGAffineTransformIdentity, -t, 0); //水平晃动

    itemView.transform = leftQuake;  // starting point

    [UIView beginAnimations:@&quot;earthquake&quot; context:(__bridge void *)(itemView)];
    [UIView setAnimationRepeatAutoreverses:YES]; // 如果不加这一句 整个动画感觉不连贯
    [UIView setAnimationRepeatCount:5];
    [UIView setAnimationDuration:0.07];
    [UIView setAnimationDelegate:self];
    [UIView setAnimationDidStopSelector:@selector(earthquakeEnded:finished:context:)];

    itemView.transform = rightQuake; // end here &amp; auto-reverse

    [UIView commitAnimations];
}

- (void)earthquakeEnded:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context {
    if ([finished boolValue]) {
        UIView* item = (__bridge UIView *)context;
        item.transform = CGAffineTransformIdentity;
    }
}
</code></pre>

<h3 id="toc_1">2.图标的抖动效果</h3>

<pre><code class="language-objc">//开始抖动
-(void)BeginWobble
{

    srand([[NSDate date] timeIntervalSince1970]);
    float rand=(float)random();
    CFTimeInterval t=rand*0.0000000001;

    [UIView animateWithDuration:0.1 delay:t options:0  animations:^
     {
         要抖动的视图.transform=CGAffineTransformMakeRotation(-0.05);
     } completion:^(BOOL finished)
     {
         [UIView animateWithDuration:0.1 delay:0 options:UIViewAnimationOptionRepeat|UIViewAnimationOptionAutoreverse|UIViewAnimationOptionAllowUserInteraction  animations:^
          {
              要抖动的视图.transform=CGAffineTransformMakeRotation(0.05);
          } completion:^(BOOL finished) {}];
     }];
}
//停止抖动
-(void)EndWobble
{

    [UIView animateWithDuration:0.1 delay:0 options:UIViewAnimationOptionAllowUserInteraction|UIViewAnimationOptionBeginFromCurrentState animations:^
     {
         要抖动的视图.transform=CGAffineTransformIdentity;
     } completion:^(BOOL finished) {}];
}

</code></pre>

]]></content>
  </entry>
  
</feed>
