<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2018-07-18T15:34:30+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[函数]]></title>
    <link href="https://acefish.github.io/15318121291068.html"/>
    <updated>2018-07-17T15:22:09+08:00</updated>
    <id>https://acefish.github.io/15318121291068.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">常用函数</h2>

<h3 id="toc_1">类型转换</h3>

<pre><code class="language-python">int(&#39;123&#39;)
123
&gt;&gt;&gt; int(12.34)
12
&gt;&gt;&gt; float(&#39;12.34&#39;)
12.34
&gt;&gt;&gt; str(1.23)
&#39;1.23&#39;
&gt;&gt;&gt; str(100)
&#39;100&#39;
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(&#39;&#39;)
False
</code></pre>

<h2 id="toc_2">定义函数</h2>

<pre><code class="language-python">def my_abs(x):
    # 检查参数类型 
    if not isinstance(x, (int, float)):
       # 当参数类型错误时  抛出错误
        raise TypeError(&quot;bad operate Params type&quot;)

    if x&gt;0:
        return x
    else:
        return -x

print(my_abs(&quot;-333&quot;)) #TypeError: bad operate Params type
</code></pre>

<p>定义一个空函数</p>

<pre><code class="language-python">def nop():
    pass
# pass用作占位符 
</code></pre>

<p>返回多个返回值<br/>
返回的其实为单一一个值，一个<code>元组</code>,我们通过多个变量接收一个元组,按位置赋值</p>

<pre><code class="language-python">import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

x, y = move(100, 100, 60, math.pi / 6)
print(x, y)
151.96152422706632 70.0
</code></pre>

<blockquote>
<p>若函数结束时没有<code>return</code>语句，就自动添加 <code>return None</code></p>
</blockquote>

<h2 id="toc_3">函数参数</h2>

<p>python的函数定义简单,灵活度很大.除了正常的必选参数外,还能使用默认参数、可变参数、关键字参数。</p>

<p><strong>参数组合</strong></p>

<blockquote>
<p>在Python中，可以使用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，但是参数的定义顺序必须是:<code>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</code></p>
</blockquote>

<pre><code class="language-python">def f1(a, b, c=0, *args, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)

def f2(a, b, c=0, *, d, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)
</code></pre>

<h3 id="toc_4">默认参数</h3>

<p>必选参数在前,默认参数在后</p>

<pre><code class="language-python">def my_power(x, n=2):
    total = 1
    for s in range(1,n+1):
        total = total*x
    return total

print(my_power(2))  # 4
</code></pre>

<p><strong>定义默认参数时: 默认参数必须指向不变对象,否则可变对象会成为函数内静态变量会在多次调用时变化，影响函数调用结果</strong></p>

<blockquote>
<p>使用默认参数即可省略参数，降低调用难度</p>
</blockquote>

<h3 id="toc_5">可变参数</h3>

<p>当不确定参数的个数时,可以使用可变参数，可以传入任意个参数,包括0个参数</p>

<pre><code class="language-python">def my_sum(*numbers):
    sum=0
    for x in numbers:
        sum += x

    return sum

print(my_sum(1,2,3,4)) # 10
numbers = [1,2,3,4,5]
#通过给list 或者 tuple前加*  将其元素变为可变参数
print(my_sum(*numbers)) #15 
</code></pre>

<p>传入的可变参数在函数内部封装为一个元组</p>

<h3 id="toc_6">关键字参数</h3>

<p>可以传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动封装为dict</p>

<pre><code class="language-python">def my_personFuc(name, age, **kw):
    print(&quot;name:&quot;, name, &quot;age:&quot;, age, kw)

my_personFuc(&quot;lyy&quot;, 24, city=&quot;luoyang&quot;) #name: lyy age: 24 {&#39;city&#39;: &#39;luoyang&#39;}
my_personFuc(&quot;wt&quot;, 20) # name: wt age: 20 {}

kwDict={&quot;city&quot;:&quot;beijing&quot;}
# 解构字典
my_personFuc(&quot;yt&quot;, &quot;25&quot;, **kwDict) # name: yt age: 25 {&#39;city&#39;: &#39;beijing&#39;}
</code></pre>

<blockquote>
<p>对于关键字参数，对于直接传入的参数，采用<code>=</code>而且<code>key</code>不能为str类似的字符串</p>
</blockquote>

<h3 id="toc_7">命名关键字参数</h3>

<pre><code class="language-python">#命名需要关键字 * ，在 * 之后的为命名关键字参数，
def my_keyPerson(name, age, *, city, job):
    print(name, age, city, job)

#命名关键字必须传入参数名 否则会报错 
my_keyPerson(&quot;lyy&quot;, 24, city=&quot;luoyang&quot;, job=&quot;iOS&quot;) # lyy 24 luoyang iOS

# 可以为可变参数隔开
def my_keyPerson1(name, age, *args, city, job):
    print(name, age, args, city, job)

# 明明关键字可以有缺省值,这样调用时候可以不传入city参数
def my_keyPerson2(name, age, *, city=&#39;Beijing&#39;, job):
    print(name, age, city, job)

</code></pre>

<h2 id="toc_8">递归函数</h2>

<p>解决递归调用栈溢出的方法是通过<code>尾递归优化</code>，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。<br/>
<code>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</code>。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况</p>

<pre><code class="language-python"># 递归函数
def fact(n):
    if n==1:
        return 1
    return n + fact(n - 1)

print(fact(10))  # 55
# 栈溢出
print(fact(1000))  #RecursionError: maximum recursion depth exceeded in comparison

#尾递归优化后
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
</code></pre>

<blockquote>
<p>目前包括Python在内的编程语言都没有做尾递归优化,因此类似上面的尾递归优化之后仍会导致栈溢出</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语句]]></title>
    <link href="https://acefish.github.io/15317414032911.html"/>
    <updated>2018-07-16T19:43:23+08:00</updated>
    <id>https://acefish.github.io/15317414032911.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">list</h2>

<pre><code class="language-python">
list1=[1, 2, 3]

print(len(list1)) #长度 3
print(&quot;第一个元素:%s&quot; % (list1[0])) #从0开始获取第一个元素 1
print(&quot;最后一个元素:%s&quot; % (list1[-1])) #从-1开始获取最后一个元素 3

list1.append(4) #追加元素到末尾
print(&quot;m末尾追加元素：%s&quot;%(list1[-1]))  # 4

list1.insert(1, 1) #向索引1插入1
print(list1)  # [1, 1, 2, 3, 4]

list1.pop() #删除末尾元素
print(list1)  # [1, 1, 2, 3]

list1.pop(1) #删除指定索引位置元素
print(list1)  # [1, 2, 3]

list1[1] = 1 #替换元素
print(list1)  # [1, 1, 3]

list1[2] = &quot;第3个元素&quot;  #list中的数据类型可以不同
list1.append(False)
list1.append([5,6])
print(list1)  # [1, 1, &#39;第3个元素&#39;, False, [5, 6]]
</code></pre>

<h2 id="toc_1">tuple</h2>

<pre><code class="language-python">tuple1=(1,) #定义只有一个元素的元组 不能使用 tuple1=(1)这样定义为1这个数
print(tuple1) # (1,)
#tuple一经定义便不能修改，不过不变的是每个元素的指向,而可以修改器内指针元素指向的对象
tuple2=() # 定义一个空元组
</code></pre>

<blockquote>
<p>因为tuple与list相比不能修改,所以更安全，尽量使用元组</p>
</blockquote>

<h2 id="toc_2">条件语句</h2>

<pre><code class="language-python">if len(tuple2)==0:
    print(&quot;空元组&quot;)
elif len(tuple2)&gt;0:   # else if的缩写
    print(&quot;非空数组&quot;)
else:
    print(&quot;无效&quot;)
</code></pre>

<blockquote>
<p>对于判断条件中的非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code></p>
</blockquote>

<h2 id="toc_3">input</h2>

<pre><code class="language-python">birth=input(&quot;birth:&quot;)
birth=int(birth)
if birth &gt; 25:
    print(&quot;人到中年，身不由己&quot;)
else:
    print(&quot;你还年轻&quot;)
</code></pre>

<blockquote>
<p>input默认导入的为一个字符串 因此需要转换类型为int才能进行与数字进行比较</p>
</blockquote>

<h2 id="toc_4">for循环</h2>

<pre><code class="language-python">for x in list1: #遍历列表
    print(x)

for x in range(1,10): 
    print(x)
</code></pre>

<h2 id="toc_5">break continue</h2>

<p><code>break</code>用于提前退出循环<br/>
<code>continue</code>用于跳过当前这次循环</p>

<pre><code class="language-python">for x in range(1,10):
    if x==5:
        break
    print(x)
    
    for x in range(1,10):
    if x==5:
        continue
    print(x)
</code></pre>

<blockquote>
<p>不要滥用break和continue，容易逻辑分差太多而出错</p>
</blockquote>

<h2 id="toc_6">dict</h2>

<pre><code class="language-python">dict1={&quot;lyy&quot;:25, &quot;wtt&quot;:20}
dict1[None] = 10
dict1[&#39;Adam&#39;] = 67
print(dict1[None]) # 10
print(dict1) #{&#39;lyy&#39;: 25, &#39;wtt&#39;: 20, None: 10, &#39;Adam&#39;: 67}

#判断key是否存在  key in dict
if &quot;lyy&quot; in dict1:
    print(dict1[&quot;lyy&quot;])   #25

print(dict1.get(&quot;eee&quot;, &quot;placehoder&quot;)) #placehoder  获取key如果没有就返回None或自指定的value

dict1.pop(&quot;lyy&quot;)  #pop删除指定键
if &quot;lyy&quot; in dict1:
    print(dict1[&quot;lyy&quot;])
else:
    print(&quot;lyy不存在&quot;)  #不存在
    

dict1[(1,)] = &quot;name&quot;  #用元组作为key
print(dict1[(1,)])  #name
#虽然元组也是不可变对象 但是元素不能为list等可变对象
dict1[(1,[1,2])] = &quot;name&quot;  #报错  unhashable type: &#39;list&#39;
</code></pre>

<p><code>dict</code>的<code>key</code>必须为不可变对象,例如字符串，整数等，而list是可变的不能作为key</p>

<blockquote>
<p>和list比较，dict有以下几个特点：<br/>
查找和插入的速度极快，不会随着key的增加而变慢；<br/>
需要占用大量的内存，内存浪费多。<br/>
而list相反：<br/>
查找和插入的时间随着元素的增加而增加；<br/>
占用空间小，浪费内存很少。</p>
</blockquote>

<h2 id="toc_7">Set</h2>

<p><code>set</code>中不能元素不能重复,因此只能为不可变对象</p>

<p>要创建<code>set</code>需要用<code>list</code>作为输入集合</p>

<pre><code class="language-python">set1 = set([1, &quot;name&quot;, 1])
print(set1)  # {1, &#39;name&#39;}
set1.add(&quot;1&quot;)
set1.add(1)
print(set1)  # {1, &#39;1&#39;, &#39;name&#39;}
set1.remove(1)
print(set1)  # {&#39;1&#39;, &#39;name&#39;}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python基础]]></title>
    <link href="https://acefish.github.io/15317258769792.html"/>
    <updated>2018-07-16T15:24:36+08:00</updated>
    <id>https://acefish.github.io/15317258769792.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">数据类型</h2>

<h3 id="toc_1">字符串</h3>

<p><strong>字符串是不可变的</strong></p>

<ol>
<li>用<code>&#39;</code>或者<code>&quot;</code>括起来的文本</li>
<li>可以通过 <code>\</code>转义字符来在文本中转义,进行<code>\n</code>换行 <code>\t</code>制表</li>
<li>可以通过在文本前加<code>r</code>表示文本不转义</li>
<li>用三个单引号<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的文本可以在内部直接换行而不需要<code>\n</code></li>
</ol>

<pre><code class="language-python">print(&quot;hello, world&quot;)
print(&quot;I\&#39;m OK!&quot;)
print(&quot;\t文本&quot;)
print(r&#39;&#39;&#39;\\line1
line2
line3aaaa&#39;&#39;&#39;)
</code></pre>

<h3 id="toc_2">布尔</h3>

<p><code>True</code>  真<br/>
<code>False</code> 假</p>

<p>布尔运算<br/>
<code>and</code>  与<br/>
<code>or</code>   或<br/>
<code>not</code>  非</p>

<h3 id="toc_3">空值</h3>

<p><code>None</code>表示空值</p>

<h2 id="toc_4">变量</h2>

<p>定义变量<br/>
<code>a=1</code></p>

<blockquote>
<p>python是动态语言 因此可以将同步类型的变量赋值给同一变量</p>
</blockquote>

<pre><code class="language-python">a=False
a=&quot;aa&quot;
print(a)
</code></pre>

<h2 id="toc_5">常量</h2>

<p>在python中常用全大写的变量名来表示常量</p>

<blockquote>
<p>python中除法<code>/</code>的结果为浮点数(即使整除),  <code>//</code>为地板除，两个除法的结果仍为整数</p>
</blockquote>

<pre><code class="language-python">print(10/3)   3.3333333333333335
print(10//3)   3
print(9/3)    3.0
print(9//3)   3
print(12.7//5.1)   2.0
print(1.2/3)    0.39999999999999997
</code></pre>

<h2 id="toc_6">编码</h2>

<p>在python3中字符串以Unicode编码，</p>

<p>可以通过<code>ord()</code>函数获取字符的整数表示<br/>
可以通过<code>chr()</code>函数将编码转为对应字符</p>

<pre><code class="language-python">print(ord(&quot;😱&quot;)) //128561
print(chr(128561)) //😱
//当知道字符的整数编码,可以用16进制来写str
print(&#39;\u4e2d\u6587&#39;) //中文
</code></pre>

<p>Python对bytes类型的数据用带<code>b</code>前缀的单引号或双引号表示:</p>

<pre><code class="language-python">x = b&#39;ABC&#39;
</code></pre>

<blockquote>
<p>python的字符串<code>str</code>在内存中以Unicode表示,当在网上传输或者保存磁盘时,需要将其转为以字节为单位的<code>bytes</code>使用<code>encode()</code>,而当从网络或磁盘读取数据读到的是<code>bytes</code>,将butes转为str，使用<code>decode()</code>方法</p>
</blockquote>

<p>可以通过<code>encode()</code>方法将<code>str</code>编码为指定的<code>bytes</code></p>

<pre><code class="language-python">print(&quot;中文&quot;.encode(&quot;utf-8&quot;))  # b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
print(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;))  #中文

#如果bytes中存在一小部分无效字节,可以添加errors=&#39;ignore&#39;来忽略错误的字节
b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)  #中
</code></pre>

<p><code>len()</code>函数用来计算<code>str</code>字符串的字符数,对于<code>bytes</code>则计算其字节数:</p>

<pre><code class="language-python">&gt;&gt;&gt; len(b&#39;ABC&#39;)
3
&gt;&gt;&gt; len(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
6
&gt;&gt;&gt; len(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
</code></pre>

<blockquote>
<p>为避免乱码,请坚持使用UTF-8编码进行转换,因此对于python的源码文件,指定其为UTF-8编码保存,并通过<code># -*- coding: utf-8 -*-</code>告诉编译器按照UTF-8读取源码</p>
</blockquote>

<p><strong><code># -*- coding: utf-8 -*-</code></strong></p>

<h2 id="toc_7">格式化</h2>

<pre><code class="language-python"># 格式化
print(&quot;这是字符串的%s格式化&quot; % (&quot;栗豫塬&quot;))
print(&quot;my name is %s age is %d height %.2f&quot; % (&quot;栗豫塬&quot;, 24, 17.0))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stack Navigation]]></title>
    <link href="https://acefish.github.io/15312926184354.html"/>
    <updated>2018-07-11T15:03:38+08:00</updated>
    <id>https://acefish.github.io/15312926184354.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">navigationOptions</h3>

<p>title: 导航栏的标题</p>

<p>header: 导航栏设置对象</p>

<p>headerTitle: 导航栏的标题, 可以是字符串也可以是个组件<br/>
headerBackTitle: 左上角的返回键文字, 默认是上一个页面的title，设置这个属性会覆盖掉title的值<br/>
headerRight: 导航栏右按钮<br/>
headerLeft: 导航栏左按钮<br/>
headerStyle: 导航栏的style<br/>
headerTitleStyle: 导航栏的title的style<br/>
headerTintColor: 返回按钮的颜色<br/>
headerPressColorAndroid ：按压返回按钮显示的颜色 安卓系统 &gt;= 5.0才有效。<br/>
gesturesEnabled ：是否允许右滑返回，在iOS上默认为true，在Android上默认为false</p>

<h3 id="toc_1">StackNavigatorConfig</h3>

<ul>
<li>initialRouteName: 设置默认的页面组件，必须是上面已注册的页面组件</li>
<li>initialRouteParams: 初始路由的参数</li>
<li>navigationOptions: 屏幕导航的默认选项</li>
<li>paths: RouteConfigs里面路径设置的映射</li>
<li>mode: 页面切换模式:
<ul>
<li>card: 普通app常用的左右切换</li>
<li>modal: 上下切换</li>
</ul></li>
<li>headerMode: 导航栏的显示模式:
<ul>
<li>float: 无透明效果, 默认</li>
<li>screen: 有渐变透明效果, 如微信QQ的一样</li>
<li>none: 隐藏导航栏</li>
</ul></li>
<li>cardStyle: 样式</li>
<li>onTransitionStart: 页面切换开始时的回调函数</li>
<li>onTransitionEnd: 页面切换结束时的回调函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[混合开发(OC)]]></title>
    <link href="https://acefish.github.io/15304988629042.html"/>
    <updated>2018-07-02T10:34:22+08:00</updated>
    <id>https://acefish.github.io/15304988629042.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">声明类 实现协议</h2>

<p>需要实现了<code>RCTBridgeModule</code>协议类,<br/>
导入<code>#import &lt;React/RCTBridgeModule.h&gt;</code></p>

<p>实现协议需要包含这个宏，可以添加参数作为访问此模块的名字 通常不指定默认使用类名<br/>
<code>RCT_EXPORT_MODULE();</code></p>

<h2 id="toc_1">声明原生方法给js调用</h2>

<p>声明需要提供给<code>React Native</code>组件调用的方法，即导出的方法<br/>
<code>RCT_EXPORT_METHOD()</code></p>

<pre><code class="language-javascript">//在OC中
RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
{
  RCTLogInfo(@&quot;Pretending to create an event %@ at %@&quot;, name, location);
}
//在js中这样调用
import { NativeModules } from &#39;react-native&#39;;
var CalendarManager = NativeModules.CalendarManager;
CalendarManager.addEvent(&#39;Birthday Party&#39;, &#39;4 Privet Drive, Surrey&#39;);
</code></pre>

<p>通常我们将多个参数使用一个字典进行存放</p>

<pre><code class="language-javascript">#import &lt;React/RCTConvert.h&gt;

RCT_EXPORT_METHOD(addEvent:(NSString *)name details:(NSDictionary *)details)
{
  NSString *location = [RCTConvert NSString:details[@&quot;location&quot;]];
  NSDate *time = [RCTConvert NSDate:details[@&quot;time&quot;]];
  ...
}

CalendarManager.addEvent(&#39;Birthday Party&#39;, {
  location: &#39;4 Privet Drive, Surrey&#39;,
  time: date.toTime(),
  description: &#39;...&#39;
})
</code></pre>

<h3 id="toc_2">声明回调函数</h3>

<pre><code class="language-javascript">
//原生
//原生模块通常只应调用回调函数一次。但是，它可以保存callback并在将来调用
RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
{
  NSArray *events = ...
  callback(@[[NSNull null], events]);
}

//js调用
CalendarManager.findEvents((error, events) =&gt; {
  if (error) {
    console.error(error);
  } else {
    this.setState({events: events});
  }
})

//采用promise

//原生
RCT_REMAP_METHOD(findEvents,
                 resolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject)
{
  NSArray *events = ...
  if (events) {
    resolve(events);
  } else {
    reject(error);
  }
}
//js调用
async function updateEvents() {
  try {
    var events = await CalendarManager.findEvents();
    this.setState({ events });
  } catch (e) {
    console.error(e);
  }
}

updateEvents();

</code></pre>

<h2 id="toc_3">多线程</h2>

<p>生模块不应对自己被调用时所处的线程做任何假设。React Native在一个独立的串行GCD队列中调用原生模块的方法，但这属于实现的细节，并且可能会在将来的版本中改变。通过实现方法<code>- (dispatch_queue_t)methodQueue</code>，原生模块可以指定自己想在哪个队列中被执行。</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_get_main_queue();
}
</code></pre>

<p>如果一个操作需要花费很长时间，原生模块不应该阻塞住，而是应当声明一个用于执行操作的独立队列</p>

<pre><code class="language-objectivec">- (dispatch_queue_t)methodQueue
{
  return dispatch_queue_create(&quot;com.facebook.React.AsyncLocalStorageQueue&quot;, DISPATCH_QUEUE_SERIAL);
}
</code></pre>

<blockquote>
<p>在模块之间共享分发队列<br/>
methodQueue方法会在模块被初始化的时候被执行一次，然后会被React Native的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p>
</blockquote>

<h2 id="toc_4">导出常量</h2>

<pre><code class="language-objectivec">- (NSDictionary *)constantsToExport
{
  return @{ @&quot;firstDayOfTheWeek&quot;: @&quot;Monday&quot; };
}
</code></pre>

<h2 id="toc_5">给JS发送事件</h2>

<p>继承<code>RCTEventEmitter</code>，实现<code>suppportEvents</code>方法并调用<code>self sendEventWithName:</code></p>

<pre><code class="language-objectivec">#import &lt;React/RCTEventEmitter.h&gt;

- (NSArray&lt;NSString *&gt; *)supportedEvents
{
  return @[@&quot;EventReminder&quot;];
}

- (void)calendarEventReminderReceived:(NSNotification *)notification
{
  NSString *eventName = notification.userInfo[@&quot;name&quot;];
  [self sendEventWithName:@&quot;EventReminder&quot; body:@{@&quot;name&quot;: eventName}];
}

</code></pre>

<p>JavaScript代码可以创建一个包含你的模块的NativeEventEmitter实例来订阅这些事件。</p>

<pre><code class="language-javascript">import { NativeEventEmitter, NativeModules } from &#39;react-native&#39;;
const { CalendarManager } = NativeModules;

const calendarManagerEmitter = new NativeEventEmitter(CalendarManager);

const subscription = calendarManagerEmitter.addListener(
  &#39;EventReminder&#39;,
  (reminder) =&gt; console.log(reminder.name)
);
...
// 别忘了取消订阅，通常在componentWillUnmount生命周期方法中实现。
subscription.remove();
</code></pre>

<h2 id="toc_6">原生UI</h2>

<p>原生视图需要被一个RCTViewManager来管理和创建。本质上都是单例 - React Native只会为每个管理器创建一个实例。它们创建原生的视图并提供给<code>RCTUIManager</code>，<code>RCTUIManager</code>则会反过来委托它们在需要的时候去设置和更新视图的属性。RCTViewManager还会代理视图的所有委托，并给JavaScript发回对应的事件</p>

<ol>
<li>创建<code>RCTViewManager</code>的子类</li>
<li>添加<code>RCT_EXPORT_MODULE()</code>标记宏</li>
<li><p>实现<code>-(UIView *)view</code>方法</p></li>
<li><p>在js代码中将视图变为可用的React组件</p></li>
</ol>

<pre><code class="language-javascript">// MapView.js
var { requireNativeComponent } = require(&#39;react-native&#39;);

// requireNativeComponent 自动把这个组件提供给 &quot;RNTMapManager&quot;
module.exports = requireNativeComponent(&#39;RNTMap&#39;, null);
</code></pre>

<h3 id="toc_7">声明属性</h3>

<pre><code class="language-objectivec">//声明属性
RCT_EXPORT_VIEW_PROPERTY(pitchEnabled, BOOL)

//设置属性之后，在js中可以直接设置
&lt;MapView pitchEnabled={false} /&gt;

//比较复杂的属性
RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RNTMap)
{
  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组件属性一]]></title>
    <link href="https://acefish.github.io/15293961047296.html"/>
    <updated>2018-06-19T16:15:04+08:00</updated>
    <id>https://acefish.github.io/15293961047296.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">View</h2>

<h3 id="toc_1">颜色与边框</h3>

<ol>
<li>backgroundColor: 背景颜色</li>
<li>opacity: 0~1透明度</li>
<li><p>borderStyle: 边框风格</p>
<ul>
<li>solid: default 实线边框</li>
<li>dotted: 点状边框</li>
<li>dashed: 虚线边框</li>
</ul></li>
<li><p>borderColor: 边框颜色,可以单独定义上下左右</p></li>
<li><p>borderRadius: 定义圆角边框,可单独定义四个角</p></li>
</ol>

<blockquote>
<p>大部分组件继承了View的属性</p>
</blockquote>

<h3 id="toc_2">视觉效果</h3>

<h4 id="toc_3">阴影</h4>

<ol>
<li>shadowColor</li>
<li>shadowOffset</li>
<li>shadowOpacity</li>
<li>shadowRadius</li>
</ol>

<h4 id="toc_4">overflow</h4>

<p>取值为 visible和hidden(默认),定义子组件产出父组件部分的是否显示，当设置为visible时，仅对ios平台有效,显示超出父组件部分</p>

<h4 id="toc_5">elevation</h4>

<p>Android平台特有效果,在组件周围渲染阴影</p>

<h3 id="toc_6">变形</h3>

<p>利用<code>transform</code>设置组件的变形,包括<code>translate</code>平移,<code>scale</code>缩放,<code>rotate</code>旋转,<code>skew</code>倾斜</p>

<pre><code class="language-javascript">const styles = StyleSheet.create({
    view1Style: {
        ....
        transform: [{scale:2}, {rotateZ:&quot;45deg&quot;}]
    }
})
//Xdeg 表示角度 取值0-360
</code></pre>

<h3 id="toc_7">回调函数</h3>

<p>回调函数命名 onB 即B事件发生的回调函数</p>

<h4 id="toc_8">onLayOut</h4>

<p>当View组件被加载或者改变布局时</p>

<h4 id="toc_9">onTouchStart、onTouchMove、onTouchEnd</h4>

<p>开始触摸事件、触摸点移动事件、触摸结束事件<br/>
三个回调函数带一个event参数,</p>

<pre><code class="language-javascript">//Event结构有用对象
{
 timeStamp: aNumber, //时间戳
 nativeEvent: {
    locationX: aNumber,
    locationY: aNumber,
 }
}
</code></pre>

<pre><code class="language-javascript">//示例 demo
constructor(props) {
        super(props)
        this._onTouchStart = this._onTouchStart.bind(this)
    }

    _onTouchStart(event) {
        console.log( event.nativeEvent.locationX)
    }

    render() {
        return(
            &lt;View style={styles.containStyle}&gt;
                &lt;View style={styles.view1Style} onTouchStart={this._onTouchStart}&gt;

                &lt;/View&gt;
            &lt;/View&gt;
        )
    }
</code></pre>

<h4 id="toc_10">removeClippedSubviews</h4>

<p>布尔属性，与性能有关的，属性为true将允许释放不在显示范围内的子组件，需要将overflow设置为hidden才会生效</p>

<h3 id="toc_11">onLayOut</h3>

<p>应用通过<code>Dimension</code>获取屏幕宽高，Dimensions.get(&#39;window&#39;).width/height,获取到的宽和高是实时屏幕的宽和高,当横置时宽大于高</p>

<h3 id="toc_12">pointEvents</h3>

<p>在RN中 触摸事件总是传递给最上层的组件，当被遮盖的组件需要向银行触摸事件，就需要从View继承的<code>pointEvents</code></p>

<p>可以取值为<code>none</code> <code>box-none</code> <code>box-only</code> <code>auto</code></p>

<p><strong>none:</strong> 发生在本组件和子组件的触摸事件交给本组件的父组件处理<br/>
<strong>box-none:</strong> 本组件显示范围内，非子组件显示范围内的时间交给本组件父组件处理,子组件显示范围交给子组件处理<br/>
<strong>box-only:</strong> 本组件显示范围内的所有触摸事件都交给本组件处理<br/>
<strong>auto:</strong> 视组件不同而不同 不是所有组件都支持box-none和box-only</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[补充]]></title>
    <link href="https://acefish.github.io/15290351401483.html"/>
    <updated>2018-06-15T11:59:00+08:00</updated>
    <id>https://acefish.github.io/15290351401483.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">当安装了第三方库之后 需要重新yarn安装依赖</h3>

<p><code>yarn install</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象]]></title>
    <link href="https://acefish.github.io/15289781671435.html"/>
    <updated>2018-06-14T20:09:27+08:00</updated>
    <id>https://acefish.github.io/15289781671435.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">JS创建对象以及对象属性的几种方式</h2>

<h3 id="toc_1">1.创建直接的对象</h3>

<pre><code class="language-javascript">person=new Object();
person.firstname=&quot;Bill&quot;;
person.lastname=&quot;Gates&quot;;
person.age=56;
person.eyecolor=&quot;blue&quot;;
</code></pre>

<h3 id="toc_2">2.替代语法(使用对象 literals)</h3>

<pre><code class="language-javascript">person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,age:50,eyecolor:&quot;blue&quot;};

</code></pre>

<h3 id="toc_3">3.函数对象构造器</h3>

<pre><code class="language-javascript">function person(firstname,lastname,age,eyecolor)
{
this.firstname=firstname;
this.lastname=lastname;
this.age=age;
this.eyecolor=eyecolor;
}
</code></pre>

<h3 id="toc_4">4.使用class</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[导航页面]]></title>
    <link href="https://acefish.github.io/15289587744708.html"/>
    <updated>2018-06-14T14:46:14+08:00</updated>
    <id>https://acefish.github.io/15289587744708.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">适配不同平台</h3>

<ol>
<li><p>文件适配</p>
<p>通过命名文件后缀为 <code>.android.js</code> 和 <code>.ios.js</code>文件 RN会根据不同平台加载不同文件</p></li>
<li><p>平台检测</p></li>
</ol>

<pre><code class="language-javascript">import {
    Platform

} from &#39;react-native&#39;
if(Platform.OS === &quot;android&quot;) {
//安卓代码
} else  {
//iOS代码
}
</code></pre>

<h3 id="toc_1">监测android物理后退按钮时间</h3>

<pre><code class="language-javascript">//对于android 点击后退按钮 如果当前有后退视图就后退 并返回true 否则返回false标识后退事件没被处理 传递给操作系统 就退出应用
    handleBackAndroid() {
        if (this.navigator.getCurrentRoutes().length &gt; 1) {
            this.navigator.pop()
            return true
        } else  {
            return false
        }
    }
    //组件挂接到当前页面
    componentDidMount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.addListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }
    //组件挂接到当前页面
    componentWillUnmount() {
        if (Platform.OS === &quot;android&quot;) {
            BackAndroid.removeListener(&quot;hardwareBackPress&quot;, this.handleBackAndroid)
        }
    }

</code></pre>

<p>可以使用<code>BackAndroid</code>的<code>addEventListener</code>函数挂接多个监听器,当返回键按下，最后的的最先执行 如果返回false会接下来执行倒数第二个 所有的都执行完 才会交给安卓操作系统</p>

<p><code>BackAndroid.exitApp();</code>可以 直接退出应用</p>

<h3 id="toc_2">颜色</h3>

<ol>
<li><code>rgba(52, 52, 52, 0.5)</code></li>
<li><code>0xF5FCFF01</code></li>
<li><code>#F5FCFF</code></li>
<li><code>rgb(245, 255, 255)</code></li>
<li><code>hsl(360, 100%, 100%)</code></li>
<li><code>hsla(360, 100%, l00%, 1.0)</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[状态机]]></title>
    <link href="https://acefish.github.io/15288713693530.html"/>
    <updated>2018-06-13T14:29:29+08:00</updated>
    <id>https://acefish.github.io/15288713693530.html</id>
    <content type="html"><![CDATA[
<p>ReactNative 将UI视作一个状态机,每个UI场景就是状态机的一个状态</p>

<blockquote>
<p>不要在状态机变量中存放于显示无关的变量,会导致务必要渲染UI</p>
</blockquote>

<h2 id="toc_0">State</h2>

<blockquote>
<p>尽可能让自定义的组件成为无状态组件<br/>
好的reactnative设计思路:创建多个只负责渲染数据的无状态组件，将他们封装在一个有状态的reactnative组件中,有状态的组件封装了UI交互的逻辑，而无状态的组件负责渲染UI界面。</p>
</blockquote>

<pre><code class="language-javascrip">constructor(props) {
        super(props)
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    updateNum(newText) {
        this.setState((state) =&gt; {
            return {input: newText}
        });
    }

    updatePWD(newText) {
        this.setState(() =&gt; {
            return {
                inputPWD : newText
            }
        })
    }
</code></pre>

<p>通过this.state.状态机变量名 访问状态机变量</p>

<p>我们需要将状态机变量看做 <strong>不可变常量</strong>，不能直接改变状态机变量，只能通过<strong>setState</strong>函数</p>

<h2 id="toc_1">渲染</h2>

<p>setState函数原型：<code>setState(oldState, callback)</code> 第二个参数为回调函数,会在setState完成并且重新渲染完成(如果需要的话)后被调用</p>

<p>如果setState函数将传入函数的返回值与当前状态机相比没有任何修改或增加,将不会进行渲染</p>

<p>改变状态机变量后 所有与状态机变量值有关系的组件都会被刷新。</p>

<blockquote>
<p>当修改组件的状态机变量值后，ReactNative会在考虑清楚如何高效的渲染UI后,执行SetState的箭头函数来渲染组件,因此setState是异步执行的函数</p>

<p>当子组件需要渲染时,那么该子组件的各个生命周期的函数都会按声明周期调用 这就是渲染高效的原因</p>
</blockquote>

<h3 id="toc_2">判断是否渲染</h3>

<pre><code class="language-javascript">//判断是否渲染，实现这个函数后,会在重新渲染组件前，调用这个函数，返回false就放弃渲染组件
shouldComponentUpdate() {
        if (this.state.input.length &lt; 3) {
            return true;
        }
        return false;
    }
</code></pre>

<h3 id="toc_3">强制渲染</h3>

<p><code>forceUpdate(callback)</code> <br/>
当UI的可变数据来源为属性和状态之外获取时,可以使用这个函数要求重新渲染，这会导致所有级别的UI都重新读取、计算、渲染。</p>

<blockquote>
<p>这个渲染过程不会调用<code>shouldComponentUpdate</code><br/>
可以通过回调函数,在执行结束后调用<br/>
尽量避免使用</p>
</blockquote>

<h3 id="toc_4">render渲染过程</h3>

<p>RN通过<code>render</code>实现重新渲染。原型为<code>ReactComponent render()</code><br/>
任何组件都必须有这个函数 也必须只能返回一个可渲染组件<br/>
通过修改属性或者状态机变量来触发render的重新渲染，而不是直接调用这个函数</p>

<h3 id="toc_5">简洁写法</h3>

<pre><code class="language-javascript">    //简洁写法1（通过指定参数名称与状态机变量名称相同 省略）
    updateNum(input) {
        this.setState(() =&gt; {
            return {input}
        })
    }
    
    //简洁写法2（省略箭头函数）
    updateNum(input) {
        this.setState( {input})
    }
 ```

## 成员变量

```javascript
    constructor(props) {
        super(props)
        this.myProperty1 = &quot;test&quot;
        this.myProperty2 = true
        this.state = {
            input: &#39;&#39;,
            inputPWD: &#39;&#39;,
        }
    }
    //就可以在组件中使用myProperty1  myProperty2 这两个成员变量
</code></pre>

<p>组件可以有静态变量、静态成员函数，直接用<code>类名.</code>调用</p>

<h3 id="toc_6">回调函数绑定</h3>

<pre><code class="language-javascript">//在constuctor函数中
this.updateNum = this.updateNum.bind(this)
</code></pre>

<p>绑定操作是为了让回调函数能正确解析出this，否则this.updateNum函数被执行时,指向另外对象而不是该组建类的实例</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flex]]></title>
    <link href="https://acefish.github.io/15287061850668.html"/>
    <updated>2018-06-11T16:36:25+08:00</updated>
    <id>https://acefish.github.io/15287061850668.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基本概念</h2>

<p>采用Flex布局的元素，称为容器，它的所有子元素 自动成为容器成员<br/>
<img src="media/15287061850668/15287068668255.png" alt=""/></p>

<h2 id="toc_1">容器属性</h2>

<pre><code class="language-text">flex-direction
flex-warp
flex-flow
justify-content
align-items
align-content
</code></pre>

<h3 id="toc_2">flex-direction</h3>

<p>决定主轴的方向 </p>

<ul>
<li>row:default 主轴为水平方向，起点在左端</li>
<li>row-reverse: 主轴为水平 起点在右端</li>
<li>column: 主轴为垂直方向，起点在上</li>
<li>colum-reverse:主轴为垂直方向 起点在下</li>
</ul>

<h3 id="toc_3">flex-warp</h3>

<p>当一条轴线放不下的情况 如何换行</p>

<ul>
<li>nowarp: default 不换行</li>
<li>wrap: 换行 第一行在上方</li>
<li>warp-reverse:换行，第一行在下方</li>
</ul>

<h3 id="toc_4">flex-flow</h3>

<p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>

<h3 id="toc_5">justify-content</h3>

<p>项目在主轴上的对齐方式</p>

<ul>
<li>flex-start: 左对齐</li>
<li>flex-end: 右对齐</li>
<li>center: 居中</li>
<li>space-between: 两端对齐，项目之间间隔相等</li>
<li>space-around: 每个项目两侧间隔相等</li>
</ul>

<h3 id="toc_6">align-items属性</h3>

<p>align-items属性定义项目在交叉轴上如何对齐</p>

<ul>
<li>flex-start: 交叉轴的起点对齐</li>
<li>flex-end: 交叉轴的终点对齐</li>
<li>center: 交叉轴的中间对齐</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
<li>strech: default 项目未设置高度或者设为auto，将默认占满整个容器</li>
</ul>

<h3 id="toc_7">align-content</h3>

<p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>

<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch：default 轴线占满整个交叉轴。</li>
</ul>

<h2 id="toc_8">项目属性</h2>

<pre><code class="language-text">order
flex-grow
flex-shrink
flex-basis
flex
align-self
</code></pre>

<h3 id="toc_9">order属性</h3>

<p>定义项目的排列顺序 数值越小 越靠前 默认为NO</p>

<h3 id="toc_10">flex-grow</h3>

<p>定义项目的放大比例 默认为0，即 如果存在剩余空间 也不放大<br/>
如果所有项目的<code>flex-grow</code>属性都为1，它们将等分剩余空间,如果属性为2，其它项目为1，则前者占据的剩余空间比其它多一倍</p>

<h3 id="toc_11">flex-shrink</h3>

<p>定义项目的缩小比例 默认为1 即如果空间不足 该项目将缩小<br/>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小<br/>
负值无效</p>

<h3 id="toc_12">flex-basis</h3>

<p>定义在分配多余空间之前，项目占据的主轴空间， 根据这个值计算是否有剩余空间，默认值为<code>auto</code>即项目的本来大小</p>

<h3 id="toc_13">flex</h3>

<p>flex属性是flex-shrink、flex-grow、flex-basis的简写，默认值是0，1，auto，后两个属性是可选的<br/>
该属性有两个快捷值：auto（1 1 auto） 和none（0 0 auto）</p>

<h3 id="toc_14">align-self</h3>

<p>允许单个项目与其它项目有不一样的对齐方式，可覆盖<code>align-items</code>属性 默认值为<code>auto</code>表示继承父元素的<code>align-items</code>属性,如果没有父属性则等同于<code>stretch</code></p>

<h1 id="toc_15">ReactNative Flex</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git]]></title>
    <link href="https://acefish.github.io/15284514278903.html"/>
    <updated>2018-06-08T17:50:27+08:00</updated>
    <id>https://acefish.github.io/15284514278903.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text">git show 命令可以查看很多信息 分支 标签 commitId

</code></pre>

<h3 id="toc_0">log</h3>

<blockquote>
<p>git log 的节点只与当前分支相关的节点,包括创建此分支之前继承的节点 和 之后自己提交的 以及作为当前分支与其他分支合并的log</p>
</blockquote>

<pre><code class="language-text">git log --graph  可以看到分支合并图
git log --graph --pretty=oneline --abbrev-commit 以图形化方式更好的展示分支合并状况
</code></pre>

<h3 id="toc_1">diff</h3>

<pre><code class="language-text">git diff 工作区与缓存区比较
git diff --cache 缓存区与HEAD比较
git diff HEAD 工作区与当前分支对比
git diff branchName 当前分支与某分支对比
git diff commitId 工作区与某次提交对比
</code></pre>

<h3 id="toc_2">回退</h3>

<pre><code class="language-text">git checkout -- fileName 将工作区文件撤销修改至与暂存区一致

git reset HEAD fileName 将暂存区的修改撤销掉 重新放回工作区(HEAD表示最新版本)

git reset commitId 回退版本

</code></pre>

<h3 id="toc_3">删除</h3>

<pre><code class="language-text"> git rm filename 将暂存区和工作区的文件一起删除
 git rm --cache filename 将暂存区的文件删除但是保留工作区文件
</code></pre>

<h3 id="toc_4">分支</h3>

<blockquote>
<p>不同分支共享工作区和暂存区,但是版本库是不一样的 ，因此不同分支下的文件是工作区 暂存区可各自的版本库文件总和 可能文件不同</p>
</blockquote>

<pre><code class="language-text">git checkout -b newBranchName 创建分支并且切换分支 相当于 git branch branchName +  git checkout branchName
git branch branchName 创建分支
git checkout branchName 切换分支为当前分支
git branch -d branchName 删除分支
git merge branchName 将其他分支合并到当前分支
git merge -m &quot;commitInfo&quot; branchName 合并分支 当不为快速合并时 新建commitInfo的提交
git merge --no-ff -m &quot;commitInfo&quot; branchName 禁用快速合并
</code></pre>

<h4 id="toc_5">快速合并</h4>

<p>如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作；git 不创建任何新的提交(commit),只是将当前分支指向合并进来的分支。 否则合并会新建一个提交来合并分支</p>

<h3 id="toc_6">stash</h3>

<pre><code class="language-text">git stash 将工作去和缓存区文件stash起来

 git stash list 查看stash内容的列表
 
 git stash apply stash@\{0\}  恢复暂存 不删除stash内容(如果不指定节点 默认最后stash的一个)
 
 git stash drop stash@\{0\} 删除stash内容(如果不指定节点 默认最后stash的一个)
 
git stash pop stash@\{0\} 恢复暂存 并且删除stash内容(如果不指定节点 默认最后stash的一个)
</code></pre>

<h3 id="toc_7">remote</h3>

<pre><code class="language-text">git remote -v 查看远程信息

git branch -r 查看远程分支信息

git checkout -b branchName origin/branchName  创建远程的branchName分支到本地


</code></pre>

<pre><code class="language-text">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 将本地分支推送到远程分支 如果没有这个远程分支就新建远程分支

git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果没有本地分支 就创建本地分支

</code></pre>

<pre><code class="language-text">
git push origin branchName 将本地分支推送到远程分支 如果分支不存在 就会新建

git push origin :branchName 删除指定远程分支 等同于 git push origin --delete master

git push origin 将当前分支 推送到远程分支

git push -u origin master 使用-u选项指定一个默认主机，这样以后就可以不加任何参数使用git push

git push -f origin branchName -f表示覆盖远程分支 相当于先删除远程分支在新建

</code></pre>

<pre><code class="language-text">git pull origin remoteBranch  remoteBranch与当前分支合并

git branch --set-upstream-to=origin/branchName branchName 指定本地分支与远程分支的连接，建立追踪关系后 就可以直接 git pull origin 省略远程分支名字 如果只有一个追踪分支 origin也可以省略 

</code></pre>

<h3 id="toc_8">变基</h3>

<p>git rebase </p>

<h3 id="toc_9">标签</h3>

<p>标签也是版本库的快照</p>

<pre><code class="language-text">git tag tagName 打标签 默认打在最新提交commit
git tag tagName commitId 给commit打上标签
git tag -a tagName -m &quot;tag说明文字&quot; commitId 给tag加说明文字 -a为标签名 -m为说明文字
git tag 查看所有标签
git show tagName 查看标签信息(git show命令还可以查看其它很多信息)
git tag -d tagName 删除本地标签

//推送标签
git push origin refs/tags/源标签名:refs/tags/目的标签名 

git push origin tagname 推送标签到远程
git push origin --tags 推送所有标签

删除远程标签
git tag -d tagname //先删除本地标签
git push origin :refs/tags/tagname

</code></pre>

<h3 id="toc_10">补充</h3>

<h4 id="toc_11">ignore</h4>

<p>git check-ignore -v 文件名 查看ignore文件写的有什么问题</p>

<h4 id="toc_12">alias</h4>

<pre><code class="language-text">git config --global alias.st status //st代表status
git config --global alias.co checkout //co 代表 checkout
git config --global alias.ci commit //ci代表commit
git config --global alias.br branch //br代表branch
git config --global alias.last &#39;log -1&#39; //git last代表 git log -l 最后一次提交信息
git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; //修改git lg 为一种好看的格式
</code></pre>

<h3 id="toc_13">搭建自定义Git仓库</h3>

<p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 与 ECMAScript 区别]]></title>
    <link href="https://acefish.github.io/15266103811219.html"/>
    <updated>2018-05-18T10:26:21+08:00</updated>
    <id>https://acefish.github.io/15266103811219.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础名词</h2>

<p>ECMA 为科学技术制定标准的组织</p>

<p>ECMA-262 目前脚本语言的规范</p>

<p>ECMAScript是定义在ECMA-262中定义的标准,用于创建通用目的脚本语言</p>

<p>JavaScript 通用目的的脚本语言，遵循ECMAScript规范</p>

<p>JavaScript引擎 能够理解和执行JavaScript代码的程序或解释器</p>

<p>JavaScript运行时 js代码运行所在环境,为js引擎所解释。运行时提供js可以运行和操作的宿主对象，js代码被引擎传递,被解析和理解之后,运行时的实体或系统将执行解释行为。例如：浏览器的宿主环境提供的对象视窗或文档等WebAPIs 服务器的宿主环境Node.js，即文件系统、处理和请求等</p>

<p>ECMAScript 6  是ECMA的第6个版本,对规范有显著改变(同名的ES2015)</p>

<p>Babel 将ES6代码转换为ES5的转译器(目前主流js引擎都支持ES6 但不一定支持ES6)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[# iOS编译过程]]></title>
    <link href="https://acefish.github.io/15266103180287.html"/>
    <updated>2018-05-18T10:25:18+08:00</updated>
    <id>https://acefish.github.io/15266103180287.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">大致过程</h2>

<blockquote>
<p>如果有工程依赖的第三方依赖库,会首先build依赖库target,然后build主target</p>
</blockquote>

<p>大致流程:</p>

<ul>
<li><p>compile各个.m文件<br/>
<code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch x86_64 -W -c path/main.m -o path/main.o</code></p>
<ul>
<li>-x 表示编译语言</li>
<li>-arch 表示编译的架构</li>
<li>-W表示各种编译警告</li>
<li>-c 表示进行预处理，编译，汇编过程</li>
<li>-o 输出结果</li>
</ul></li>
<li><p>Copy静态资源(包括img, string, font等)<br/>
//copy图片到app<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copypng <br/>
-compress -strip-PNG-text path/MaskView/MaskView/en.lproj/icons.png path/MaskView.app/en.lproj/icons.png</code></p></li>
<li><p>compile xib文件<br/>
编译xib，生成nib文件<br/>
 <code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool</code></p></li>
<li><p>compile storyboard文件<br/>
编译storyBoard,生成.storyBoard，其包内容为nib+plist<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool</code></p></li>
<li><p>compile asset catalogs<br/>
生成Asset.car文件<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/actool</code></p></li>
<li><p>process info.plist<br/>
处理info.plist<br/>
<code>builtin-infoPlistUtility</code></p></li>
<li><p>link storyboards<br/>
链接storyboard<br/>
<code>/Applications/Xcode.app/Contents/Developer/usr/bin/ibtool</code></p></li>
<li><p>run custom script<br/>
执行脚本<br/>
<code>/bin/sh</code></p></li>
<li><p>touch app</p>
<p><code>/usr/bin/touch</code></p></li>
<li><p>sign app<br/>
对app进行签名<br/>
<code>/usr/bin/codesign</code></p></li>
<li><p>validate app<br/>
校验app<br/>
<code>builtin-validationUtility</code></p></li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用宏定义]]></title>
    <link href="https://acefish.github.io/15260169489026.html"/>
    <updated>2018-05-11T13:35:48+08:00</updated>
    <id>https://acefish.github.io/15260169489026.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">#ifdef <strong>OBJC</strong>宏定义</h2>

<p><img src="media/15260169489026/15260169903529.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS基础使用]]></title>
    <link href="https://acefish.github.io/15205769334278.html"/>
    <updated>2018-03-09T14:28:53+08:00</updated>
    <id>https://acefish.github.io/15205769334278.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础语法</h2>

<ol>
<li>JS忽略出现的空格、制表符、空格</li>
<li>JS中分号是可选的，如果一行只有一句代码，是可以忽略这个分号的</li>
<li>JS是区分大小写的</li>
<li><p>JS中单行注释用<code>//</code> 多行注释用<code>/*...*/</code> JS可以识别<code>html</code>注释的开始部分<code>&lt;!--</code>但不能识别html注释的结尾部分<code>--&gt;</code></p>
<pre><code class="language-javascript">//对于js代码我们可以这样写，在不支持js的浏览器中节省我们的代码
&lt;!--<br/>
  var1 = 10<br/>
//--&gt;
</code></pre></li>
</ol>

<h2 id="toc_1">不支持js的警告信息</h2>

<pre><code class="language-javascript">&lt;html&gt;
    &lt;body&gt;

    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
    &lt;!--
       document.write(&quot;Hello World!&quot;)
    //--&gt;
    &lt;/script&gt;


    &lt;noscript&gt;
    //对于不支持或者没开启js功能的浏览器会在屏幕上显示这航信息
      Sorry...JavaScript is needed to go ahead.
    &lt;/noscript&gt;
    &lt;/body&gt;
    &lt;/html&gt;

</code></pre>

<h2 id="toc_2">JS代码位置</h2>

<ol>
<li><code>HTML</code>网页的<head>...<head></li>
<li><code>HTML</code>网页的<body>...<body></li>
<li><code>HTML</code>网页的<body>...<body>和<head>...<head></li>
<li>外部文件.js文件,并引用在<head>...<head>中</li>
</ol>

<pre><code class="language-javascript">&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;filename.js&quot; &gt;&lt;/script&gt;
    &lt;/head&gt;
</code></pre>

<h2 id="toc_3">JS变量</h2>

<p>1.数据类型有<br/>
    1). 数值类型(未区分整数和浮点数，均用64位浮点格式表示)<br/>
    2). 字符串类型<br/>
    3). 布尔类型  true 或者 false</p>

<ol>
<li>使用<code>var</code>声明变量 必须先声明在使用</li>
<li>JS变量是对大小写敏感的</li>
</ol>

<h2 id="toc_4">运算符</h2>

<ol>
<li>算术运算符 +、-、*、/、%、++、--</li>
<li>比较运算符 ==、!=、&gt;、&lt;、&gt;=、&lt;=</li>
<li>逻辑运算符 &amp;&amp;、||、！</li>
<li>位运算符 &amp;、|、<sup>、~、&lt;&lt;、&gt;&gt;(按最高位进行补位)、&gt;&gt;&gt;(左边补零移位)</sup></li>
<li>赋值运算符：=、+=、-=、*=、/=、%=</li>
<li>条件运算符： ？:</li>
<li>typeof运算符：返回类型的字符串</li>
</ol>

<h2 id="toc_5">If...Else</h2>

<pre><code class="language-javascript"> &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    var book = &quot;maths&quot;;
    if( book == &quot;history&quot; ){
       document.write(&quot;&lt;b&gt;History Book&lt;/b&gt;&quot;);
    }else if( book == &quot;maths&quot; ){
       document.write(&quot;&lt;b&gt;Maths Book&lt;/b&gt;&quot;);
    }else if( book == &quot;economics&quot; ){
       document.write(&quot;&lt;b&gt;Economics Book&lt;/b&gt;&quot;);
    }else{
      document.write(&quot;&lt;b&gt;Unknown Book&lt;/b&gt;&quot;);
    }
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h2 id="toc_6">Switch Case</h2>

<pre><code class="language-javascript">
switch (expression)
    {
      case condition 1: statement(s)
    break;
      case condition 2: statement(s)
    break;
       ...
      case condition n: statement(s)
    break;
      default: statement(s)
    } 
</code></pre>

<h2 id="toc_7">while循环</h2>

<pre><code class="language-javascript">while(expression){  
        statement  
    }
    
    do{  
        statement  
    }while(expression);  
    
</code></pre>

<h2 id="toc_8">for循环</h2>

<pre><code class="language-javascript">for(initialize;test condition;iteration statement)  
    {  
        statement;  
    }
</code></pre>

<h2 id="toc_9">for in循环</h2>

<pre><code class="language-javascript"> for (variablename in object){  
        statement
    } 
</code></pre>

<p>将对象的属性作为参数变量来实现循环</p>

<h2 id="toc_10">循环控制</h2>

<h3 id="toc_11">break</h3>

<p>提前结束整个循环</p>

<h3 id="toc_12">continue</h3>

<p>立即开始下次循环</p>

<h3 id="toc_13">使用标签来控制流</h3>

<p>一个标签可以被用于 break , continue 语句去更精确地控制流<br/>
在js1.2之后,标签是一个标识符后跟一个冒号,应用于声明或代码块。</p>

<blockquote>
<p>continue或break语句以及其标签的名字之间不允许有换行符。标签名称和其后循环体之间也不应有任何其他语句</p>
</blockquote>

<pre><code class="language-javascript">  &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    document.write(&quot;Entering the loop!&lt;br /&gt; &quot;);
    outerloop:   // This is the label name
    for (vari = 0; i&lt; 5; i++)
    {
    document.write(&quot;Outerloop: &quot; + i + &quot;&lt;br /&gt;&quot;);
    innerloop:
    for (var j = 0; j &lt; 5; j++)
    {
    if (j &gt;  3 ) break ; // Quit the innermost loop
    if (i == 2) break innerloop; // Do the same thing
    if (i == 4) break outerloop; // Quit the outer loop
    document.write(&quot;Innerloop: &quot; + j + &quot;  &lt;br /&gt;&quot;);
       }
    }
    document.write(&quot;Exiting the loop!&lt;br /&gt; &quot;);
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h2 id="toc_14">函数</h2>

<h3 id="toc_15">定义函数</h3>

<p>使用函数关键字<code>function</code></p>

<pre><code class="language-javascript">//定义函数
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function functionname(parameter-list)
    {
        statements
    }
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h3 id="toc_16">调用函数</h3>

<pre><code class="language-javascript">  &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    sayHello();
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h3 id="toc_17">函数参数</h3>

<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function sayHello(name, age)
    {
       alert( name + &quot; is &quot; + age + &quot; years old.&quot;);
    }
    //--&gt;
    &lt;/script&gt;
    
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    sayHello(&#39;Zara&#39;, 7 );
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h3 id="toc_18">return 语句</h3>

<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function concatenate(first, last)
    {
       var full;

       full = first + last;
       return  full;
    }
    //--&gt;
    &lt;/script&gt;
    
     &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
       var result;
       result = concatenate(&#39;Zara&#39;, &#39;Ali&#39;);
       alert(result );
    //--&gt;
    &lt;/script&gt;
</code></pre>

<h2 id="toc_19">事件</h2>

<h3 id="toc_20">onclick事件类型</h3>

<p>当用户点击鼠标左按钮</p>

<pre><code class="language-javascript">&lt;html&gt;
    &lt;head&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function sayHello() {
       alert(&quot;Hello World&quot;)
    }
    //--&gt;
    &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;input type=&quot;button&quot; onclick=&quot;sayHello()&quot; value=&quot;Say Hello&quot; /&gt;
    &lt;/body&gt;
    &lt;/html&gt;  
</code></pre>

<h3 id="toc_21">onsubmit事件类型</h3>

<p>尝试提交一个表单，可以用此事件类型进行表单验证，</p>

<pre><code class="language-javascript">
&lt;html&gt;
    &lt;head&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    &lt;!--
    function validation() {
       all validation goes here
       .........
       return either true or false
    }
    //--&gt;
    &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    //当表单中加上 onsubmit=&quot;return false&quot; 可以阻止表单提交
    &lt;form method=&quot;POST&quot; action=&quot;t.cgi&quot; onsubmit=&quot;return validate()&quot;&gt;
    .......
    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
    &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;  
</code></pre>

<h3 id="toc_22">onmouseover 和 onmouseout</h3>

<p>onmouseover 事件发生时,当你把你的鼠标在任何元素上时， onmouseover 事件发生。当你把鼠标从该元素移开时，onmouseout 事件发生</p>

<h2 id="toc_23">Cookies</h2>

<p><a href="http://wiki.jikexueyuan.com/project/javascript/cookies.html">参考资料</a></p>

<h3 id="toc_24">写入cookies</h3>

<p><code>document.cookie = &quot;key1=value;key2=value2;expires=date&quot;;</code></p>

<pre><code class="language-javascript">//写入cookie
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function WriteCookie()
{
   if( document.myform.customer.value == &quot;&quot; ){
      alert(&quot;Enter some value!&quot;);
      return;
   }

   cookievalue= escape(document.myform.customer.value) + &quot;;&quot;;
   document.cookie=&quot;name=&quot; + cookievalue;
   alert(&quot;Setting Cookies : &quot; + &quot;name=&quot; + cookievalue );
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;myform&quot; action=&quot;&quot;&gt;
Enter name: &lt;input type=&quot;text&quot; name=&quot;customer&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;Set Cookie&quot; onclick=&quot;WriteCookie();&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="toc_25">读取cookies</h3>

<p>document.cookie 对象的值就是 Cookie 的属性值,document.cookie 字符串会保存一系列用分号分开的 name = value 键值对</p>

<pre><code class="language-javascript">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function ReadCookie()
{
   var allcookies = document.cookie;
   alert(&quot;All Cookies : &quot; + allcookies );

   // Get all the cookies pairs in an array
   cookiearray  = allcookies.split(&#39;;&#39;);

   // Now take key value pair out of this array
   for(var i=0; i&lt;cookiearray.length; i++){
      name = cookiearray[i].split(&#39;=&#39;)[0];
      value = cookiearray[i].split(&#39;=&#39;)[1];
      alert(&quot;Key is : &quot; + name + &quot; and Value is : &quot; + value);
   }
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;myform&quot; action=&quot;&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;Get Cookie&quot; onclick=&quot;ReadCookie()&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>

<h3 id="toc_26">设置cookies有效日期</h3>

<pre><code class="language-javascript">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function WriteCookie()
{
   var now = new Date();
   now.setMonth( now.getMonth() + 1 ); 
   cookievalue = escape(document.myform.customer.value) + &quot;;&quot;
   document.cookie=&quot;name=&quot; + cookievalue;
   document.cookie = &quot;expires=&quot; + now.toUTCString() + &quot;;&quot;
   alert(&quot;Setting Cookies : &quot; + &quot;name=&quot; + cookievalue );
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;formname&quot; action=&quot;&quot;&gt;
Enter name: &lt;input type=&quot;text&quot; name=&quot;customer&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;Set Cookie&quot; onclick=&quot;WriteCookie()&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="toc_27">删除cookies</h3>

<p>删除一个 Cookie，从而下次尝试读取 Cookie 信息时会返回一个空值，可以设置 Cookie 的有效生存时间为过去的某个时间的即可。</p>

<pre><code class="language-javascript">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function WriteCookie()
{
   var now = new Date();
   now.setMonth( now.getMonth() - 1 ); 
   cookievalue = escape(document.myform.customer.value) + &quot;;&quot;
   document.cookie=&quot;name=&quot; + cookievalue;
   document.cookie = &quot;expires=&quot; + now.toUTCString() + &quot;;&quot;
   alert(&quot;Setting Cookies : &quot; + &quot;name=&quot; + cookievalue );
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form name=&quot;formname&quot; action=&quot;&quot;&gt;
Enter name: &lt;input type=&quot;text&quot; name=&quot;customer&quot;/&gt;
&lt;input type=&quot;button&quot; value=&quot;Set Cookie&quot; onclick=&quot;WriteCookie()&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS11]]></title>
    <link href="https://acefish.github.io/15143731430102.html"/>
    <updated>2017-12-27T19:12:23+08:00</updated>
    <id>https://acefish.github.io/15143731430102.html</id>
    <content type="html"><![CDATA[
<p><code>estimatedRowHeight</code>是一个预估高度，iOS11之前是为0，在iOS11下，这个值默认为44。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UISearchBar UISearchController UITextField]]></title>
    <link href="https://acefish.github.io/15124643482351.html"/>
    <updated>2017-12-05T16:59:08+08:00</updated>
    <id>https://acefish.github.io/15124643482351.html</id>
    <content type="html"><![CDATA[
<p>1.用searchBar的搜索框的话 取消按钮会在键盘消失即searchBar失去第一响应者时变为不可点击状态 需要再次点击取消按钮或者搜索框使其成为第一响应者才能点击取消按钮</p>

<p>2.UIsearchController<br/>
点击出现搜索结果控制器的动画不收控制,依赖于当前searchBar位置与self.view相对，对于tabbleView的headView的searchBar，其tableView的y为0,并且不能用自动布局</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战:ARKit捕捉平面]]></title>
    <link href="https://acefish.github.io/15082392311480.html"/>
    <updated>2017-10-17T19:20:31+08:00</updated>
    <id>https://acefish.github.io/15082392311480.html</id>
    <content type="html"><![CDATA[
<p>当捕捉到一个平面锚点<code>ARPlaneAnchor</code>会添加到当前场景中，我们可以通过监听<code>ARSCNView</code>代理来获取这个平面锚点</p>

<pre><code class="language-objectivec">//添加节点时候调用（当开启平地捕捉模式之后，如果捕捉到平地，ARKit会自动添加一个平地节点）
- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor
{
    if ([anchor isMemberOfClass:[ARPlaneAnchor class]]) {
        NSLog(@&quot;捕捉到平地&quot;);
    }
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARCamera]]></title>
    <link href="https://acefish.github.io/15082385455420.html"/>
    <updated>2017-10-17T19:09:05+08:00</updated>
    <id>https://acefish.github.io/15082385455420.html</id>
    <content type="html"><![CDATA[
<p><code>ARCamera</code>是一个相机,连接虚拟场景与现实场景的枢纽</p>

<p>它的API大致只需要了解即可,ARKit会默认帮我们进行配置好</p>

<h2 id="toc_0">API</h2>

<pre><code class="language-objectivec">/**
 4x4矩阵表示相机位置，同ARAnchor
 */
@property (nonatomic, readonly) matrix_float4x4 transform;

/**
相机方向（旋转）的矢量欧拉角
分别是x/y/z
 */
@property (nonatomic, readonly) vector_float3 eulerAngles;

/**
 相机追踪状态（在下方会有枚举值介绍）
 */
@property (nonatomic, readonly) ARTrackingState trackingState NS_REFINED_FOR_SWIFT;

/**
追踪运动类型
 */
@property (nonatomic, readonly) ARTrackingStateReason trackingStateReason NS_REFINED_FOR_SWIFT;

/**
相机内参矩阵
3x3矩阵
 fx 0   px
 0  fy  py
 0  0   1
 */
@property (nonatomic, readonly) matrix_float3x3 intrinsics;

/**
摄像头分辨率
 */
@property (nonatomic, readonly) CGSize imageResolution;

/**
投影矩阵
*/
@property (nonatomic, readonly) matrix_float4x4 projectionMatrix;

/**
创建相机投影矩阵
 */
- (matrix_float4x4)projectionMatrixWithViewportSize:(CGSize)viewportSize orientation:(UIInterfaceOrientation)orientation zNear:(CGFloat)zNear zFar:(CGFloat)zFar;

@end

//相机追踪状态枚举
typedef NS_ENUM(NSInteger, ARTrackingState) {

    /** 不被允许 */
    ARTrackingStateNotAvailable,

    /** 被限制 限值原因ARTrackingStateReason */
    ARTrackingStateLimited,

    /** 正常. */
    ARTrackingStateNormal,
} NS_REFINED_FOR_SWIFT;

/**
 追踪运动类型
 */
API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(macos, watchos, tvos)
typedef NS_ENUM(NSInteger, ARTrackingStateReason) {
    /** 无. */
    ARTrackingStateReasonNone,
    
    /** 初始化追踪 */
    ARTrackingStateReasonInitializing,

    /** 过度运动. */
    ARTrackingStateReasonExcessiveMotion,

    /** 未找到可见特征 缺少纹理 */
    ARTrackingStateReasonInsufficientFeatures,
} NS_REFINED_FOR_SWIFT;

</code></pre>

]]></content>
  </entry>
  
</feed>
