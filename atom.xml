<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ACEfish-Blog]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2019-01-11T14:03:31+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[pod repo update]]></title>
    <link href="https://acefish.github.io/15556625620569.html"/>
    <updated>2019-04-19T16:29:22+08:00</updated>
    <id>https://acefish.github.io/15556625620569.html</id>
    <content type="html"><![CDATA[
<p>我们平时开发pod update或者pod install , 这里其实 pod的工作就是根据pod库名在master/Specs/中找到对应的库，若指定版本则找到指定版本的podspec,否则找最高版本的podspec，找到后根据podsepc文件中的配置下载指定的库资源。</p>

<p>那么pod repo update 的工作就是更新pod资源目录，也就是master下的资源，简单说 如果有一个第三方库发布了一个最新的版本，如果你不执行pod repo update，那么你的本地是不会知道有一个最新版本的，还会一直以你本地的资源目录为准。那么你永远都拿不到这个库的最新版本。</p>

<p>使用pod update是默认会执行一遍pod repo update ，所以会发现如果你的pod库引用多了，每次pod update都很慢，网络如果不好更是经常会断掉，就是因为你在更新pod时，也更新了资源目录</p>

<p>pod update 工作流程 :</p>

<ul>
<li>先拉取远程最新目录，再根据目录中的资源重新更新一遍pod</li>
<li>如果你的podfile中每个库都指定了版本还好，如果没有，那么每次都是拉一遍最新库， 这时候就要用到命令
<code>
pod update --no-repo-update
</code></li>
</ul>

<p>有些时候会引用一些私有库 ， <code>pod repo update</code> 会把<code>~/.cocoapods/repos/</code>这个目录下所有的资源库目录都更新一遍，有时候不想更新master，只想更新某个具体的私有库 可以使用<code>pod repo update ~/.cocoapods/repos/***/</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15556594680013.html"/>
    <updated>2019-04-19T15:37:48+08:00</updated>
    <id>https://acefish.github.io/15556594680013.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15556594680013/15556596812617.jpg" alt="" style="width:300px;"/><br/>
<img src="media/15556594680013/15556600069879.jpg" alt="" style="width:293px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[otool命令]]></title>
    <link href="https://acefish.github.io/15554889031358.html"/>
    <updated>2019-04-17T16:15:03+08:00</updated>
    <id>https://acefish.github.io/15554889031358.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mach文件]]></title>
    <link href="https://acefish.github.io/15554886689884.html"/>
    <updated>2019-04-17T16:11:08+08:00</updated>
    <id>https://acefish.github.io/15554886689884.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时]]></title>
    <link href="https://acefish.github.io/15553854847636.html"/>
    <updated>2019-04-16T11:31:24+08:00</updated>
    <id>https://acefish.github.io/15553854847636.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instruments Help]]></title>
    <link href="https://acefish.github.io/15553150729300.html"/>
    <updated>2019-04-15T15:57:52+08:00</updated>
    <id>https://acefish.github.io/15553150729300.html</id>
    <content type="html"><![CDATA[
<p>官方文档<a href="https://help.apple.com/instruments/mac/current/#//apple_ref/doc/uid/TP40004652-CH5">Instruments Help</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO]]></title>
    <link href="https://acefish.github.io/15551517319694.html"/>
    <updated>2019-04-13T18:35:31+08:00</updated>
    <id>https://acefish.github.io/15551517319694.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">官方文档地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中的泛型]]></title>
    <link href="https://acefish.github.io/15550609641165.html"/>
    <updated>2019-04-12T17:22:44+08:00</updated>
    <id>https://acefish.github.io/15550609641165.html</id>
    <content type="html"><![CDATA[
<p><a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/">参考</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC]]></title>
    <link href="https://acefish.github.io/15549735665033.html"/>
    <updated>2019-04-11T17:06:06+08:00</updated>
    <id>https://acefish.github.io/15549735665033.html</id>
    <content type="html"><![CDATA[
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE">官方文档地址</a></p>

<p><code>KVC(Key-value coding)</code>是由<code>NSKeyValueCoding</code>非正式协议(其实就是我们所的分类或类别)启用的机制，通过该机制提供了对属性的间接访问。<br/>
当对象符合键值编码时，属性可以通过字符串参数进行接口寻址。<br/>
这种对属性的间接访问机制提供了对实例变量和其相关访问器方法的直接访问</p>

<blockquote>
<p>键值编码是一个基本概念，是许多其他Cocoa技术的基础，例如键值观察(KVO)，Cocoa绑定，CoreData和AppleScript能力。在某些情况下，键值编码还有助于简化代码。</p>
</blockquote>

<p>通过KVC 我们可以实现以下功能:</p>

<ol>
<li>获取对象属性</li>
<li>操作对象属性</li>
<li>在集合对象上进行集合运算符运算</li>
<li>获取非对象属性</li>
<li>通过keyPath来获取对象属性</li>
</ol>

<p><code>NSObject</code>的<code>NSKeyValueCoding</code>分类实现了KVC方法，并提供默认实现;而<code>NSArray</code>、<code>NSDictionary</code>、<code>NSMutableDictionary</code>等都又提供了自己的实现</p>

<p><img src="media/15549735665033/15550373964851.jpg" alt="" style="width:200px;"/></p>

<p>为了使对象符合键值编码，应确保其实现了NSKeyValueCoding非正式协议，并实现了相应的方法，<code>NSObject</code>使用了<code>NSKeyValueCoding</code>协议并为它们和其它基本方法提供了默认实现。因此从NSObject派生的对象，大部分工作已经完成；</p>

<p>符合键值编码的对象可以实现其他Cocoa的技术:</p>

<ol>
<li>KVO</li>
<li>Cocoa绑定：这一系列技术完全实现了模型 - 视图 - 控制器范例，其中模型封装应用程序数据，视图显示和编辑数据，控制器在两者之间进行调解。 阅读<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html#//apple_ref/doc/uid/10000167i">Cocoa Bindings编程主题</a>以了解有关Cocoa绑定的更多信息。</li>
<li>CoreData: <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075">文档地址</a></li>
<li>AppleScript：  <a href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i">AppleScript Overview</a></li>
</ol>

<h2 id="toc_0">API</h2>

<h4 id="toc_1">直接访问对象属性</h4>

<pre><code class="language-objectivec">- (nullable id)valueForKey:(NSString *)key;
- (void)setValue:(nullable id)value forKey:(NSString *)key;
</code></pre>

<pre><code class="language-objectivec">//点语法访问器
myAccount.currentBalance = @(100.0);
[myAccount setCurrentBalance:@(100.0)];

//KVC
[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];
NSNumber *currentBalance = [myAccount valueForKey:@&quot;currentBalance&quot;];

Person *owerModel = [[Person alloc] init];
[myAccount setValue:owerModel forKeyPath:@&quot;ower&quot;];
</code></pre>

<blockquote>
<p>对于<code>forKey:</code>不常用，因为我们均可以使用<code>forKeyPath:</code>来代替，对于keyPath只有一层也是可以的</p>
</blockquote>

<h4 id="toc_2">路径访问属性</h4>

<pre><code class="language-objectivec">- (nullable id)valueForKeyPath:(NSString *)keyPath;
- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;
</code></pre>

<pre><code class="language-objectivec">//键路径是以点分隔的多个键字符串  指定了要遍历的对象属性序列
[myAccount setValue:@&quot;lyy&quot; forKeyPath:@&quot;ower.name&quot;];
NSString *name = [myAccount valueForKeyPath:@&quot;ower.name&quot;];
</code></pre>

<h4 id="toc_3">键未定义异常</h4>

<p>当找不到key命名的属性时，会调用获取值的 </p>

<pre><code class="language-objectivec">- (id)valueForUndefinedKey:(NSString *)key;
- (void)setValue:(id)value forUndefinedKey:(NSString *)key;
</code></pre>

<p>找不到系统会默认引发一个<code>NSUndefinedKeyException</code>异常，可以通过重写这两个方法避免崩溃</p>

<blockquote>
<p>对于keyPath的方式访问属性，kayPath的键对应对象属性序列，到哪一级找不到对应属性，就会触发对应该级对象的这个两个方法，而不是总触发第一级对象的</p>
</blockquote>

<h4 id="toc_4">对于非对象值</h4>

<p>当<code>setValue</code>时，如果属性不是对象值，而是标量或者结构体时，KVC会自动将value拆箱然后赋值给属性<br/>
同理，当<code>valueForKey/keyPath:</code>会自动将属性值装箱，返回一个<code>NSNumber</code>或者<code>NSValue</code></p>

<pre><code class="language-objectivec">//封装为为NSValue
NSPoint、NSRange、NSRect、NSSize
</code></pre>

<h4 id="toc_5">对于nil</h4>

<ul>
<li><p>对于属性为对象值时，可以直接设置对象值为nil，或者获取对象指为nil</p></li>
<li><p>对于属性为非对象值，即为标量或者结构体时，此时系统无法帮我们拆箱,会触发<code>setNilValueForKey:</code>方法，并且引发一个<code>NSInvalidArgumentException</code>异常，可以通过重写该方法避免</p></li>
</ul>

<h3 id="toc_6">多值访问</h3>

<pre><code class="language-objectivec">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;
- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;
</code></pre>

<p>提供了可以同时获取和设置多个值的方法，相当于一次性掉了多次<code>valueForKey</code>和<code>setValue:forKey:</code>，当key值不存在时也会触发<strong>键未定义异常</strong>的崩溃和避免崩溃方法<br/>
注意： 这两个方法中只能设置的为key，而不能使用keyPath</p>

<h3 id="toc_7">访问集合属性</h3>

<p>对于属性为集合对象，与获取普通对象属性相同，可以直接获取和设置到集合对象属性值</p>

<pre><code class="language-objectivec">[myAccount setValue:dataArr forKey:@&quot;transactionsArray&quot;];
NSArray *obj = [myAccount valueForKeyPath:@&quot;transactionsArray&quot;];
</code></pre>

<p>另外一个较常用的功能,我们可以使用<code>valueForKeypath:</code>直接获取数组中每个对象的属性值集合</p>

<pre><code class="language-objectivec">NSArray *obj1 = [myAccount valueForKeyPath:@&quot;transactionsArray.payee&quot;];
</code></pre>

<p>在keyPath中遇到数组时，会对数组中的每个元素都执行接下来的<code>valueForKeyPath:</code>,最后返回一个值的集合</p>

<p>但是对于集合的属性集合<code>setValue:forkey/KeyPath:</code>并不好用，其并不会将value中的数组分别复制给key中的属性，而是会将value直接赋值给每个key中的属性</p>

<h3 id="toc_8">操作集合属性</h3>

<p>对于集合属性 我们想要修改其内容 需要先用<code>valueForKeyPath</code>获取到其不可变属性值，然后用其创建可变对象值然后修改，再用<code>setValueForKeyPath</code>方法重新设置回去，较麻烦</p>

<p>苹果提供了直接可以获取集合属性的可变对象进行操作的方法</p>

<pre><code class="language-objectivec">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;
- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;

- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath;

- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;
- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;
</code></pre>

<p>会返回一个行为继承于<code>NSMutableArray/NSMutableOrderedSet/NSMutableSet</code>的内置对象，对这个对象直接操作(例如增加、删除元素)，系统会根据我们的操作直接修改原对象<br/>
这样修改维护集合中的对象，还可以<strong>支持键值观察机制</strong></p>

<blockquote>
<p>这种方法只适合直接修改集合属性，而不适合修改集合属性的属性值集合，原因和不对其使用<code>setValue:forkey/KeyPath:</code>原因相同</p>
</blockquote>

<h3 id="toc_9">属性验证</h3>

<p>NSKeyValueCoding协议提供了支持属性验证的方法。 可以通过调用</p>

<pre><code class="language-objectivec">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;

- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;
</code></pre>

<p>协议的默认实现会像实例搜索是否存在实现了<code>validate&lt;Key&gt;:error:</code>方法，默认为返回YES表示验证成功，我们可以再这个方法中实现自己的验证逻辑</p>

<pre><code class="language-objectivec">BankAccount *myAccount = [[BankAccount alloc] init];
NSError *error;
NSNumber *balance = @(100.0);
BOOL result = [myAccount validateValue:&amp;balance forKey:@&quot;currentBalance&quot; error:&amp;error];

//BankAccount.m
- (BOOL)validateCurrentBalance:(id *)ioValue error:(NSError *__autoreleasing *)outError {
    if (!ioValue || ((NSNumber *)*ioValue).integerValue &gt;= 100) {
        *outError = [NSError errorWithDomain:@&quot;错误qqq&quot; code:123 userInfo:@{@&quot;key&quot;: @&quot;金额太大了&quot;}];
        return NO;
    }
    return YES;
}
</code></pre>

<p>当然如果不想每个不同key验证都写一次验证方法的话，就直接继承实现自己的validateValue</p>

<pre><code class="language-objectivec">- (BOOL)validateValue:(inout id  _Nullable __autoreleasing *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable __autoreleasing *)outError {
    
    if (!ioValue || ((NSNumber *)*ioValue).integerValue &gt;= 100) {
        *outError = [NSError errorWithDomain:@&quot;错误qqq&quot; code:123 userInfo:@{@&quot;key&quot;: @&quot;金额太大了&quot;}];
        return NO;
    }
    return YES;
}
</code></pre>

<blockquote>
<p><code>- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</code>怎么使用呢????</p>
</blockquote>

<h2 id="toc_10">集合运算符</h2>

<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW9">官方文档</a></p>

<p>使用<code>valueForKeyPath:</code>时，可以在路径中嵌入<strong>集合运算符</strong><br/>
集合运算符是在<code>@</code>关键字标识，指定了getter应该执行的操作，以便在数据返回之前以某种方式操作数据</p>

<p><img src="media/15549735665033/15550626615233.jpg" alt="" style="width:500px;"/></p>

<p>当keyPath包含集合运算符时，@前路径为左键路径，表示相对操作对象的集合路径，当操作对象直接为集合对象时，可以省略左键路劲;@运算符后的为右键路径，表示操作的集合中的属性，除了<code>@count</code>都需要右键路径</p>

<p>集合运算符共有三种类型:</p>

<ul>
<li><p>聚合运算符<br/>
以某种方式合并集合中的对象，并返回和右键路径属性相同类型的一个值;（@count例外）</p>
<ol>
<li><p><strong>@avg</strong> 读取右键属性值，并将其转为<code>double</code>类型(将nil转为0)，计算其算术平均值，返回一个<code>NSNumber</code>对象</p>
<pre><code class="language-objectivec">NSNumber *transactionAverage = [self.transactions valueForKeyPath:@&quot;@avg.amount&quot;];
</code></pre></li>
<li><p><strong>@count</strong> 获取集合中元素个数，忽略右键属性(如果有)</p>
<pre><code class="language-objectivec">NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@&quot;@count&quot;];
</code></pre></li>
<li><p><strong>@max</strong> 搜索右键属性对应的值集合 返回最大的那个(比较时忽略nil)<br/>
比较使用的时<code>compare:</code>方法，因此右键属性值必须能响应该方法</p>
<pre><code class="language-objectivec">NSDate *latestDate = [self.transactions valueForKeyPath:@&quot;@max.date&quot;];
</code></pre>
<blockquote>
<p><code>Foundation</code>中内置很多类都已经实现了该方法，我们也可以通过自己实现<code>- (NSComparisonResult)compare:(id)other</code>方法来实现自定义model的compare</p>
</blockquote></li>
<li><p><strong>@min</strong><br/>
与@max同理</p></li>
<li><p><strong>@sum</strong> 将集合中右键元素都转为double类型(将nil转为0)求和</p></li>
<li><p><strong>@count</strong></p></li>
</ol>
<pre><code class="language-objectivec">    NSInteger count = [[myAccount.transactionsArray valueForKeyPath:@&quot;@count&quot;] integerValue];
</code></pre></li>
<li><p>数组运算符<br/>
返回一个NSArray实例，返回集合中属性的子集</p>
<p><strong>@distinctUnionOfObject</strong>返回一个数组其中包含了右键属性的不重复的值的集合(不包含nil元素)；</p>
<pre><code class="language-objectivec">NSArray *arr = [myAccount valueForKeyPath:@&quot;transactionsArray.@distinctUnionOfObjects.amount&quot;];
</code></pre>
<p><strong>@unionOfObjects</strong> 返回右键属性值的集合并不会去重(不包含nil元素)</p></li>
<li><p>嵌套操作符<br/>
嵌套运算符处理嵌套的集合，集合的条目本身就包含了一个集合</p></li>
</ul>

<p><strong>@distinctUnionOfArrays</strong> 返回右键集合属性的所有集合元素中不重复值的集合</p>

<pre><code class="language-objectivec">    NSArray *arr = [objArray valueForKeyPath:@&quot;@distinctUnionOfArrays.transactionsArray.payee&quot;];
</code></pre>

<p><strong>unionOfArrays</strong> 返回右键集合属性的所有元素集合（不去重）</p>

<pre><code class="language-objectivec">    NSArray *arr1 = [objArray valueForKeyPath:@&quot;@unionOfArrays.transactionsArray.payee&quot;];
</code></pre>

<p><strong>@distinctUnionOfSets</strong> 与<code>distinctUnionOfArrays</code>类似 不同的是 其需要NSSet实例属性包含NSSet集合</p>

<h2 id="toc_11">KVC的搜索规则</h2>

<!--学习自简书[KVC原理剖析](https://www.jianshu.com/p/1d39bc610a5b)
-->

<p>NSObject提供的<code>NSKeyValueCoding</code>协议默认实现，将基于键的访问映射到对象属性。这些协议方法使用key参数在自己对象实例中搜索访问器、实例变量以及某些约定命名方法</p>

<h3 id="toc_12">基础Getter的搜索模式</h3>

<p><code>valueForKey:</code>的默认实现，会根据key参数在对象实例中进行以下搜索流程:</p>

<ol>
<li>按顺序搜索实例变量中的方法名类似:<code>get&lt;Key&gt;</code>、<code>&lt;Key&gt;</code>、<code>is&lt;Key&gt;</code>或者<code>_&lt;Key&gt;</code>的方法,如果找到直接跳到第5步</li>
<li><p>搜索实例中匹配<code>countOf&lt;Key&gt;</code>方法和<code>objectIn&lt;Key&gt;AtIndex:</code>方法(对应NSArray类的基本方法)以及<code>&lt;key&gt;AtIndexes:</code>(对应NSArray的<code>objectsAtIndexes:</code>方法)，如果找到第一个方法以及至少后两个方法中的一个，就创建一个相应NSArray所有方法的集合代理对象并返回，否则执行第3步</p>
<p>这个代理对象会将接收到的所有NSArray消息转换为<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexes:</code>方法的组合来交给原始对象响应。如果原始对象还实现了<code>get&lt;Key&gt;:range:</code>可选方法，也会在适当时候是使用；这个数组代理对象工作起来就像真的NSArray一样</p>
<blockquote>
<p>代理对象的作用只是将交给其的方法进行组合，转交给原始对象响应，让其工作的像一个真的数组一样</p>
</blockquote></li>
<li><p>搜索名字为<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>和<code>memberOf &lt;Key&gt;</code>的三个方法(对应NSSet类定义方法)，如果找到这个3个方法就返回一个响应所有NSSet方法的代理对象，否则执行第4步<br/>
其会将随后收到的所有NSSet方法转换为上面3个方法的组合，让这个代理对象就像真的NSSet一样</p></li>
<li><p>如果上面方法都没找到，并且接收对象的<code>accessInstanceVariablesDirectly</code>类方法返回YES。就按顺序搜索<code>_&lt;key&gt;</code>、<code>_isKey</code>、<code>&lt;Key&gt;</code>、<code>is&lt;Key&gt;</code>实例变量名，找到的话执行第5步，否则执行第6步</p></li>
<li><p>如果是对象就直接返回，如果为非对象就装箱返回</p></li>
<li><p>如果都没找到就触发<code>valueForUndefineKey:</code>异常</p></li>
</ol>

<h3 id="toc_13">基础Setter模式搜索</h3>

<ol>
<li>按顺序搜索名字为<code>set&lt;Key&gt;</code>或者<code>_set&lt;Key&gt;</code>的访问器，找到就直接调用</li>
<li>如果找不到简单访问器，并且类方法<code>accessInstanceVariablesDirectly</code>类方法返回YES，并且按顺序查找<code>&lt;Key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>实例变量，如果找到直接设置值</li>
<li>以上两步都找不到,带用<code>setValue:forUndefinedKey:</code>默认会引发异常</li>
</ol>

<h3 id="toc_14">可变数组的搜索模式</h3>

<p><code>mutableArrayValueForKey:</code>用一下流程返回一个可变数组的代理对象</p>

<ol>
<li><p>搜索方法<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>(对应NSMutableArray的私有方法<code>insertObject:atIndex:</code>和<code>removeObjectAtIndex:</code>)，或者方法名为<code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>（对应NSMutableArray的为<code>insertObjects:atIndexes:</code>和<code>removeObjectsAtIndexes:</code>）。假如对象有至少一个insert方法或者一个remove方法，就返回一个响应<code>NSMutableArray</code>方法的代理对象。</p>
<p>代理对象通过发送一些组合的消息insertObject:in<Key>AtIndex:, removeObjectFrom<Key>AtIndex:, insert<Key>:atIndexes:,和remove<Key>AtIndexes:给<code>mutableArrayValueForKey:</code>消息的原始接收者来响应这些插入或者删除方法</p>
<p>当接收<code>mutableArrayValueForKey：</code>的原始消息对象实现名称为<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject:</code>或<code>replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code>的（可选）替换方法时，代理对象也会在适当时使用这些方法以获得最佳性能。</p>
<blockquote>
<p>代理的可变对象会响应所有NSMUtalbeArray方法，并将其转交给原始的对象消息接受者，对集合数组进行修改</p>
</blockquote></li>
<li><p>如果对象没有可变数组方法，就搜索名称为<code>set&lt;Key&gt;:</code>的访问器方法，这种情况会向<code>mutableArrayValueForKey:</code>的原始接收者发出<code>set&lt;Key&gt;</code>方法来，来响应NSMutableArray代理对象的消息</p>
<blockquote>
<p>注意: 这种方法的机制会比上一步的效率低得多，它会重复创建集合而不是修改原有集合,在使用KVC时应该尽量避免这种情况</p>
</blockquote></li>
<li><p>加入以上2中都没找到哦，并且对象响应<code>accessInstanceVariablesDirectly</code>类方法返回YES，就按顺序搜索<code>_&lt;Key&gt;</code>和<code>&lt;Key&gt;</code>的实例变量<br/>
找到这样的实例变量，就返回一个代理对象，会把NSMutableArray消息转发给实例变量</p></li>
<li><p>如果以上消息都失败了，就返回一个NSMutableArray的代理对象，该对象在收到<code>NSMutablrArray</code>消息后向<code>mutableArrayValueForKey:</code>原始接受者发出<code>setValue:ForUndefineKey:</code>消息，会引起<code>NSUndefinedKeyException</code>异常</p></li>
</ol>

<h3 id="toc_15">MutableOrderedSet的搜索模式</h3>

<p><code>mutableOrderedSetValueForKey</code> 与 数组搜索模式类似 ，只是其第一步搜索的方法为<code>insertObject:in&lt;Key&gt;AtIndex:</code>和<code>removeObjectFrom&lt;Key&gt;AtIndex:</code>、 <code>insert&lt;Key&gt;:atIndexes:</code>和<code>remove&lt;Key&gt;AtIndexes:</code>和可选方法<code>replaceObjectIn&lt;Key&gt;AtIndex:withObject: 或 replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</code></p>

<h3 id="toc_16">MutableSet搜索模式</h3>

<p>和mutableArray类似</p>

<p>第一步方法为:<br/>
<code>add&lt;Key&gt;Object:</code>和 <code>remove&lt;Key&gt;Object:</code> <code>add&lt;Key&gt;:</code>和<code>remove&lt;Key&gt;:</code>和可选方法<code>intersect&lt;Key&gt;: or set&lt;Key&gt;:</code></p>

<p>多了第二步骤搜索:<br/>
加入<code>mutableSetValueForKey</code>方法调用者是<code>manager object</code>则搜索模式不在继续,详情看CoreData核心编程指南</p>

<h2 id="toc_17">KVC性能</h2>

<p>KVC性能没有直接访问属性快，但是性能消耗微乎其微;<br/>
但是需要注意对操作可变集合对象的搜索模式，最好自己实现方法，避免重复创建集合进行赋值，这样性能消耗太大</p>

<h2 id="toc_18">注意</h2>

<ol>
<li>KVC本质是运行时查找对象实例的方法或变量，因此可以利用其访问私有变量，因此可以利用这一点，修改系统组件的样式或属性</li>
<li>为避免KVC的硬编码，可以采用<code>NSStringFromSelector(@selector(METHODNAME))</code></li>
<li>可以用KVC来触发KVO，即使在对象没有set访问器方法的情况下，即直接时候使用kvc赋值给对象的实例变量而该变量没有set方法时</li>
</ol>

<p>参考资料: <a href="https://www.jianshu.com/p/1d39bc610a5b">KVC原理剖析</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[main函数之前发生了什么]]></title>
    <link href="https://acefish.github.io/15549543814877.html"/>
    <updated>2019-04-11T11:46:21+08:00</updated>
    <id>https://acefish.github.io/15549543814877.html</id>
    <content type="html"><![CDATA[
<p>学习自sunnyxx的<a href="https://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></p>

<h2 id="toc_0">dyld</h2>

<h3 id="toc_1">动态链接库</h3>

<p>iOS中用到系统frameWork都是动态链接的</p>

<p>使用<code>otool</code>命令查看依赖的动态库</p>

<pre><code class="language-objectivec">otool -L TestMain

TestMain:
    /System/Library/Frameworks/CoreGraphics.framework/CoreGraphics
    /System/Library/Frameworks/UIKit.framework/UIKit
    /System/Library/Frameworks/Foundation.framework/Foundation
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation
    /usr/lib/libobjc.A.dylib    /usr/lib/libSystem.B.dylib 
</code></pre>

<p>除了我们添加或依赖的系统动态库，还有默认添加的lib:<code>libobjc</code>（objc和runtime需要依赖的库），<code>libSystem</code>包含了很多系统界别的lib,常用到的有：</p>

<ul>
<li>libdispatch(GCD)</li>
<li>libsystem_c(C语言库)</li>
<li>libsystem_blocks(Block)</li>
<li>libcommonCrypto(加密库，比如常用的md5函数)</li>
</ul>

<p>这些库都是<code>dylib</code>格式</p>

<h3 id="toc_2">dyld(the dynamic link editor)</h3>

<p>Apple的动态链接器，系统kernel做好启动程序的准备后由dyld负责,dyld作用顺序概括:</p>

<ol>
<li>从kernel留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li>
<li>non-lazy符号立即link到可执行文件，lazy的存到表里</li>
<li>为可执行文件执行静态初始化</li>
<li>找到可执行文件的main函数，准备参数并调用</li>
<li>程序执行中 绑定lazy符号、提供runtime动态加载、提供调试器的接口</li>
<li>程序main函数return后执行static terminator</li>
<li>某些场景下 main函数结束后调用libSystem的__exit函数</li>
</ol>

<p>dyld是开源的，<a href="https://github.com/opensource-apple/dyld">源码github地址</a></p>

<p>在项目源码中有<code>dyldStartup.s</code>这个汇编文件，实现了<code>__dyld_start</code>,其主要实现了:</p>

<ol>
<li>调用dyldbootstrap::start()方法</li>
<li>上个方法返回了main函数地址，填入参数并调用main函数</li>
</ol>

<p><img src="media/15549543814877/15549648909838.jpg" alt="" style="width:350px;"/></p>

<p>栈底的dyldbootstrap::start()方法，继而调用了dyld::_main()方法，其中完成了刚才说的递归加载动态库过程，由于libSystem默认引入，栈中出现了libSystem_initializer、libdispatch_init、_objc_init等的初始化方法。</p>

<h2 id="toc_3">ImageLoader</h2>

<p>image指二进制文件，里面是各种符号和代码等，因此ImageLoader是将这些文件加入内存</p>

<h2 id="toc_4">runtime与load</h2>

<p><code>libSystem</code>是是若干系统lib的集合容器，里面就一个<code>init.c</code>文件，因此调用<code>libSystem_initializer</code>会逐步调用到<code>_objc_init</code>，这个就是objc和runtime<br/>
的初始化入口</p>

<p>这里除了初始化runtime环境外，_objc_init绑定了新image被加载后的<code>callback</code>：</p>

<pre><code class="language-objectivec">dyld_register_image_state_change_handler(
dyld_image_state_bound, 1, &amp;map_images);
dyld_register_image_state_change_handler(
dyld_image_state_dependents_initialized, 0, &amp;load_images);
</code></pre>

<p>当新的image被加载进来之后由<code>runtime</code>去解析这个二进制文件的符号表和代码</p>

<p><img src="media/15549543814877/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-11%2014.28.40.png" alt=" 屏幕快照 2019-04-11 14.28.40" style="width:300px;"/></p>

<p>整个调用顺序:</p>

<ol>
<li>dyld将整个应用程序二进制文件初始化</li>
<li>由ImageLoader读取image，其中包括了代码、类和方法各种符号</li>
<li>因为runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime处理</li>
<li>runtime调用回调函数<code>map_image</code>做解析处理，之后<code>load_images</code>调用<code>call_load_methods</code>方法，遍历所有加载的class，然后按照继承和层架关系调用Class和其Category的<code>+load()</code>方法</li>
</ol>

<h3 id="toc_5">load方法收集</h3>

<p>在<code>loadImage</code>后 会调用<code>prepare_load_methods</code>方法来获取所有类的列表，并且收集其中load方法。这个方法中会调用<code>schedule_class_load</code>遍历类递归至根节点来收集完成的关系树，并执行<code>add_class_to_loadable_list</code>将其加入执行列表， 然后调用<code>call_load_methods</code>方法，其会创建一个<code>autoreleasePool</code>使用函数指针来动态调用类和<code>Category</code>的<code>+load</code>方法</p>

<p>此时，可执行文件中和动态库所有符号<code>Class、Protocol、Selector、IMP...</code>等都已经按照格式加载到内存，并被runtime管理，这样之后，<code>runtime</code>运行时机制和那些方法（动态添加class、swizzle等）才能生效</p>

<h2 id="toc_6">真正的main函数</h2>

<p>当前面的这些操作结束，dyld会清理现场，将调用栈回归，调用真正的main函数</p>

<p><img src="media/15549543814877/15549695741385.jpg" alt="" style="width:300px;"/></p>

<h2 id="toc_7">补充</h2>

<p>此处只提及了runtime这个分支的初始化以及所做的事情，真正流程比这个复杂的多，还有类似<code>GCD</code><code>XPC</code>等系统库分支</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIApplicationMain]]></title>
    <link href="https://acefish.github.io/15547885598364.html"/>
    <updated>2019-04-09T13:42:39+08:00</updated>
    <id>https://acefish.github.io/15547885598364.html</id>
    <content type="html"><![CDATA[
<p>创建一个应用程序对象和代理，并且设置事件循环(包括应用的runloop)</p>

<pre><code class="language-objectivec">int UIApplicationMain(int argc, char * _Nullable *argv, NSString *principalClassName, NSString *delegateClassName);
//argc: argv参数的个数
//argv: 提供给main函数的参数
//principalClassName: 设置UIApplicaion类或其子类的名字，可以为nil即默认为UIApplication
//delegateClassName: 设置代理，假如从应用的main nib file加载可以该参数传空
</code></pre>

<blockquote>
<p>If the application’s Info.plist file specifies a main nib file to be loaded, by including the NSMainNibFile key and a valid nib file name for the value, this function loads that nib file.</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15543696145918.html"/>
    <updated>2019-04-04T17:20:14+08:00</updated>
    <id>https://acefish.github.io/15543696145918.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络安全、本地存储安全和逆向]]></title>
    <link href="https://acefish.github.io/15543692800437.html"/>
    <updated>2019-04-04T17:14:40+08:00</updated>
    <id>https://acefish.github.io/15543692800437.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时]]></title>
    <link href="https://acefish.github.io/15543581687703.html"/>
    <updated>2019-04-04T14:09:28+08:00</updated>
    <id>https://acefish.github.io/15543581687703.html</id>
    <content type="html"><![CDATA[
<p>苹果开放的<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/">源码</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15543461783731.html"/>
    <updated>2019-04-04T10:49:38+08:00</updated>
    <id>https://acefish.github.io/15543461783731.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础使用]]></title>
    <link href="https://acefish.github.io/15542595230571.html"/>
    <updated>2019-04-03T10:45:23+08:00</updated>
    <id>https://acefish.github.io/15542595230571.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-objectivec">//直接定义
@property (nonatomic, copy) void(^block)(NSInteger);

//方法中定义
block:(void(^) (NSInteger index))block;

//其他定义
typedef void(^Block)(NSInteger index);
@property (nonatomic, copy) Block block;
</code></pre>

<pre><code class="language-objectivec">//声明加定义
returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[静态库与动态库]]></title>
    <link href="https://acefish.github.io/15542163059530.html"/>
    <updated>2019-04-02T22:45:05+08:00</updated>
    <id>https://acefish.github.io/15542163059530.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">库</h2>

<p>库(library)就是一堆对象文档(.o文件)的归档，是一段编译好的二进制代码,加上头文件来供别人使用。</p>

<p>使用库的情况:</p>

<ol>
<li>当我们想封装代码给别人使用而不想别人看到源码</li>
<li>当代码不会经常改动，可以将其打包成库，减少编译时间</li>
</ol>

<h2 id="toc_1">静态库</h2>

<p>静态库:在静态链接时会被直接复制目标程序中，这样在编译完成后程序并没有外部依赖，但是目标程序会变大</p>

<p>静态库在windows中为<code>.lib</code> mac和linux下为<code>.a</code> mac下还有 <code>.framework</code></p>

<h2 id="toc_2">动态库</h2>

<p>动态库:动态库在静态链接时并不会被拷贝到目标程序中，目标程序只会存储指向动态库的引用，程序运行时，动态库才会真正加载进来，动态库不需要拷贝到程序中，不影响程序体积，同一份库可以被多个程序使用，但是使目标程序依赖于外部环境</p>

<p>动态库在windows下为<code>.dll</code> mac为<code>.dylib和.framework</code> linux下为<code>.so</code> (系统提供的framework都是动态库)</p>

<p>在Xcode7之后，<code>.dylib</code>文件替换为了<code>.tbd</code>文件</p>

<p>动态库好处:</p>

<ul>
<li>代码共用: 在磁盘中只需要一份，可以让多个程序共用依赖链接</li>
<li>易于维护: 因为是程序执行时才link的，因此lib很容易更新替换</li>
<li>减少可执行文件体积: 不需要打包进可执行文件，因此执行文件体积就小了很多</li>
</ul>

<h3 id="toc_3">.dylib与.tbd</h3>

<p><code>.tbd</code>是基于文本的，因此只是包含在项目中的文本文件，其作用是指向所需的<code>.dylib</code>二进制文件链接。因为文本文件比二进制文件小很多，因此可以减少其下载大小(在实际动态链接时，仍然链接的为.dylib文件)</p>

<h3 id="toc_4">.framwork</h3>

<p>在iOS开发中还会用到<code>Framework</code>，在iOS8之前 只能使用苹果的framework动态库，而在iOS8之后，开发者可以自己打包framework，但是自己开发的framework还是类似静态库，需要拷贝到app中，苹果又把这种 Framework 称为 Embedded Framework</p>

<h3 id="toc_5">系统的.framework与.dylib</h3>

<p>系统为什么提供了.dylib动态库还有.framework动态库<br/>
个人觉得是因为他们层级不一样,.dylib是系统操作<strong>系统内置库</strong>，底层的；.framework是开发的应用层级<strong>框架</strong></p>

<h2 id="toc_6">参考资料</h2>

<p><a href="http://www.cnblogs.com/Jenaral/p/5530383.html">iOS 静态库，动态库与 Framework 浅析</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APP启动优化]]></title>
    <link href="https://acefish.github.io/15542146663946.html"/>
    <updated>2019-04-02T22:17:46+08:00</updated>
    <id>https://acefish.github.io/15542146663946.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">App启动主要包括三个阶段</h2>

<ol>
<li>main()函数执行前</li>
<li>main()函数执行后</li>
<li>首屏渲染完成</li>
</ol>

<h3 id="toc_1">main函数执行前</h3>

<ul>
<li>加载可执行文件</li>
<li>加载动态链接库</li>
<li>Objc运行时的初始处理，包括Objc相关类的注册、category注册、selector唯一性检查等</li>
<li>初始化，包括执行+load()方法，attribute((constructor))修饰的函数调用、创建C++静态全局变量</li>
</ul>

<p>因此可做的优化:</p>

<ul>
<li>减少动态库加载。每个库本身都有依赖关系,使用更少的动态库，如果使用的动态库数量较多，尽量将多个动态库合并。苹果支持做多可以支持6个非系统动态库合并为一个</li>
<li>减少加载启动后不会去使用的类或者方法</li>
<li>+load()方法内容可以放到首屏渲染完成后再执行，或者使用<code>+initialize()</code>方法替换。因为，在一个<code>+load()</code>方法中，进行运行时方法替换操作会带来4好眠的消耗，避免积少成多，对启动速度带来影响</li>
<li>控制C++全局变量的数量</li>
</ul>

<h3 id="toc_2">main函数执行后</h3>

<p>main()执行后的阶段，从main()函数执行开始，到<code>appDelegate</code>中<code>didFinishLaunchingWithOptions</code>方法里首屏渲染相关方法执行完成</p>

<p>这个阶段主要为首页需要的业务代码，包括：</p>

<ul>
<li>首屏初始化所需配置文件读写操作</li>
<li>首屏列表大数据的读取</li>
<li>首屏渲染的大量计算等</li>
</ul>

<p>我们不应该把各种初始化都放在这个时候，应该只在这个时候放置首屏渲染必须的任务</p>

<h3 id="toc_3">首屏渲染完成后</h3>

<p>非首屏其它业务模块的初始化，监听的注册、配置文件的读取等。即，截止到<code>didFinishLaunchingWithOptions</code>方法作用域执行收评渲染之后所有方法执行完成。</p>

<h2 id="toc_4">优化</h2>

<h3 id="toc_5">功能级别优化</h3>

<p>main（）函数开始执行后，到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做</p>

<h3 id="toc_6">方法级别的优化</h3>

<p>即检查首屏渲染完成前主线程有哪些耗时的方法，将耗时方法滞后或者异步。</p>

<blockquote>
<p>常见的耗时方法通常是计算大量数据时，即加载、编辑、存储图片和文件等资源时，但是也有可能为其它方法类似load方法太多的堆积耗时</p>
</blockquote>

<h4 id="toc_7">1. 定时抓取主线程上的方法堆栈，计算一段时间内各个方法的耗时</h4>

<p>Xcode中的Time Profiler就是这种方式</p>

<p>这种方法需要考虑设置抓取的定时间隔，间隔长了会漏掉一些方法，导致检查出来耗时不准确；而设置的短了，抓取堆栈方法本身调用过多也会影响整体耗时，导致结果不准确</p>

<p>一般将时间设置为0.01s，这样对整体耗时影响小，虽然此时很多耗时方法不准确了，但是因为整体耗时更加重要，这也是够用的</p>

<h4 id="toc_8">2. 对obcc_msdSend方法进行hook掌握所有方法的执行耗时</h4>

<p>hook <code>objc_msgSend</code>优点是非常精确，而缺点即只能针对OC方法，对C方法和block方法需要使用<code>libffi</code>的<code>ffi_call</code>来hook了，但是编写维护相关工具门槛较高</p>

<p><strong>原理</strong>:<br/>
OC中的每个对象都会指向一个类，每个类也都有一个方法类表，方法列表中的方法由<code>selector</code>函数指针<code>metadata</code>组成，objc_msgSend就是在运行时根据对象和方法的selector去找相应的函数指针，然后执行，然后执行，因此objc_msgSend是OC放大执行的必经之路<br/>
objc_msgSend调用频率最高，本身是用汇编语言写的，可以提高app生命周期的性能，也可以实现未知参数跳转到任意函数指针的功能</p>

<h2 id="toc_9">Hook objc_msgSend方法</h2>

<p>Fackbook开源了一个库，可以再iOS上运行的Mach-O二进制文件中动态地重新绑定符号，<strong>fishhook</strong><a href="https://github.com/facebook/fishhook">源码地址</a></p>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LLDB]]></title>
    <link href="https://acefish.github.io/15541740415551.html"/>
    <updated>2019-04-02T11:00:41+08:00</updated>
    <id>https://acefish.github.io/15541740415551.html</id>
    <content type="html"><![CDATA[
<p>学习自 <a href="https://juejin.im/post/5c8ca84ce51d456f43189dbd">LLDB 知多少</a></p>

<p>LLDB是一个有着REPL的特性和C++、Python插件的开源调试器<br/>
LLDB是下一代高性能调试器。 它由一组可重用的组件构建，可以高度利用较大的LLVM项目中的现有库，例如Clang表达式解析器和LLVM反汇编程序。<br/>
LLDB是Mac OS X上Xcode的默认调试器，支持在桌面和iOS设备和模拟器上调试C，Objective-C和C ++。</p>

<h2 id="toc_0">LLDB命令结构</h2>

<p>LLDB命令通用结构:</p>

<pre><code class="language-c">&lt;command&gt;[&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]
</code></pre>

<ul>
<li>commond、subcommond：LLDB调试命令的名称。命令和子命令按照层级结构来排列:一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，以此类推</li>
<li>action：命令操作，想在前面的命令序列的上下文中执行的一些操作</li>
<li>options：命令选项，行为修改器。通常带有一些值</li>
<li>argument：命令参数，根据使用的命令的上下文来表示不同的东西</li>
<li>[]：表示命令可选</li>
</ul>

<p>例如:<br/>
<code>breakpoint set -n main</code> <br/>
command为breakpoint、action为set、option即为-n表示根据方法name设置断点、argument：main表示方法名main</p>

<h4 id="toc_1">原始命令</h4>

<p>LLDB支持不带命令选项的原始命令，原始命令会将命令后面的所有东西当做参数(arguement)处理。但很多原始命令也可以带命令选项，当你使用命令选项的时候，需要在命令选项<strong>后面</strong>加<code>--</code>区分命令选项和参数。<br/>
例如： <br/>
<code>expression</code>(就是<code>p</code>/<code>print</code>/<code>call</code>)、<code>expression -o</code>(就是 <code>po</code>)，我们用这两个命令打印一下一个<code>UIView</code>的地址</p>

<pre><code class="language-objectivec">//调用对象的description方法
(lldb) po 0x7fe8a201b400
&lt;UITableView: 0x7fe8a201b400; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x600001c072a0&gt;; layer = &lt;CALayer: 0x6000012029e0&gt;; contentOffset: {0, 0}; contentSize: {0, 0}; adjustedContentInset: {0, 0, 0, 0}&gt;

//计算地址的值
(lldb) expression 0x7fa3b981ee00
(long) $0 = 140341168696832

(lldb) p 0x7fa3b981ee00
(long) $1 = 140341168696832

//expression即为一个原始命令 为了告诉其 -o为命令选项而不是参数 需要加上 --
(lldb) expression -o -- 0x7fa3b981ee00
&lt;UITableView: 0x7fa3b981ee00; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x600001e19ce0&gt;; layer = &lt;CALayer: 0x600001001420&gt;; contentOffset: {0, 0}; contentSize: {0, 0}; adjustedContentInset: {0, 0, 0, 0}&gt;

(lldb) expression -object -- 0x7fa3b981ee00
&lt;UITableView: 0x7fa3b981ee00; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x600001e19ce0&gt;; layer = &lt;CALayer: 0x600001001420&gt;; contentOffset: {0, 0}; contentSize: {0, 0}; adjustedContentInset: {0, 0, 0, 0}&gt;
</code></pre>

<blockquote>
<p>假如前n个字母已经能匹配到某个命令，则只写前n个命令等效于写下完整的命令。</p>
</blockquote>

<h2 id="toc_2">LLDB常用命令</h2>

<h3 id="toc_3">apropos 辅助记忆</h3>

<p>当不能完全记得某个命令时，使用<code>apropos</code>通过命令中的关键字获取相关命令信息</p>

<p><img src="media/15541740415551/15541870365461.jpg" alt=""/></p>

<h3 id="toc_4">断点设置</h3>

<p>使用断点命令，实现图形化界面不好实现的功能</p>

<ol>
<li>breakpoint list: 查看所有断点列表</li>
<li>breakpoint delete: 删除所有断点（可以跟上组号，表示删除指定组）</li>
<li>breakpoint disable/enable: 禁用 启用指定断点</li>
<li>breakpoint set -r some：遍历项目中包含some这个字符所有方法并设置断点</li>
<li>breakpoint 支持按文件名、函数名、行数、正则等各种条件筛选设置断点</li>
<li>watchpoint set expression 0x10cc64d50: 在内存中为地址为0x10cc64d50的对象设置内存断点</li>
<li>target stop-hook add -o &quot;frame variable&quot;: 添加每次程序stop时都希望执行的命令</li>
<li>target stop-hook、watchpoint 的增删改查命令与 breakpoint 的基本相同</li>
<li>等等</li>
</ol>

<h3 id="toc_5">流程控制</h3>

<ol>
<li><p>图一<br/>
<img src="media/15541740415551/15541893007015.jpg" alt=""/></p></li>
<li><p>图二<br/>
<img src="media/15541740415551/15541893330198.jpg" alt=""/></p></li>
</ol>

<ul>
<li>第一个按钮：continue/c 继续执行</li>
<li>第二个按钮：
<ul>
<li>图一： thread step-over/next/n 当前线程下一步（以一个完整子函数为一步）</li>
<li>图二： thread step-inst-over/ni 当前线程下一步（以一个汇编函数为一步）</li>
</ul></li>
<li>第三个按钮：
<ul>
<li>图一： thread step-in/step/s 当前线程下一步（遇到子函数就进入并且继续单步执行）</li>
<li>图二： thread step-inst-over/si 当前线程下一步（遇到汇编函数就进入并且继续单步执行汇编指令）</li>
</ul></li>
<li>第四个按钮：thread step-out/finish 退出当前帧栈</li>
</ul>

<p><strong>其他命令</strong></p>

<ul>
<li>thread return: 有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离次函数、伪造返回值的方式。</li>
</ul>

<h3 id="toc_6">可执行文件&amp;共享库查询命令</h3>

<p>这些命令常用于逆向和定位错误时</p>

<ol>
<li>image list: 列出主要的可执行文件和所有依赖的共享库。</li>
<li><p>image lookup --address 0x1ec4：在可执行文件或者任何共享库中查找原始地址信息</p></li>
<li><p>image lookup -v --address 0x1ec4：查找完整的源代码行信息。</p></li>
<li><p>image lookup --type NSString：根据名称查找对应（NSString）类型的信息。</p></li>
</ol>

<h3 id="toc_7">其它常用命令模板</h3>

<ul>
<li><code>register read</code>：显示当前线程的通用寄存器。</li>
<li><code>register write rax 123</code>：将一个新的十进制值“123”写入当前线程寄存器“rax”。</li>
<li><code>memory read --size 4 --format x --count 4 0xbffff3c0</code>：从地址0xbffff3c0读取内存，并显示4个十六进制uint32_t值。</li>
</ul>

<h2 id="toc_8">插件</h2>

<ol>
<li>推荐插件一： facebook 开源的 LLDB 插件 <a href="https://github.com/facebook/chisel">chisel</a></li>
<li>推荐插件二：<a href="https://github.com/DerekSelander/LLDB">DerekSelander/LLDB</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可变数组的实现原理]]></title>
    <link href="https://acefish.github.io/15541732018193.html"/>
    <updated>2019-04-02T10:46:41+08:00</updated>
    <id>https://acefish.github.io/15541732018193.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
</feed>
