<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[栗豫塬的博客]]></title>
  <link href="https://acefish.github.io/atom.xml" rel="self"/>
  <link href="https://acefish.github.io/"/>
  <updated>2017-09-07T10:26:17+08:00</updated>
  <id>https://acefish.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="https://acefish.github.io/15047511695312.html"/>
    <updated>2017-09-07T10:26:09+08:00</updated>
    <id>https://acefish.github.io/15047511695312.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扩展]]></title>
    <link href="https://acefish.github.io/15042587690391.html"/>
    <updated>2017-09-01T17:39:29+08:00</updated>
    <id>https://acefish.github.io/15042587690391.html</id>
    <content type="html"><![CDATA[
<p><strong>扩展</strong>就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能</p>

<blockquote>
<p>类似OC中的分类功能,但是Swift中的分类没有名字</p>
</blockquote>

<p><strong>Swift中的扩展可功能</strong>:</p>

<ul>
<li>添加计算型属性和计算类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议
还可以对协议进行扩展、提供协议要求的实现，添加额外的功能，让符合协议的类型拥有这些功能</li>
</ul>

<blockquote>
<p>扩展只能添加新的功能不能重写已有功能</p>
</blockquote>

<h2 id="toc_0">扩展语法</h2>

<p>用关键字<code>extension</code>声明扩展:</p>

<pre><code class="language-swift">extension SomeType {
    // 为 SomeType 添加的新功能写到这里
}
</code></pre>

<p>扩展一个已有类型,使其采纳一个或多个协议</p>

<pre><code class="language-swift">extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>

<blockquote>
<p>扩展一个已有实例的新功能,那么新功能对该类型所有实例都可用，不论创建时间</p>
</blockquote>

<h2 id="toc_1">计算型属性</h2>

<pre><code class="language-swift">extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print(&quot;One inch is \(oneInch) meters&quot;)
    // 打印 “One inch is 0.0254 meters”
let threeFeet = 3.ft
print(&quot;Three feet is \(threeFeet) meters&quot;)
    // 打印 “Three feet is 0.914399970739201 meters”
</code></pre>

<p>扩展<code>Double</code>类型,增加计算型属性,实现距离转换<br/>
上面的属性是只读的计算型属性,省略了<code>get</code>关键字</p>

<blockquote>
<p>可以增加新的计算型属性,但是不能增加存储型属性，也不能为已有属性添加属性观察器</p>
</blockquote>

<h2 id="toc_2">构造器</h2>

<p>扩展可以为已有类型添加新的构造器。<br/>
扩展能为类添加新的便利构造器,但是不能为类添加新的指定构造器或者析构器</p>

<blockquote>
<p>如果使用扩展为一个“值类型”添加构造器,同时该值类型的原始实现没有定义定制构造器,且所有存储属性提供了默认值,我们可以在扩展的构造器中调用默认构造器和逐一成员构造器(当原始实现中有定制的构造器,就不能调用了)</p>
</blockquote>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>

<p>因为<code>Rect</code>没有指定构造器,存储属性也都有默认值,因此获得一个逐一成员构造器和默认构造器，</p>

<pre><code class="language-swift">extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        //调用结构体的逐一成员构造器
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>

<h2 id="toc_3">方法</h2>

<p>为已有类型添加新的实例方法和类型方法</p>

<pre><code class="language-swift">extension Int {
    func repetitions(task: () -&gt; Void) {
        for _ in 0..&lt;self {
            task()
        }
    }
}
//为Int类型添加一个名为`repetitions`的实例方法
//这个方法接受一个`()-&gt;Void`类型的单参数，没有参数也没有返回值的函数
</code></pre>

<h3 id="toc_4">可变实例方法</h3>

<p>扩展中添加的实例方法也可以修改该实例本身，对于值类型即结构体或者枚举修改<code>self</code>或其属性的方法就必须将该实例方法标注为<code>mutating</code>(类似原始实现)</p>

<pre><code class="language-swift">extension Int {
    mutating func square() {
        self = self * self
    }
}
</code></pre>

<h2 id="toc_5">下标</h2>

<p>扩展为已有类型添加下标.</p>

<pre><code class="language-swift">extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
        for _ in 0..&lt;digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// 返回 5
746381295[1]
// 返回 9
//取的下标越界时自动用0补充
746381295[9]
// 返回 0，即等同于：
0746381295[9]
</code></pre>

<p>上面的例子为<code>Int</code>增加下标方法，<code>[n]</code>返回十进制数字从右向左数的第<code>n</code>个数字</p>

<h2 id="toc_6">嵌套类型</h2>

<p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型:</p>

<pre><code class="language-swift">extension Int {
    enum Kind {
    case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
</code></pre>

<p>为<code>Int</code>添加了一个嵌套枚举,来表明特定整数的类型，即正数、负数或零</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[嵌套类型]]></title>
    <link href="https://acefish.github.io/15042543172572.html"/>
    <updated>2017-09-01T16:25:17+08:00</updated>
    <id>https://acefish.github.io/15042543172572.html</id>
    <content type="html"><![CDATA[
<p><strong>嵌套类型:</strong>在支持的类型中定义嵌套的枚举、类和结构体</p>

<p>要在一个类型中嵌套另一个类型,将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套</p>

<h2 id="toc_0">嵌套类型实践</h2>

<pre><code class="language-swift">struct BlackjackCard {
    //嵌套的 Suit 枚举//牌的花色
    enum Suit: Character {
        case Spades = &quot;块&quot;, Hearts = &quot;心&quot;, Diamonds = &quot;*&quot;, Clubs = &quot;额&quot;
    }
    //嵌套的 Rank 枚举
    enum Rank: Int {
        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
        case Jack, Queen, King, Ace
        struct Values {//用于反应Ace有两种值，而其他只有一个
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
                case .Ace:
                    return Values(first: 1, second: 11)
                case .Jack, .Queen, .King:
                    return Values(first: 10, second: nil)
                default:
                    return Values(first: self.rawValue, second: nil)
            }
        }
    }
    // BlackjackCard 的属性和方法
    let rank: Rank, suit: Suit
    var description: String {
        var output = &quot;suit is \(suit.rawValue),&quot;
        output += &quot; value is \(rank.values.first)&quot;
        if let second = rank.values.second {
            output += &quot; or \(second)&quot;
        }
        return output
    }
}
</code></pre>

<p><code>BlackjackCard</code>结构体有默认的成员构造器,可以用默认构造器去初始化常量:</p>

<pre><code class="language-swift">/**
尽管Rank和Suit嵌套在BlackjackCard中,类型可以从上下文推断出来,
因此可以用`.Ace 和.Spades`引用枚举实例
*/
let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)
// 打印 “theAceOfSpades: suit is ?, value is 1 or 11”
</code></pre>

<h2 id="toc_1">引用嵌套类型</h2>

<p>在嵌套类型的类型名前加上外部类型的类型名作为前缀:</p>

<pre><code class="language-swift">let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
//红心符号
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型转换]]></title>
    <link href="https://acefish.github.io/15037348375137.html"/>
    <updated>2017-08-26T16:07:17+08:00</updated>
    <id>https://acefish.github.io/15037348375137.html</id>
    <content type="html"><![CDATA[
<p>在<code>Swift</code>中通过<code>is</code>和<code>as</code>操作符来实现<strong>类型转换</strong>，可以来检查值的类型或者转换类型<br/>
可以用它检查一个类型是否实现了某个协议</p>

<h2 id="toc_0">定义一个类层次作为例子</h2>

<p>在数组中存了一个父类的两个子类的实例</p>

<blockquote>
<p>在数组中存在两种子类类型,会推断这个数组为共同的父类类型<br/>
此时虽然数组中存的是子类类型实例,但是迭代的话取出的实例会为父类类型，此时我们需要判断和转换类型</p>
</blockquote>

<h2 id="toc_1">检查类型</h2>

<p>用类型检查操作符<code>is</code> 检查实例是否属于特定子类型，返回<code>bool</code>值</p>

<pre><code class="language-swift">for item in library {
    if item is Movie { //判断实例是否为 Movie类型
        movieCount += 1
    } else if item is Song { //判断实例是否为 Song类型
        songCount += 1
    }
}
</code></pre>

<h2 id="toc_2">向下转型</h2>

<p>当某类型的实例属于一个子类,可以用<code>as?</code>或者<code>as!</code>将其向下转换位子类类型</p>

<p>因为向下转型可能失败，因此提供<code>as?</code>和<code>as!</code>(带上强制解包)，当不确定是否成功时用<code>as?</code> 确定一定成功时<code>as!</code></p>

<pre><code class="language-swift">for item in library {
    if let movie = item as? Movie {
        print(&quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    } else if let song = item as? Song {
        print(&quot;Song: &#39;\(song.name)&#39;, by \(song.artist)&quot;)
    }
}
</code></pre>

<p><code>if let movie = item as? Movie</code>尝试将<code>item</code>转为<code>Movie</code>类型。若成功，设置一个新的临时常量<code>movie</code>来存储返回的可选<code>Movie</code>中的值</p>

<h2 id="toc_3">Any和AnyObject的类型转换</h2>

<p>不确定类型的表达方式:<br/>
<code>Any</code>可以表示任何类型，包括函数类型。<br/>
<code>AnyObject</code>可以表示任何类类型的实例</p>

<p>建议只在确定需要使用时才使用<code>Any</code>和<code>AnyObject</code></p>

<pre><code class="language-swift">var things = [Any]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append(&quot;hello&quot;)
things.append((3.0, 5.0))
things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;))
things.append({ (name: String) -&gt; String in &quot;Hello, \(name)&quot; })
</code></pre>

<p>然后我们可以在<code>switch</code>表达式的</p>

<pre><code class="language-swift">for thing in things {
    switch thing {
    case 0 as Int:
        print(&quot;zero as an Int&quot;)
    case 0 as Double:
        print(&quot;zero as a Double&quot;)
    case let someInt as Int:
        print(&quot;an integer value of \(someInt)&quot;)
    case let someDouble as Double where someDouble &gt; 0:
        print(&quot;a positive double value of \(someDouble)&quot;)
    case is Double:
        print(&quot;some other double value that I don&#39;t want to print&quot;)
    case let someString as String:
        print(&quot;a string value of \&quot;\(someString)\&quot;&quot;)
    case let (x, y) as (Double, Double):
        print(&quot;an (x, y) point at \(x), \(y)&quot;)
    case let movie as Movie:
        print(&quot;a movie called &#39;\(movie.name)&#39;, dir. \(movie.director)&quot;)
    case let stringConverter as String -&gt; String:
        print(stringConverter(&quot;Michael&quot;))
    default:
        print(&quot;something else&quot;)
    }
}
// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of &quot;hello&quot;
// an (x, y) point at 3.0, 5.0
// a movie called &#39;Ghostbusters&#39;, dir. Ivan Reitman
// Hello, Michael
</code></pre>

<blockquote>
<p><code>Any</code>是可以表示所有类型的值,包括可选类型,当你在用<code>Any</code>类型来表示一个可选值时,会给出警告，此时可以用<code>as</code>操作符显示转换为<code>Any</code></p>
</blockquote>

<pre><code>let optionalNumber: Int? = 3
things.append(optionalNumber) // 会有警告
things.append(optionalNumber as Any) // 没有警告
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[错误处理]]></title>
    <link href="https://acefish.github.io/15034731740974.html"/>
    <updated>2017-08-23T15:26:14+08:00</updated>
    <id>https://acefish.github.io/15034731740974.html</id>
    <content type="html"><![CDATA[
<p><strong>错误处理</strong>就是响应错误以及从错误中回复的过程</p>

<p><code>Swift</code>提供了运行时对可恢复错误的抛出、捕获、传递和操作等的支持<br/>
通常用来区分失败情况,让程序解决并处理某些错误，把解决不了的错误报告给用户</p>

<h2 id="toc_0">表示并抛出错误</h2>

<p><code>Swift</code>中 错误用符合<code>Error</code>协议的类型值来表示，这个空协议表明该类型可以用于错误处理</p>

<p>通常用枚举类型来构建一组相关的错误状态,枚举的关联值可以提供错误状态的额外信息</p>

<p>使用关键字<code>throw</code>关键字来抛出一个错误，表示有意外发生</p>

<pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection //选择无效
    case insufficientFunds(coinsNeeded: Int) //金额不足
    case outOfStock //缺货
}

throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre>

<h2 id="toc_1">处理错误</h2>

<p><code>Swift</code>中有<code>4</code>种处理错误的方式<br/>
1.把函数抛出的错误传递给调用此函数的代码<br/>
2.用<code>do-catch</code>语句处理错误<br/>
3.将错误作为可选类型处理<br/>
4.断言此错误根本不会发生</p>

<p>我们在调用一个能抛出错误的函数、方法或者构造器之前，用<code>try</code>关键字或者<code>try?</code><code>try!</code>这种变体关键字</p>

<blockquote>
<p>与其他语言的<code>try</code>，<code>catch</code>和<code>throw</code>不同的是<code>swift</code>的错误挫力不涉及解除调用栈,因此其性能特性是可以和<code>return</code>语句相媲美的</p>
</blockquote>

<h3 id="toc_2">用throwing函数传递错误</h3>

<p>在函数声明的参数列表后加上<code>throws</code>关键字，表明可以抛出错误，这个函数就称为<code>throwing</code>函数<br/>
如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面</p>

<pre><code class="language-swift">func canThrowErrors() throws -&gt; String
func cannotThrowErrors() -&gt; String
</code></pre>

<p><strong><code>throwing</code>函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</strong></p>

<blockquote>
<p>对于<code>throwing</code>函数可以传递错误,非<code>throwing</code>函数抛出的错误只能在函数内部处理</p>
</blockquote>

<pre><code class="language-swift">struct Item {
    var price: Int
    var count: Int
}
class VendingMachine {
    var inventory = [
                     &quot;Candy Bar&quot;: Item(price: 12, count: 7),
                     &quot;Chips&quot;: Item(price: 10, count: 4),
                     &quot;Pretzels&quot;: Item(price: 7, count: 11)
                     ]
    var coinsDeposited = 0
    func dispenseSnack(snack: String) {
        print(&quot;Dispensing \(snack)&quot;)
    }
    //throwing函数 会抛出VendingMachineError错误
    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.InvalidSelection
        }
        guard item.count &gt; 0 else {
            throw VendingMachineError.OutOfStock
        }
        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }
        coinsDeposited -= item.price
        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem
        print(&quot;Dispensing \(name)&quot;)
    }
}
</code></pre>

<p>使用了<code>guard</code>语句来提前退出方法，因为<code>throw</code>语句会立即退出方法，保证只有在满足所有条件时才成功卖出商品</p>

<p><code>vend(itemNamed:)</code>会传递它抛出的所有错误,因此在跳用这个方法时，要么直接处理这些错误(<code>do-catch</code>语句,<code>try?</code>或<code>try!</code>)，要么将错误继续传递下去</p>

<pre><code class="language-swift">let favoriteSnacks = [
    &quot;Alice&quot;: &quot;Chips&quot;,
    &quot;Bob&quot;: &quot;Licorice&quot;,
    &quot;Eve&quot;: &quot;Pretzels&quot;,
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;
    try vendingMachine.vend(itemNamed: snackName)
}
//传似抛出的错误
</code></pre>

<p><code>buyFavoriteSnack</code>方法会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法尝试购买,通过在<code>vend(itemNamed:)</code>方法前加<code>try</code>关键字</p>

<p><code>throwing</code>构造器和<code>throwing</code>一样可以传递错误</p>

<pre><code class="language-swift">struct PurchasedSnack {
    let name: String
    init(name: String, vendingMachine: VendingMachine) throws {
        try vendingMachine.vend(itemNamed: name)
        self.name = name
    }
}
</code></pre>

<h3 id="toc_3">用Do-Catch处理错误</h3>

<p><strong><code>do-catch</code>语句运行一段<code>闭包</code>代码来处理错误</strong></p>

<p>在<code>do</code>语句抛出一个错误,与<code>catch</code>中的字句匹配</p>

<pre><code class="language-swift">do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</code></pre>

<p><code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误.如果<code>catch</code>没有指定错误模式，那就可以匹配任何错误，并且把错误绑定到名字为<code>error</code>的局部变量</p>

<p><code>catch</code>不必处理抛出的所有错误,错误可以传递到周围,但是必须被处理，可以使外围的<code>do-catch</code>语句 或者是一个<code>throwing</code>函数进行处理</p>

<p>注意:<br/>
在<code>do</code>语句中的<code>try</code>如果有抛出错误就立刻执行<code>catch</code>语句,并判断这个错误是否要被继续传递下去,否则执行<code>do</code>子句中余下的语句</p>

<h3 id="toc_4">将错误转换成可选值</h3>

<p>通过<code>try?</code>将错误转换为一个可选值,如果表达式有错误抛出,那么表达式的值就为<code>nil</code></p>

<pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()
//等效于
let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>

<p>此时不论<code>someThrowingFunction()</code>返回值是什么类型,x，y就是该返回值类型的可选类型</p>

<h3 id="toc_5">禁用错误传递</h3>

<p>当我们确定知道某个<code>throwing</code>函数在运行时是不会抛出错误的,那么可以用<code>tr<br/>
y!</code>来禁用错误传递，它会将调用包装在一个不会有错误抛出的运行时断言中</p>

<h2 id="toc_6">指定清理操作</h2>

<p><code>defer</code>语句在即将离开当前代码块时执行一系列语句，来执行一些必要的清理工作，而不管你是由于哪种方式离开代码块</p>

<ul>
<li><code>defer</code>语句将代码执行延迟到当前作用域退出之前。</li>
<li>该语句由<code>defer</code>关键字和要延时执行的语句组成(延迟执行的语句不能包含任何控制转移语句，或是抛出一个错误)。</li>
<li>延时执行的操作会按照他们被指定时的顺序的相反顺序执行(第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行)</li>
</ul>

<pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // 处理文件。
        }
        // close(file) 会在这里被调用，即作用域的最后。
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可选链式调用]]></title>
    <link href="https://acefish.github.io/15031302948355.html"/>
    <updated>2017-08-19T16:11:34+08:00</updated>
    <id>https://acefish.github.io/15031302948355.html</id>
    <content type="html"><![CDATA[
<p><strong>可选链式调用</strong>是在当前值可能为<code>nil</code>的可选值上请求和调用属性、方法以及下标的方法。如果可选值不为空,调用成功,否则如果可选值为<code>nil</code>，那么调用将返回<code>nil</code>。多个调用可以结合为一个调用链,若任何一个节点为<code>nil</code>。整个调用链都会失败</p>

<h2 id="toc_0">可选链式调用代替强制展开</h2>

<p>在想调用的属性、方法、下标的可选值后加上<code>?</code>来定义一个可选链。</p>

<blockquote>
<p>很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误</p>
</blockquote>

<p>可选链式调用,不论调用的属性、方法及下标返回值的类型,返回结果都是具有相同类型的可选值,可以利用这个可选返回值来判断链式调用是否成功,有值则返回成功，<code>nil</code>表示调用失败</p>

<pre><code class="language-swift">class Person {
    var residence: Residence?
}
class Residence {
    var numberOfRooms = 1
}
let john = Person()
</code></pre>

<p>我们直接<code>let roomCount = john.residence!.numberOfRooms</code>因为<code>residence</code>为<code>nil</code>强制展开的话是会触发运行时错误的</p>

<p>这时我们可以采用可选链式调用来访问<code>numberOfRooms</code>用<code>?</code>代替<code>!</code></p>

<pre><code class="language-swift">if let roomCount = john.residence?.numberOfRooms {
    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)
} else {
    print(&quot;Unable to retrieve the number of rooms.&quot;)
}
</code></pre>

<p><strong>添加问号之后，Swift 就会在<code>residence</code>不为<code>nil</code>的情况下访问<code>numberOfRooms</code></strong></p>

<p>即使<code>numberOfRooms</code>是非可选类型<code>Int</code>，只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回<code>Int?</code>而不是<code>Int</code></p>

<h2 id="toc_1">为可选链式调用定义模型类</h2>

<h2 id="toc_2">通过可选链式调用访问属性</h2>

<p>通过可选链式调用<strong>访问可能不存在实例的属性</strong>:</p>

<pre><code class="language-swift">//john.residence实例可能为nil
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print(&quot;John&#39;s residence has \(roomCount) room(s).&quot;)
} else {
    print(&quot;Unable to retrieve the number of rooms.&quot;)
}
</code></pre>

<p>通过可选链式调用<strong>设置属性值</strong></p>

<pre><code class="language-swift">//john.residence实例可能为nil
let someAddress = Address()
john.residence?.address = someAddress
</code></pre>

<p>对于这种可选链式调用的赋值,如果<code>john.residence</code>为<code>nil</code>，获取<code>address</code>属性失败，那么右侧的代码是不会被执行的</p>

<h2 id="toc_3">通过可选链式调用调用方法</h2>

<p>对于<code>Residence</code>类中定义的方法</p>

<pre><code class="language-swift">func printNumberOfRooms() {
    print(&quot;The number of rooms is \(numberOfRooms)&quot;)
}
</code></pre>

<p>这个方法没有返回值,那就是具有隐式的返回值<code>Void</code><br/>
那么如果用可选链式调用这个方法，返回值就为<code>Void?</code></p>

<pre><code class="language-swift">//john.residence 为Residence类 可能为nil的实例
if john.residence?.printNumberOfRooms() != nil {
    print(&quot;It was possible to print the number of rooms.&quot;)
} else {
    print(&quot;It was not possible to print the number of rooms.&quot;)
}
//可以根据返回值是否为nil 判断调用是否成功
</code></pre>

<p>对实例中的属性赋值 也会返回一个可选类型</p>

<pre><code class="language-swift">if (john.residence?.address = someAddress) != nil {
print(&quot;It was possible to set the address.&quot;)
} else {
print(&quot;It was not possible to set the address.&quot;)
}
</code></pre>

<h2 id="toc_4">通过可选链式调用访问下标</h2>

<p>可以在一个可选值上访问下标,判断下标是否成功</p>

<pre><code class="language-swift">//john.residence可能为nil
if let firstRoomName = john.residence?[0].name {
    print(&quot;The first room name is \(firstRoomName).&quot;)
} else {
    print(&quot;Unable to retrieve the first room name.&quot;)
}
</code></pre>

<blockquote>
<p>注意:下标调用的时候将问号放在下标方括号的前面而不是后面</p>
</blockquote>

<pre><code class="language-swift">john.residence?[0] = Room(name: &quot;Bathroom&quot;)
</code></pre>

<p><code>john.residence</code>为nil时，赋值仍然会失败</p>

<h3 id="toc_5">访问可选类型的下标</h3>

<p>如果下标返回可选类型值,可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用</p>

<pre><code class="language-swift">var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]
testScores[&quot;Dave&quot;]?[0] = 91
testScores[&quot;Bev&quot;]?[0] += 1
testScores[&quot;Brian&quot;]?[0] = 72
</code></pre>

<p>定义一个字典,包含两个键值对，因为字典下标返回的是可选类型值,对于<code>testScores[&quot;Brian&quot;]</code>因为字典中没有这个键，所以返回为<code>nil</code>，调用失败</p>

<h2 id="toc_6">连接多层可选链式调用</h2>

<p>可以连接多个可选链式调用在更深模型层级中访问属性、方法、下标，但是是不会增加返回值的可选层级的</p>

<ul>
<li>通过可选链式调用访问一个 Int 值，将会返回 Int? ，无论使用了多少层可选链式调用</li>
<li>通过可选链式调用访问 Int? 值，依旧会返回 Int? 值，并不会返回 Int??</li>
</ul>

<pre><code class="language-swift">if let johnsStreet = john.residence?.address?.street {
    print(&quot;John&#39;s street name is \(johnsStreet).&quot;)
} else {
    print(&quot;Unable to retrieve the address.&quot;)
}
</code></pre>

<p><code>john.residence.address</code>为<code>nil</code>因此调用失败<br/>
尽管<code>street</code>属性为<code>String？</code>  返回值仍然为<code>String?</code></p>

<h2 id="toc_7">在方法的可选返回值上进行可选链式调用</h2>

<pre><code class="language-swift">if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print(&quot;John&#39;s building identifier is \(buildingIdentifier).&quot;)
}
</code></pre>

<p>在可选值的基础上调用<code>buildingIdentifier()</code>方法  返回<code>String?</code>类型值</p>

<pre><code class="language-swift">if let beginsWithThe =
john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) {
    if beginsWithThe {
        print(&quot;John&#39;s building identifier begins with \&quot;The\&quot;.&quot;)
    } else {
        print(&quot;John&#39;s building identifier does not begin with \&quot;The\&quot;.&quot;)
    }
}
</code></pre>

<p>在方法的返回值基础上进行可选链式调用 </p>

<blockquote>
<p>在方法的圆括号后面加上问号即可</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动引用计数]]></title>
    <link href="https://acefish.github.io/15028525854956.html"/>
    <updated>2017-08-16T11:03:05+08:00</updated>
    <id>https://acefish.github.io/15028525854956.html</id>
    <content type="html"><![CDATA[
<p>与<code>OC</code>相同 <code>Swift</code>使用自动引用计数(ARC)来跟踪和管理应用程序内存</p>

<h2 id="toc_0">工作机制</h2>

<p>创建类的实例时,<code>ARC</code>会分配一块内存来存储实例信息.不再使用该实例,ARC将其释放.当是实例被释放后，其方法或属性均不能被访问或调用。<br/>
因此，为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>

<h2 id="toc_1">循环强引用</h2>

<p>如果两个类实例互相引用,那么类实例的强引用数永远不能变为0，这就是<strong>循环强引用</strong></p>

<h2 id="toc_2">解决循环强引用方法</h2>

<p>解决办法: <strong>弱引用</strong> <strong>无主引用</strong></p>

<p>将循环引用中一个实例对另外的实例不保持强引用</p>

<p>当其他的实例有更短的生命周期时,使用弱引用，即其 实例 析构在先时; 当其他实例有相同或者更长的声明周期时,请使用无主引用</p>

<h3 id="toc_3">弱引用</h3>

<p>弱引用不会对其引用的实例保持强引用，因而不会阻止<code>ARC</code>销毁被引用的实例。</p>

<p>声明属性或变量时,在前面加上<code>weak</code>关键字表明是个弱引用</p>

<p><code>ARC</code>会在引用的实例被销毁后自动将其赋值为<code>nil</code>.并且弱引用可以允许它们的值运行时赋值为<code>nil</code>，所以会被定义为可选类型变量而不是常量</p>

<p>弱引用为可选类型变量,可以通过检查是否为nil,防止访问已经销毁的实例的引用</p>

<blockquote>
<p>在<code>ARC</code>设置弱引用为<code>nil</code>时,属性观察不会被触发</p>
</blockquote>

<pre><code class="language-swift">class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
}

var john: Person?
var unit4A: Apartment?
john = Person(name: &quot;John Appleseed&quot;)
unit4A = Apartment(unit: &quot;4A&quot;)
john!.apartment = unit4A
unit4A!.tenant = john
//因为Apartment 中 的 tenant 属性为弱引用,因此即使这样也不会产生循环引用

john = nil
// 打印 “John Appleseed is being deinitialized”

unit4A = nil
// 打印 “Apartment 4A is being deinitialized”

</code></pre>

<p>变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息</p>

<h3 id="toc_4">无主引用</h3>

<p>与弱引用类似,无主引用不会保持住引用的实例<br/>
与弱引用不同,<strong>无主引用用在与其他实例有相同或者更长声明周期时使用</strong><br/>
在属性前加<code>unowned</code>关键字进行声明</p>

<p>无主引用为非可选类型,因此<code>ARC</code>无法在实例被销毁后将无主引用设置为<code>nil</code></p>

<p><em>注意</em>:</p>

<blockquote>
<p>使用无主引用，必须<strong>保证引用始终指向一个未销毁的实例</strong><br/>
试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误</p>
</blockquote>

<p>举个栗子:<br/>
<code>Customer</code>客户和<code>CreditCard</code>银行卡之间的关系,两个类都将另外一个类的实例作为自身属性,关系是客户可能没有银行卡,但是银行卡一定有客户,因此将银行卡的<code>customer</code>设置为无主引用</p>

<pre><code class="language-swift">
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64 //确保在32、64位机器上均可以保存16位的卡号
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}


var john: Customer?
john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)

john = nil
// 打印 “John Appleseed is being deinitialized”
// 打印 ”Card #1234567890123456 is being deinitialized”

</code></pre>

<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对 <code>Customer</code>实例的无主引用</p>

<blockquote>
<p>对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过 <code>unowned(unsafe)</code>来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作</p>
</blockquote>

<h3 id="toc_5">无主引用以及隐式解析可选属性</h3>

<pre><code class="language-swift">class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>

<p>我们在<code>Country</code>的<code>capitalCity</code>属性声明为<code>City!</code>隐式解析可选类型的属性,表明像其他可选类型一样，默认值为<code>nil</code>，但是不需要展开他的值就能访问</p>

<p>因为<code>capitalCity</code>的默认值为默认为<code>nil</code>，因此在构造country时,当name赋值以后,初始化就完成了,此时我们就能把这个初始化的<code>country</code>实例传递给<code>City</code>来构造City实例</p>

<h2 id="toc_6">闭包引起的循环强引用</h2>

<p>闭包和类 类似,都是引用类型,因此,将闭包赋值为某属性时,是将这个闭包的引用赋值给属性,因此当闭包体中访问实例的某个属性时,就会造成循环引用</p>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<blockquote>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为<code>HTML</code>输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>

<p><strong>闭包捕获列表</strong>解决闭包引起的循环引用</p>

<p>对于一个类的闭包属性,想要改变这个属性的行为,可以通过给这个属性再赋值一个闭包</p>

<p><code>HTMLElement</code>有类和作为<code>asHTML</code>默认值的闭包之间的循环强引用</p>

<p>注意:<br/>
虽然闭包中多次使用<code>self</code>，但是它只捕获<code>HTMLElement</code>实例的一个强引用</p>

<p>此时<code>HTMLElement</code>实例和它的闭包是不会被销毁和释放的</p>

<h2 id="toc_7">解决闭包引起的循环强引用</h2>

<p>在定义闭包时同时定义<strong>捕获列表</strong>作为闭包的一部分，捕获列表定义了闭包体内捕获一个或多个引用类型的规则.声明捕获的引用为弱引用或者无主引用,而不是强引用</p>

<blockquote>
<p><code>Swift</code>规定:在闭包中使用<code>self</code>的成员，要使用<code>self.someProperty</code>或者<code>self.someMethod()</code>，而不是使用<code>someProperty</code>或<code>someMethod()</code></p>
</blockquote>

<h3 id="toc_8">定义捕获列表</h3>

<p>捕获列表由一对元素组成,一个是<code>weak</code>或<code>unowned</code>关键字,另一个是类实例的引用如<code>self</code>或初始化的变量.在方括号中用逗号隔开</p>

<pre><code class="language-swift">//如果闭包有参数列表和返回类型，把捕获列表放在它们前面
lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // 这里是闭包的函数体
}

/**
如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，
那么可以把捕获列表和关键字 in 放在闭包最开始的地方
*/

lazy var someClosure: Void -&gt; String = {
    [unowned self, weak delegate = self.delegate!] in
    // 这里是闭包的函数体
}

</code></pre>

<h3 id="toc_9">弱引用和无主引用</h3>

<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为<code>无主引用</code>。(即被捕获的引用不会变为nil使用无主引用)<br/>
在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>，弱引用总是可选类型,在引用的实例被销毁后自动置为<code>nil</code></p>

<pre><code class="language-swift">class HTMLElement {
    let name: String
    let text: String?
    lazy var asHTML: Void -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }
    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre>

<p>在<code>asHTML</code>闭包中多了一个捕获列表，<code>[unowned self]</code>将self声明为无主引用<br/>
这时候没有了循环引用,我们就可以销毁<code>HTMLElement</code>实例了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[析构过程]]></title>
    <link href="https://acefish.github.io/15025006795297.html"/>
    <updated>2017-08-12T09:17:59+08:00</updated>
    <id>https://acefish.github.io/15025006795297.html</id>
    <content type="html"><![CDATA[
<p>只适用类类型,当类的实例被释放时,析构器会被立即调用。<br/>
<code>deinit</code>关键字标示析构器</p>

<h2 id="toc_0">析构过程原理</h2>

<p>自动释放不需要的实例来释放资源,通过自动引用计数来管理内存。实例被释放时会自动清理,但是使用自己的资源需要进行额外的清理(比如自己打开一个文件管理类，需要在类被释放前手动关闭该文件).</p>

<p>在类的定义中,每个类最多只能有一个析构器,不带任何参数</p>

<pre><code class="language-swift">deinit {
    // 执行析构过程
}
</code></pre>

<p>析构器在实例被释放前被调用,不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器<br/>
实现的最后，父类的析构器会被自动调用。</p>

<p>直到实例的析构器被调用后，实例才会被释放,所以析构器可以访问实例的所有属性，并且可以根据那些属<br/>
性可以修改它的行为(比如查找一个需要被关闭的文件)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[构造过程]]></title>
    <link href="https://acefish.github.io/15020961612430.html"/>
    <updated>2017-08-07T16:56:01+08:00</updated>
    <id>https://acefish.github.io/15020961612430.html</id>
    <content type="html"><![CDATA[
<p>在类、结构体、枚举实例可用前必须执行<strong>构造过程</strong>，用来设置存储属性的初始值和其他的设置或初始化任务</p>

<p>通过定义<strong>构造器</strong>来实现构造过程，构造器是用来创建特定类型新实例的特殊方法。</p>

<blockquote>
<p>与OC不同,swift的构造器无序返回值,只需保证实例在第一次使用前完成正确的初始化</p>
</blockquote>

<p><strong>类的实例</strong>也可以通过定义<strong>析构器</strong>在实例释放之前执行特定的清除工作</p>

<h2 id="toc_0">存储属性的初始化赋值</h2>

<p>类和结构体在创建实例时,存储属性必须有合适的值<br/>
可以在构造器中为存储型属性赋值,也可以在定义属性值时设置默认值,这两种方法设置存储属性值时,值是被直接设置的,不会触发任何属性观察者</p>

<h3 id="toc_1">构造器</h3>

<pre><code class="language-swift">//最简单形式
init() {
    // 在此处执行构造过程
}
</code></pre>

<h3 id="toc_2">默认属性值</h3>

<pre><code class="language-swift">struct Fahrenheit {
    var temperature = 32.0
}
</code></pre>

<h2 id="toc_3">自定义构造过程</h2>

<h3 id="toc_4">构造参数</h3>

<p>自定义构造过程，在定义中提供<strong>构造参数</strong></p>

<pre><code class="language-swift">struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0
</code></pre>

<h3 id="toc_5">参数的内部名称和外部名称</h3>

<p>构造器并没有可区分的名字,都为<code>init</code>，因此需要构造器中的参数名和类型来确定应该被调用的构造器,因此外部名称很重要</p>

<pre><code class="language-swift">struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red = red
        self.green = green
        self.blue = blue
    }
    init(white: Double) {
        red = white
        green = white
        blue = white
    }
}

let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)

//只要构造器定义了外部名称就必须使用,否则报错
let veryGreen = Color(0.0, 1.0, 0.0)//报编译时错误，需要外部名称
</code></pre>

<h3 id="toc_6">不带外部名的构造器参数</h3>

<p>使用下划线来<code>_</code>来不为构造器某个参数提供外部名称</p>

<pre><code class="language-swift">struct Celsius {
    var temperatureInCelsius: Double
    init(_ celsius: Double){
        temperatureInCelsius = celsius
    }
}

let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius 为 37.0
</code></pre>

<p>此时构造器意图明确 可以不需要外部参数名称</p>

<h3 id="toc_7">可选属性类型</h3>

<p>在类型中包含一个逻辑上允许为空的存储型属性,要将其定义为<code>可选类型</code>,可选类型属性在初始化时自动初始化为<code>nil</code></p>

<pre><code class="language-swift">class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: &quot;Do you like cheese?&quot;)
cheeseQuestion.ask()
// 打印 &quot;Do you like cheese?&quot;
cheeseQuestion.response = &quot;Yes, I do like cheese.&quot;
</code></pre>

<p>定义一个可选类型<code>response</code>因为答案在问题之前是无法确定,所以设为<code>String?</code>类型，在实例初始化是,自动赋值为<code>nil</code></p>

<h3 id="toc_8">构造过程中常量属性的修改</h3>

<p>在构造过程中任意时间点都可以给常量属性指定值,直到构造过程结束为一个确定的值,一旦常量属性赋值就永不能更改</p>

<blockquote>
<p>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>

<pre><code class="language-swift">class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
</code></pre>

<h2 id="toc_9">默认构造器</h2>

<p>如果结构体或者类的所有属性都有默认值,那么<code>Swift</code>会提供一个默认构造器,将所有值设置为默认值</p>

<pre><code class="language-swift">class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</code></pre>

<h3 id="toc_10">结构体的逐一成员构造器</h3>

<p>在结构体中,如果没有提供自定义构造器，会自动获得逐一成员构造器</p>

<pre><code class="language-swift">struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>

<h2 id="toc_11"><strong>值类型</strong>的构造器代理</h2>

<p>构造器可以通过调用其他构造器来完成实例的部分构造过程,即<strong>构造器代理</strong></p>

<p>对于值类型不支持继承,所以构造代理只能代理自己的其他构造器,对于类类型可以继承,需要保证其所有继承的存储型属性在构造时也能正确的初始化</p>

<p>值类型,可以使用也只能用<code>self.init</code>在自定义构造器中引用同类型的其他构造器</p>

<p>值类型定义一个自定义构造器,将无法访问默认构造器(结构体也无法访问逐一构造器),防止在给值类型增加一个复杂的自定义构造器后仍然有人使用自动生成的构造器</p>

<blockquote>
<p>可以通过将自定义的构造器写在扩展中,而不是将值类型写在原始定义中,来使可以通过默认构造器，逐一成员构造器,以及自定义构造器来创建实例</p>
</blockquote>

<h2 id="toc_12">类的继承和构造过程</h2>

<p>类里面的所有存储属性,包括所有继承自父类的属性，都必须在构造过程中设置初始值</p>

<p>类类型的两种构造器:  <strong>指定构造器</strong> <strong>便利构造器</strong></p>

<h3 id="toc_13">指定构造器和便利构造器</h3>

<p>指定构造器初始化类中提供的所有属性,并根据父类链向上条用父类构造器实现父类的初始化<br/>
每个类都必须至少有一个指定构造器,可以通过继承父类的指定构造器来满足条件;</p>

<p>便利构造器是次要、辅助的构造器，定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>

<h3 id="toc_14">指定构造器、便利构造器语法</h3>

<p>类的指定构造器语法与值类型简单构造器相同:</p>

<pre><code class="language-swift">init(parameters) {
    statements
}
</code></pre>

<p>便利构造器在<code>init</code>关键字前加<code>convenience</code>关键字</p>

<pre><code class="language-swift">convenience init(parameters) {
    statements
}
</code></pre>

<h3 id="toc_15">类的构造器代理规则</h3>

<p>构造器之间代理调用限制:</p>

<ol>
<li>指定构造器必须调用父类的指定构造器</li>
<li>便利构造器必须调用同类中定义的其它构造器</li>
<li>便利构造器必须最终导致一个指定构造器被调用</li>
</ol>

<h3 id="toc_16">两段式构造过程</h3>

<p>构造过程的两个阶段:<br/>
第一阶段: 存储属性指定一个初始值<br/>
第二阶段: 进一步定制它们的存储型属性</p>

<p>可以防止属性值在初始化前被访问和被另外的构造器意外赋其他值</p>

<p>两段式构造过程的构造流程:</p>

<p>阶段1:</p>

<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化，阶段1结束</li>
</ul>

<p>阶段2：</p>

<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问<code>self</code>、修改它的属性并调用实例方法等等</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用 self</li>
</ul>

<h3 id="toc_17">构造器的继承和重写</h3>

<p>与<code>OC</code>不同,<code>swift</code>的子类默认情况下不继承父类构造器，以防止父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例</p>

<p>要在子类中提供和父类相同指定构造器时,需要重写父类的这个指定构造器,因此必须在子类构造器前加上<code>override</code>修饰符，即使重写的是系统提供的默认构造器,也需要带上<code>override</code></p>

<blockquote>
<p>重写一个父类的指定构造器时，你总是需要写<code>override</code>修饰符，即使你的子类将父类的指定构造器重写为了便利构造器</p>
</blockquote>

<p>而在子类中写一个和父类相同的便利构造器,因为子类不能直接调用父类的便利构造器,因此并未对其进行重写，也不需要加上<code>override</code>前缀</p>

<pre><code class="language-swift">class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return &quot;\(numberOfWheels) wheel(s)&quot;
    }
}
</code></pre>

<p>因为存储属性有默认值,因此会自动获得一个默认构造器</p>

<pre><code class="language-swift">class Bicycle: Vehicle {
    override init() {
        super.init()//可以确保继承的属性 numberOfWheels 能被 Vehicle 类初始化
        numberOfWheels = 2
    }
}
//子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。
</code></pre>

<h3 id="toc_18">构造器的自动继承</h3>

<p>默认子类不继承父类构造器,但是如果满足特定条件是可以被自动继承的</p>

<p>如果为<strong>子类引用的新属性都提供了默认值</strong>:</p>

<ol>
<li>如果子类没有定义任何指定构造器,将自动继承<strong>所有父类</strong>的指定构造器</li>
<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则1继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器</li>
</ol>

<h3 id="toc_19">指定构造器和便利构造器实践</h3>

<pre><code class="language-swift">class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: &quot;[Unnamed]&quot;)
    }
}

let namedMeat = Food(name: &quot;Bacon&quot;)
// namedMeat 的名字是 &quot;Bacon”
let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
</code></pre>

<pre><code class="language-swift">class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    //便利构造器重写了父类的指定构造器
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
let oneMysteryItem = RecipeIngredient() //会继承父类的便利构造器
let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)
let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)
</code></pre>

<pre><code class="language-swift">class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = &quot;\(quantity) x \(name)&quot;
        output += purchased ? &quot; ?&quot; : &quot; ?&quot;
        return output
    }
}
/**
    子类引用的属性都提供了默认值,并且没有自定义构造器,将自动继承所有父类中指定和便利
    构造器
*/
</code></pre>

<h2 id="toc_20">可失败构造器</h2>

<p>如果类、结构体、枚举类型对象在构造时可能会失败,则为其定义一个<strong>可失败构造器</strong></p>

<p>可失败构造器通过在<code>init</code>关键字后添加<code>?</code></p>

<p>注意:<br/>
可失败构造器的参数名和参数类型不能与其他非可失败构造器参数名及参数类型相同</p>

<p>可失败构造器创建自身类型的可选类型对象，构造器并不支持返回值,我们在构造器方法中通过<code>return nil</code>来表示构造失败，</p>

<pre><code class="language-swift">struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}

let anonymousCreature = Animal(species: &quot;&quot;)
// anonymousCreature 的类型是 Animal?, 而不是 Animal
if anonymousCreature == nil {
    print(&quot;The anonymous creature could not be initialized&quot;)
}
// 打印 &quot;The anonymous creature could not be initialized&quot;
</code></pre>

<h3 id="toc_21">枚举类型的可失败构造器</h3>

<p>通过提供的参数来获取特定的枚举成员,如果参数无法匹配任何枚举成员,则构造失败</p>

<pre><code class="language-swift">enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case &quot;K&quot;:
            self = .Kelvin
        case &quot;C&quot;:
            self = .Celsius
        case &quot;F&quot;:
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
</code></pre>

<h3 id="toc_22">带原始值的枚举类型可失败构造器</h3>

<p>带原始值的枚举类型会自带可失败构造器 <code>init?(rawValue:)</code>，参数<code>rawvalue</code>的和枚举类型原始值类型相同,如果能和枚举成员原始值匹配则构造响应枚举成员,否则构造失败</p>

<pre><code class="language-swift">enum TemperatureUnit: Character {
    case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;
}
</code></pre>

<h3 id="toc_23">构造失败的传递</h3>

<p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器，也能向上代理到父类可失败构造器,如果在代理的其他可失败构造器触发构造失败，构造过程终止,接下来构造代码不执行</p>

<pre><code class="language-swift">class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity &lt; 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
//尝试用空name初始化CarItem导致父类构造过程失败
if let oneUnnamed = CartItem(name: &quot;&quot;, quantity: 1) {
    print(&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;)
} else {
    print(&quot;Unable to initialize one unnamed product&quot;)
}
// 打印 &quot;Unable to initialize one unnamed product”

</code></pre>

<h3 id="toc_24">可失败构造器重写</h3>

<p>可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器,但是不能用可失败构造器重写非可失败构造器</p>

<pre><code class="language-swift">class Document {
    var name: String?
    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
    init() {}
    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
    init?(name: String) {
        self.name = name
        if name.isEmpty { return nil }
    }
}

class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = &quot;[Untitled]&quot;
    }
    //用非可失败构造器 init(name:) 重写了父类的可失败构造器 init?(name:)
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = &quot;[Untitled]&quot;
        } else {
            self.name = name
        }
    }
}

//或者可以写为

class UntitledDocument: Document {
    override init() {
    //通过强制解包调用父类的可失败构造器
        super.init(name: &quot;[Untitled]&quot;)!
    }
}
</code></pre>

<h3 id="toc_25">可失败构造器 init!</h3>

<p>可以通过在<code>init</code>后加上<code>!</code>定义一个可失败构造器，会构造一个对应类型的隐式解包可选类型对象</p>

<p>可以在<code>init?</code>中代理到<code>init!</code>，反之亦然。你也可以用<code>init?</code>重写<code>init!</code>，反之亦然。你还可以用 <code>init</code>代理到<code>init!</code>，不过，一旦<code>init!</code>构造失败，则会触发一个断言</p>

<h2 id="toc_26">必要构造器</h2>

<p>类的构造器前添加<code>required</code>修饰符表明所有该类的<code>子类</code>都必须实现该构造器</p>

<pre><code class="language-swift">class SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加<code>required</code>修饰符,不需要添加<code>override</code>修饰符</p>

<pre><code class="language-swift">class SomeSubclass: SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>注意：<br/>
<strong>如果在子类继承的构造器能满足必要构造器的要求,则无须在子类中显式提供必要构造器的实现</strong></p>

<h2 id="toc_27">用闭包或函数设置属性默认值</h2>

<p>使用闭包或全局函数为村塾属性提供默认值,当该类型实例被创建，对应闭包或函数会被调用,他们的返回值会作为这个属性的默认值</p>

<pre><code class="language-swift">class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
    }()
}
</code></pre>

<p>闭包结尾的必须需要一对空的<code>小括号</code>.表明<code>swift</code>立即执行闭包，将闭包的返回值赋值给属性，如果没有括号就相当于将闭包作为值赋值给属性</p>

<blockquote>
<p>在使用闭包来初始化属性时,在闭包被执行时，实例其他部分还没有被初始化,因此不能再闭包中访问其他属性，即使有默认值。也不能隐式使用<code>self</code>或者调用任何实例方法</p>
</blockquote>

<p>闭包初始化存储属性<br/>
```swift<br/>
struct Checkerboard {<br/>
//设置100个bool颜色的数组<br/>
    let boardColors: [Bool] = {<br/>
        var temporaryBoard = <a href="">Bool</a><br/>
        var isBlack = false<br/>
        for i in 1...8 {<br/>
            for j in 1...8 {<br/>
                temporaryBoard.append(isBlack)<br/>
                isBlack = !isBlack<br/>
            }<br/>
            isBlack = !isBlack<br/>
        }<br/>
        return temporaryBoard<br/>
    }()</p>

<pre><code>//返回某一行或列的颜色
func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
    return boardColors[(row * 8) + column]
}
</code></pre>

<p>}</p>

<p>let board = Checkerboard()<br/>
print(board.squareIsBlackAtRow(0, column: 1))<br/>
// 打印 &quot;true&quot;<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[继承]]></title>
    <link href="https://acefish.github.io/15018175799489.html"/>
    <updated>2017-08-04T11:32:59+08:00</updated>
    <id>https://acefish.github.io/15018175799489.html</id>
    <content type="html"><![CDATA[
<p>类可以继承父类的方法、属性和其他特征</p>

<p>类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。</p>

<p>可以为类中继承的属性添加属性观察器</p>

<h2 id="toc_0">定义一个基类</h2>

<p>不继承于其它类的类,称之为基类</p>

<p>注意:</p>

<blockquote>
<p><code>Swift</code>中类并不是从一个通用类继承而来.如果没有为定义的类制定一个超类的话,这个类自动成为一个基类</p>
</blockquote>

<p>创建一个<code>Vehicle</code>的基类，来描述通用车辆</p>

<pre><code class="language-swift">class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return &quot;traveling at \(currentSpeed) miles per hour&quot;
    }
    func makeNoise() {
        // 什么也不做-因为车辆不一定会有噪音
    }
}
</code></pre>

<h2 id="toc_1">子类生成</h2>

<pre><code class="language-swift">//定义一个自行车Bicycle继承自Vehicle
class Bicycle: Vehicle {
    var hasBasket = false
}
</code></pre>

<p>除了继承自父类的方法、属性外，还定义了一个默认值为<code>false</code>的存储属性<code>hasBasket</code></p>

<pre><code class="language-swift">let bicycle = Bicycle()
bicycle.hasBasket = true
//修改继承的属性
bicycle.currentSpeed = 15.0
print(&quot;Bicycle: \(bicycle.description)&quot;)
// 打印 &quot;Bicycle: traveling at 15.0 miles per hour&quot;
</code></pre>

<h2 id="toc_2">重写</h2>

<p>为继承来的实例方法、类方法、实例属性、下标提供自己的实现,即为<strong>重写</strong></p>

<p>需要在重写的定义前加上 <code>override</code>关键字表明重写,否则即为错误的提供了相同的定义</p>

<h3 id="toc_3">访问父类的方法、属性和下标</h3>

<p>通过<code>super</code>前缀来访问父类版本中的方法、属性或下标</p>

<ul>
<li>在方法 someMethod() 的重写实现中，可以通过 super.someMethod() 来调用超类版本的 someMethod() 方法</li>
<li>在属性 someProperty 的 getter 或 setter 的重写实现中，可以通过 super.someProperty 来访问超类版本的someProperty 属性</li>
<li>在下标的重写实现中，可以通过 super[someIndex] 来访问超类版本中的相同下标</li>
</ul>

<h3 id="toc_4">重写方法</h3>

<pre><code class="language-swift">class Train: Vehicle {
    override func makeNoise() {
        print(&quot;Choo Choo&quot;)
    }
}
</code></pre>

<h3 id="toc_5">重写属性</h3>

<p>重写继承来的实例或者类型属性来提供自己定制的<code>getter</code>或者<code>setter</code>或添加属性观察器来观察属性值的改变</p>

<h4 id="toc_6">重写属性的setter和getter</h4>

<p>子类并不知道继承来的属性是存储型还是计算型,重写时要提供属性名称和类型来让编译器去查找父类同名同类型的属性</p>

<p>可以把继承的只读属性重写为可读写,但是没有办法把可读写的重写为只读属性</p>

<blockquote>
<p>如果你在重写属性中提供了<code>setter</code>，那么你也一定要提供<code>getter</code>。如果你不想在重写版本中的<br/>
<code>getter</code>里修改继承来的属性值，你可以直接通过<code>super.someProperty</code>来返回继承来的值</p>
</blockquote>

<pre><code class="language-swift">class Car: Vehicle {
    var gear = 1
    //重写description属性
    override var description: String {
        return super.description + &quot; in gear \(gear)&quot;
    }
}

let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print(&quot;Car: \(car.description)&quot;)//返回自定义描述
// 打印 &quot;Car: traveling at 25.0 miles per hour in gear 3&quot;
</code></pre>

<h4 id="toc_7">重写属性观察器</h4>

<p>注意:<br/>
1. 不能为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器,因为它们不能被设置<br/>
2. 不能同时提供重写的<code>setter</code>和重写的属性观察器。因为此时我们可以直接在setter中观察值的变化</p>

<pre><code class="language-swift">class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1(后向下取得最接近的整数值在加1)
        }
    }
}
</code></pre>

<p>为属性<code>currentSpeed</code>添加观察器，设置速度时就会自动选择合适的档位</p>

<h2 id="toc_8">防止重写</h2>

<p>通过把方法、属性或下标 前加关键字<code>final</code>来防止被重写,例如:<code>final var</code> ， <code>final func</code> ， <code>final class func</code> ，以及 <code>final subscript</code></p>

<p>通过在<code>class</code>前添加关键字<code>final</code>表示这个类是不可被继承的</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[下标]]></title>
    <link href="https://acefish.github.io/15017615739867.html"/>
    <updated>2017-08-03T19:59:33+08:00</updated>
    <id>https://acefish.github.io/15017615739867.html</id>
    <content type="html"><![CDATA[
<p>下标可以定义在类、结构体和枚举中，用于访问集合、列表或序列中的元素</p>

<p>一个类型可以定义多个下标.通过不同索引类型进行重载.下标不限于一维</p>

<h2 id="toc_0">下标语法</h2>

<p>通过在实例名称后的方括号中传入一个或多个索引值来对实例进行存取</p>

<p>定义下标使用<code>subscript</code>关键字,指定一个或者多个输入参数和返回类型<br/>
下标可以设置为读写或者只读,通过是<code>getter</code>或者<code>setter</code>实现</p>

<pre><code class="language-swift">subscript(index: Int) -&gt; Int {
    get {
        // 返回一个适当的 Int 类型的值
    }
    set(newValue) {
        // 执行适当的赋值操作
    }
}
</code></pre>

<p>可以不指定<code>setter</code>的参数,默认提供<code>newValue</code></p>

<pre><code class="language-swift">struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
print(&quot;six times three is \(threeTimesTable[6])&quot;)
// 打印 &quot;six times three is 18&quot;
</code></pre>

<p>定义一个数学公式结构体,只读的下标语法</p>

<h2 id="toc_1">下标用法</h2>

<pre><code class="language-swift">//字典的下标语法
var numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]
numberOfLegs[&quot;bird&quot;] = 2
</code></pre>

<h2 id="toc_2">下标选项</h2>

<p>下标可以使用变量参数和可变参数,但不能使用输入输出参数,也不能给参数设置默认值</p>

<p>下标的重载:<br/>
类和结构体可以根据自身需要提供多个下标实现,通过入参和类型进行区分</p>

<pre><code class="language-swift">struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        //通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            //断言语句
            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)
            return grid[(row * columns) + column]
        }
        set {
            //断言语句
            assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;)
            grid[(row * columns) + column] = newValue
        }
    }
}
</code></pre>

<pre><code class="language-swift">var matrix = Matrix(rows: 2, columns: 2)
//下标入参用逗号进行分割
matrix[0, 1] = 1.5 //将下标为(0,1)位置设置为1.5
</code></pre>

<p>通过断言,检查下标入参<code>row</code>和<code>colum</code>的值是否有效.定义方法<code>indexIsValidForRow(_:column:)</code>检查入参<code>row</code>和<code>columu</code>是否越界,断言会在下标月结</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法]]></title>
    <link href="https://acefish.github.io/15017296324997.html"/>
    <updated>2017-08-03T11:07:12+08:00</updated>
    <id>https://acefish.github.io/15017296324997.html</id>
    <content type="html"><![CDATA[
<p><code>类、结构体、枚举</code>都可以定义实例方法，实例方法为给定类型实例封装了具体的任务和功能</p>

<p><code>类、结构体、枚举</code>也可定义类型方法,类型方法与类型本身关联（与OC中类似）</p>

<h2 id="toc_0">实例方法</h2>

<p>实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。<br/>
<strong>实例方法的语法与函数完全一致</strong></p>

<p>实例方法能够隐式访问它所属类型的所有的其他实例方法和属性</p>

<pre><code class="language-swift">class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}

let counter = Counter()
// 初始计数值是0
counter.increment()
// 计数值现在是1
counter.increment(by: 5)
// 计数值现在是6
counter.reset()
// 计数值现在是0
</code></pre>

<h3 id="toc_1">self属性</h3>

<p>与OC类似,<code>self</code>等同于该类型的实例本身</p>

<pre><code class="language-swift">//所以我们可以这么写
func increment() {
    self.count += 1
}
</code></pre>

<p>其实没必要写<code>self</code>，使用已知的属性名或者方法名 <code>swift</code>会假定你使用的是当前实例属性或者方法</p>

<p>我们使用的主要场景:<br/>
实例方法的某个<code>参数名称</code>与实例的某个<code>属性名称</code>相同的时候,此时优先使用参数名,因此我们通过<code>self</code>属性来进行区分使用属性</p>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOfX(_ x: Double) -&gt; Bool {
        return self.x &gt; x//用self来区分属性
    }
}

let somePoint = Point(x: 4.0, y: 5.0)

if somePoint.isToTheRightOfX(1.0) {
    print(&quot;This point is to the right of the line where x == 1.0&quot;)
}
// 打印 &quot;This point is to the right of the line where x == 1.0&quot;
</code></pre>

<h3 id="toc_2">实例方法中修改值类型</h3>

<p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改</p>

<p>我们可以通过给这个实例方法选择<code>可变(mutating)</code>行为，就可以在方法内部修改改变它的属性;这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的<code>self</code>属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例</p>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
    mutating func moveByX(deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveByX(2.0, y: 3.0)
print(&quot;The point is now at (\(somePoint.x), \(somePoint.y))&quot;)
// 打印 &quot;The point is now at (3.0, 4.0)&quot;
</code></pre>

<p>注意:<br/>
不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性</p>

<h3 id="toc_3">在可变方法中给self赋值</h3>

<p>可以在可变方法中给隐含属性<code>self</code>赋予一个新的实例</p>

<pre><code class="language-swift">struct Point1 {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point1(x: x + deltaX, y: y + deltaY)
    }
}
</code></pre>

<p>创建一个新的结构体实例赋值给self，替换现在的实例</p>

<p>枚举的可变方法，定义了一个三态开关状态枚举,通过调用<code>next()</code>进行切换状态</p>

<pre><code class="language-swift">enum TriStateSwitch {
    case Off, Low, High
    mutating func next() {
        switch self {
        case .Off:
            self = .Low
        case .Low:
            self = .High
        case .High:
            self = .Off
        }
    }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight 现在等于 .High
ovenLight.next()
// ovenLight 现在等于 .Off
</code></pre>

<h2 id="toc_4">类型方法</h2>

<p>定义在类型本身上的方法,即为类型方法<br/>
通过在方法<code>func</code>前加关键字<code>static</code>，来指定类型方法,通过加关键字<code>class</code>来实现子类重写父类的方法实现</p>

<blockquote>
<p>在<code>oc</code>中只能为类定义类型方法,但是在<code>swift</code>中可以为类,结构体,枚举定义类方法</p>
</blockquote>

<p>类型方法在类型上通过点语法调用<br/>
在类型方法中,<code>self</code>指向类型本身,同样的可以用其来区分同样的类型属性和类型方法参数</p>

<p>在类型方法体中可以调用本类中类型属性或的其他类型方法,调用是可以直接通过类型方法名称或者类型属性名称进行调用,而不用在前面添加类型名称</p>

<pre><code class="language-swift">//检测玩家等级的结构体
struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1
    static func unlock(_ level: Int) {
        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func isUnlocked(_ level: Int) -&gt; Bool {
        return level &lt;= highestUnlockedLevel
    }
    @discardableResult //
    mutating func advance(to level: Int) -&gt; Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
</code></pre>

<pre><code class="language-swift">//玩家类
class Player {
    var tracker = LevelTracker()
    let playerName: String
    func complete(level: Int) {
        LevelTracker.unlock(level + 1)
        tracker.advance(to: level + 1)
    }
    init(name: String) {
        playerName = name
    }
}
</code></pre>

<pre><code class="language-swift">var player = Player(name: &quot;Argyrios&quot;)
player.complete(level: 1)
print(&quot;highest unlocked level is now \(LevelTracker.highestUnlockedLevel)&quot;)
// 打印 &quot;highest unlocked level is now 2&quot;

player = Player(name: &quot;Beto&quot;)
if player.tracker.advance(to: 6) {
print(&quot;player is now on level 6&quot;)
} else {
print(&quot;level 6 has not yet been unlocked&quot;)
}
// 打印 &quot;level 6 has not yet been unlocked&quot;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性]]></title>
    <link href="https://acefish.github.io/15015839505859.html"/>
    <updated>2017-08-01T18:39:10+08:00</updated>
    <id>https://acefish.github.io/15015839505859.html</id>
    <content type="html"><![CDATA[
<p>属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>

<p>属性也可以直接作用于类型本身，这种属性称为类型属性。</p>

<p>可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作.可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>

<h2 id="toc_0">存储属性</h2>

<p>存储属性就是存储在特定类或结构体实例里的一个常量或变量,可以为变量或者常量<br/>
可以在定义存储属性时指定默认值，也可在构造过程中设置或修改存储属性值,甚至修改常量存储属性值</p>

<pre><code class="language-swift">struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
rangeOfThreeItems.firstValue = 6
</code></pre>

<p>定义一个结构体,包含<code>firstValue</code>变量存储属性,和<code>length</code>常量存储属性。<code>length</code>在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值</p>

<h3 id="toc_1">常量结构体的存储属性</h3>

<p>若结构体声明为常量,则无法修改实例的任何属性,即使为变量属性:</p>

<pre><code class="language-swift">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// 该区间表示整数0，1，2，3
rangeOfFourItems.firstValue = 6//报错不可修改
// 尽管 firstValue 是个变量属性，这里还是会报错
</code></pre>

<p>这是由于结构体为值类型,值类型为常量则所有属性也变为常量</p>

<p>对于引用类型的类来说,将引用类型赋值给一个常量，仍然可以修改实例的变量属性</p>

<h3 id="toc_2">延迟存储属性</h3>

<p><strong>延迟属性</strong>第一次调用时才会结算其初始化值的属性<br/>
在属性声明前加<code>lazy</code>来标示一个延迟存储属性</p>

<blockquote>
<p>必须将延迟存储属性声明成<code>变量</code>（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而<strong>常量属性在构造过程完成之前必须要有初始值</strong>，因此无法声明成延迟属性。</p>
</blockquote>

<pre><code class="language-swift">class DataImporter {
    /*
    DataImporter 是一个负责将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */
    var fileName = &quot;data.txt&quot;
    // 这里会提供数据导入功能
}
class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // 这里会提供数据管理功能
}
</code></pre>

<pre><code class="language-swift">let manager = DataManager()
manager.data.append(&quot;Some data&quot;)
//此时实例的import属性还没创建
</code></pre>

<pre><code class="language-swift">print(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 &quot;data.txt”
</code></pre>

<p><strong>如果一个被标记为<code>lazy</code>的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次</strong></p>

<h3 id="toc_3">存储属性和实例变量</h3>

<p>与OC不同<code>Swift</code>没有属性对应的实例变量，因此没有办法直接访问属性的后端存储，方便统一访问方式<br/>
使属性的全部信息包括<code>命名、类型和内存管理特征</code>都在一个地方定义</p>

<h2 id="toc_4">计算属性</h2>

<p>计算属性不存储值而是提供一个<code>getter</code>和一个可选的<code>setter</code>,来间接获取和设置其他属性或变量的值</p>

<blockquote>
<p>必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的</p>
</blockquote>

<pre><code class="language-swift">struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
                  size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)
</code></pre>

<p>可以通过<code>square.center</code>访问计算属性<code>center</code> 会调用<code>getter</code>计算新的值返回<br/>
<code>center</code>可以设置一个新值,会调用<code>setter</code>来修改<code>origin</code>来移动正方形</p>

<h3 id="toc_5">简化setter声明</h3>

<p>如果计算属性的<code>setter</code>没有定义表示新值,就可以使用默认名称<code>newValue</code></p>

<pre><code class="language-swift">struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
</code></pre>

<h3 id="toc_6">只读的计算属性</h3>

<p>只有<code>getter</code>没有<code>setter</code>的计算属性就是只读计算属性，可以访问值,不能设置新值</p>

<pre><code class="language-swift">struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
</code></pre>

<p>只读属性可以省略掉 <code>get</code>关键字和花括号</p>

<h2 id="toc_7">属性观察器</h2>

<p><strong>属性观察器</strong>监控和响应属性值变化，每次属性被设置时会调用属性观察器</p>

<p>为<code>除了延迟属性</code>外其他存储属性添加属性观察器，对于继承的存储属性和计算属性,通过重写的方式来添加属性观察器<br/>
对于非继承的计算属性没必要添加属性观察器，我们可以通过<code>setter</code>方法直接监控</p>

<p>属性观察期器:<br/>
* <code>willSet</code>在新值被设置前调用<br/>
* <code>didSet</code>在新值被设置之后调用</p>

<p><code>willSet</code>观察器会将新的属性值作为常量参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名<br/>
称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>

<p><code>didSet</code>观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。如果<br/>
在<code>didSet</code>方法中再次对该属性赋值，那么新值会覆盖旧的值</p>

<blockquote>
<p>父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>
</blockquote>

<pre><code class="language-swift">class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)
        }
        didSet {
            if totalSteps &gt; oldValue {
                print(&quot;Added \(totalSteps - oldValue) steps&quot;)
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
</code></pre>

<p>注意:<br/>
在willSet或者didSet方法中设置属性值是不会触发的属性观察器方法  </p>

<blockquote>
<p>如果将属性通过<code>in-out</code>方式传入函数，<code>willSet</code>和<code>didSet</code>也会调用。这是因为<code>in-out</code>参数采用了拷入拷出模式：即在函数内部使用的是参数的<code>copy</code>，函数结束后，又对参数重新赋值。</p>
</blockquote>

<h2 id="toc_8">全局变量和局部变量</h2>

<p>全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<p><strong>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量</strong></p>

<p>我们之前用的变量都是存储型变量,跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入</p>

<p>我们可以在全局或局部范围为存储型变量定义观察器</p>

<p>在全局或局部范围都可以定义计算型变量。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样</p>

<p><strong>注意:</strong><br/>
1. 全局的常量或变量都是延迟计算，类似<code>延迟属性</code>但是不需要<code>lazy</code>声明<br/>
2. 局部的常量或变量从不延迟计算</p>

<h2 id="toc_9">类型属性</h2>

<p>可以为类型本身定义属性</p>

<p>类型属性用于定义某个类型所有实例共享的数据</p>

<p>类型属性也可以有 存储型的常量或变量 计算型的只能为变量</p>

<p>注意:</p>

<blockquote>
<p>存储型类型属性必须指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值</p>

<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用<code>lazy</code>修饰符。</p>
</blockquote>

<h3 id="toc_10">类型属性语法</h3>

<p>在<code>OC</code>中,在类中关联的静态变量和常量是作为全局静态变量定义</p>

<p>在<code>Swift</code>中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，作用范围就在类型支持的范围内</p>

<p>使用<code>static</code>来定义类型属性。<br/>
在为类定义计算型类型属性时，可以改用关键字<code>class</code>来支持子类对父类的实现进行重写</p>

<pre><code class="language-swift">//结构体
struct SomeStructure {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 1
    }
}
//枚举
enum SomeEnumeration {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 6
    }
}
//类
class SomeClass {
    static var storedTypeProperty = &quot;Some value.&quot;
    static var computedTypeProperty: Int {
        return 27
    }
    //子类对父类的实现进行重写
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}

</code></pre>

<h3 id="toc_11">获取和设置类型属性值</h3>

<p>类型属性通过点运算符通过类型本身来访问</p>

<pre><code class="language-swift">print(SomeStructure.storedTypeProperty)
    // 打印 &quot;Some value.&quot;
SomeStructure.storedTypeProperty = &quot;Another value.&quot;
print(SomeStructure.storedTypeProperty)
    // 打印 &quot;Another value.”
print(SomeEnumeration.computedTypeProperty)
    // 打印 &quot;6&quot;
print(SomeClass.computedTypeProperty)
    // 打印 &quot;27&quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类和结构体]]></title>
    <link href="https://acefish.github.io/15005513837564.html"/>
    <updated>2017-07-20T19:49:43+08:00</updated>
    <id>https://acefish.github.io/15005513837564.html</id>
    <content type="html"><![CDATA[
<p>可以使用完全相同的语法规则来为<code>类</code>和<code>结构体</code>定义属性(<code>常量</code>、<code>变量</code>)和添加方法，从而扩展类和结构体的功能</p>

<p>与其他编程语言不同,<code>swift</code>不要求为自定义类和结构创建独立的接口和实现文件.所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口</p>

<h2 id="toc_0">类和结构体对比</h2>

<blockquote>
<p>类通过引用计数进行多次引用,结构体通过复制的方式在代码中传递,不使用引用计数</p>
</blockquote>

<h3 id="toc_1">定义语法</h3>

<p>通过关键之<code>class</code>和<code>struct</code>来分别标识类和结构体</p>

<blockquote>
<p>类和结构体名使用首字母大写的方式进行命名</p>
</blockquote>

<pre><code class="language-swift">//定义一个结构体 描述显示器屏幕分辨率
struct Resolution {
    var width = 0
    var height = 0
    //当这两个属性被初始化为整数 0 的时候，它们会被推断为 Int 类型。
}

//定义一个类 描述视频显示器的特定模式
//四个变量存储属性
class VideoMode {
    var resolution = Resolution()//分辨率 结构体
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
</code></pre>

<p><code>存储属性</code>是被<code>捆绑</code>和<code>存储</code>在类或结构体中的常量或变量。</p>

<h3 id="toc_2">类和结构体实例</h3>

<p>初始化结构体或类的实例</p>

<pre><code class="language-swift">let someResolution = Resolution()
let someVideoMode = VideoMode()
</code></pre>

<p>通过这种方式创建类或者结构体实例,属性都会被初始化为默认值.</p>

<h3 id="toc_3">属性访问</h3>

<p>通过点语法访问实例属性。</p>

<pre><code class="language-swift">//访问结构体属性
print(&quot;The width of someResolution is \(someResolution.width)&quot;)
// 打印 &quot;The width of someResolution is 0&quot;

//访问变量属性
someVideoMode.resolution.width = 1280
print(&quot;The width of someVideoMode is now \(someVideoMode.resolution.width)&quot;)
// 打印 &quot;The width of someVideoMode is now 1280&quot;
</code></pre>

<blockquote>
<p>在OC中是不能直接设置结构体子属性值，swift中可以直接设置比如<code>resolution.width</code>属性值,在oc中我们需要给整个结构体<code>resolution</code>设置新值</p>
</blockquote>

<h3 id="toc_4">结构体类型成员逐一构造器</h3>

<p>对于<strong>结构体</strong><br/>
所有结构体都有一个自动生成的<strong>成员逐一构造器</strong>，用来初始化新结构体成员的属性</p>

<pre><code class="language-swift">//通过属性名称
let vga = Resolution(width:640, height: 480)
</code></pre>

<p>类是没有这个成员构造器的</p>

<h2 id="toc_5">结构体和枚举时值类型</h2>

<p><strong>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝</strong></p>

<p>实际上,在<code>Swift</code>中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是<strong>以结构体的形式所实现</strong></p>

<p>在<code>swift</code>中,所有结构体和枚举类型都是值类型。因此,它们的实例以及实例中包含的值类型属性,在传递时都会被复制</p>

<pre><code class="language-swift">let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
cinema.width = 2048
print(&quot;cinema is now \(cinema.width) pixels wide&quot;)// &quot;cinema is now 2048 pixels wide&quot;
print(&quot;hd is still \(hd.width) pixels wide&quot;)//&quot;hd is still 1920 pixels wide&quot;
</code></pre>

<p>在对结构体进行赋值的时候,进行了拷贝,cinema和hd是完全不同的两个实例,因此改变了cinema的宽对hd没有影响</p>

<p>枚举也是值类型,遵循相同的行为准则</p>

<h2 id="toc_6">类是引用类型</h2>

<p>与值类型不同,引用类型在传递时,值不会被拷贝.因此，<strong>引用的是已存在的实例本身而不是其拷贝</strong>。</p>

<pre><code class="language-swift">let tenEighty = VideoMode()
tenEighty.frameRate = 25.0

let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
print(&quot;The frameRate property of tenEighty is now \(tenEighty.frameRate)&quot;)//30.0
</code></pre>

<p>类是引用类型，所以<code>tenEight</code>和<code>alsoTenEight</code>实际上引用的是相同的<code>VideoMode</code>实例<br/>
注意:<br/>
虽然<code>alsoTenEighty</code>为常量但是仍然可以改变<code>alsoTenEighty.frameRate</code>因为这两个常量的值并未改变,这个常量的值存储的并不是<code>ViewMode</code>的实例,而是对其的引用.</p>

<h3 id="toc_7">恒等运算符</h3>

<p>等价于 <code>===</code>  不等价于 <code>!==</code> 用来检测两个变量或常量是否引用同一个实例</p>

<p><code>===</code>与<code>==</code>的不同:<br/>
“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。<br/>
“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准</p>

<h3 id="toc_8">指针</h3>

<p>一个引用实例的<code>swift</code>常量或者变量,与C指针类似,但是并不直接指向某个内存地址,也不需要用<code>*</code>表明在创建引用.</p>

<h2 id="toc_9">类和结构体的选择</h2>

<h2 id="toc_10">字符串、数组、字典类型的赋值和复制行为</h2>

<p>因为<code>swift</code>中很多基本类型,<code>String</code>，<code>Array</code>和<code>Dictionary</code>类型均以结构体的形式实现，赋值给新的常量变量或者传入函数方法中的时候会被拷贝</p>

<blockquote>
<p>在OC中<code>NSString</code>，<code>NSArray</code>和<code>NSDictionary</code>是以类的形式实现,不会发生值拷贝而是传递引用</p>

<p>Swift会在绝对必要时才执行实际拷贝,确保性能最优,因此我们没有必要回避赋值来增加性能</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[枚举]]></title>
    <link href="https://acefish.github.io/15003778819226.html"/>
    <updated>2017-07-18T19:38:01+08:00</updated>
    <id>https://acefish.github.io/15003778819226.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>与C语言不同，<code>Swift</code>中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p></li>
<li><p>枚举成员可以指定任意类型的关联值存储到枚举成员中</p></li>
<li><p>在 Swift 中，<strong>枚举类型</strong>是一等（first-class）类型。采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p></li>
</ol>

<h2 id="toc_0">枚举语法</h2>

<p>用<code>enum</code>关键字来创建枚举</p>

<pre><code class="language-swift">enum CompassPoint {
    case north
    case south
    case east
    case west
}

//多个成员可以在同一行 用 , 隔开
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>我们使用<code>case</code>来定义一个新的枚举成员值</p>

<blockquote>
<p>与OC不同,Swift枚举成员不会再创建时被赋予一个默认的整型值。这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的<code>CompassPoint</code>类型</p>
</blockquote>

<p>在<code>Swift</code>中每个枚举定义了一个全新的类型，与Swift中的其他类型一样,名字以大写字母开头</p>

<pre><code class="language-swift">var directionToHead = CompassPoint.west
//此时directionToHead类型可以被推断出来,我们可以直接使用 . 语法将其设置为另一个枚举值
directionToHead = .east
</code></pre>

<p>当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名。</p>

<h2 id="toc_1">用switch语句匹配枚举值</h2>

<p>在判断一个枚举类型值时,<code>switch</code>必须穷举所有情况，如果不需要匹配每个成员可以使用<code>default</code>分支</p>

<pre><code class="language-swift">let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print(&quot;Mostly harmless&quot;)
default:
    print(&quot;Not a safe place for humans&quot;)
}
// 打印 &quot;Mostly harmless”
</code></pre>

<h2 id="toc_2">关联值</h2>

<p>可以使用<code>Swift</code>的枚举来<strong>存储任意类型的关联值</strong>,枚举成员的关联值类型可以不同(关联值)</p>

<pre><code class="language-swift">enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
</code></pre>

<p>定义一个枚举类型,一个成员值是具有 <code>(Int，Int，Int，Int)</code>类型关联值的 upc，另一个是<code>String</code>类型关联值的qrcode</p>

<pre><code class="language-swift">//给其赋值关联的元组值
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
//赋值新的枚举关联字符串
productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;)
//productBarcode同一时间只能存储这两个值中的一个
</code></pre>

<pre><code class="language-swift">switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case .qrCode(let productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 打印 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<p>我们可以提取出来关联值作为常量或变量</p>

<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>：</p>

<pre><code class="language-swift">switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print(&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
case let .qrCode(productCode):
    print(&quot;QR code: \(productCode).&quot;)
}
// 输出 &quot;QR code: ABCDEFGHIJKLMNOP.&quot;
</code></pre>

<h2 id="toc_3">原始值</h2>

<p>枚举成员可以被<strong>默认值（称为原始值）预填充</strong>，这些原始值的类型必须相同。</p>

<pre><code class="language-swift">enum ASCIIControlCharacter: Character {
    case tab = &quot;\t&quot;
    case lineFeed = &quot;\n&quot;
    case carriageReturn = &quot;\r&quot;
}
</code></pre>

<p>枚举类型<code>ASCIIControlCharacter</code>的原始值类型被定义为<code>Character</code><br/>
每个原始值在枚举声明中必须是唯一的。</p>

<blockquote>
<p>注意原始值与关联值的不同，原始值是在定义枚举是预先填充的值，对于特定的枚举成员其原始值不变<br/>
关联值是创建一个基于枚举成员的常量或变量时才设置的值,枚举成员的关联值可以变化</p>
</blockquote>

<h3 id="toc_4">原始值的隐式赋值</h3>

<p>当原始值为整数或者字符串类型的枚举时,Swift会自动为每个枚举成员设置原始值;</p>

<ol>
<li><p>原始值为整形枚举</p>

<pre><code class="language-swift">enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
</code></pre>

<p>当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0</p></li>
<li><p>原始值为字符串类型</p>

<pre><code class="language-swift">enum CompassPoint: String {
    case north, south, east, west
}
//CompassPoint.south 拥有隐式原始值 south
</code></pre>

<p>使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称</p></li>
</ol>

<p>使用枚举成员的<code>rawValue</code>属性可以访问枚举成员初始值</p>

<pre><code class="language-swift">let earthsOrder = Planet.earth.rawValue
    // earthsOrder 值为 3
let sunsetDirection = CompassPoint.west.rawValue
    // sunsetDirection 值为 &quot;west&quot;
</code></pre>

<h3 id="toc_5">原始值初始化枚举实例</h3>

<p>定义枚举时使用原始值,会获得一个初始化方法,有一个<code>rawValue</code>类型为原始值类型的参数，返回一个枚举类型或为<code>nil</code></p>

<pre><code class="language-swift">let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet 类型为 Planet? 值为 Planet.uranus
//因为不一定都能找到匹配的行星  返回的是可选类型
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print(&quot;Mostly harmless&quot;)
    default:
        print(&quot;Not a safe place for humans&quot;)
    }
} else {
    print(&quot;There isn&#39;t a planet at position \(positionToFind)&quot;)
}
//找不到11代表的行星
</code></pre>

<h2 id="toc_6">递归枚举</h2>

<p>是一种枚举类型  有一个或多个成员使用该枚举类型实例作为关联值</p>

<p>可以在枚举成员前加<code>indirect</code>表示该成员可递归, 或者在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归</p>

<pre><code class="language-swift">enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}

indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}

//递归枚举使用
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

//递归函数中使用递归枚举
func evaluate(_ expression: ArithmeticExpression) -&gt; Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}
print(evaluate(product))//18
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包]]></title>
    <link href="https://acefish.github.io/14993105877642.html"/>
    <updated>2017-07-06T11:09:47+08:00</updated>
    <id>https://acefish.github.io/14993105877642.html</id>
    <content type="html"><![CDATA[
<p>闭包是自包含的函数代码块,可以在代码中被传递和使用</p>

<p><strong>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</strong></p>

<blockquote>
<p><code>Swift</code>中的闭包与<code>C</code>和<code>Objective-C</code>中的代码块（<code>blocks</code>）以及其他一些编程语言中的匿名函数比较相似<br/>
在函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包</p>
</blockquote>

<p>闭包的形式：</p>

<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>

<p>闭包可以进行一定语法优化，常见优化:</p>

<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回<code>单表达式</code>闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>

<h2 id="toc_0">闭包表达式</h2>

<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。</p>

<h3 id="toc_1">sorted方法</h3>

<p><code>Swift</code>的<code>sorted(by:)</code>方法根据提供的排序的闭包函数.将数组排序后返回一个同样大小排序后的数组,原数组不变</p>

<p><code>let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</code><br/>
对于数组这个用于排序的闭包函数类型为<code>(String, String) -&gt; Bool</code>通过返回bool值决定第一个参数在前还是在后</p>

<pre><code class="language-swift">func backward(_ s1: String, _ s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversedNames = names.sorted(by: backward)
// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]
</code></pre>

<p>为了写<code>return s1 &gt; s2</code>这么简单的表达式却需要写函数太过繁琐,我们可以使用闭包表达式语法</p>

<h3 id="toc_2">闭包表达式语法</h3>

<pre><code class="language-swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>闭包表达式参数 可以是<code>in-out</code>参数，但不能设定默认值。可以使用可变参数但是要放到参数最后</p>

<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。（<code>in</code>前为闭包定义,后为闭包函数体）</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<h3 id="toc_3">根据上下文推断类型</h3>

<p>因为这个闭包函数的作为方法参数传入,因此其类型已经确定为<code>(String, String) -&gt; Bool</code>,因此我们可以省略这些类型声明,因为可以被正确推断出来</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
//我们将闭包作为函数或方法的参数时,其类型总是可以推断出来的
//推荐完整格式闭包,增加代码可读性
</code></pre>

<h3 id="toc_4">单表达式闭包隐式返回</h3>

<p>如果闭包内只有一行单一表达式,并且明确了需要的返回类型,可以省略<code>return</code>关键字</p>

<pre><code class="language-swift">//
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<h3 id="toc_5">参数名称缩写</h3>

<p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，你可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数</p>

<p>如果使用参数名称缩写,那么在闭包定义中也可以省略参数列表,对应的参数名称缩写的类型也可以推断出来,这样的话<code>in</code>关键字也可以省略</p>

<pre><code class="language-swift">//此时闭包表达式只剩下闭包函数体
reversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<h3 id="toc_6">运算符方法</h3>

<p><code>Swift</code>的<code>String</code>类型定义了关于大于号<code>（ &gt; ）</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断出你想使用大于号的字符串函数实现：</p>

<pre><code class="language-swift">reversedNames = names.sorted(by: &gt;)
</code></pre>

<h2 id="toc_7">尾随闭包</h2>

<p>如果要将一个很长的闭包作为函数最后一个参数,为了增强代码的可读性,我们可以使用<code>尾随闭包</code>的方式来调用函数</p>

<pre><code class="language-swift">func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
    // 函数体部分
}
// 以下是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure(closure: {
    // 闭包主体部分
})
// 以下是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
    // 闭包主体部分
}

reversedNames = names.sorted() { $0 &gt; $1 }
//如果闭包函数是函数的唯一参数我们还可以省略（）
reversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<pre><code class="language-swift">//举栗子
let strings = numbers.map {
    (number) -&gt; String in
    var number = number
    var output = &quot;&quot;
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number &gt; 0
    return output
}
// strings 常量被推断为字符串类型数组，即 [String]
// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]
</code></pre>

<h2 id="toc_8">值捕获</h2>

<p>闭包可以在被定义的上下文捕获常量或变量</p>

<p>最简单的捕获值的闭包形式是嵌套函数</p>

<pre><code class="language-swift">func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementer() -&gt; Int {
        runningTotal += amount
    return runningTotal
    }
    return incrementer
}
</code></pre>

<p><code>makeIncrementer</code>的返回类型是<code>() -&gt; Int</code>说明要返回一个函数<br/>
对于嵌套函数<code>incrementer()</code>并没有参数，而是捕获了<code>runningTotal</code>和<code>amount</code>变量的引用.捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>

<blockquote>
<p>如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。 Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>

<pre><code class="language-swift">let incrementByTen = makeIncrementor(forIncrement: 10)
incrementByTen()// 返回的值为10
incrementByTen()// 返回的值为20
incrementByTen()// 返回的值为30
</code></pre>

<p>这个常量函数每次调用都会将<code>runningTotal</code>变量增加<code>10</code></p>

<h2 id="toc_9">闭包是引用类型</h2>

<p><code>函数</code>和<code>闭包</code>都是引用类型，因此我们设置的常量或者变量是设置的对应函数或闭包的引用，而不是闭包内容本身</p>

<blockquote>
</blockquote>

<h2 id="toc_10">逃逸闭包</h2>

<p>将闭包作为参数传递到另一个函数中,但是这个闭包在函数返回后才执行,则这个闭包从函数中<code>逃逸</code>，我们可以通过在函数名之前标注<code>@escaping</code>表示这个闭包允许<code>逃逸</code></p>

<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中,此时必须闭包是可逃逸的否则函数的作用域结束，这个外部变量保存的闭包。。。会导致编译错误</p>

<p>逃逸闭包我们常用于在一个函数需要异步执行操作,通常会让函数返回,在异步操作完成后再调用执行这个闭包,因为闭包需要在函数返回之后被调用,所以需要逃逸闭包</p>

<pre><code class="language-swift">var completionHandlers: [() -&gt; Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {
    completionHandlers.append(completionHandler)
}

func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {
    closure()
}
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
let instance = SomeClass()
instance.doSomething()
print(instance.x)
// 打印出 &quot;200&quot;
completionHandlers.first?()
print(instance.x)
</code></pre>

<h2 id="toc_11">自动闭包</h2>

<p>一种自动创建的闭包，用于包装传递给函数作为参数的表达式。不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这样帮我们省略掉花括号,用一个普通表达式代替显式的闭包</p>

<p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受自动闭包作为它的<code>condition</code>参数和 <code>message</code>参数；它的<code>condition</code>参数仅会在<code>debug</code>模式下被求值，它的<code>message</code>参数仅当 <code>condition</code>参数为<code>false</code>时被计算求值。</p>

<p><strong>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。</strong></p>

<pre><code class="language-swift">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
//未使用自动闭包
func serve(customer customerProvider: () -&gt; String) {
    print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: { customersInLine.remove(at: 0) } )
// 打印出 &quot;Now serving Alex!&quot;

//使用自动闭包
func serve(customer customerProvider: @autoclosure () -&gt; String) {
print(&quot;Now serving \(customerProvider())!&quot;)
}
serve(customer: customersInLine.remove(at: 0))
</code></pre>

<blockquote>
<p>过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟<br/>
执行的</p>
</blockquote>

<pre><code class="language-swift">//可以通过同时加上@autoclosure @escaping 自动闭包可以“逃逸”
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {
    customerProviders.append(customerProvider)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSNotification]]></title>
    <link href="https://acefish.github.io/14988080333726.html"/>
    <updated>2017-06-30T15:33:53+08:00</updated>
    <id>https://acefish.github.io/14988080333726.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">notification的使用</h2>

<h3 id="toc_1">注册观察者</h3>

<p><code>- (void)addObserver:(id)notificationObserver selector:(SEL)notificationSelector name:(NSString *)notificationName object:(id)notificationSender<br/>
</code><br/>
注意:</p>

<ol>
<li><code>notificationObserver</code>不能为nil</li>
<li><code>notification Selector</code>回调方法有且只有一个参数(<code>NSNotification</code>对象)</li>
<li>如果<code>notificationName</code>为<code>nil</code>，则会接收所有的通知(如果<code>notificationSender</code>不为空，则接收所有来自于<code>notificationSender</code>的所有通知)</li>
<li>如果<code>notificationSender</code>为<code>nil</code>，则会接收所有<code>notificationName</code>定义的通知；否则，接收由<code>notificationSender</code>发送的通知</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的</li>
</ol>

<h3 id="toc_2">post通知</h3>

<pre><code class="language-objc">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;First&quot; object:@&quot;博客园-Fly_Elephant&quot;];
-(void)notificationFirst:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
}
//名称:First----对象:博客园-Fly_Elephant

[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;Second&quot; object:@&quot;http://www.cnblogs.com/xiaofeixiang&quot; userInfo:dict];
-(void)notificationSecond:(NSNotification *)notification{
    NSString  *name=[notification name];
    NSString  *object=[notification object];
    NSDictionary  *dict=[notification userInfo];
    NSLog(@&quot;名称:%@----对象:%@&quot;,name,object);
    NSLog(@&quot;获取的值:%@&quot;,[dict objectForKey:@&quot;key&quot;]);
}
//名称:Second----对象:http://www.cnblogs.com/xiaofeixiang
//获取的值:keso
</code></pre>

<h2 id="toc_3">通知原理</h2>

<p>单例的方式创建一个<code>NSNotificationCenter</code>对象<br/>
对象注册观察者时 将注册的<code>name</code> <code>selector</code> <code>object</code> 作为一个模型 添加到一个数组中</p>

<p>post时根据名字和object 找到数组中注册的对象 执行通知的方法</p>

<h2 id="toc_4">多线程</h2>

<p>在多线程应用中，<code>Notification</code>在哪个线程中<code>post</code>，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。<br/>
也就是说，<code>Notification</code>的发送与接收处理都是在同一个线程中.</p>

<h2 id="toc_5">通告队列 NSNotificationQueue</h2>

<p><code>NSNotificationQueue</code> 作用是充当通告中心(<code>NSNotificationCenter</code>)的缓冲区,以FIFO的顺序进行维护。当一个通告上升到队列最前时，就将他发送给通告中心，通告中心随后将它派发给所有注册为观察者的对象</p>

<p>参考<a href="http://www.jianshu.com/p/b4835026e8e9">NSNotification&amp;NSNotificationCenter(实现原理,多线程,内存管理角度)</a><br/>
参考<a href="http://www.cnblogs.com/heyonggang/p/3681689.html">iOS NSNotification的使用</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数 Functions]]></title>
    <link href="https://acefish.github.io/14986177362678.html"/>
    <updated>2017-06-28T10:42:16+08:00</updated>
    <id>https://acefish.github.io/14986177362678.html</id>
    <content type="html"><![CDATA[
<p>在<code>Swift</code>中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型。可以把函数类型当做任何其他<br/>
普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数<br/>
的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>

<h2 id="toc_0">函数的定义与调用</h2>

<pre><code class="language-swift">func greet(person: String) -&gt; String {
    let greeting = &quot;Hello, &quot; + person + &quot;!&quot;
    return greeting
}
</code></pre>

<p>定义一个函数,以<code>func</code>为前缀，定义了一个输入参数一个叫<code>person</code>的<code>String</code>值，用<code>-&gt;</code>来指定函数返回类型一个<code>String</code>类型返回值</p>

<blockquote>
<p><code>print(_:separator:terminator:)</code>这个函数第一个参数为<code>_</code>即并没有设置标签,其他参数设置了标签并且有默认值因此是可选的 </p>
</blockquote>

<h2 id="toc_1">函数参数与返回值</h2>

<p>在函数参数名称为<code>_</code>即不设置名称 </p>

<h3 id="toc_2">无参函数</h3>

<pre><code class="language-swift">func sayHelloWorld() -&gt; String {
    return &quot;hello, world&quot;
}
print(sayHelloWorld())
// 打印 &quot;hello, world&quot;
</code></pre>

<p><strong>注意:</strong><br/>
即使这个函数没有参数,但是定义中在函数名后还是<strong>需要一对圆括号</strong>。当被调用时，也需要<strong>在函数名后写一对圆括号</strong>与C语言函数相同</p>

<h3 id="toc_3">多参函数</h3>

<pre><code class="language-swift">func greet(person: String, alreadyGreeted: Bool) -&gt; String {
    if alreadyGreeted {
        return greetAgain(person: person)
    } else {
        return greet(person: person)
    }
}
print(greet(person: &quot;Tim&quot;, alreadyGreeted: true))
// 打印 &quot;Hello again, Tim!&quot;
</code></pre>

<p>传递多个参数,之前用<code>,</code>隔开,这个函数与前面函数虽然名称相同 但是参数不同因此是不同的两个函数</p>

<blockquote>
<p>重载:指两个函数的函数名相同,函数的参数列表不同(包括参数个数和参数类型)，至于返回类型可同可不同<br/>
OC不完全支持重载,即OC支持参数个数不同的函数重载,Swift是完全支持重载的</p>
</blockquote>

<h3 id="toc_4">无返回值函数</h3>

<pre><code class="language-swift">func greet(person: String) {
    print(&quot;Hello, \(person)!&quot;)
}
greet(person: &quot;Dave&quot;)
// 打印 &quot;Hello, Dave!&quot;
</code></pre>

<blockquote>
<p>虽然没有定义返回值,其实返回了一个特殊的<code>Void</code>值,这是<strong>一个空的元组</strong>，没有任何元素,可以写为()</p>
</blockquote>

<h3 id="toc_5">多重返回值函数</h3>

<p>我们可以用元组让多个值作为一个复合值从函数中返回</p>

<pre><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

let bounds = minMax(array: [8, -6, 2, 109, 3, 71])
print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
// 打印 &quot;min is -6 and max is 109&quot;
</code></pre>

<blockquote>
<p>我们在返回元组时不需要给元组命名，因为它们的名字在函数返回类型中就已经确定了</p>
</blockquote>

<h3 id="toc_6">可选元组返回值</h3>

<p>如果函数返回的元组类型有可能整个元组都“没有值”,可以使用可选元组返回类型来说明元组可能为<code>nil</code></p>

<blockquote>
<p>注意 可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
</blockquote>

<p>对于上面的数组我们添加一个空数组检查,当传入的数组为空时返回<code>nil</code>:</p>

<pre><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}

//用可选类型绑定来检查函数返回的是一个存在的元组还是一个nil
if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
}
// 打印 &quot;min is -6 and max is 109&quot;

</code></pre>

<h2 id="toc_7">函数参数标签和参数名称</h2>

<p>每个函数参数都有一个<code>参数标签</code>以及一个<code>参数名称</code>.<br/>
<code>参数标签</code>在调用函数的时候使用:调用时需要将函数的参数标签写在对应参数前<br/>
<code>参数名称</code>在函数的实现中使用。默认,函数参数使用参数名称来作为参数标签</p>

<h3 id="toc_8">指定参数标签</h3>

<p>在参数名称前指定它的参数标签，中间以空格分隔:</p>

<pre><code class="language-swift">//参数标签使函数在调用时更有表达力,保持可读性
//argumentLabel参数标签  parameterName参数名称
func someFunction(argumentLabel parameterName: Int) {
    // 在函数体内，parameterName 代表参数值
}
func greet(person: String, from hometown: String) -&gt; String {
    return &quot;Hello \(person)! Glad you could visit from \(hometown).&quot;
}
print(greet(person: &quot;Bill&quot;, from: &quot;Cupertino&quot;))
</code></pre>

<h3 id="toc_9">忽略参数标签</h3>

<p>我们用下划线来忽略 不设置参数标签</p>

<pre><code class="language-swift">func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值
}
someFunction(1, secondParameterName: 2)
</code></pre>

<blockquote>
<p>如果一个参数有标签,那么在调用时必须使用标签来标记这个参数</p>
</blockquote>

<h3 id="toc_10">默认参数值</h3>

<p>可以在函数体重通过给参数赋值来为任意一个参数定义默认值. 如果定义了默认值，可以在调用这个函数时忽略这个参数:</p>

<pre><code class="language-swift">func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    // 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault = 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12
</code></pre>

<p>我们通常将不带默认值的参数放在函数参数列表最前。因为一般没有默认值参数更重要，将不带默认值的参<br/>
数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更<br/>
为清晰。</p>

<h3 id="toc_11">可变参数</h3>

<p>通过在变量类型名后加上<code>...</code>的方式来定义可变参数<br/>
可变参数可以接受零个或多个值,我们用其来指定函数传入不确定数量的输入值</p>

<p>我们在函数体中将可变参数传入值变为数组来使用</p>

<pre><code class="language-swift">func arithmeticMean(_ numbers: Double...) -&gt; Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// 返回 3.0, 是这 5 个数的平均数。
arithmeticMean(3, 8.25, 18.75)
// 返回 10.0, 是这 3 个数的平均数。
</code></pre>

<blockquote>
<p>一个函数最多只能有一个可变参数</p>
</blockquote>

<h3 id="toc_12">输入输出参数</h3>

<p>参考<a href="http://www.csdn.net/article/2015-01-20/2823635-swift-pointer">Swift中的指针操作及使用</a></p>

<p>函数参数默认为常量,因此在函数体中修改会导致编译错误。如果想要在函数中修改某个参数值,并且这些修改在函数调用后仍然有效，那么需要把这个参数定义为输入输出参数</p>

<p>在参数定义前加上<code>inout</code>关键字来定以输入输出参数，这个值被函数修改然后被传出函数替换原来的值.</p>

<p>只能传递变量给输入输出参数,不能传入常量或字面量，调用时当传入的参数作为输入输出参数时,需要在参数名前加<code>&amp;</code>表示这个值可被修改</p>

<blockquote>
<p>输入输出参数不能有默认值，而且可变参数不能用<code>inout</code>标记</p>
</blockquote>

<pre><code class="language-swift">func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)
// 打印 &quot;someInt is now 107, and anotherInt is now 3&quot;
</code></pre>

<p><strong>可以参考C语言中函数的 指针参数</strong></p>

<h2 id="toc_13">函数类型</h2>

<p>每个函数都有 由<code>函数的参数类型</code>和<code>返回类型</code> 组成<code>函数类型</code></p>

<pre><code class="language-swift">func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    return a + b
}
</code></pre>

<p>函数类型为<code>(Int, Int) -&gt; Int</code></p>

<pre><code class="language-swift">func printHelloWorld() {
    print(&quot;hello, world&quot;)
}
</code></pre>

<p>函数类型为<code>() -&gt; Void</code></p>

<h3 id="toc_14">函数类型的使用</h3>

<p>在<code>Swift</code>中使用函数类型和使用其他类型一样。</p>

<pre><code class="language-swift">var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</code></pre>

<p>定义一个类型是‘一个有两个Int型的参数并返回一个Int型的值的<code>mathFunction</code>变量，指向<code>addTwoInts</code>函数</p>

<p>函数类型与其他类型一样可以通过赋值让<code>Swift</code>推断其函数类型</p>

<h3 id="toc_15">函数类型作为参数类型</h3>

<pre><code class="language-swift">func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print(&quot;Result: \(mathFunction(a, b))&quot;)
}

//调用
printMathResult({ (a, b) -&gt; Int in
    return a*b
}, 10, 20)
</code></pre>

<p><code>printMathResult(_:_:_:)</code>函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得<code>printMathResult(_:_:_:)</code>能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>

<h3 id="toc_16">函数类型作为返回类型</h3>

<p>我们可以将函数类型作为另一个函数的返回类型</p>

<pre><code class="language-swift">func stepForward(_ input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(_ input: Int) -&gt; Int {
    return input - 1
}

func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    return backward ? stepBackward : stepForward
}

//执行
var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
// moveNearerToZero 现在指向 stepBackward() 函数。
</code></pre>

<p>上面例子获取一个整形接近0应该用的函数</p>

<pre><code class="language-swift">print(&quot;Counting to zero:&quot;)
// Counting to zero:
while currentValue != 0 {
    print(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// 3...
// 2...
// 1...
// zero!
</code></pre>

<h2 id="toc_17">嵌套函数</h2>

<p>前面定义的所有函数都为<code>全局函数</code><br/>
我们可以把函数定义在其他函数中,这就是<code>嵌套函数</code><br/>
默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>

<blockquote>
<p>OC中是不支持在一个函数中定义另外一个函数</p>
</blockquote>

<p>我们用返回嵌套方式重写<code>chooseStepFunction(backward:)</code>函数</p>

<pre><code class="language-swift">func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {
    //我们在函数中定义另外函数
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    //返回嵌套函数
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)
while currentValue != 0 {
print(&quot;\(currentValue)... &quot;)
currentValue = moveNearerToZero(currentValue)
}
print(&quot;zero!&quot;)
// -4...
// -3...
// -2...
// -1...
// zero!
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络通信]]></title>
    <link href="https://acefish.github.io/14982190720101.html"/>
    <updated>2017-06-23T19:57:52+08:00</updated>
    <id>https://acefish.github.io/14982190720101.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">TCP/IP五层模型</h2>

<p><img src="media/14982190720101/14982758829850.jpg" alt=""/><br/>
<code>TCP/IP协议五层模型</code>中的应用层对应<code>网络七层模型</code>中的第五层、第六层和第七层的功能</p>

<ul>
<li>应用层:对应应用程序的通信服务  如HTTP,FTP,NFS,SMTP</li>
<li>传输层:是否选择差错恢复协议还是无差错恢复协议，在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。 如TCP UDP</li>
<li>网络层:主要为数据包寻找路由(路由寻址),为了适应最大传输单元长度(MTU)小于包长度的传输介质，网络层还定义了如何分包 ,路由器</li>
<li>数据链路层:传输有地址的帧 ，以太网交换机等 数据成帧后通过差错控制提供数据帧在信道上无差错的传输</li>
<li>物理层:数据传输的物理媒介</li>
</ul>

<p>应用层用于识别数据内容,通过遵循应用层协议(HTTP、FTP或者我们自己定义的协议等)可以识别数据,使数据有意义</p>

<p>TCP/IP协议还提供一项名为UDP（用户数据报协议)<br/>
TCP：面向连接、传输可靠、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br/>
UDP：面向非连接(是指在正式通信前不必与对方先建立连接，不管对方状态就直接发送)、传输不可靠、用于传输少量数据(数据包模式)、速度快。</p>

<p>//UDP传输层传输的示意图<br/>
<img src="media/14982190720101/14982727461179.png" alt=""/></p>

<p>UDP端口对于基于UDP的通信作为单一消息队列和网络端点来操作，而所有TCP通信的终点都是唯一的连接。每个TCP连接由两个端点唯一识别。由于所有TCP连接由两对 IP 地址和TCP端口唯一识别（每个所连主机都有一个地址/端口对），因此每个TCP服务器端口都能提供对多个连接的共享访问</p>

<h2 id="toc_1">TCP的长连接和短连接</h2>

<p>在利用TCP协议开始通讯前,需要客户端和服务端进行<code>三次握手</code>来建立连接,而在结束通信后需要由<code>四次握手</code>来释放连接</p>

<h3 id="toc_2">TCP短连接&amp;&amp;长连接</h3>

<p>短连接即建立连接后,<code>client</code>向<code>server</code>发送消息,<code>server</code>收到消息回应<code>client</code> 然后完成了一次读写通信后,这时候双方都可以进行<code>close</code>操作,一般由客户端进行断开连接的操作,因此短连接只进行一次传递读写的操作</p>

<p>长连接是在建立连接,进行读写之后并不会主动关闭连接,后续仍然使用这个连接来进行读写</p>

<h3 id="toc_3">维护长连接</h3>

<p>我们在应用中创建一个长连接，这个长连接并没有确切时间限制,而是说这条连接需要时间较长<br/>
通常我们在应用中对网络通信的实时性要求较高,需要及时知道已经断开的连接进行及时处理,因此我们需要手工来进行不断探测</p>

<h4 id="toc_4">1.应用层使用心跳包</h4>

<p>一般在一个心跳间隔,客户端发送一个特定<code>ping</code>消息到服务器,服务器返回消息完成一次心跳交互,等待下一轮.如果客户端没有收到心跳反馈就会关闭掉<code>TCP</code>连接,心跳周期一般设置为几分钟,比如微信为300S</p>

<p>心跳机制可以由客户端和服务器两端都可以发送心跳包，两端也都可以监测, 一般为客户端发送心跳包服务器监测,如果在一个心跳周期没有收到心跳反馈可以断开连接(或者没有收到反馈后再发送几次ping包确定没有收到反馈后即断开连接)  而服务器一般在心跳间隔的1.5周期没有收到客户端的心跳包可以选择断开连接，当然具体情况视应用具体需求而定</p>

<h4 id="toc_5">2.TCP/IP协议层面的心跳机制</h4>

<p><strong>TCP保活功能:</strong><br/>
保活功能<code>主要为服务器</code>应用提供，用来检测客户端主机是否已经崩溃,如果客户端主机已经消失,那么服务器上这个连接就成为了半开放连接,而保活功能就是用来检测这种半开放连接的:<br/>
如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机处于以下4个状态之一：</p>

<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ol>

<p>TCP的心跳机制即为利用上面说的保活功能使两小时后发现TCP连接是否存在,如果想要使时间减少就需要修改内核方面参数,这种方式是很不合适的</p>

<h2 id="toc_6">socket编程</h2>

<p><code>socket</code>也称为<strong>套接字</strong>,用于描述IP地址和端口,实现不同主机间通信,IP地址和端口确定一个socket</p>

<blockquote>
<p>端口:用于区分不同应用服务,比如<code>HTTP</code>或者<code>FTP</code>等,然后可以根据应用协议来解析数据</p>
</blockquote>

<p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层，对<code>TCP/IP</code>进行了封装，这就是<code>Socket编程接口</code>,程序员通过其进行网络开发.</p>

<blockquote>
<p>HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力</p>
</blockquote>

<p><img src="media/14982190720101/14984586168116.jpg" alt=""/></p>

<p>在<code>Internet</code>上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个<code>Socket</code>，并绑定到一个端口上，不同的端口对应于不同的服务。</p>

<p><img src="media/14982190720101/14982205873836.jpg" alt=""/></p>

<h2 id="toc_7">常用应用层协议</h2>

<p><strong>应用层协议 :规定了客户端和服务器之间的数据传输格式</strong></p>

<h3 id="toc_8">1.HTTP</h3>

<h4 id="toc_9">长连接&amp;&amp;短连接</h4>

<p>HTTP为应用层协议,在传输层使用TCP协议，在网络使用IP协议<br/>
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br/>
HTTP的长连接和短连接本质就是TCP的长连接和短连接,http通过tcp三次握手建立连接<br/>
在HTTP/1.0中默认使用短连接，每进行一次HTTP操作就建立一次连接,结束就中断<br/>
从HTTP/1.1开始，默认使用长连接来保持连接特性,使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code>,可以在一次连接中处理多个请求，可以重叠进行<br/>
<code>Keep-Alive</code>并不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如<code>Apache</code>）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<blockquote>
<p>注意:这个alive 和 tcp的alive是不同的</p>
</blockquote>

<h4 id="toc_10">轮询</h4>

<p>分为短轮询和长轮询</p>

<p>短轮询:向服务器发送数据，服务器返回结果,不断的操作就是轮询,缺点是浪费了大量资源<br/>
优点：后端程序编写比较容易。 <br/>
缺点：请求中有大半是无用，浪费带宽和服务器资源。 <br/>
实例：适于小型应用。</p>

<p>长轮询：解决了短轮询的问题,长轮询的操作是:前段发送请求给后端，后台收到请求后并不及时返回,加入后台数据没有更新,就将请求挂起来直到有消息返回才返回响应信息并关闭连接,这样就不会频繁请求堵塞服务器<br/>
优点：在无消息的情况下不会频繁的请求，耗费资源小。 <br/>
缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 <br/>
实例：WebQQ、Hi网页版 <br/>
<img src="media/14982190720101/14985257353004.png" alt=""/></p>

<h3 id="toc_11">2.WebSocket</h3>

<p>在上面介绍的HTTP的轮询方式是非常浪费资源的,因为HTTP的header非常长,我们频繁发送一个很小的数据却占用了大量带宽,因此我们可以用<code>webSocket</code>代替</p>

<p><code>WebSocket</code>是应用层协议，是<code>html5</code>一种新的协议。它<strong>实现了浏览器与服务器全双工通信</strong></p>

<p>WebSocket建立连接过程:<br/>
1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行<br/>
2. TCP连接成功后，浏览器通过<code>HTTP协议</code>向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）<br/>
3. 服务器收到客户端的握手请求后，同样采用<code>HTTP协议</code>回馈数据。<br/>
4. 当收到了连接成功的消息后，通过TCP通道进行传输通信</p>

<blockquote>
<p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的<br/>
<code>WebSocket</code>是一种双向通信协议，在建立连接后，<code>WebSocket</code>服务器和<code>Browser/Client Agent</code>都能主动的向对方发送或接收数据，就像<code>Socket</code>一样;</p>
</blockquote>

<p>存在问题:<br/>
<code>webSockets</code>虽然是实现了长连接，但是如果客户端与服务端长时间没有发送数据，那么网络链路就会认为这个连接已经失效，会自作主张的将其断开，因此需要发送心跳包</p>

<p>iOS端使用webSocket：<br/>
<a href="http://www.cocoachina.com/ios/20161031/17886.html">接入WebSocket记录</a></p>

<h2 id="toc_12">iOS中网络编程</h2>

<h3 id="toc_13">iOS网络层次</h3>

<p>iOS网络编程层次结构分为三层:<br/>
Cocoa层：NSURL，Bonjour，Game Kit，WebKit<br/>
Core Foundation层：基于C的CFNetwork 和 CFNetServices<br/>
OS层:基于C的 BSD socket</p>

<p><code>Bonjour</code>封装了<code>CFNetwork</code>,Bonjour中的<code>NSNetService</code>也有对应底层实现<code>CFNetService</code>，<code>NSInputStream</code>有对应的底层实现<code>CFInputStream</code></p>

<p><code>Bonjour</code>是一种能够自动查询接入网络中的设备或应用程序的协议，抽象ip和port为<code>service</code>，一个应用程序<code>publish</code>一个网络服务<code>service</code>然后网络中的其他程序就能自动发现这个<code>service</code>，从而可以向这个<code>service</code>查询其<code>ip</code>和<code>port</code>，然后通过获得的<code>ip</code>和<code>port</code>建立 <code>socket</code>链接进行通信。通常我们是通过<code>NSNetService</code>和<code>NSNetServiceBrowser</code>来使用 <code>Bonjour</code>的，前者用于建立与发布<code>service</code>，后者用于监听查询网络上的<code>service</code>。<br/>
不多做介绍,深入学习可以参考<a href="http://www.cnblogs.com/kesalin/archive/2011/09/15/cocoa_bonjour.html">深入浅出Cocoa之Bonjour网络编程</a></p>

<h3 id="toc_14">iOS中应用限制</h3>

<p>Apple为了让设备尽量省电，减少不必要的开销，保持系统流畅除了特殊的官方程序外是不会让程序在后台无限执行的,开发者开发的程序收到以下限制:</p>

<p>按下<code>home</code>将应用转为后台运行后,app后台运行时间有限（可以通过<code>backgroundTimeRemaining</code>属性来获取这个可用时间）(<code>拥有180s运行时间可以处理后台操作</code>), 时间结束后我们的程序在程序会进入挂起状态，这种状态下应用不会执行任何代码、关闭定时器、系统会收回给程序分配的<code>socket</code>资源</p>

<p>我们只能通过苹果提供的几种特殊后台方式来进行程序的“后台”工作</p>

<ol>
<li><p>进入后台后前若应用还有未完成任务,可以申请有限时间(最多不超过10分钟)来完成重要任务<br/>
当10分钟到了后会，无论怎么向系统申请继续后台，系统会强制挂起App，挂起所有后台操作、线程，直到用户再次点击App之后才会继续运行。</p>

<pre><code class="language-objc">- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void (^)(void))handler
//返回一个新的后台任务的唯一的标示符，你必须将这个值传给endBackgroundTask:方法来标记任务的结束。如果无法在后台运行这个方法将返回UIBackgroundTaskInvalid。
//handle回调是在时间快到了执行,防申请到的时间片段内，还是没能完成任务的话，做最后的清理和标注工作,如果不传的话，那么结果就是iOS直接kill掉你的APP
</code></pre>

<p>必须在任务执行结束时，调用<code>endBackgroundTask</code>并传递这个标示符，来结束后台任务。</p></li>
<li><p>iOS为特殊任务设计的后台模式</p></li>
</ol>

<p>后台下载任务：<br/>
<code>Background Downloading</code> <strong>后台下载</strong>,必须使用 iOS 指定的机制才可以，那就是 <code>NSURLSession</code></p>

<p>后台运行的特定服务类型<br/>
    <img src="media/14982190720101/14990618979269.jpg" alt=""/></p>

<pre><code>1. 应用在后台播放或者录制音频
2. APP更新GPS信息，通知给用户
3. `voip` 网络电话功能
4. 杂志应用,在后台下载杂志并处理(用通知触发后台下载任务)
5. 一些控制外设的app，需要不停与外设沟通.系统就不会主动关闭 APP 与 外设之间的连接，而是替
    APP 监视这个连接，但有数据过来时，会唤醒 APP 进行处理，每次唤醒 APP 只有 10S 时间
    进行数据处理(不够的话还使用上面的方法申请更多时间)
6. iPhone作为蓝牙中心设备，需要不停更新蓝牙设备
7. iphone作为蓝牙外围设备，需要不停访问其他蓝牙设备数据
8. 需要在后台频繁有规律获取数据,统在你的 APP 进入后台后，会间隔性的给机会将你的 APP 唤醒，
   并回调你的 委托方法`application:performFetchWithCompletionHandler:`
9. App后台关注推送,推送到达时，后台启动app：服务端推送加上键值对content-available = 1的
   话, 手机收到这个通知后，会自动启动 APP 到后台，或 唤醒（依旧保持后台执行），并回调 委托
   方法 application:didReceiveRemoteNotification:fetchCompletionHandler:
</code></pre>

<p>详细设计可参考<a href="http://dxjia.cn/2016/05/26/ios-background-executions/?utm_source=tuicool&amp;utm_medium=referral">iOS 后台任务设计指导</a></p>

<h2 id="toc_15">补充：</h2>

<h3 id="toc_16">WebService</h3>

<p><code>Web Service</code>是一种可以接收从<code>Internet</code>或者<code>Intranet</code>上的其它系统中传递过来的请求，轻量级的独立的通讯技术。<br/>
WebService是一种跨编程语言和跨操作系统平台的远程调用技术</p>

<p>远程调用就是:一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法。 例如百度等把自己的系统服务以<code>webservice</code>服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能</p>

<p>可以从多个角度来理解<code>WebService</code>，从表面上看，<code>WebService</code>就是一个应用程序向外界暴露出一个能通过<code>Web</code>进行调用的<code>API</code>,能用编程的方法通过Web来调用这个应用程序,那么提供这个<code>WebService</code>的应用程序就是服务端。从深层次看，<code>WebService</code>是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在<code>Web</code>上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写<code>WebService</code>，只要我们可以通过<code>WebService</code>标准对这些服务进行查询和访问。</p>

<p>为了分布式应用程序的创建,必须要有一套标准的类型系统,需要标准的描述语言来描述webService让开发者可以获取信息，最后还需要有一个方法对这个<code>WebService</code>进行远程调用即远程调用协议(RPC)，为了达到跨语言跨平台目的这个RPC还需要和平台语言无关</p>

<ol>
<li>XML+XSD
WebService采用HTTP协议传输数据，采用XML格式封装数据，
<code>XSD</code>即 <code>XML Schema</code> 是定义了XML的标准数据类型.WebService平台就是用XSD来作为其数据类型系统的。</li>
<li>SOAP（简单对象访问协议）
WebService采用HTTP协议传输数据，采用XML格式封装数据，并且增加了一些特定的HTTP消息头来说明消息的内容格式，这些特定的HTTP消息头和XML内容格式就是<code>SOAP协议</code>。SOAP提供了标准的RPC方法来调用Web Service。
<code>SOAP协议 = HTTP协议 + XML数据格式</code>
SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。</li>
<li>WSDL（Web服务描述语言）
WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么。<code>WSDL</code>文件是一个<code>XML</code>文档，用于描述Web Service及其函数、参数和返回值。</li>
</ol>

<p><code>WebService</code>服务提供商可以通过两种方式来暴露它的<code>WSDL</code>文件地址：1.注册到<code>UDDI</code>服务器，以便被人查找；2.直接告诉给客户端调用者。</p>

<p><code>WebService</code>的调用有3种方式：<br/>
1)httpget <br/>
2)httppost<br/>
3)httpsoap<br/>
<code>soap</code>的优点是 可以传递结构化的数据，而前两种不行</p>

<p>将数据直接用XML格式封装 因此不用担心编码，大小写等问题,传递数据可以是数组，对象等</p>

<p>但是由于要进行XML解析 因此会导致效率有所降低</p>

<h2 id="toc_17">参考连接:</h2>

<p><a href="http://blog.csdn.net/wwd0501/article/details/54582912">WebSocket介绍，与Socket的区别</a><br/>
<a href="http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html">Web 通信 之 长连接、长轮询</a><br/>
<a href="http://blog.csdn.net/prl18353364833/article/details/51593643">网络七层协议 五层模型</a><br/>
<a href="http://www.jianshu.com/p/49d7997ad3b7">Web Service到底是什么</a><br/>
<a href="https://www.zhihu.com/question/20215561">WebSocket 是什么原理</a><br/>
<a href="http://www.jianshu.com/p/121fc5b7f2d3">iOS Background Modes</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[控制流]]></title>
    <link href="https://acefish.github.io/14980952471508.html"/>
    <updated>2017-06-22T09:34:07+08:00</updated>
    <id>https://acefish.github.io/14980952471508.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">For-In循环</h2>

<p>可以用来遍历区间</p>

<pre><code class="language-swift">//遍历一个闭区间
for index in 1...5 {
    print(&quot;(index) times 5 is (index * 5)&quot;)
}
</code></pre>

<p><code>index</code>在每次遍历开始时是会自动赋值的<code>常量</code>,会隐式声明,不用使用关键字<code>let</code>进行声明</p>

<p>有时我们进行遍历,并不关心遍历出的值,只需要遍历的次数,这时候我们可以使用下划线<code>_</code>代替变量名忽略这个值</p>

<pre><code class="language-swift">//求 3的10次方 这时候我们不关心便利出来的值 只关系执行次数
let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
</code></pre>

<p>我们还可以使用<code>for-in</code>遍历 </p>

<ul>
<li>数组所有元素 </li>
<li>遍历一个字典访问键值对,键值对以元组形式返回,可以使用显示的常量名称解读<code>(key, value)</code></li>
<li>字符串中的字符(<code>greeting.characters.indices</code>，返回包含所有字符的range)</li>
</ul>

<h2 id="toc_1">While</h2>

<h3 id="toc_2">While</h3>

<p>循环开始时判断条件是否符合,<code>ture</code>执行循环的语句,<code>false</code>结束循环</p>

<pre><code class="language-swift">while square &lt; finalSquare {
    
}
</code></pre>

<h3 id="toc_3">Repeat-While</h3>

<p>与<code>while</code>的区别就是执行判断条件之前会首先执行一次循环的代码块(类似do-while)</p>

<pre><code class="language-swift">repeat {
    statements
} while condition
</code></pre>

<h2 id="toc_4">条件语句</h2>

<h3 id="toc_5">IF语句</h3>

<pre><code class="language-swift">let temperatureInFahrenheit = 90
if temperatureInFahrenheit &lt;= 32 {
    print(&quot;It&#39;s very cold. Consider wearing a scarf.&quot;)
} else if temperatureInFahrenheit &gt;= 86 {
    print(&quot;It&#39;s really warm. Don&#39;t forget to wear sunscreen.&quot;)
} else {
    print(&quot;It&#39;s not that cold. Wear a t-shirt.&quot;)
}
//也可以不要最后的else语句 这样有可能既不冷也不热,不会触发if和else if 也就不会打印任何消息
</code></pre>

<h3 id="toc_6">switch</h3>

<p>将某个值与一个或多个同类型的值作比较</p>

<pre><code class="language-swift">switch some value to consider {
case value 1:
    respond to value 1
case value 2,
    value 3:
    respond to value 2 or 3
default:
    otherwise, do something else
}
</code></pre>

<p>完备性:<br/>
对于<code>switch</code>语句每个可能的值,需要至少一个<code>case</code>分支与之对应,对于某些没办法用<code>case</code>覆盖所有分支的情况,可以通过在最后加上<code>default</code>分支来涵盖其他没有对应的值</p>

<h4 id="toc_7">隐式break</h4>

<p>与OC中的<code>switch</code>语句不同,即使在<code>case</code>语句后没有break 也在执行<code>case</code>分钟的代码执行完毕后终止<code>switch</code>语句的执行，不会继续执行下一个<code>case</code>分支</p>

<p>注意:<br/>
<code>case</code>分支中都至少包含一条语句</p>

<pre><code class="language-switch">//case分支后至少需要一条语句 下面这种写法是错误的
let anotherCharacter: Character = &quot;a&quot;
switch anotherCharacter {
case &quot;a&quot;: // 无效，这个分支下面没有语句
case &quot;A&quot;:
    print(&quot;The letter A&quot;)
default:
    print(&quot;Not the letter A&quot;)
}
//此时如果想case&quot;a&quot;分支什么都不执行 可以直接执行一条break语句
</code></pre>

<p>此时如果我们想<code>&quot;a&quot;和&quot;A&quot;</code>都执行<code>print(&quot;The letter A&quot;)</code>可以将两个值组合为一个复合匹配</p>

<pre><code class="language-swift">let anotherCharacter: Character = &quot;a&quot;
switch anotherCharacter {
case &quot;a&quot;, &quot;A&quot;:
    print(&quot;The letter A&quot;)
default:
    print(&quot;Not the letter A&quot;)
}
//为了可读性 可以写为多行形式
case &quot;a&quot;,
     &quot;A&quot;
</code></pre>

<h4 id="toc_8">区间匹配</h4>

<p>case分支的匹配模式也可以是一个值的区间</p>

<pre><code class="language-swift">let approximateCount = 62
let countedThings = &quot;moons orbiting Saturn&quot;
var naturalCount: String
switch approximateCount {
case 0:
    naturalCount = &quot;no&quot;
case 1..&lt;5:
    naturalCount = &quot;a few&quot;
case 5..&lt;12:
    naturalCount = &quot;several&quot;
case 12..&lt;100:
    naturalCount = &quot;dozens of&quot;
case 100..&lt;1000:
    naturalCount = &quot;hundreds of&quot;
default:
    naturalCount = &quot;many&quot;
}
print(&quot;There are \(naturalCount) \(countedThings).&quot;)
</code></pre>

<h4 id="toc_9">元组</h4>

<p>可以使用元组在同一个<code>switch</code>语句中测试多个值，元组中的元素可以是值,也可以是区间,也可以使用<code>_</code>(下划线)来匹配所有可能的值</p>

<pre><code class="language-swift">let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print(&quot;(0, 0) is at the origin&quot;)
case (_, 0)://下划线匹配所有值
    print(&quot;(\(somePoint.0), 0) is on the x-axis&quot;)
case (0, _):
    print(&quot;(0, \(somePoint.1)) is on the y-axis&quot;)
case (-2...2, -2...2)://区间匹配
    print(&quot;(\(somePoint.0), \(somePoint.1)) is inside the box&quot;)
default:
    print(&quot;(\(somePoint.0), \(somePoint.1)) is outside of the box&quot;)
}
// 输出 &quot;(1, 1) is inside the box&quot;
//（0,0）虽然符合所有分支模式 但是只有第一个case分支会执行
</code></pre>

<p>注意：</p>

<blockquote>
<p>与OC中的switch不同,swift中的case分支中的值是允许交叉的,即允许多个case匹配同一个值,但是只会执行第一个被匹配的case分支</p>
</blockquote>

<h4 id="toc_10">值绑定</h4>

<p>将匹配的值绑定到一个临时变量或常量,在<strong>case内部使用</strong></p>

<pre><code class="language-swift">let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print(&quot;on the x-axis with an x value of \(x)&quot;)
case (0, let y):
    print(&quot;on the y-axis with a y value of \(y)&quot;)
case let (x, y)://可以匹配所有分支
    print(&quot;somewhere else at (\(x), \(y))&quot;)
}
// 输出 &quot;on the x-axis with an x value of 2&quot;
</code></pre>

<pre><code class="language-swift">let somesPoint = (1, 1)
switch somesPoint {
case (let x, 0):
    print(&quot;X中上\(x)&quot;)
case (0, var y):
    print(&quot;Y中上\(y)&quot;)
case let defaultPint:
    print(defaultPint, defaultPint.0, defaultPint.1)
}
</code></pre>

<h4 id="toc_11">Where</h4>

<p><code>case</code>分支的模式可以使用<code>where</code>语句来判断额外的条件</p>

<pre><code class="language-swift">let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
    case let (x, y) where x == y:
print(&quot;(\(x), \(y)) is on the line x == y&quot;)
    case let (x, y) where x == -y:
print(&quot;(\(x), \(y)) is on the line x == -y&quot;)
    case let (x, y):
print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)
}
// 输出 &quot;(1, -1) is on the line x == -y&quot;
</code></pre>

<h4 id="toc_12">复合匹配</h4>

<p>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个<code>case</code>后面，并且用逗号隔开。此时当<code>case</code>后任意模式匹配时,这个分支就会被匹配</p>

<pre><code class="language-swift">let someCharacter: Character = &quot;e&quot;
switch someCharacter {
case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:
    print(&quot;\(someCharacter) is a vowel&quot;)
    //匹配列表过长 可以分行写
case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,
&quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:
    print(&quot;\(someCharacter) is a consonant&quot;)
default:
    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)
}
// 输出 &quot;e is a vowel&quot;
</code></pre>

<pre><code class="language-swift">let stillAnotherPoint = (9, 0)
switch stillAnotherPoint {
case (let distance, 0), (0, let distance):
    print(&quot;On an axis, \(distance) from the origin&quot;)
default:
    print(&quot;Not on an axis&quot;)
}
/**
    第一个case分之中,两个模式都值绑定了distance
*/
</code></pre>

<h2 id="toc_13">控制转移</h2>

<p>控制转移语句改变代码执行顺序,实现代码的跳转</p>

<h3 id="toc_14">Continue</h3>

<p>立即停止本次循环开始下次循环</p>

<pre><code class="language-swift">let puzzleInput = &quot;great minds think alike&quot;
var puzzleOutput = &quot;&quot;
for character in puzzleInput.characters {
    switch character {
        case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;:
        continue
    default:
        puzzleOutput.append(character)
    }
}
print(puzzleOutput) // 输出 &quot;grtmndsthnklk&quot;
//这里把continue换位break输出结果是一样的,因为continue会匹配为循环体，而break会匹配为switch语句结束执行,循环体还会继续执行下去
</code></pre>

<h3 id="toc_15">Break</h3>

<p>立刻结束控制流的执行，可以更早结束一个<code>switch</code>代码块或者一个循环体</p>

<h4 id="toc_16">循环中的break</h4>

<p>当在一个循环体中使用<code>break</code>时，会立刻中断该循环体的执行，后跳转到表示循环体结束的大括号<code>( } )</code>后的第一行代码，不会再有循环的代码被执行</p>

<h4 id="toc_17">Switch中的break</h4>

<p>在<code>Switch</code>中使用<code>break</code>时会立刻中断<code>switch</code>代码块的执行,跳转到表示 switch 代码块<br/>
结束的大括号<code>( } )</code>后的第一行代码</p>

<p>我们可以用其去忽略一个或多个分支,因为switch不允许有空分支,我们可以在分支语句中写为break,来立即结束市场代码块的执行</p>

<h3 id="toc_18">贯穿   fallthrough</h3>

<p><code>Swift</code>与C不同,<code>switch</code>不会从上一个<code>case</code>分支落入到下一个<code>case</code>分支中。<br/>
但是如果我们想要与C类似的贯穿的风格就需要加上关键字<code>fallthrough</code></p>

<pre><code class="language-swift">let integerToDescribe = 5
var description = &quot;The number \(integerToDescribe) is&quot;
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += &quot; a prime number&quot;
    fallthrough
case 10:
    description += &quot; , and also&quot;
    fallthrough
default:
    description += &quot; an integer.&quot;
}
print(description)
// 输出 &quot;The number 5 is a prime number, and also an integer.&quot;
</code></pre>

<p>在分支语句加上<code>fallthrough</code>关键字后,在执行完分支语句后会继续执行下面的分支，即贯穿到<code>default</code>分支</p>

<p>注意:<br/>
在加上<code>fallthrough</code>后是不会判断下面的<code>case</code>语句的匹配条件而直接执行其分支中的代码</p>

<blockquote>
<p>在C语言的switch语句中也是如果不加break时,那么执行完一条case语句后会直接执行下一条case分支代码,而不会判断分支条件,直到遇到break或者switch语句结束,这与swift中是一致的</p>
</blockquote>

<h3 id="toc_19">带标签的语句</h3>

<p>当有循环体和条件语句嵌套时,我们想要显式指明用break终止哪个循环体<br/>
当有多个循环体嵌套时,显示指明用continue开始哪个循环体的下次循环</p>

<p>这时候就需要 <strong>标签</strong></p>

<p>声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签,作为这个语句的前导关键字,该标签后面加上一个冒号。<br/>
<code>label name : while condition { statements } //对while循环体的标签</code></p>

<pre><code class="language-swift">gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // 骰子数刚好使玩家移动到最终的方格里，游戏结束。
        break gameLoop
    case let newSquare where newSquare &gt; finalSquare:
        // 骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子
        continue gameLoop
    default:
        // 合法移动，做正常的处理
        square += diceRoll
        square += board[square]
    }
}
print(&quot;Game over!&quot;)
</code></pre>

<p>我们用<code>标签+冒号+while循环</code>来声明循环为<code>gameLoop</code>，然后用<code>break 标签</code>或者<code>continue 标签</code>来避免break switch语句 而直接作用于循环体</p>

<h2 id="toc_20">提前退出  guard</h2>

<p>与<code>if</code>语句类似<code>guard</code>语句的执行取决于其后的一个bool条件,如果为真时直接执行<code>guard</code>语句后的代码,如果为假时执行<code>else</code>中的语句</p>

<p><strong>注意:</strong><br/>
条件不满足会执行<code>else</code>分支上的代码,这个分支这个分支<strong>必须转移控制以退出<code>guard</code>语句出现的代码段</strong>。可以使用控制转移语句如<code>return</code>, <code>break</code>, <code>continue</code>或者<code>throw</code>做这件事，或者调用一个不返回的方法或函数，例如<code>fatalError()</code>。</p>

<pre><code class="language-swift">func greet(person: [String: String]) {
    guard let name = person[&quot;name&quot;] else {
        return
    }
    print(&quot;Hello \(name)&quot;)
    guard let location = person[&quot;location&quot;] else {
        print(&quot;I hope the weather is nice near you.&quot;)
        return
    }
    print(&quot;I hope the weather is nice in \(location).&quot;)
}
greet(person: [&quot;name&quot;: &quot;John&quot;])
// 输出 &quot;Hello John!&quot;
// 输出 &quot;I hope the weather is nice near you.&quot;
greet(person: [&quot;name&quot;: &quot;Jane&quot;, &quot;location&quot;: &quot;Cupertino&quot;])
// 输出 &quot;Hello Jane!&quot;
// 输出 &quot;I hope the weather is nice in Cupertino.&quot;
</code></pre>

<h2 id="toc_21">检测API的可用性</h2>

<p><code>Swift</code>内置支持检查<code>API</code>可用性，可以确保我们不会在当前机器上使用不可用API，否则会在编译期间报错</p>

<p>为了判断代码在指定部署机器上是否可用,我们在<code>if</code>或<code>guard</code>中使用<code>可用性条件</code>去执行一段代码,在运行时有条件的执行一段代码，来在运行时判断调用的<code>API</code>是否可用</p>

<pre><code class="language-swift">if #available(iOS 10, macOS 10.12, *) {
    // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API
} else {
    // 使用先前版本的 iOS 和 macOS 的 API
}
</code></pre>

<p>最后的 <code>*</code> 是必须的用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。</p>

<p><code>#available()</code>一般使用<strong>平台名字</strong>(iOS,macOS,watchOS,tvOS)以及<strong>版本号</strong>（iOS 10 等）</p>

]]></content>
  </entry>
  
</feed>
